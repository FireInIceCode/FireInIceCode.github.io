<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Coding Gorilla Training</title>
      <link href="/2024/07/04/codinggorilla/"/>
      <url>/2024/07/04/codinggorilla/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h1><h3 id="A-NOI2024-模拟赛-Day-1-加一2-5"><a href="#A-NOI2024-模拟赛-Day-1-加一2-5" class="headerlink" title="A. [NOI2024 模拟赛 Day 1] 加一2.5"></a>A. [NOI2024 模拟赛 Day 1] 加一2.5</h3><p>对偶问题,则转化为每个位置有一个变量$x_i\ge 0$,要求$\sum_{j\ge i} x_j \le suf_i,\sum_{j\le i} x_j \le pre_j$,最大化$\sum_i b_ix_i$.</p><p>容易想到考虑前缀和,则限制变成$s_i\le s_{i+1},s_i\le pre_i,s_n-s_i\le suf_{i+1}$,注意到答案关于$s_n&#x3D;\sum_i x_i$是凸的,所以直接三分它,后面是Slope Trick.</p><h3 id="B-NOI2024-模拟赛-Day-1-快速排序"><a href="#B-NOI2024-模拟赛-Day-1-快速排序" class="headerlink" title="B. [NOI2024 模拟赛 Day 1] 快速排序"></a>B. [NOI2024 模拟赛 Day 1] 快速排序</h3><h3 id="C-NOI2024-模拟赛-Day-1-可达点对"><a href="#C-NOI2024-模拟赛-Day-1-可达点对" class="headerlink" title="C. [NOI2024 模拟赛 Day 1] 可达点对"></a>C. [NOI2024 模拟赛 Day 1] 可达点对</h3><h2 id="课"><a href="#课" class="headerlink" title="课"></a>课</h2><h3 id="loj4138-「PA-2024」Dzielniki"><a href="#loj4138-「PA-2024」Dzielniki" class="headerlink" title="loj4138. 「PA 2024」Dzielniki"></a>loj4138. 「PA 2024」Dzielniki</h3><p>考虑若已经知道了$x+c$是$2^t$的倍数,尝试知道它是不是$2^{t+1}$的倍数,如果不是再加上$2^t$显然就是,于是可以令$t\gets t+1$递归上去.要判断是不是$2^{t+1}$,在$t$较大的时候问因数个数然后分解质因数下有大概率正确,不行就多问两项.而较小的情况下不对,比如$t&#x3D;0\to t&#x3D;1$,于是先一直随直到有一个稍微大一点的比如$t&#x3D;3+$的去判.</p><p>感觉就是没有顺着$d$的性质走,而是用一些大概率对,小概率不对的东西,然后多跑几项判?</p><h3 id="loj4134-「PA-2024」Desant-3"><a href="#loj4134-「PA-2024」Desant-3" class="headerlink" title="loj4134. 「PA 2024」Desant 3"></a>loj4134. 「PA 2024」Desant 3</h3><p>考虑如果某一条指令对应的是一个$1$一个$0$,都会统一成$10$,此时把这两个取反是没有区别的.</p><p>于是直接搜,有些位确定,有些位没确定,然后当前拿到一条指令,如果只有一位确定,那另一位只有一种情况有必要搜,否则没有区别会消掉,只有两个都不确定的时候你会搜$00$或$11$的情况,于是每次确定两位,复杂度$m2^{n&#x2F;2}$,然后就做完了.</p><h3 id="loj4133-「PA-2024」Kolorowy-las"><a href="#loj4133-「PA-2024」Kolorowy-las" class="headerlink" title="loj4133. 「PA 2024」Kolorowy las"></a>loj4133. 「PA 2024」Kolorowy las</h3><p>首先如果没有link-cut,我们直接点分树,复杂度俩log.如果先染色后查询是1log.</p><p>哦然后你可以倒着做,碰到染色就把周围的点拿出来回答查询,这样只要支持每次找一个点周围最近的询问,然后上一个lct,找最近点的话就直接把当前点变成根,然后要能维护子树深度最浅点,所以需要套set.这实际上是个AAAtree.复杂度俩log.</p><p>toptree!1log了.</p><p>树分块!容易发现一个大于$2B$的块可以被分成两个块且保证大小限制(关于边分块,关于点可能不能分成符合要求的两部分),可以$q\sqrt n$.</p><h3 id="P10353-PA2024-Grupa-permutacji"><a href="#P10353-PA2024-Grupa-permutacji" class="headerlink" title="P10353 [PA2024] Grupa permutacji"></a>P10353 [PA2024] Grupa permutacji</h3><p>[conclusion] 对于置换生成的对称群,任取若干个位置,它们的取值对$(p_{i_1}\ldots p_{i_k})$是均匀的,即每种的方案数相等.</p><p>于是拿出$(i,j)$,则经过一次置换后会变成$(p_i,p_j)$,然后连边(由于把一个置换重复若干次就是逆,所以双向边),然后若一个连通块里有$a$个$p_i&lt;p_j$的和$b$个$p_i&gt;p_j$的显然贡献期望$\dfrac{ab}{a+b}$.</p><p>这样做复杂度$n^3$,然后第二个结论是只保留$\log n$个就可以得到这个图,需要像loj177 一样进行一些随机复合破坏性质.</p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="模拟赛"><a href="#模拟赛" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>发现进行若干次变换后,$a’&#x3D;-pqa+p(p+q)b+q(p+q)c$,每次操作是$(p,q)\to (p+q,q),(p,p+q)$.</p><p>确定$p,q$后辗转相除.</p><p>可以同除$pq$使得变成关于$\dfrac{p}{q}$的方程组.</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>容易想到burnside,问题变成对于一个排列算答案,就是边$(i,j)$连边$(p_i,p_j)$然后算连通块数,这个显然是环,其实就是两个环合起来,那么设环长是$a_1\ldots a_k$,则环数就是$\sum_{i\lt j} \gcd(a_i,a_j) + \sum_i \lfloor \dfrac{a_i}{2}\rfloor$.而这组环长对应的排列数是显然组合数.这个直接搜划分数然后卡常可以过$n&#x3D;96$,好像每次搜一个值的比每次搜一个快.</p><p>考虑meet in the middle,划分数拆成$P_{\ge B}$和$P_{&lt;B}$这样的,只有$\sum_{i\lt t} \gcd(a_i,a_j)$是跟两边都有关的,算这个我们只要知道$f_i&#x3D;\sum_{j} \gcd(i,a_j)$,所以把$f$作为状态发现不多就行了.</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><h2 id="课-1"><a href="#课-1" class="headerlink" title="课"></a>课</h2><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="模拟赛-1"><a href="#模拟赛-1" class="headerlink" title="模拟赛"></a>模拟赛</h2><h2 id="C-NOI2024-模拟赛-Day-3-优先队列"><a href="#C-NOI2024-模拟赛-Day-3-优先队列" class="headerlink" title="C. [NOI2024 模拟赛 Day 3] 优先队列"></a>C. [NOI2024 模拟赛 Day 3] 优先队列</h2><p>容易发现到是$A$按弹出顺序的后缀最大值限制了填法,设后缀max的值为$a_1\ldots a_k$,位置为$p_1\ldots p_k$.对于一个后缀max $a_i$,有$&lt;a_i$的非$A$集合的数不能在它前面,然后大于$a_i$的$A$集合的数不能在$p_{i-1}$后面.</p><p>一维是限制往前一维限制往后是不能简单处理的(赛时考虑容斥可以得到$n^{6,7,8}$做法).考虑把非$A$集合的数限制变成,在$p_i$前面的数值必须大于$a_i$.</p><p>于是可以dp,$f_{i,j,k,0&#x2F;1}$表示考虑前$i$次操作,当前堆中有$j$个$A$集合的数,当前位置往后碰到的第一个后缀max为$k$,$k$是否在堆中,然后在<code>+</code>处计算非$A$集合数的贡献,在<code>-</code>处,若$j&#x3D;1$且$k$在堆中时说明弹出了一个后缀max,枚举下一个后缀max$l$并计算值在$[l,k]$中的数的贡献,转移是$O(1)$的.复杂度$n^3$</p><h2 id="课-2"><a href="#课-2" class="headerlink" title="课"></a>课</h2><h3 id="CF1989F-Simultaneous-Coloring"><a href="#CF1989F-Simultaneous-Coloring" class="headerlink" title="CF1989F Simultaneous Coloring"></a>CF1989F Simultaneous Coloring</h3><p>显然每行&#x2F;列最多被染一次.考虑一个点为红表示染行在染列之后,那么列向行连边,为蓝相反,于是形成一张二分图.此时如果是DAG显然可以一个一个染,否则发现一个SCC必须同时染,所以答案就是每个大小大于$1$的SCC大小平方和.</p><p>但是不能暴力跑,考虑只有加边的话可以维护SCC合并的过程,那我们要知道加入哪条边后导致SCC合并了,这个可以考虑整体二分,考虑现在要求图$G$的答案,图$G$中每条边的出现时间在$[l,r]$中,那么加入$[l,mid]$的边跑tarjan,然后把SCC作为新的点,得到一张图递归到$[mid+1,r]$,把每个SCC内的边拿出来递归到左边即可.</p><p>复杂度$(n+m)\log q+q\alpha(n)$</p><h3 id="Gym105112B"><a href="#Gym105112B" class="headerlink" title="Gym105112B"></a>Gym105112B</h3><p>要求构造方案.</p><p>考虑假设已经填出第一行$w&#x3D;\sum_{i&#x3D;1}^k a_i$,尝试得到第二行,一个朴素想法是把第一个和最后一个换一下,不妨设$a_1&lt;a_k$,但这个方案可能仍然不合法:若仍然存在两前缀相等,容易发现一定有$a_k&#x3D;a_1+\sum_{i\in S} a_i$,那么在第一行中就把这些元素都替换成$a_k$,重复下去,必然有合法了或者全都变成了$a_k$.</p><p>如果全都变成了$a_k$,那么考虑撤销最后一次变换,那么撤销最后一次一定有一个集合$\sum_{i\in S} a_i&#x3D;a_k$,此时把集合中一个元素放到最前面作为第一行,第二行全都填$a_k$,就是合法的.</p><p>但暴力替换是$n^2$的,考虑直接找到一组使用最大块最多的方案即可.这个用bitset做就好了.</p><h3 id="Gym105139C"><a href="#Gym105139C" class="headerlink" title="Gym105139C"></a>Gym105139C</h3><p>考虑把划分成若干矩形变成切若干刀,那么有$\text{Cut Times}&#x3D;\text{Rect Count}+\text{Circle Count}$,因为对于一个环需要一刀断开.</p><p>考虑找到所有$270°$的外角,容易发现每刀会消掉一个或两个,消掉两个当且仅当同行同列,就是找一个不交的匹配.那么把每种可能的匹配边拿出来,不能同时选的之间连边,就是最大独立集.同时只有横的匹配和竖的匹配之间有边所以二分图转匹配即可.</p><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><h2 id="模拟赛-2"><a href="#模拟赛-2" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><p>JSC2023 Final G Fusion</p><p>$xy+1$是有意义的,考虑组合意义,发现如果我们让每个合并后的点代表一个连通块,建树,那么算的实际上是这棵树的连通块数(包含空),且每个叶子节点有$a_i$种方案.于是考虑枚举一个连通块,发现他的权值就是它包含的叶子(即原树上点的乘积).那你其实可以把包含相同叶子集合的一起做,于是问题就变成了每个原树上点染色黑&#x2F;白(即是否选入连通块),然后每次合并两个颜色相同(因为方案包含空点,所以白点成对出现)的点,选择他们的颜色(黑点合并为黑色,白点合并颜色任意).</p><p>然后就是这个怎么数,此时我们不关心点权只关心颜色,想到Shrinking Tree那个题</p><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><h2 id="模拟赛-3"><a href="#模拟赛-3" class="headerlink" title="模拟赛"></a>模拟赛</h2><h2 id="课-3"><a href="#课-3" class="headerlink" title="课"></a>课</h2><h3 id="P10441-JOISC-2024-Day4-乒乓球"><a href="#P10441-JOISC-2024-Day4-乒乓球" class="headerlink" title="P10441 [JOISC 2024 Day4] 乒乓球"></a>P10441 [JOISC 2024 Day4] 乒乓球</h3><h3 id="P10433-JOISC-2024-Day2-棋盘游戏"><a href="#P10433-JOISC-2024-Day2-棋盘游戏" class="headerlink" title="P10433 [JOISC 2024 Day2] 棋盘游戏"></a>P10433 [JOISC 2024 Day2] 棋盘游戏</h3><p>首先注意到第一个人是关键的,设它经过$a$轮共走$b$步到达$T$,则其他每个人的贡献可以写作仅有$b$确定的函数$f(b)$,其他人都只是要尽量快的结束自己的回合,只会有两种行为:第一轮走到一个终止位置,然后每次离开一步再回来,此时$f(b)&#x3D;2x+d_i$,先用$s$轮,$t$步走到一个相邻两个终止位置,以后每次走一步,有$f(b)&#x3D;(x-s)+t,x&gt;s$,注意到$(x-s)+t\ge 2x+d_i$得到$x\le t-s-d_i\ge s$,因为必然有$t\ge 2s+d_i$.于是每个人的贡献$f(b)$是分$2$段一次函数,且只要计算$t-s$,这个直接给终止点赋值$-1$,边赋值为$1$跑bfs即可.</p><p>然后求出所有点的贡献之后要考虑$1$,$1$一个走法是走$a&#x3D;a_0,b&#x3D;b_0$,$a_0$是最小合法解,这个是容易求的,因为$b_0-b\le n$,$a$的答案比$a_0$至少大$(k-1)(a-a_0)$,于是$a\le a_0+\dfrac{n}{k-1}$.</p><p>于是若$k&gt;B$,只要把走了几个终止点也放到状态里去最短路复杂度即是$\dfrac{n^2}{B}$.</p><p>对于$k&lt;B$,注意到段数不多,此时对每一段直接让终止点权值为斜率,边权值为$1$去跑,取最小值既是答案,因为容易发现算错的一定不优.</p><h3 id="Qoj7514-Clique-Challenge"><a href="#Qoj7514-Clique-Challenge" class="headerlink" title="Qoj7514. Clique Challenge"></a>Qoj7514. Clique Challenge</h3><p>容易发现最大团大小$k&lt;\sqrt{2m}$.先考虑给定$n\le \sqrt{2m}\le 44$的时候怎么做.</p><p>这个数据范围显然meet in the middle,考虑已经处理了两边各自的最大团,那么枚举左边的一个最大团,算出他们点连到右边的集合的交集,则这个交集内的可能是最大团,跑高维子集和即可.</p><p>那么现在$n$大了,考虑分成若干个小部分,一个很神秘的做法是我们拓展三元环计数的做法:按照度数把边定向,度数小指向度数大,容易分析出一个点的出度最大为$\sqrt 2m$,于是枚举一个点,对他的出边集合数团数,相当于每个团在拓扑序最小的位置数了.</p><h3 id="Qoj6308-Magic"><a href="#Qoj6308-Magic" class="headerlink" title="Qoj6308. Magic"></a>Qoj6308. Magic</h3><p>又是必要猜充要题.</p><p>考虑若存在区间$[l_1,r_1],[l_2,r_2],l_1&lt;l_2&lt;r_1&lt;r_2$,那么若$(r_1,r_1+1)$贡献就要求$2$比$1$先操作,若$(l_2-1,l_2)$贡献要求$1$比$2$先操作,于是给这两个点连边,则最后选的显然要是图的一个独立集,这是必要条件.</p><p>考虑如果选择了一个独立集,那么如果有环,比如选了$[l,r]$的$r,r+1$贡献,那么一定是要求$[l’,r’]$使得这个区间要先执行,而若$l&lt;l’&lt;r&lt;r’$,因为独立集不会选$l’$,所以一定是又钦定了$r’,r’+1$贡献,则这个共线点一定是单调右移的,不会成环.</p><p>显然是二分图,bitset优化匈牙利&#x2F;线段树优化建图后dinic 即可.</p><h3 id="CF1844G-Tree-Weights"><a href="#CF1844G-Tree-Weights" class="headerlink" title="CF1844G Tree Weights"></a>CF1844G Tree Weights</h3><p>考虑从低到高逐位确定,先确定模$2$的情况,那么此时$dis(u,v)&#x3D;dis(1,u)+dis(1,v)-2dis(1,lca(u,v))\equiv dis(1,u)+dis(1,v)$,于是相当于让若干个$d_u&#x3D;dis(1,u)$相同&#x2F;不同,可以直接确定.</p><p>然后若确定了模$2^k$的情况,发现容易用相同的方法确定模$2^{k+1}$的情况,就做完了.</p><h3 id="AGC057C-Increment-or-Xor"><a href="#AGC057C-Increment-or-Xor" class="headerlink" title="[AGC057C] Increment or Xor"></a>[AGC057C] Increment or Xor</h3><p>建出01trie,我们都知道实际上相当于 选择某些层交换子树 或者 对这个树的右链交换左右儿子.</p><p>那么异或一个数,$+1$,再异或一个数,就可以交换任意一条链的左右儿子.</p><p>考虑我们始终是要交换左右儿子,所以若当前的树和目标不同构一定无解,否则可以得到每个点是否需要交换,设为$c_u&#x3D;0&#x2F;1$.每次可以链翻转$c$和层翻转$c$,要求最后全都变成$0$.</p><p>那么枚举是否翻转最后一层,然后就知道了链每个最后一层点是否要翻转,转掉之后check是否每层$c$相同即可.</p><h3 id="Qoj8552-Sticks"><a href="#Qoj8552-Sticks" class="headerlink" title="Qoj8552. Sticks"></a>Qoj8552. Sticks</h3><p>画一下图,发现可以找到一条左上到右下的线把图分成上下两部分,上面部分只通过列覆盖,下面这部分只通过行覆盖.考虑对这条线dp.为了不数重显然钦定这条线是所有线中最靠上的一条.</p><p>需要明确我们的限制,若钦定这条线在第$i$列高度为$h_i$,则要么$h_i$这个格子被从上到下的格子覆盖,要么$h_{i-1}&#x3D;h_i$,于是可以设$f_{i,j}$表示上半部分最后一个位置是$(i,j)$的情况下,前$i$行和前$j$列的方案数.(其实就是dp这条线吧!)</p><h3 id="AGC057E-RowCol-x2F-ColRow-Sort"><a href="#AGC057E-RowCol-x2F-ColRow-Sort" class="headerlink" title="[AGC057E] RowCol&#x2F;ColRow Sort"></a>[AGC057E] RowCol&#x2F;ColRow Sort</h3><p>todo</p><h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><h2 id="模拟赛-4"><a href="#模拟赛-4" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h3><p>考虑怎么判定一个能不能到另一个,我们试图贪心构造,考虑最大值如何移动,它可以移动到后面的任意位置,如果目标位置在前面肯定寄了,否则考虑它要走一个什么路径移动过去(显然,他的移动过程中会选择若干个元素,把它们往前循环移位).我们肯定希望尽可能多的保留逆序对,于是选择所有位置$i$满足$p_i$比后面的元素都大,移动这些位置.可以$n^2$的判断了.</p><p>考虑扩展这个判定,把所有排列放到一个自动机上使得自动机上$a\to b$当且仅当$a$可以转变成$b$,且若$a,b$路径唯一.对于路径唯一的问题是容易dp的.</p><p>考虑一个排列操作的第一步会是什么,它应该由 当前排列,已经操作了$&gt;x$的值现在要操作$x$,$x$的目标位置$y$ 确定而如果$x&#x3D;y$它应该连到</p><h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><h2 id="模拟赛-5"><a href="#模拟赛-5" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h3><p>注意到对一个$[1,i]$前缀操作完后,最后$k-1$个数(即$[i-k+2,i]$)一定是最大的$k-1$个数.</p><p>考虑一轮操作,先把$[1,k]$排序,然后每次加入一个元素,则如果它不是前缀max我们要操作一次把它向前移动到$[i-k,i]$中第一个比它小的数的后面,于是一轮的贡献是$[[1,k] is ordered]+\sum_i [p_i&gt;\max_{j&lt;i} p_j]$.</p><p>发现一个位置成为前缀max之后,不会再变成非前缀max.一个前缀$p$经过$1$轮操作后,数集是前$p+k-2$减去前$k-1$大,经过$c$轮后是$p+c(k-1)-1$减去前$c(k-1)$大($c(k-1)$如果超过$n-p$就用$n-p$).前缀$p-1$和前缀$p$的数集的差显然就是$p$处的值.于是一个朴素想法是枚举每一个前缀$p$二分$c$,然后看$[1,p-1]$经过$c$轮后的最大值和$[1,p]$经过$c$轮后的最大值,而这也就是求前缀$kth$,容易主席树树上二分做到整体1log.</p><h3 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h3><p>考虑拆贡献,那么即求$\max \sum_{v&#x3D;1^n} (\sum_i [A_i\ge v])(\sum_i [B_i\ge v])$.由于$\sum_i [A_i\ge v]+\sum_i [B_i\ge v]$确定,问题即$\min \sum_{v&#x3D;1^n} (\sum_i [A_i\ge v]-\sum_i [B_i\ge v])^2$,</p><p>看起来仍然很不可做,考虑它的下界,当然是所有偶数处是$0$,所有奇数处是$1$.尝试达到这个下界,即数轴上有$n$对点,要给每个点赋值$-1,1$,每对点值不能相同,而要达到下界就是rank为$2i-1$和$2i$两个点值不相同.用边$(u,v)$表示$u,v$不同,那么发现图是二分图(每个点度数都是$2$,且恰好有一个$A_i\ne B_i$的边和一个rank产生的边),于是一定可以染色达到下界,就做完了.</p><h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><p>考虑最简单的暴力是$f_{i,A,B,C}$表示我们让$i$个点变成$1$,其余点是$0$的部分方案数(部分方案数就是某些系数乘起来,单看他们可能找不到简单的组合意义),且这$i$个点内已经使用过的边集是$A$,$1$的点和$0$的点之间已经使用过的边集是$B$,仍然是$0$的点之间的已经使用的边集是$C$.</p><p>容易注意到我们不关心$A$的具体内容而只关心它的大小.</p><p>而$C$也只记录大小就能转移,要记录$C$时因为当我们把一个新的点变成$1$的时候,我们需要知道它有多少条边没被选要加入$B$中,而这点可以这时再枚举用了几条边计算贡献.</p><p>对于$B$,发现只要记录每个点的度数,且不关心具体的点所以是度数集合.</p><p>这样状态做到$2^nn^4$,然后转移的时候要另一个dp,分配新变成$1$的这个点的边要如何加入$B$中并计算贡献.复杂度$2^nn^5$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>几个组合构造的证明</title>
      <link href="/2024/06/23/combination_construction/"/>
      <url>/2024/06/23/combination_construction/</url>
      
        <content type="html"><![CDATA[<h1 id="几个组合构造的证明"><a href="#几个组合构造的证明" class="headerlink" title="几个组合构造的证明"></a>几个组合构造的证明</h1><p>有人问无标号海胆计数,然后大喊CYC构造,然后发现大家都把各种构造是啥忘了.</p><p>设$A(x)&#x3D;\sum_i a_ix^i$是我们要构造的东西</p><h2 id="可重集构造MSET"><a href="#可重集构造MSET" class="headerlink" title="可重集构造MSET"></a>可重集构造MSET</h2><p>EI在WC上讲过,MSET是这样的:<br>$$<br>\begin{gathered}<br>    \mathrm{MSET} A(x)&#x3D;\prod (\dfrac{1}{1-x^i})^{a_i}\<br>    &#x3D;\exp \sum_i -a_i\ln (1-x^i)\<br>    &#x3D;\exp \sum_i a_i \sum_{j&#x3D;1} \dfrac{x^{ij}}{j}\<br>    &#x3D;\exp \sum_{i&#x3D;1} \dfrac{A(x^i)}{i}<br>\end{gathered}\<br>$$</p><h2 id="幂集构造PSET"><a href="#幂集构造PSET" class="headerlink" title="幂集构造PSET"></a>幂集构造PSET</h2><p>类比MSET,写式子,求ln,展开ln,交换求和号.</p><p>$$<br>\begin{gathered}<br>    \mathrm{PSET} A(x)&#x3D;\prod_i (1+x^i)^{a_i}\<br>    &#x3D;\exp \sum_i a_i \ln (1+x^i)\<br>    &#x3D;\exp \sum_i a_i \sum_{j&#x3D;1} \dfrac{x^{ij}}{j}(-1)^{j-1}\<br>    &#x3D;\exp \sum_{i&#x3D;1} \dfrac{(-1)^{i-1}}{i}A(x^i)<br>\end{gathered}<br>$$</p><h2 id="环构造CYC"><a href="#环构造CYC" class="headerlink" title="环构造CYC"></a>环构造CYC</h2><p>不burnside的证明来自 Analytic Combinatorics.</p><p>首先大家都知道不能直接$\mathrm{SEQ}$再积分,因为循环节.</p><p>那么定义一个序列&#x2F;环是本原的当且仅当没有循环节,则对本原序列的GF积分就是本原环.</p><p>先数序列,用$x$统计容量,$y$统计成分,$F(x,y)&#x3D;\mathrm{SEQ}<em>{\ge 1}(yA(x))&#x3D;\dfrac{yA(x)}{1-yA(x)}$表示非空序列,设$G(x,y)$为本原序列的GF,则有$F(x,y)&#x3D;\sum</em>{i\ge 1} G(x^i,y^i)$.应用莫反得到</p><p>$$<br>G(x,y)&#x3D;\sum_{i\ge 1} \mu(i)F(x^i,y^i)&#x3D;\sum_{i\ge 1}\mu(i)\dfrac{y^iA(x^i)}{1-y^iA(x^i)}<br>$$</p><p>于是本原环的GF有</p><p>$$<br>\begin{gathered}<br>    H(x,y)&#x3D;\int \dfrac{G(x,y)}{y} \mathrm{d}y\<br>    &#x3D;\sum_{i\ge 1} \int \mu(i)\dfrac{A(x^i)}{1-y^iA(x^i)}\mathrm{d}y\<br>    \because \int \dfrac{a}{1-ay^i}\mathrm{d}y&#x3D;-\ln(1-ay^i)\dfrac{1}{i}\<br>    \therefore H(x,y)&#x3D;-\sum_{i\ge 1} \dfrac{\mu(i)}{i}\ln(1-A(x^i)y^i)<br>\end{gathered}<br>$$</p><p>最后环的GF显然有</p><p>$$<br>\begin{gathered}<br>    B(x,y)&#x3D;\sum_{k\ge 1}H(x^k,y^k)\<br>    &#x3D;-\sum_{k\ge 1} \sum_{i\ge 1} \dfrac{\mu(i)}{i}\ln(1-A(x^{ik})y^{ik})\<br>    &#x3D;-\sum_{k\ge 1} \ln(1-A(x^k)y^k)\sum_{i\mid k}\dfrac{\mu(i)}{i}\<br>    \because \sum_{i\mid k}\dfrac{\mu(i)}{i}&#x3D;\frac{1}{k}\sum_i \mu(i)\dfrac{k}{i}&#x3D;\dfrac{\varphi(k)}k\<br>    \therefore B(x,y)&#x3D;-\sum_{k\ge 1}ln(1-A(x^k)y^k)\dfrac{\varphi(k)}{k}<br>\end{gathered}<br>$$</p><p>大功告成.</p><h2 id="试看看"><a href="#试看看" class="headerlink" title="试看看"></a>试看看</h2><p>无标号荒漠计数</p><p>$1$</p><p>无标号海胆计数</p><p>$\mathrm{CYC}(\mathrm{SEQ}(x))$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三轮省集</title>
      <link href="/2024/06/20/sdptt3/"/>
      <url>/2024/06/20/sdptt3/</url>
      
        <content type="html"><![CDATA[<h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><h2 id="模拟赛"><a href="#模拟赛" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>Qoj4907 djq 学生物</p><p>容易想到一张图,然后邻接矩阵的幂,然后要求$\sum_i M^i&#x3D;\dfrac{1}{1-M}$.</p><p>然后容易想到换成”排列幂级数”多项式,转移多项式$F(x)&#x3D;\sum_p c_p x^p$,$p$为一个排列,$x^p\cdot x^q&#x3D;x^{p\circ q}$,要求$\sum_i F(x)^i&#x3D;\dfrac{1}{1-F}$,就是要给这个东西求逆.容易发现若答案存在逆一定存在.</p><p>因为每一位分别做,容易想到类似FWT的形式,回想 “FWT本质” 类似物,比如试着找矩阵$C$使得$C_{i,j}$为$i\to j$的贡献,然后变换完之后点积就对应卷积.但是这里不适用(找不到合法的$C$).$p\circ q$不交换本身性质不好,拆成三个矩阵也是未知数少于方程数的.</p><p>然后感觉这里见识到更本质的FWT,我们实际上是在找可逆线性变换$T$使得$T(a)\cdot T(b)&#x3D;T(a\times b)$,$T$把数变换到矩阵也是合法的.用矩阵强行模拟$S_3$的结构,构造出</p><p>$$<br>M_{123}&#x3D;(\begin{Bmatrix}<br>    1 &amp; 0\0 &amp; 1 \<br>\end{Bmatrix},1,1)\<br>M_{132}&#x3D;(\begin{Bmatrix}<br>    1 &amp; -1\0 &amp; -1 \<br>\end{Bmatrix},1,-1)\<br>M_{213}&#x3D;(\begin{Bmatrix}<br>    0 &amp; 1\1 &amp; 0 \<br>\end{Bmatrix},1,-1)\<br>M_{231}&#x3D;(\begin{Bmatrix}<br>    -1 &amp; 1\-1 &amp; 0 \<br>\end{Bmatrix},1,1)\<br>M_{312}&#x3D;(\begin{Bmatrix}<br>    0 &amp; -1\1 &amp; -1 \<br>\end{Bmatrix},1,1)\<br>M_{321}&#x3D;(\begin{Bmatrix}<br>    -1 &amp; 0\-1 &amp; 1 \<br>\end{Bmatrix},1,-1)<br>$$</p><p>三个元素间做乘法是点乘,矩阵做乘法就是矩阵乘.</p><p>你会好奇为什么要构造这个大小的而不直接用$3\times 3$的置换矩阵,但先别管</p><p>然后这个构造方式的话,后面两维写全$1$ 和 排列奇偶性显然是对的,第一列可以考虑几何构造,选择平面上三个点$(0,0),(0,1),(1,0)$分别代表$1,2,3$,找到一个矩阵可以交换两个点而第三个点位置不变即可.</p><p>构造出矩阵之后我们现在会做$n&#x3D;1$的情况,就对于原序列是$\sum_i c_i x^{p}$,$i\in [0,5]$是$p$的字典序编号(题目中的),则设$M&#x3D;\sum_i c_iM_i$,把$M$求逆,再变换回来(容易发现上面的线性变换满秩)即可.</p><p>现在要做高维的情况,考虑矩阵的直积,即$A\otimes B&#x3D;(a_{i,j}B)<em>{i,j}$(把$A$的每个位置乘上$B$这个矩阵,得到一个新的巨大矩阵).它有性质$(A\otimes B)\times (C\otimes D)&#x3D;(A\times C)\otimes (B\times D)$($\times$表示矩阵乘法).所以多维用直积变换,若$a$一个位置表示成$a</em>{p_1,p_2,p_3\ldots p_k}$,那么我们实际上算的是$\sum\limits_{p_1\ldots p_k} a_ {\Large \otimes}<em>i M</em>{p_i}$.</p><p>然后变换完了你得到一个矩阵套矩阵的东西,我们不看点积那层关系(认为形如$(A,B,C)$的是三个不同的矩阵)你要对这个东西求逆,求逆复杂度是$\sum_i \binom{n}{i}2^{n-i}2^{3i}&#x3D;10^n$</p><p>然后就做完了.</p><p>你会发现我们平时写的FWT都可以认为是这种矩阵直积的形式,只不过底层是$1\times 1$的矩阵.</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>Qoj8359 travel</p><p>看南外题解吧:</p><blockquote><p><img src="/img/2024-06-21-14-06-23-image.png" alt="图 0">  </p></blockquote><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>CF947I</p><p>todo</p><h2 id="课"><a href="#课" class="headerlink" title="课"></a>课</h2><h3 id="CF1924F-Anti-Proxy-Attendance"><a href="#CF1924F-Anti-Proxy-Attendance" class="headerlink" title="CF1924F Anti-Proxy Attendance"></a>CF1924F Anti-Proxy Attendance</h3><p>把题目转化为有$n$个vector,每次给定一个区间,交互库会把区间内部<code>pushback</code>$0$,外部<code>pushback</code>$1$,或者正好相反($1$表示答案在这一侧),那么如果出现连续$3$个$1$或连续$3$个$0$则这个位置必然不是答案,可以被排除.</p><p>则只用考虑每个vector最后两个位置,如果是<code>00</code>或<code>11</code>赋权值$1$,若为<code>01</code>或<code>10</code>赋权值$\phi$,若已经排除了赋权值$0$,则设上一次权值和为$A$,下一次交互库选择区间内部<code>pushback</code>$1$的权值为$B_1$,区间内部<code>pushback</code>$0$的权值为$B_0$,发现必然有$\phi A&#x3D;B_0+B_1$.最后$A&#x3D;O(1)$,一开始$A&#x3D;O(n)$,所以交互库希望尽量大,会选择$\max (B_0,B_1)$给你,则每次$A$最多减小到$\dfrac{\phi}{2}A$,操作次数有下限$O(\log_{\dfrac{2}{\phi}} n)$</p><p>考虑所有前缀,问空前缀和问整个序列$B_0,B_1$必然恰好交换,则必然存在某处$\vert B_0-B_1\vert$很小,在这里问显然就是最优的.就能做到$O(\log_{\dfrac{2}{\phi}}n)$的次数了.</p><h3 id="uoj883"><a href="#uoj883" class="headerlink" title="uoj883"></a>uoj883</h3><p>大贪心讨论</p><p>显然我们要走所有黑点虚树的一个欧拉序,考虑dp,容易发现只要记录$f_{u,0&#x2F;1,0&#x2F;1}$表示 遍历$u$的子树,从$u$&#x2F;$u$的儿子开始,$u$&#x2F;$u$的儿子结束 的最小代价就是一个子问题,考虑转移.</p><p>对于两个子树之间的问题,只有$(0,0)\to (0,0)$花费$0$,其他花费$1$.由此,每个子树的选择应该是先游先取$f$小的,再取$0$多的状态转移.</p><p>对于$u$和自己第一个儿子,只有$u$是$(1,x)$,$v$是$(0,y)$花费$0$,其他花费$1$,同理对最后一个儿子只有$u,v$分别是$(x,1),(y,0)$花费$0$.</p><p>于是显然有</p><ul><li>对$f_{u,0,0}$,儿子排列是$u\to (1,0)?\to (0,0)\ldots \to (0,1)(1,0)\ldots\to (1,1)\ldots \to u$,$?$表示不一定有.</li><li>对$f_{u,1,0}$,儿子排列$(0,0)\ldots \to (0,1)(1,0)\ldots \to (1,1)\ldots \to u$.对$f_{u,1,0}$同理.</li><li>对$f_{u,1,1}$,注意此时一个取$(1,1)$的点变成取$(0,0)$可能加$2$,所以可能把所有子节点变成$(0,0)$,且此时可能遍历不到$u$需要加$1$次操作.而一般情况只要做$(0,0)\ldots \to (0,1)(1,0)\ldots \to (1,1)\ldots\to (1,0) \to u$即可.</li></ul><h3 id="uoj884"><a href="#uoj884" class="headerlink" title="uoj884"></a>uoj884</h3><p>显然的暴力是$f_{i,j}$表示走到这个格子的方案数.$f_{i,j}&#x3D;f_{i-1,j-1}+f_{i,j-1}$,有障碍的格子为$0$.</p><p>考虑GF优化这个东西,设$F_i(x)&#x3D;\sum_j f_{i,j}x^j$,如果没有障碍则$F_i(x)&#x3D;\dfrac{F_{i-1}(x)}{(1-x)}$,存在一个障碍就要把那个位置设为$-\sum_{j&lt;p} f_{i,j}$来抵消前面的贡献,于是只要支持快速查单项式系数,加单项式,除$1-x$.</p><p>但还是很慢,时间分块重构,每$B$个重构,于是维护$\dfrac{F_i}{(1-x)^k}$的形式,但这样底下的项数是$O(n)$的,不如维护$G_i(1-x)^k$的形式,在每块开始时设$k&#x3D;B$,每次减$1$,这样查可以$O(B)$,修改时再维护修改的项$\dfrac{H(x)}{x^l}$,则因为$H$项数也是$O(B)$的就好做了.然后只要每$B$次进行重构,也就是计算$\dfrac{F(x)}{(1-x)^B}$,注意到$(1-x)^{509}\bmod 509 &#x3D; 1-x^{509}$,于是取$B&#x3D;509$,除$1-x^{509}$可以线性.</p><p>总复杂度是$nB+\dfrac{n^2}{B}\approx n\sqrt n$</p><h1 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h1><h2 id="模拟赛-1"><a href="#模拟赛-1" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h3><p>P3993 [BJOI2017] 同构</p><p>考虑区分的点在反图上点也是区分的,于是相当于加最少的边让所有点区分,然后你发现$n$比较大的时候一个树肯定就弄完了,然后你发现过不了样例,可能是多个连通块省边,那如果这个连通块$m\ge n$就不能省一条边没有意义,于是都是树,且每个连通块互不同构,最大化连通块数量.于是显然从小到大选,只要求每个大小的,不自同构的无根树数量.</p><p>考虑一棵树不自同构的充要条件是,不存在一条边&#x2F;点,使得删去它后剩下的若干连通块中有两个相同.发现一个子树和一个子树补的不会做,发现选重心为根就做完了,</p><h3 id="Qoj4898-基础图论练习题"><a href="#Qoj4898-基础图论练习题" class="headerlink" title="Qoj4898. 基础图论练习题"></a>Qoj4898. 基础图论练习题</h3><p>考虑直接若干个等差数列合并在一起就是公差取gcd,但限定长度之后不能直接这样做.</p><p>容易证明${d_i\vert 2d_i\le n}$可以合并成一个gcd,可以考虑弱周期引理,考场上没有意识到它和字符串的相关性,那你就直接注意到任意时刻位置$x$必然要么可以走集合中的至少一个,否则终点一定在$[1,n]$外,即可.</p><p>那你现在应该想到弱周期引理啊,你会意识到$d$相当于给了一个周期,$n-d$就是一个border,那么容易得到border&#x2F;d构成$\log n$段值域不交的等差数列,于是周期,那么有用的$d$只有$\log n$个.</p><p>考虑现在要能做到给你一个$d$的集合$S$找到等差数列,这里不像普通字符串那样简单,因为$d$的集合是不完全的.</p><p>别字符串了,类比TopCoder 12832 Huge Graph可以得到一个类似辗转相减gcd的方式:考虑拿出最小的$d_1$,那么若当前节点编号$x&gt;d_1$,你一定可以走$x\to x-d_1\to x-d_i$,于是用$d_i-d_1$替换掉$d_1$,而对$x\le d_1$不能进行下面的变换,单向后连一个$d_1$,容易发现变换前后图等价.此时前$d_1$个点不对连通性产生影响(只有一条$+d_1$连到后面),可以删掉,可以递归下去.把不断相减变成取模(辗转相除),容易发现只会递归log次,复杂度是$\vert S\vert\log n$</p><p>现在每个$d$有不同的边权,需要从小到大加入$O(n)$次,注意到这个过程中只有曾作为最小值的$d$是有用的,可以只保留它们做,复杂度就$a\log^2 n$了.</p><p>但还有一些散边,考虑我们希望找到一个点在这个连通块中最小的代表元,发现这个可以在上面的递归中同步进行,找一个点复杂度是$\log n$.于是只要找到所有散边端点对应代表元,考虑先算出所有整边($a$条)的答案,那么散边的贡献只取决于散边代表元 在 加入整边的过程中的Kruskal重构树 上的虚树(其实是代表了它们每个点之间的整边边权最小值),抽出这棵虚树之后跑Kru即可.</p><p>考虑怎么建这棵虚树,显然对两个点什么时候连通可以二分,那么整体二分,$f(l,r,S)$表示加入第$l$组整边前$S$中点两两不连通,加入$r$后两两连通,求解出其中的点何时连通.那么算出$[1,mid]$的整边加入后的连通块是$S_1\ldots S_k$,递归计算$f(l,mid,S_1)\ldots f(l,mid,S_k)$,每个集合拿出一个元素组成$T$调用$f(mid+1,r,T)$即可.</p><p>复杂度是$(a+b)\log^2 n$</p><h2 id="课-1"><a href="#课-1" class="headerlink" title="课"></a>课</h2><h3 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h3><blockquote><p>有一个未知$01$序列,每次可以询问子集中$1$的个数,要求$O(\dfrac{n}{\log n})$的次数问出序列.</p></blockquote><p>分治,考虑若已经能构造$q$次解决长$n$的问题,拓展到$2q+1$次解决长$2n+q$的问题,则把$2n+q$分成$n,n,q$三段,设第一段的$q$个询问是$S_1\ldots S_1$,第二段是$T_1\ldots T_q$,那么我们把新的询问分成$q$个$  pair$,每个pair询问$x&#x3D;S_i+T_i$和$y&#x3D;S_i-T_i+a_{2n+i}$(用多的一次询问$[n+1,2n]$,通过询问补集算$-T_i$),则容易通过$x+y$的奇偶性判断$a_{2n+i}$,然后求$S$和$T$是简单的,分析一下就是$\dfrac{n}{\log n}$.</p><h3 id="P6837-IOI2020-数蘑菇"><a href="#P6837-IOI2020-数蘑菇" class="headerlink" title="P6837 [IOI2020] 数蘑菇"></a>P6837 [IOI2020] 数蘑菇</h3><p>luogu题解写的很清楚</p><p>重点在于充分利用奇偶之类的信息.</p><h3 id="P8531-Ynoi2003-戌亥彗星"><a href="#P8531-Ynoi2003-戌亥彗星" class="headerlink" title="P8531 [Ynoi2003] 戌亥彗星"></a>P8531 [Ynoi2003] 戌亥彗星</h3><p>先考虑一次询问怎么做.</p><p>考虑处理限制,容易发现第二&#x2F;三个限制有单调性,第一个没有.</p><p>对于第二个限制考虑从小到大扫右端点,lct维护最大编号生成树,则左端点是编号上的一个区间$[l_{1,i},r_{1,i}]$,用两个lct双指针,一个一直删直到变成树求出$r$,一个维护不考虑$r$这条边一直删直到变成树求出$l$.</p><p>对第三个限制我们在上面的过程可以知道那条环上的非树边,维护环点度数大于等于$2$的数量和非环点大于等于$2$的数量即可找到$[l_{2,i},r_{2,i}]$,取个交,记为$[L_i,R_i]$</p><p>对第一个限制,由于上面两个已经满足,只要$\vert V\vert&#x3D;\vert E\vert$.而$V$相当于数颜色.</p><p>考虑扫描线扫$r’$,则问题相当于维护序列$a,b,c$,支持:</p><ul><li>对$a$区间加</li><li>对$b$所有$a_i&#x3D;0$的位置区间加</li><li>全局$c_i\gets c_i+b_i$</li></ul><p>注意$a$最小值是$0$,那么第二个操作其实是最小值加,考虑怎么设计标记和信息,这里可以先不考虑$c$的操作,那么一次对$a$的区间加后面接一次对$b$的加后面这次一定无效,,同理一次对$b$的加后面接一次对$a$的减前面这次也一定无效,于是只要维护 $(a,b)$表示对$a$区间减,对$b$加 或 $(b,a)$表示先对$b$加再对$a$加两种标记,容易合并.</p><p>复杂度单log.</p><h3 id="Uoj463"><a href="#Uoj463" class="headerlink" title="Uoj463"></a>Uoj463</h3><p>todo</p><h1 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h1><h2 id="模拟赛-2"><a href="#模拟赛-2" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h3><p>写了一个假贪心然后似了.</p><p>不能观察得到,较短的串选的一定是原串的一个前缀,后面全填$0$,于是直接枚举前缀,$O(1)$维护值即可.</p><h3 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h3><p>ZR 香雪兰</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><p>考虑连通块就是$V-E&#x3D;1$,设$f_{i,j}$表示前$i$个选$j$个,扫描线扫$i$线段树维护$V-E$dp,复杂度$nk\log n$,卡常可过.</p><p>看看怎么做到$nk$,首先给根也加一个父亲,然后把是连通块转化成有且仅有一个点满足$i$在区间内而$fa_i$在区间外,即对$[l,r]$贡献是$\sum_{i\in [l,r]} [fa_i&lt;l]+[fa_i&gt;r]$.dp的时候扫$r$的话,显然后面这部分是单调的,一个后缀,前面的相当于加入一个点$i$时对区间$(fa_i,i]$做区间加.而注意这个是只有区间加没有减的,我们只要能维护和为$0&#x2F;1$的区间.</p><p>于是维护仅考虑$[fa_i&lt;l]$的部分,所以满足条件位置的dp值即前缀和(以便查区间和),而因为我们只有后缀加,只要开俩栈,加的时候从一个里取出来放到另一个即可.复杂度$nk+n\log n$.</p><h2 id="课-2"><a href="#课-2" class="headerlink" title="课"></a>课</h2><h3 id="GYM102028J"><a href="#GYM102028J" class="headerlink" title="GYM102028J"></a>GYM102028J</h3><p>设$f_i$表示只被$i$覆盖的格子数.</p><p>若两个矩形无交只要求$f_i$最大的两个.</p><p>然后枚举每个格子,若它恰被两个地毯覆盖给这个对的贡献$+1$.然后只要找覆盖一个位置的两个元素,于是二维前缀和,查询覆盖每个位置的个数,编号和,编号平方和.</p><h3 id="cf16-exhibition-final-e"><a href="#cf16-exhibition-final-e" class="headerlink" title="cf16_exhibition_final_e"></a>cf16_exhibition_final_e</h3><p>容易发现不会有中转.</p><p>若有$u\to v$连边$(u,v)$,考虑一个连通集合$S$,它一定是一棵树(否则有中转),则每个点都会变成$\dfrac{(\sum_i a_i-\sum_{(u,v)\in E} dis(u,v))}{\vert S\vert}$.证明考虑新加一个叶子归纳.</p><p>于是一个点集只要求最小生成树.</p><p>于是求出每个集合最后会变成多少,然后直接跑子集卷积,复杂度$n^22^n$</p><h3 id="CF1239E"><a href="#CF1239E" class="headerlink" title="CF1239E"></a>CF1239E</h3><p>容易发现第一行单增第二行单减.</p><p>容易发现下凸,于是最大值一定在两侧.</p><p>于是最小值放在左上角和右下角,跑背包$n^3V$就过了.</p><h3 id="Qoj5874"><a href="#Qoj5874" class="headerlink" title="Qoj5874"></a>Qoj5874</h3><p>meet in the middle,枚举问号少的一半.</p><p>如果高位问号少,你可以几乎确定平方根,直接把后面全填$0$开方然后往后找$O(1)$个即可,然后再确定低位是容易的.</p><p>如果低位问号少,注意到若最低位是$1$,则高位加$1$</p><h3 id="ARC160E-Make-Biconnected"><a href="#ARC160E-Make-Biconnected" class="headerlink" title="[ARC160E] Make Biconnected"></a>[ARC160E] Make Biconnected</h3><p>显然每个叶子都需要至少连一条边,否则删掉它的父亲一定不合法.</p><p>我们希望这也是上界,则叶子跑匹配,于是考虑关于子树内叶子个数的带权重心,那么一定能找到一个匹配使得任意一对点在两个不同的子树,此时容易发现合法.</p><p>若叶子数为奇数,todo</p><h3 id="CF1558F-Strange-Sort"><a href="#CF1558F-Strange-Sort" class="headerlink" title="CF1558F Strange Sort"></a>CF1558F Strange Sort</h3><p>todo</p><h1 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h1><h3 id="A-3"><a href="#A-3" class="headerlink" title="A"></a>A</h3><blockquote><p>区间加,区间对固定数取模,区间和.</p></blockquote><p>容易发现修改容易复合,变成$+a$,取模,$+b$的形式,然后$+a$需要做区间rank,所以分块.每块维护$a,b$和所有值的有序数组就做到$n\sqrt n\log n$.</p><p>然后可以把一些log去掉,比如修改散块重建的时候不sort而使用归并,离线逐块处理干掉二分,就可以把log放到根号底下.</p><p>然后可以单根号,不离线逐块二分,分散层叠掉&#x2F;cf</p><h3 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h3><p>喵的为啥以前做过的题一点也想不起来!</p><p>JOI Open 2019 三级跳</p><h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><p>容易发现很局部,想到一个dp是$f_{i,j,k}$表示长$i$的区间,还有$j$次操作,第$k$个位置的答案,然后在$[l,r]$的第一次操作一定是在$[l,r]$的一个中点,把它分成两部分,此时枚举$k$表示左边分到$k$个操作,右边分到$i-k$个操作,把操作在时间轴上插起来分配系数转移.转移是卷积可以优化到$n^2\log n$</p><p>然后$k$这一维显然必须杀了,容易想到$f_{l,r,i}$表示$l,r$这个区间剩$i$次操作,转移还是一样分配系数,然而把复杂度算错了,注意到复杂度是$n\log^3 n$.(而不是$n^2\log n$)</p><p>再优化就搞成单侧递归,显然长度为奇数的区间只要递归到一侧再把答案复制到另一边,复杂度就是$n\log n$了.</p><p>尝试不要ntt,概率转方案数,时间轴上分配操作的标号考虑EGF,则$F_{l,r}(x)&#x3D;\sum_i \dfrac{x^i}{i!}f_{l,r,i}$,有<br>$$<br>mid&#x3D;\lfloor \frac{l+r}{2} \rfloor\<br>F_{l,r}(x)&#x3D;<br>\begin{cases}<br>    2n\int F_{l,mid-1}(x)(1+x)^{r-(mid+1)+1}+1,2\nmid n\<br>    n\int F_{l,mid-1}(x)(1+x)^{r-(mid+1)+1}+\int F_{l,mid}(x)(1+x)^{r-(mid+2)+1}+1,2\mid n<br>\end{cases}<br>$$</p><h2 id="课-3"><a href="#课-3" class="headerlink" title="课"></a>课</h2><h3 id="loj2159-「POI2011-R1」收缩点-Plot"><a href="#loj2159-「POI2011-R1」收缩点-Plot" class="headerlink" title="loj2159. 「POI2011 R1」收缩点 Plot"></a>loj2159. 「POI2011 R1」收缩点 Plot</h3><p>显然先二分,但判定是最小圆覆盖,不能动态加点,可以$O(k)$解决规模$k$的问题.</p><p>此时不能二分,因为最坏每次只加一个点就似了,我们希望它和下一段长度有关,于是先倍增尝试,若以$i$为左端点,$i+2^k$可行而$i+2^{k+1}$不可行,再在这个区间二分,复杂度就$n\log n\log V$了.</p><p>[trick] 二分&#x2F;倍增并非完全等价,当有均摊时</p><h3 id="Timus-2057"><a href="#Timus-2057" class="headerlink" title="Timus 2057"></a>Timus 2057</h3><p>考虑什么时候无解,全$a$无解,考虑整个串一定是回文串,那么拿到$a$后第一个$b$,显然回文中心不在这之前,然后如果回文中心恰好是这个$b$显然无解,回文中心在这之后,尝试在第一个$b$后面砍一刀,剩下的递归下去,得出最后一种无解可能是$abababa\ldots$这样的.</p><p>于是就会判无解.</p><p>然后直接dp,让$j$能转移到$i$当且仅当这个区间有解,然后处理$i$往前极长的$abab$和$a$区间,会对奇数&#x2F;偶数的$j$分别有上界限制,然后对$aa\ldots baa\ldots$的情况对每个$i$是唯一的,就做完了.</p><h3 id="Qoj7303"><a href="#Qoj7303" class="headerlink" title="Qoj7303"></a>Qoj7303</h3><p>考虑模$2$很关键,考虑给每个集合$S$一个容斥系数$w(S)$,使得对连通的集合是$1$而其他的是$0$,想到算$2^{c}\bmod 4$,$c$为连通块个数,于是最后只要算$(\sum_S 2^{c_S})\bmod 4$,等价于把连通块染色,或者说把每个点黑白灰染色,要求不存在黑白边.</p><p>于是扫编号维$3^13$状压dp即可.</p><h3 id="ARC160D-Mahjong"><a href="#ARC160D-Mahjong" class="headerlink" title="[ARC160D] Mahjong"></a>[ARC160D] Mahjong</h3><p>考虑建立操作序列到原序列的双射,对同一位置的$k$次区间加替换成单点加,证明考虑把原序列模$k$然后差分应该对应操作序列.</p><p>然后数数是GF简单题.</p><h3 id="loj3911"><a href="#loj3911" class="headerlink" title="loj3911"></a>loj3911</h3><p>显然是最终子序列的一个前缀&#x2F;后缀拼接,于是先预处理$f_{i,j}$表示前缀和为$j$的本质不同子序列个数.</p><p>这个也得dp,设$f_{i,j,k}$表示前$i$个字符,前缀和为$j$,长度为$k$的,每次枚举子序列下一个字符转移.</p><p>然后拼接的时候也可能有重复,钦定求$s_a+s_b$的问题时拼接得到的$s_a$极大的匹配即可,那么若我们希望下一个匹配的是字符$c\in {L,R}$,就要求$s$在最后一个位置之后没有出现过,然后就做完了.</p><h3 id="AGC056B-Range-Argmax"><a href="#AGC056B-Range-Argmax" class="headerlink" title="[AGC056B] Range Argmax"></a>[AGC056B] Range Argmax</h3><p>要构造$x$到$p$的双射,从大到小每次填一个最大值,删去包含这个最大值的$x$,递归到两边,为了避免数重我们希望这个最大值是满足条件的最前面.</p><p>于是dp,要从$[l,r]$以最大值$k$处分开,那么对$[l,k-1]$的最大值$k’$,有$k$是合法的最左位置当且仅当存在区间同时包含$k’,k$,否则容易发现可以让$k’$当这个最大值,于是$f_{l,r,k}$表示区间$l,r$且最大值位置必须在$k$之后的方案数,即可dp.</p><h3 id="ARC165E-Random-Isolation"><a href="#ARC165E-Random-Isolation" class="headerlink" title="[ARC165E] Random Isolation"></a>[ARC165E] Random Isolation</h3><p>考虑转化成可以任意删点,但只统计连通块大于等于$k$的次数,然后拆贡献算一个点$u$被删时连通块大于等于$k$的概率.</p><p>让连通块以$u$为根,设这个连通块大小为$a$,和这个连通块有边但比它早删的点数为$b$,数数.</p><p>后面是二维卷积树形dp.</p><h1 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h1><h2 id="模拟赛-3"><a href="#模拟赛-3" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A-4"><a href="#A-4" class="headerlink" title="A"></a>A</h3><p>容易想到一个$n^3$的区间dp.</p><p>容易想到$n^3\log n$的区间dp.</p><p>容易想到把二分干掉改成枚举答案,每次把一个区间点亮.</p><p>但是复杂度都很劣.</p><p>不容易想到这个题正解是bitset的$n^3$.然后用bitset的find_first&#x2F;next查找下一个点亮的区间就做完了.</p><h3 id="B-3"><a href="#B-3" class="headerlink" title="B"></a>B</h3><p>容易发现$b$从大到小排序,得到一个$n^2$dp,$f_{i,j}$表示前$i$个,已经选了$j$个的最小值.有$f_{i,j}&#x3D;\min(f_{i-1,j},f_{i-1,j-1}+a_i+(j-1)\cdot b_i)$容易发现固定$i$dp值是凸的.</p><p>不知道怎么发现,dp的两种转移分别是一个前缀和一个后缀,于是只要支持区间加等差数列,区间加,区间平移$1$,平衡树维护即可.</p><p>怎么发现呢,zzk表示注意到$b\le 10$的部分分,此时对每个$b$把$a$排序,每个$b$要选$a$的一个前缀$a_{1\ldots k}$,这个$k$是有决策单调性的,然后类比过来.</p><p>另一个做法是考虑贪心,容易发现一开始最小的$a_p$一定会被选,删掉它之后考虑剩余的数贡献变化,若$b_i&gt;b_p$则$a_i\gets b_i$,否则按$b$排序后$i$会插入到$p$前面,$a_i\gets a_i+b_p$.然后接着选最小的重复即可.</p><p>于是只要支持区间加,区间加等差数列,区间和,复杂度$n\log^2 n$.</p><h3 id="C-3"><a href="#C-3" class="headerlink" title="C"></a>C</h3><p>首先转化到,每个人让$[l_i,r_i]$加$1$,可以翻转为让$[1,l_i)\cup (r_i,n]$加$1$,最小化最大值.</p><p>然后注意到,若存在两个不交的区间都被翻转,他们翻转后覆盖完全包含他们翻转前,所以一定不优,于是有存在一个位置被所有翻转的区间包含.</p><p>于是一个部分分是二分答案$mid$,枚举这个被所有区间包含的位置$x$,对$i&lt;x$,一个包含$i$的区间翻转后必然不包含$i$,于是设$pre_i$表示左端点在$i$及之前的翻转区间个数,有$(a_i-pre_i)+(pre_x-pre_i)\le mid$,可以得到$pre_i$的下界,枚举$pre_x$可以得到每个$pre_i$的限制.</p><p>然后显然左边翻转的区间的$r$越大越好,于是从$1$到$x$贪心,到$i$时把所有$l&#x3D;i,r\ge x$的区间按$r$加入大根堆,取走并翻转堆顶若干个区间直到满足$pre_i$的限制,最后判断右边是否合法.$n^3\log^2 n$</p><p>设未翻转前每个位置覆盖次数为$a_i$,翻转后为$b_i$</p><p>然后注意到,存在一种最优方案,使得若所有被翻转区间的交是$[l,r]$,有$[l,r]$中$b$的最大值和全局$b$最大值最多差$1$.考虑若差$2$以上选择$[l,?]$和$[?,r]$翻转不劣.</p><p>然后注意到,存在一种最优方案,使得设$t&#x3D;\argmin_{i\in [l,r]} a_i$,$k&#x3D;\argmin_i a_i$,$a_k&#x3D;a_i$.证明考虑反证,若$a_k&gt;a_t$有$k\notin [l,r]$,一开始有$a_k\ge a_t+1$,由上面的性质有$b_t\ge a_k-1$,相加并调整就有$a_k-b_k\ge a_t-b_t$,矛盾.</p><p>于是不需要枚举$pre_i$,有$mid\in {b_t,b_t+1},b_t&#x3D;a_t-pre_x$,于是$pre_x\in {a_t-mid,a_t-mid+1}$.$n^2\log^2 n$</p><p>然后注意到,我们枚举的$x$可以选择任意$a_x&#x3D;\max_{i&#x3D;1}^n a_i$,考虑反证,设$k\notin [l,r]$且$a_k$也是$a$的全局最大值,于是有$a_k-b_k\ge a_x-b_x-2$(翻转一个区间有$2$的差),由上一个注意知道$a_x&#x3D;a_k$,于是$b_k-b_t\ge 2$与第二个注意矛盾.</p><h2 id="课-4"><a href="#课-4" class="headerlink" title="课"></a>课</h2><h3 id="「Dwango-Programming-Contest-6th」Cookie-Distribution"><a href="#「Dwango-Programming-Contest-6th」Cookie-Distribution" class="headerlink" title="「Dwango Programming Contest 6th」Cookie Distribution"></a>「Dwango Programming Contest 6th」Cookie Distribution</h3><p>把$\prod_i c_i$拆组合意义,表示每个人再从自己的cookie中选一个.然后直接按天dp,每天分配若干个选中的和若干个没选中的.</p><h3 id="「JOISC-2015-Day2」Keys"><a href="#「JOISC-2015-Day2」Keys" class="headerlink" title="「JOISC 2015 Day2」Keys"></a>「JOISC 2015 Day2」Keys</h3><p>对每个时间间隔分类讨论,什么时候一个间隔可以关门:</p><ul><li>前一个人进入,后一个人出门,总是可以.</li><li>两人都进,要求后一个人有钥匙</li><li>两人都出,要求前一个人有钥匙</li><li>前一个人出后一个人进要求两人都有钥匙</li></ul><p>注意到只有第四种情况和两人都有关,此时把两个人连边,一定得到若干条链,对每条链分别dp最后卷起来,复杂度$n^2$.</p><h3 id="「JOISC-2020-Day4」治疗计划"><a href="#「JOISC-2020-Day4」治疗计划" class="headerlink" title="「JOISC 2020 Day4」治疗计划"></a>「JOISC 2020 Day4」治疗计划</h3><p>好离奇.</p><p>设$f_i$表示当前的方案推到某个时刻$t_i$可以治疗$[1,r_i]$的最小代价.若$i&lt;j$,则$[1,r_i]$推到时刻$j$应该是$[1,r_i-t_j+t_i]$这样的感觉.</p><p>有了这个之后因为我们不知道转移顺序,用仿dij的形式每次拿最小的更新即可做到$n\log n$.</p><p>有一种从扫时间到扫序列维的感觉,所以这个神奇的状态是怎么想到的.</p><h3 id="「JOISC-2020-Day3」星座-3"><a href="#「JOISC-2020-Day3」星座-3" class="headerlink" title="「JOISC 2020 Day3」星座 3"></a>「JOISC 2020 Day3」星座 3</h3><p>对楼建大根笛卡尔树,设当前处理最大值为$a_u$的区间,注意到两边低于$a_u$的星星是子问题,高于$a_u$的左右子树分别至多剩一个,我们只关心它的高度,于是设$f_{u,i}$表示$a_u$为最大值的区间,保留的最高的星星高度为$i$的答案,有$f_{u,i}&#x3D;\max(f_{l,i}+\max_{k&lt;i} f_{r,k},f_{r,i}+\max_{k&lt;i} f_{l,k})$,对$u$这一列的单独转移,容易发现都可以线段树合并维护.</p><h3 id="AGC033D-Complexity"><a href="#AGC033D-Complexity" class="headerlink" title="AGC033D Complexity"></a>AGC033D Complexity</h3><p>考虑设$f_{l,r,u,d}$表示这个矩形的凌乱度,容易做到$n$,而你注意到凌乱度不超过$\log (n+m)$量级,于是交换一维变成$f_{l,u,d,v}$表示最大的$r$使得凌乱度为$v$</p><p>把它分成横着两个矩形的转移时容易的,对竖着的需要一个分界点,注意到这个分界点有单调性可以二分,或者双指针.</p><p>就过了.</p><h3 id="PKUSC2024-独立"><a href="#PKUSC2024-独立" class="headerlink" title="PKUSC2024 独立"></a>PKUSC2024 独立</h3><p>容易想到一个暴力时$f_{u,i,j}$表示$u$子树内,可选可不选$&#x2F;不选u$的最大独立集分别是$i,j$的方案数.结合小N的独立集容易想到只需要记录$j-i$的差,有$f_{u,a}*f_{v,b}\to f_{u,\max(a+b,0)}$.</p><p>转移显然是卷积形式,但问题是值域很大,不过容易发现一个方案是否合法只和相对大小关系有关,一般这种情况可以猜多项式,归纳容易证明$f_{u,x}$是关于$x$的$siz_u$次多项式,于是只存前$siz_u$个点值即可.</p><p>转移的时候,要先把点值扩张到$siz_u+siz_v$,即我们要支持已知一个多项式的点值快速求另一些点值,直接写成拉格朗日插值,形式就是卷积,扩张完了之后直接卷即可.</p><h1 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h1><h2 id="模拟赛-4"><a href="#模拟赛-4" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A-5"><a href="#A-5" class="headerlink" title="A"></a>A</h3><p>原题是P5972 [PA2019] Desant</p><p>考虑dp,则若从前往后dp到第$i$个,我们只需要记录前$i-1$选了哪些数,在注意到我们只要记录考虑$[i+1,n]$把整个序列划分成若干个区间,只要记录每个区间里有几个数,以这个为状态就过了.</p><p>分析考虑你的状态数实际上是求$\sum_i a_i&#x3D;n,\max \prod a_i$,容易发现是$3^{\dfrac{n}{3}}$的.</p><h3 id="B-4"><a href="#B-4" class="headerlink" title="B"></a>B</h3><p>先考虑$n&#x3D;2$,显然每个点值经过一次,而且这种东西应该考虑分治,且若从第$l$列走到第$r$列($l&lt;r$)一定只会从左往右走,于是一个分治区间内的子问题不会走到外面,此时只要对$(mid,1),(mid,2)$处跑单源最短路,设左边第$i$个点经过$(mid,x)$的距离为$a_{x,i}$,右边是$b_{x,i}$,那么你想算$\sum_{i,j} \min(a_{0,i}+a_{1,i},a_{2,i}+a_{2,j}$</p><h3 id="C-4"><a href="#C-4" class="headerlink" title="C"></a>C</h3><p>经典结论是背包在体积模$\mathrm{lcm}(w_1\ldots w_n)$的每个等价类是凸的,而显然$b_i$相同的时候模$b_i$的位置是凸的,跑闵和即可.</p><p>另一个做法是凸函数和非凸函数做max+卷积可以决策单调性单log,所以就不依赖背包数组的凸性了.</p><h2 id="课-5"><a href="#课-5" class="headerlink" title="课"></a>课</h2><h3 id="AGC043C"><a href="#AGC043C" class="headerlink" title="AGC043C"></a>AGC043C</h3><p>首先图的笛卡尔积在说什么,相当于你在三个图上各有一个点,每次挪动一个位置,形成的图.</p><p>显然我们要贪心,按$x+y+z$从大到小能选就选,那么把边从$(x+y+z)$小的连到大的,则你会选所有没有出边的点,然后连到他们的点不能选,再往下可以选,那么我们看成三张图的组合游戏,于是答案就是所有先手必败点的权值和.而因为三个图独立所以直接求SG值做异或就是合并的SG值.</p><p>注意到SG值最大是$\sqrt m$,暴力做异或卷积即可.</p><h3 id="AGC034D"><a href="#AGC034D" class="headerlink" title="AGC034D"></a>AGC034D</h3><p>把曼哈顿距离转化成$4$个max,于是建$4$个点表示四种绝对值是否取负情况,$S$向所有代表红球的连边,红球向$4$个虚点连边,再向蓝球连边,再连到$T$.</p><p>可以模拟费用流做到$n\log n$.设点是$S\to R_i\to F_{1\ldots 4}\to B_i \to T$.就是最短路一定是从$S\to R_i\to F_{q_1}\to R_{p_1}&#x2F;B_{p_1} \ldots F_{q_k} \to B_j \to T$,用堆维护出$S\to F_i,F_i\to T$,$F_i\to F_j$(只经过一个中转点)的最短路径,然后跑全源最短路.</p><h3 id="loj6703-小-Q-的序列"><a href="#loj6703-小-Q-的序列" class="headerlink" title="loj6703. 小 Q 的序列"></a>loj6703. 小 Q 的序列</h3><p>考虑一个dp,直接做自然是$f_{i,j}$表示前$i$个选了$j$个,$f_{i,j}&#x3D;f_{i-1,j}+f_{i-1,j-1}(a_i+j)$,然后直接GF,容易发现这里对$i$列GF是困难的($a_i$是点<br>乘),于是$F_i(x)&#x3D;(1+a_ix+x^2\mathrm{D})F_{i-1}(x)$,然后不会了.</p><p>做一个转换,$k&#x3D;i-j$,有$f_{i,k}&#x3D;f_{i-1,k-1}+f_{i-1,k+1}(a_i+i-k)$,就又$F_i(x)&#x3D;(x+(a_i+i)-x\mathrm{D})F_{i-1}(x)$.</p><p>再做变换$G_i(x)&#x3D;e^{-x}F_i(x)$,有</p><p>$$<br>e^{-x}F_i(x)&#x3D;x(e^{-x}F_{i-1}(x)+e^{-x}F_{i-1}’(x))+(a_i+i)F_{i-1}(x)\<br>G_i(x)&#x3D;xG_{i-1}’(x)+(a_i+i)G_{i-1}(x)\<br>g_{i,j}&#x3D;g_{i-1,j}(a_i+i+j)<br>$$</p><p>于是直接有$g_{n,i}&#x3D;g_{1,i}\prod_{j&#x3D;1}^n(a_j+j+i)$,设多项式$\prod_{j&#x3D;1}^n(a_j+j+x)$多点求值就做完了.</p><p>[think] 感觉关键在于我们的目标是让后面的项和前面尽可能少的项有关,另外导数的次数是重要的(会有较大影响),对此多尝试一些变换.然后就是用$e^x$合并导数和常数部分.</p><h3 id="ARC105F"><a href="#ARC105F" class="headerlink" title="ARC105F"></a>ARC105F</h3><p>考虑一个连通二分图只有两种染色,那么对于一种点的染色相当于要求一些边能选一些边不能选,选出连通图的方案数.</p><p>考虑容斥,对任意一个图,是一个包含$1$的连通块和剩下一个任意图,于是设$f_S$表示子集$S$是连通二分图的答案,$g_S$表示子集$S$是二分图的答案,就有$f_S&#x3D;g_S-\sum_{T\subsetneq S} 2f_Tg_{S&#x2F;T}$.</p><p>暴力是$3^n$,可以半在线子集卷积搞成$n^22^n$</p><p>别容斥了,不如集合幂级数ln,对$g$直接ln就好了啊.</p><h3 id="loj2398-「JOISC-2017-Day-3」自然公园"><a href="#loj2398-「JOISC-2017-Day-3」自然公园" class="headerlink" title="loj2398. 「JOISC 2017 Day 3」自然公园"></a>loj2398. 「JOISC 2017 Day 3」自然公园</h3><p>首先怎么确定一条链,若已知两个链头链尾,容易找到一个$i$使得保留$1\ldots i$连通而$1\ldots {i-1}$不连通,此时必有$i$在这条链上,分成左右两边递归下去,复杂度是$n\log n$.</p><p>于是现在考虑维护一个与$0$相连的连通块,每次加入一个与这个连通块有边的点,那么对连通块dfs序编号,容易二分到这个点和这个连通块第一个相连的点,删掉它分裂成多个连通块递归找到其他所有边,每个连通块只要一次二分.</p><p>最后要能找到一个与连通块有边的点,那么随便找到一个点和连通块中一个点,用链的方法递归的找即可.</p><h3 id="loj3038-「JOISC-2019-Day3」穿越时空-Bitaro"><a href="#loj3038-「JOISC-2019-Day3」穿越时空-Bitaro" class="headerlink" title="loj3038. 「JOISC 2019 Day3」穿越时空 Bitaro"></a>loj3038. 「JOISC 2019 Day3」穿越时空 Bitaro</h3><p>经典套路先给$L_i,R_i$分别减去$i$,就没有走路需要消耗$1$个时间的代价了.</p><p>然后考虑线段树,若序列$[l,r]$中的所有区间有交我们只要记录这个交,如果无交那么发现进去之后走法是唯一的,一定是贴着边走,仍然可以线段树维护(记录进入区间和出口).</p><p>复杂度单log.</p><h3 id="JOISC-2020-Day1-扫除"><a href="#JOISC-2020-Day1-扫除" class="headerlink" title="JOISC 2020 Day1 扫除"></a>JOISC 2020 Day1 扫除</h3><p>首先考虑如果没有加点,那么发现所有被操作过至少一次的点是一个左上到右下的阶梯,于是可以用平衡树维护阶梯实现操作.</p><p>但现在有加点会破坏阶梯的性质,考虑线段树分治,用修改和查询把点的存在时间分到区间上,每次先处理左区间,然后把左区间处理完后每个点传到右区间作为起始位置.</p><p>复杂度$n\log^2 n$</p><h3 id="P5606-小-K-与毕业旅行"><a href="#P5606-小-K-与毕业旅行" class="headerlink" title="P5606 小 K 与毕业旅行"></a>P5606 小 K 与毕业旅行</h3><p>看到这个相邻两项乘积&#x2F;和不大于啥,考虑扫值域dp连续段,把每个数在$\min(x,m&#x2F;x)$(在对于$x&gt;m&#x2F;x$,$x$在这之前必须是孤立点)处插入,可以做到$n^2$.</p><p>考虑构造更好的转移顺序,使得可以把点分成两类,A类点和后面每个点都满足条件,B类点和后面每个点都不满足条件,那么每插入一个B类点已让空位减少$1$,每增加一个A类点让空位增加$1$,就能线性了.</p><p>然后考虑负数,显然一正一负一定能拼</p><h1 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h1><h2 id="模拟赛-5"><a href="#模拟赛-5" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A-6"><a href="#A-6" class="headerlink" title="A"></a>A</h3><p>容易发现一定有一个全集一个空集,对剩下的四个集合容易想到它们之间的”结构”不多,于是想到考虑有2^{m-2}$种不同状态的元素(被哪几个集合包含),每个状态的元素是一个集合,若确定这些集合显然就确定了答案,然后$2{2^{m-2}}$的枚举每个状态集合是空的的情况去check,显然若有$f_i$种方案有$i$个非空集,答案就是$\binom{m}{2}{n\brace i}f_i$,就做完了.</p><h3 id="B-5"><a href="#B-5" class="headerlink" title="B"></a>B</h3><p>容易想到匹配,但匹配之间的限制不能直接做,考虑网络流,直接二分答案,然后每个时间建一层图,每层图的每个点再拆两个点中间连$1$限制不能相交,然后跑最大流就行了.</p><h3 id="C-5"><a href="#C-5" class="headerlink" title="C"></a>C</h3><p>容易想到枚举相同的前缀,于是问题变成了一棵树儿子大于父亲拓扑序,且限制若干点等于某值,限制一个点大于某值的方案数,这个东西就直接从大到小排序二项式系数选一选就行了啊.</p><h2 id="课-6"><a href="#课-6" class="headerlink" title="课"></a>课</h2><h3 id="CCPC-Final-2022-E"><a href="#CCPC-Final-2022-E" class="headerlink" title="CCPC Final 2022 E"></a>CCPC Final 2022 E</h3><p>因为排列设$(x,y)&#x3D;(a_u,b_v)$.</p><p>不妨设$u&lt;v$,那么$u$之后的每次取$max&#x2F;min$是确定的,且设$y$在$u$时刻是$y$,经过若干次取max&#x2F;min后最后得到的值一定是$\min(\max(y,c),d)$的形式,于是$y$一定是$c,d$中的一个.只要能维护$y$可能取值的最小值或最大值即可,这个用值域线段树维护$x&#x3D;i$处时$y$的值,每次是对一个区间取max&#x2F;min.</p><p>对$u&gt;v$同理,考虑$u&#x3D;v$,前面一定都取max&#x2F;min,后面要满足$c,d$的限制,也容易判断..</p><h3 id="Shenzhen-23-C"><a href="#Shenzhen-23-C" class="headerlink" title="Shenzhen 23 C"></a>Shenzhen 23 C</h3><p>首先注意到$k$可以模$7$,只要考虑$k&#x3D;1\ldots 6$.</p><p>直接dp是$f_{i,s_1\ldots s_6}$表示考虑前$i$个,前$i$个$k&#x3D;1\ldots 6$的和模$7$分别是多少,复杂度$n7^6$看起来就过不了.</p><p>注意到模$4,5,6$分别相当于模$-1,-2,-3$,即若某个$k\in{4,5,6}$的奇数位和偶数位带权和分别是$a,b$,则要求$b-a\not\equiv 0\pmod{7}$,于是对奇数偶数分别跑dp,然后枚举顶到的上界位置合并,枚举偶数的一项,把对$b$的限制$[a\ne b]$容斥成$1-[a&#x3D;b]$,容斥复杂度是$3^3$,总复杂度$n21^3$</p><h3 id="ECF2023C-Equal-Sums"><a href="#ECF2023C-Equal-Sums" class="headerlink" title="ECF2023C Equal Sums"></a>ECF2023C Equal Sums</h3><p>直接dp,设$f_{i,j,s}$表示一边前$i$个,一边前$j$个,差为$s$.</p><p>转移的时候若$s&gt;0$加一个$y$,$s&lt;0$加一个$x$,就能保证$\vert s\vert\le 500$,优化到$n^3$.</p><h1 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h1><h2 id="模拟赛-6"><a href="#模拟赛-6" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="A-7"><a href="#A-7" class="headerlink" title="A"></a>A</h3><p>显然看起来大多数数都直接相同的两两匹配消了,现在还剩下若干个$x\bmod 2$.另外容易发现奇数的话我们已经钦定了大小关系,后面可以直接确定;偶数的话,考虑一定是前面一段上下相同的,紧接着两个可能不同的,直接枚举这两个数,此时大小关系又被确定,可以按照奇数的填.</p><p>然后就是一些细节,比如答案可能很大需要高精度;若枚举的两个数正好差$1$,可能存在前面把两个$0$或$9$放到后面的情况;若枚举完前面只剩$0$需要把这些$0$放到后面填.</p><h3 id="B-6"><a href="#B-6" class="headerlink" title="B"></a>B</h3><p>容易想到LGV,于是只要能算$1&#x2F;2 \to n-1&#x2F;n$的方案数.</p><p>注意复杂度关于交点个数是没啥问题的,dp即可.</p><p>为了减小常数,std是每次加入一条弦,记录$f_i$表示第$i$条弦最后一个交点处的方案数.</p><h3 id="C-6"><a href="#C-6" class="headerlink" title="C"></a>C</h3><p>首先你可以直接根据排列得到唯一的$n-1$项rand序列,容易想到设一开始种子的每一位是$x_0\ldots x_w$,则可以表示出之后的每一个数为$\sum_i w_i \sum_{j\in S_i} x_j$的形式,同时,若$x\equiv a\pmod p$,$p&#x3D;q\times 2^t$,就能列出关于$x$的$2^t$个同余方程,然后可能不满秩,但可以枚举自由元的取值,就做完了.</p><h2 id="课-7"><a href="#课-7" class="headerlink" title="课"></a>课</h2><h3 id="Qoj7901-Basic-Substring-Structure"><a href="#Qoj7901-Basic-Substring-Structure" class="headerlink" title="Qoj7901. Basic Substring Structure"></a>Qoj7901. Basic Substring Structure</h3><p>考虑修改一个位置$x$时,若一个后缀的lcp$y&lt;x-1$一定没变,若$y\ge x$一定会变成$x-1$,只要考虑$y&#x3D;x-1$的后缀,显然每个后缀只在$x$的一个修改方案有$y&#x3D;x-1$,那你就直接枚举所有有至少一个$y&#x3D;x-1$的修改方案暴力算lcp即可.</p><h3 id="P9623-ICPC2020-Nanjing-R-Baby’s-First-Suffix-Array-Problem"><a href="#P9623-ICPC2020-Nanjing-R-Baby’s-First-Suffix-Array-Problem" class="headerlink" title="P9623 [ICPC2020 Nanjing R] Baby’s First Suffix Array Problem"></a>P9623 [ICPC2020 Nanjing R] Baby’s First Suffix Array Problem</h3><p>考虑先假装后缀的顺序就是sa中的顺序,而不对,即$rk_a&lt;rk_b,s_{a\ldots n}&gt;s_{b\ldots n}$当且仅当仅考虑这个区间,$b$是$a$的前缀,在这个区间外能比出来,考虑数这种反例.</p><p>那么分成两类,设询问的是后缀$s_{k\ldots n}$,而$i$与其构成反例.</p><p>若$i&lt;k$,则限制为$l\le i\lt k\le r,rk_i\lt rk_k,lcp(i,k)\ge r-k$,容易发现$lcp(i,k)\ge r-k$在$rk$的限制上是一个区间,所以这是个二维数点.</p><p>若$i&gt;k$,则限制为$l\le k&lt;i\le r,rk_i&gt;rk_k,lcp(i,k)\ge r-i$.考虑这其实是一个$[k,r]$这个区间的border,于是只要能求区间字符串的border,这个东西考虑基本子串字典.</p><p>另一种做法是对着上面的上DS,考虑cdq分治,计算右边的$i$对左边的$k$的贡献,那么扫出$pm_i$,$sm_i$分别表示左右两边的前缀min,则限制就是$pm_i+i\ge r,sm_k+i\ge r,i\le r$这样,这样剩下的问题是个二维数点,直接做就好了.复杂度$n\log^2 n$.</p><h3 id="Uoj608-【UR-20】机器蚤分组"><a href="#Uoj608-【UR-20】机器蚤分组" class="headerlink" title="Uoj608. 【UR #20】机器蚤分组"></a>Uoj608. 【UR #20】机器蚤分组</h3><p>首先考虑这是一个最小链覆盖,那么转化成最长反链覆盖,而一个反链一定可以调整成长度相同的,所以答案其实是 某长度的本质不同子串个数 的最大值.</p><p>再注意到,当长度大时主要收区间限制,当长度小时主要是字符串内容限制,于是注意不到,当且仅当长度$k$满足区间内所有长度$k$的所有串互不相同时,答案由$k$产生.直觉考虑若这个长度有两个串相等,那么这两个串的所有对应子串都相等,容易发现长度更短不优.</p><p><img src="/img/2024-07-01-10-59-51-image.png" alt="图 1">  </p><p>于是对全局,答案既是$n-\max_{i&lt;j} lcp(s_{i\ldots n},s_{j\ldots n})$,放到后缀树上就对应lca,那么在后缀树上对endpos启发式合并,每次合并两个集合时,有贡献的只有合并两个集合归并起来后,相邻两项来自不同集合的对,这个显然只有$n\log n$对.剩下就是简单ds.</p><h3 id="Uoj656-【ULR-2】霸占排行榜"><a href="#Uoj656-【ULR-2】霸占排行榜" class="headerlink" title="Uoj656. 【ULR #2】霸占排行榜"></a>Uoj656. 【ULR #2】霸占排行榜</h3><p><del>对AC自动机跑DAG剖分</del>&#x2F;kx</p><p>考虑肯定是把$T$在AC机上跑一遍,考虑先求$dir_{u,i}$表示$u$走过$s_i$后的位置,$end_{u,i}$表示最大的$j$使得$u+s_{i,1\ldots j}$还在AC机中.把匹配$s$的过程分成$u\to end_{u,i}\to fail_{end_{u,i}}\to dir_{u,i}$,考虑$v&#x3D;fail_{end_{u,i}}$,若$dep_v\le dep_{end_{u,i}}-dep_u$,相当于$u$的信息全丢了,可以直接从$1$开始匹配,即$dir_{u,i}&#x3D;dir_{1,i}$,否则可以看出只有$u$长为$l&#x3D;dep_v-(dep_{end_{u,i}}-dep_u)$的后缀是有用的,那么在 fail 树 上跳直到这个串的长度(即$dep$)为$l$即可.</p><p>则若已知每个$end_{u,i}$,我们可以$O(nl)$求出每个$dir_{u,i}$,然后对每个$s$单独做,我们知道它在每个位置被插入了多少次,求每个节点被经过次数.仍然沿用上面的讨论,把一个节点开始走一个$s$的过程拆成$u\to end_{u,i}\to dir_{u,i}$,第一部分是一个祖先链加,第二个部分可以递归的做,就可以$O(nl)$的解决这个问题.</p><p>于是考虑怎么求$end_{u,i}$,树剖,则对于一条链能走多远是一个lcp的问题,可以exkmp,直接跳容易做到$nl\log n$.然后把要从一个位置开始跳一个$s$的后缀这个询问挂在轻儿子上.把所有$s$的后缀排序,对一个轻子树,按照字典序从小到大遍历这些后缀则每个点只会经过一次.于是复杂度就是轻子树大小和$l\log l$了.</p><p>总复杂度是$nl+l\log l+S\log S$,$S&#x3D;\sum_i \vert s_i\vert$.</p><p>重点是,把AC自动机上匹配分成$u\to end_u\to dir_u$使得可以递归处理,以及把问题分成重链+轻子树.</p><h3 id="Uoj772-【UER-11】企鹅游戏"><a href="#Uoj772-【UER-11】企鹅游戏" class="headerlink" title="Uoj772. 【UER #11】企鹅游戏"></a>Uoj772. 【UER #11】企鹅游戏</h3><p>考虑AC自动机后,问一个串就是走一遍,每次到根的链加.但你当然不用都加,注意到$s$在$t$中的出现次数是$L^{4&#x2F;3}$量级,那么只要记录AC自动机上每个点到根的链上第一个代表$s$中元素的节点,往上跳,且不跳相同的节点即可.</p><h3 id="CF1909G-Pumping-Lemma"><a href="#CF1909G-Pumping-Lemma" class="headerlink" title="CF1909G Pumping Lemma"></a>CF1909G Pumping Lemma</h3><p>枚举$s$中$y$和$z$的分界线,则现在要求$y^{k-1}$有多少个循环节同时是$x+y$的后缀.而是$x+y$的后缀就是要求$\vert y\vert \le LCS(s_{1\ldots i},s_{i+1\ldots i+(n-m)})$,那么当$i$增加的时候只要比较$s_{i+1}$和$s_{i+n-m+1}$,若不相等清空可行集合,否则可行的$y$集合中增加一个,而原来集合的每个都是可以的,于是只要hash检验新增的这个,就做完了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024NOI准备</title>
      <link href="/2024/05/30/preparefornoi/"/>
      <url>/2024/05/30/preparefornoi/</url>
      
        <content type="html"><![CDATA[<h1 id="2024NOI准备"><a href="#2024NOI准备" class="headerlink" title="2024NOI准备"></a>2024NOI准备</h1><h3 id="ABC225H-Social-Distance-2"><a href="#ABC225H-Social-Distance-2" class="headerlink" title="[ABC225H] Social Distance 2"></a>[ABC225H] Social Distance 2</h3><p>考虑 $k$ 个确定的人把问题分成若干长度固定的段, 设长 $l$ 的段内有 $j$ 个人的贡献和是 $f_{l, j}$, 则 $[x^{m-k}] \prod_{l\in S} \sum_j f_{l, j}x^j$ 即为答案.</p><p>考虑 $f_{l, j}$ 怎么求, 显然相当于 $j+1$ 段, 和为 $l+1$, 求每段长度乘积的和, 这个是经典的, 一段的贡献显然是 $\dfrac{x}{(1-x)^2}$, 于是总贡献是 $\dfrac{x^{j+1}}{(1-x)^{2j+2}}&#x3D;\binom{l+j+1}{l-j}$ 即可.</p><p>然后两端点的段要特殊处理(不含第一段的贡献), 方法一样.</p><h3 id="ARC101F-Robots-and-Exits"><a href="#ARC101F-Robots-and-Exits" class="headerlink" title="[ARC101F] Robots and Exits"></a>[ARC101F] Robots and Exits</h3><p>容易发现洞把序列分成若干段, 对于任意一段其一定是左边的点从左边出右边的点从右边出, 所以其实相当于数合法 $01$ 序列, $0$ 表示某个机器人从左边出 $1$ 表示从右边出. 然后考虑段间的限制, 设 $i$ 到左右出口的距离分别为 $l_i, r_i$, 则 若 $l_i&gt;l_j, r_i&lt;r_j$, 则有 $a_i&#x3D;1\to a_j&#x3D;1, a_j&#x3D;0\to a_i&#x3D;0$.</p><p>那么所有选 $0$ 的顶层区间(没有祖先选 $0$), 容易发现它们唯一确定了方案, 要求仅为不能有包含关系, 于是按 $l$ 排序就是简单二维数点.</p><p>或者看成把 $(l_i, r_i)$ 画到平面上, 那么相当于选了一条左下到右上的分界线.</p><p>复杂度单log.</p><h3 id="AGC032F-One-Third"><a href="#AGC032F-One-Third" class="headerlink" title="[AGC032F] One Third"></a>[AGC032F] One Third</h3><p>考虑相当于每次插入一个红点后就在左右各 $\dfrac{1}{3}$ 处分别放置蓝点和绿点, 最后求最小的异色点对距离.</p><p>则按照第一次插入把环分成三份, 容易发现三份是等价的, 则问题变成了给定一条长 $l$ 线段, $n-1$ 次随机一个位置随机一个颜色放一个点, 问最小异色点对距离期望.</p><p>考虑怎么去除异色的限制, 考虑枚举前 $k$ 小的段都是同色的, 容易发现概率是 $\dfrac{1}{3^k}$. 那么只要计算长 $l$ 的线段上随机撒 $n-1$ 个点, 第 $k$ 段期望长度.</p><p>那么最短的是好求的:</p><p>$$<br>E(X)&#x3D;\int_0^{\frac{l}{n}} P(X\ge x)dx &#x3D; \int_0^{\frac{l}{n}} (l-nx)^{n-1}dx&#x3D;\dfrac{1}{n^2}<br>$$</p><p>这里第二个等号是考虑相当于分成 $n$ 个长至少为 $x$ 的线段, 则先把它们减去 $x$ 就成了在 $1-nx$ 的线段上选 $n-1$ 个点.</p><p>考虑次短, 相当于剩下 $n-1$ 段中最小值, 则先都减去最小值, 于是有</p><p>$$<br>E(X_2)&#x3D;E(X)+\int_0^{\dfrac{1}{n}} P(X&#x3D;x) \dfrac{l-nx}{n^2}dx&#x3D;E(X)+\dfrac{1-nE(X)}{(n-1)^2}<br>$$</p><p>得到</p><p>$$<br>E(X_k)&#x3D;\dfrac{1}{n}\sum_{i&#x3D;0}^{k-1} \dfrac{1}{n-i}<br>$$</p><p>就做完了.</p><h3 id="AGC044E-Random-Pawn"><a href="#AGC044E-Random-Pawn" class="headerlink" title="[AGC044E] Random Pawn"></a>[AGC044E] Random Pawn</h3><p>随机游走题, 设从位置 $i$ 开始最大期望价值为 $f_i$($0$ 起始), 有</p><p>$$<br>f_i&#x3D;\max(a_i, -b_i+\dfrac{1}{2}(f_{i-1\bmod n}+f_{i+1\bmod n}))<br>$$</p><p>显然 $a$ 最大值处 $mx$ 有 $f_{mx}&#x3D;a_{mx}$, 断环成链.</p><p>想起来 $b_i&#x3D;0$ 的时候这个题是 USACO 2018 P A. Balance Beam, 考虑如何转化. 则设一些系数 $c$ 使得令 $g_i&#x3D;f_i+c_i$, 有 $g_i&#x3D;\max(a_i+c_i, -b_i+\dfrac{1}{2}(g_{i-1}+g_{i+1}-c_{i-1}-c_{i+1}))$, 则只要 $c_{i-1}+c_{i+1}&#x3D;-2b_i$, $c$ 是容易递推的.</p><h3 id="ARC133E-Cyclic-Medians"><a href="#ARC133E-Cyclic-Medians" class="headerlink" title="[ARC133E] Cyclic Medians"></a>[ARC133E] Cyclic Medians</h3><p>好巧妙</p><p>不知道干啥就先拆贡献, 转化成最后 $a\ge x$ 的方案数, 则容易想到 $&lt;x$ 的数为 $0$, $\ge x$ 的数为 $1$, 称 $a$ 改变当且仅当 $x&#x3D;y$(此时后面的状态与前面无关), 分类讨论:</p><p>若存在 $x&#x3D;y$, 则 $a$ 于 $A$ 无关, 发现已经没有什么阻止它对称了, 也就是 $x$ 的方案数和 $x, y$ 都翻转后 $V-x+1$ 的方案数是一样的, 而 $x, y$ 翻转会让不合法和合法翻转, 于是 $cnt_x+cnt_{V-x+1}$ 就是总方案数减去不存在 $x&#x3D;y$ 的方案数再除 $2$.</p><p>对于不存在 $x&#x3D;y$, 限制是很严格的: 设 $g&#x3D;\gcd(n, m)$, 则有序对 $(x_i, y_j)$ 存在当且仅当 $i\equiv j\pmod g$ 的, 把所有模 $g$ 相等的位置拿出来设为 $S$, 则 $\forall i, j\in S, x_i&#x3D;x_j, y_i&#x3D;y_j, x_i\ne y_i$. 于是方案数可以直接统计了.</p><p>复杂度除快速幂和 $\gcd$ 外线性.</p><p>[think] 核心性质: 对称</p><h3 id="ARC133F-Random-Transition"><a href="#ARC133F-Random-Transition" class="headerlink" title="[ARC133F] Random Transition"></a>[ARC133F] Random Transition</h3><p>[trick] 考虑转化问题, 把 $\dfrac{x}{n}$ 的概率加一否则减一的概率凑出来, 则对于一开始在 $a$, 最后为 $b$ 的概率, 等价于 $n$ 个硬币有 $a$ 个正面向上, $k$ 次随机翻一枚, 最后有 $b$ 个正面向上的概率.</p><p>那么每个硬币独立了, 于是设EGF, 用 $x, y$ 表示翻动次数和硬币个数, 有</p><p>$$<br>\begin{gathered}<br>    F_0(x)&#x3D;\sum_{2\nmid i} \dfrac{(x&#x2F;n)^i}{i! }y+\sum_{2\mid i} \dfrac{(x&#x2F;n)^i}{i! }&#x3D;\dfrac{(1+y)e^{x&#x2F;n}+(1-y)e^{-x&#x2F;n}}{2}\<br>    F_1(x)&#x3D;\sum_{2\nmid i} \dfrac{(x&#x2F;n)^i}{i! }+\sum_{2\mid i} \dfrac{(x&#x2F;n)^i}{i! }y&#x3D;\dfrac{(1+y)e^{x&#x2F;n}-<br>    (1-y)e^{-x&#x2F;n}}{2}<br>\end{gathered}<br>$$</p><p>则答案的EGF是</p><p>$$<br>\begin{gathered}<br>    Ans(x)&#x3D;m! n^{-m}[x^m]\sum_i w_i F_1^i(x) F_0^{n-i}(x)\<br>    \text{let}\ A(x)&#x3D;(1+y)e^x, B(x)&#x3D;(1-y)e^{-x}. \</p><pre><code>Ans(x)=m! n^&#123;-m&#125;2^&#123;-2n&#125;[x^m]\sum_i w_i(A+B)^i(A-B)^&#123;n-i&#125;</code></pre><p>\end{gathered}<br>$$</p><p>考虑 $A^iB^{n-i}$ 的系数即</p><p>$$<br>\begin{gathered}<br>    [x^i]\sum_i w_i(x+1)^i(x-1)^{n-i}&#x3D;\<br>    [x^i] (x-1)^n\sum_i w_i (\dfrac{x+1}{x-1})^i<br>\end{gathered}<br>$$</p><p>于是对 $\sum_i w_ix^i$ 多项式复合得到和式部分, 再卷 $(x-1)^n$ 即是系数多项式设为 $\sum_i c_ix^i$.</p><p>则 $[x^m]\sum_i c_iA^iB^{n-i}&#x3D;[x^m]c_ie^{(2i-n)x} \cdot (1+y)^i(1-y)^{n-i}&#x3D;c_i\dfrac{(2i-n)^m}{m! }(1+y)^i(1-y)^{n-i}$</p><p>和上面的形式一样! 于是 $y$ 的系数直接就取出来了.</p><h3 id="ABC238Ex-Removing-People"><a href="#ABC238Ex-Removing-People" class="headerlink" title="[ABC238Ex] Removing People"></a>[ABC238Ex] Removing People</h3><p>时间倒流考虑往位置填人, 要求是加人时有一个相邻点指向自己, 此时有一个很局部的性质, 这个点的贡献只和相邻点有关. 于是考虑区间dp, 设 $f_{l, r}$ 表示 $l, r$ 已经加入, 然后填好中间的这个方案数. $g_{l, r}$ 表示权值和.</p><p>转移就是考虑第一下填到哪, 然后把两边乘起来分配标号.</p><h3 id="P7718-「EZEC-10」Equalization"><a href="#P7718-「EZEC-10」Equalization" class="headerlink" title="P7718 「EZEC-10」Equalization"></a>P7718 「EZEC-10」Equalization</h3><p>显然要差分 $c_i&#x3D;a_i-a_{i-1}$, 考虑如果你的操作有一端连着端点那么相当于单点修改, 否则是给 $c_i\gets c_i+x, c_j\gets c_j-x$ 这样.</p><p>那么对第二类的修改连边 $i\to j$, 最优解一定形成若干棵树, 对每棵树如果所有点原来的 $\sum c_i\ne 0$ 还必然要用一次单点修改. 于是去dp子集划分即可, 每个子集对应一棵树.</p><p>然后要求方案数, 显然不会有相同的方案, 算一棵树的时候上个Caylay, 对于有自环的多乘个 $2n$($2$ 是因为单点修改可以操作 $[1, x]$ 也可以操作 $[x, n]$), 就做完了.</p><p>复杂度 $3^n$</p><h3 id="Shake-It"><a href="#Shake-It" class="headerlink" title="Shake It!"></a>Shake It!</h3><p>首先转化成最大流.</p><p>设 $f_{i, j}$ 表示 $S\to T$ 形的图操作 $i$ 次得到的图有 $j$ 的流量, $g_{i, j}$ 表示 $S\to a\to T$ 形的图操作 $i$ 次有 $j$ 的流量, 则 $g_{i, j}&#x3D;\sum_{k, a, b, \min(a, b)&#x3D;j-1} f_{k, a}f_{i-k, b}$. 是显然的, 复杂度是 $n^4$, 而 $g$ 转移到 $f$ 的时候注意此时 $g$ 中相同的方案是不区分的, 则枚举 $i, j$ 的方案用了多少个, 有 $f_{i, j}&#x3D;f_{i-kj, j-kj}\cdot \binom{g_{i, j}+k-1}{k-1}$. 就做完了吧!</p><h3 id="ABC231G-Balls-in-Boxes"><a href="#ABC231G-Balls-in-Boxes" class="headerlink" title="[ABC231G] Balls in Boxes"></a>[ABC231G] Balls in Boxes</h3><p>对一个盒子: $F(x)&#x3D;\sum_i \dfrac{(a_i+i)x^i}{i! }&#x3D;(a_i+x)e^x$, 卷起来提取 $k$ 就是答案.</p><p>要算</p><p>$$<br>[x^m]e^{nx}\prod_i (a_i+x)<br>$$</p><p>右边次数很低, 诶这不做完了?</p><h3 id="ABC242Ex-Random-Painting"><a href="#ABC242Ex-Random-Painting" class="headerlink" title="[ABC242Ex] Random Painting"></a>[ABC242Ex] Random Painting</h3><p>小球是在干什么, 装神弄鬼, 随机一个区间的意思</p><p>但是好厉害的题</p><p>显然可以离散化令 $n$ 变成 $m$ 的同阶.</p><h4 id="Sol1"><a href="#Sol1" class="headerlink" title="Sol1"></a>Sol1</h4><p>一个做法是min-max反演, 考虑对于一种方案, 所有方块被染色的时间组成多重集 $S$. 则</p><p>[trick] $\max(S)&#x3D;\sum_{T\subset S} (-1)^{T+1} \min(T)$, $E(\max(S))&#x3D;\sum_{T\subset S}(-1)^{T+1} E(\min(T))$.</p><p>于是考虑求一个子集的最小覆盖时间期望, 即第一次存在一个区间和这个集合有交的期望. 若与集合 $T$ 相交的区间有 $k$ 个, 显然期望是 $\dfrac{m}{k}$, 则dp设 $f_{i, j}$ 表示考虑前 $i$ 个格子的子集合 $T$, $i$ 必选, 与 $T$ 相交的区间有 $j$ 个的带容斥系数方案数. 转移是考虑上一个选择的元素 $j$ 从 $j$ 转移过来. 暴力复杂度是 $n^2m$. 可以线段树做到 $n^2\log n$</p><h4 id="Sol2"><a href="#Sol2" class="headerlink" title="Sol2"></a>Sol2</h4><p>考虑一个状态 $S$ 是当前已经染色的区间的集合, 显然转移形成dag, 有</p><p>[trick] 对DAG, $\text{停时期望}&#x3D;\sum_{S\text{不合法}} \text{S出现的概率}\times \text{离开状态S的期望时间}$.</p><p>离开有 $S$ 的期望时间显然是 $\dfrac{m}{\vert S\vert}$, 则要算 $p_i$ 表示选了 $i$ 个区间还没结束的概率.</p><p>哦, 做法一等价于算这个的时候用二项式反演钦定若干点必然不被覆盖吧</p><p>dp, 把区间按左端点排序, $f_{i, j, k}$ 表示考虑前 $i$ 个区间, 覆盖了 $[1, j]$, 选了 $k$ 个区间, 当前区间必选的概率, 转移只要求上一个区间的右端点能覆盖当前区间左端点.</p><p>注意到 $k$ 和给定区间无关, 设 $F_{i, j}(x)&#x3D;\sum_{k&#x3D;0}^m f_{i, j, k}x^k$, 则可以用同样的方法对任意常数算 $F_{i, j}(C)$, 于是最后来一个拉插就行了.</p><p>[trick] dp时强硬的用多项式表示一维并维护点值</p><p>复杂度和上面的做法一样.</p><h3 id="P4707-重返现世"><a href="#P4707-重返现世" class="headerlink" title="P4707 重返现世"></a>P4707 重返现世</h3><p>随便开一个minmax反演题. 来学minmax容斥证明, 基本思路就是 $C_1(S)&#x3D;\sum_{T\subset S} f(T)C_2(T)$, 其中 $C_1, C_2$ 可能是第几大&#x2F;小状物, 然后改为枚举右边 $C_2(T)$ 的值列组合数, 再套一下二项式反演.</p><p>这个题要求第 $k$ 小, 但其实第在知道集合总大小的情况下第 $k$ 小和第 $k$ 大是一样的, 发现对于一个集合它的最小值是好球的, 我们来推一推. 我们希望有 $\mathrm{kthmin}(S)&#x3D;\sum_{T\subset S} f(\vert T\vert)\min(T)$</p><p>考虑右边枚举最小值在集合中的 $rank$ 是 $y$(集合最小值rank为 $1$)值是 $v_y$, 则为 $\sum_{y&#x3D;1}^{\vert S\vert} v_y\sum_{i&#x3D;1}^{\vert S\vert-y+1} \binom{\vert S\vert-y}{i-1}f(i)$, 于是要求 $\sum_{i&#x3D;1}^{\vert S\vert-y+1} \binom{\vert S\vert-y}{i-1}f(i)&#x3D;[y&#x3D;k]$, 这不是二项式反演吗, 于是 $f(i)&#x3D;\binom{i-1}{\vert S\vert-k}(-1)^{i-\vert S\vert+k-1}$</p><p>于是这个题, $\mathrm{kthmin}(S)&#x3D;\sum_{T\subset S}\binom{\vert T\vert-1}{\vert S\vert-k}(-1)^{\vert T\vert-\vert S\vert+k-1}\min(T)$.</p><p>于是我们想算 $g_i&#x3D;\sum_{\vert T\vert&#x3D;i} \dfrac{m}{\sum_{j\in T} a_j}$, 对所有的 $i$.</p><p>直接背包显然爆炸了, 也就是我们不能把 $i$ 割裂的做, 需要整体维护, 注意到 $g_i$ 在答案中的贡献系数是 $(-1)^{i}F(i)$, $F$ 是不超过 $11$ 次的多项式或者说组合数, 于是做完了. 复杂度 $nmk$.</p><h3 id="P5244-USACO19FEB-Mowing-Mischief-P"><a href="#P5244-USACO19FEB-Mowing-Mischief-P" class="headerlink" title="P5244 [USACO19FEB] Mowing Mischief P"></a>P5244 [USACO19FEB] Mowing Mischief P</h3><p>$S$ 中的点两人都要经过, 所以容易发现相当于选若干个点 $(x_1, y_1)\ldots (x_k, y_k)$, 最大化 $k$ 再最小化 $\sum_i (x_i-x_{i-1})(y_i-y_{i-1})$.</p><p>那么直接dp, 设 $f_i$ 表示以 $i$ 点为结尾的序列长度, $g_i$ 表示面积, 那么 $g_i$ 只能从 $x_j\le x_i, y_j\le y_i, f_i&#x3D;f_j+1$ 的地方转移过来. 那么你按照 $f$ 排序转移.</p><p>那么 $g_i&#x3D;g_j+(x_i-x_j)(y_i-y_j)$, 但问题是变量有两个, 贡献形式形如($x_iy_j+x_jy_i+C_j$).</p><p>考虑决策单调性, 按 $x$ 排序, 同一层节点一定是 $y$ 单调递减的, 发现 $j$ 有决策单调性(容易发现交叉劣于包含), 随 $i$ 增加 $j$ 减少, 但是还有区间限制, 不同区间限制的决策点不好处理.</p><p>那就都搞成同一区间限制, 线段树分治, 把每个区间都拆到线段树上, 同一节点的限制就相同了. 复杂度俩log.</p><h3 id="P3438-POI2006-ZAB-Frogs"><a href="#P3438-POI2006-ZAB-Frogs" class="headerlink" title="P3438 [POI2006] ZAB-Frogs"></a>P3438 [POI2006] ZAB-Frogs</h3><p>二分答案, 只保留大于 $x$ 的, 判连通性, 复杂度是 $nm\log n$, 只要想办法对每个点求最近的坏点距离. 一行一起做是斜率优化.</p><h3 id="CF878D-Magic-Breeding"><a href="#CF878D-Magic-Breeding" class="headerlink" title="CF878D Magic Breeding"></a>CF878D Magic Breeding</h3><p>还挺巧妙.</p><p>对值域为 $01$ 的时候, 容易bitset, 同时注意 $n$ 维只有 $2^k$ 种本质不同的情况, 复杂度是 $\dfrac{2^kq}{w}$</p><p>对于原题, 考虑 $n$ 维是独立的, 可以先把每维离散化到 $1\ldots k$, 此时值域只有 $1\ldots k$, 再把每个数 $x$ 拆成 $k-1$ 位 $[x&gt;1], [x&gt;2]\ldots [x&gt;k-1]$, 就做完了!</p><h3 id="The-Ultimate-LIS-Problem"><a href="#The-Ultimate-LIS-Problem" class="headerlink" title="The Ultimate LIS Problem"></a>The Ultimate LIS Problem</h3><p>显然 $n$ 和 $2n+1$ 是有深意的.</p><p>考虑LIS转化成最小链覆盖, 然后构造长度分别为 $2, 2, 2, 2, \ldots 3$ 的解.</p><p>那么 $2$ 想到匹配, 于是把 $n+1$ 拿出来, $[1, n]$ 的看成右括号, $[n+2, 2n+1]$ 看成左括号, 左右括号数量相等必然存在一个位置可以转的合法, 先转过去.</p><p>然后此时如果 $n+1$ 在至少一个匹配的括号对里面显然直接做完了, 否则我们可以把它转到开头, 它必须要当左括号, 则意味着后面必须有两个左括号可以合并, 即 $[n+2, 2n+1]$ 不为升序, 那么一定可以做到. 同时还可以把 $n+1$ 放在最后判定是否有两个右括号可以合并.</p><p>那怎么证必要啊, 考虑你总可以把 $n+1$ 转到头上, 刚才说明任意两个左括号不可合并, 任意两个右括号不可合并, 看起来就真的无解了.</p><p>然后看下怎么求 $k$ 了, 维护一个括号序, 需要支持单点修改, 找到前缀和的最小值, 循环移位, 找到任意两个同色位置 $i, j$ 满足 $i&lt;j, a_i&gt;a_j$. 平衡树即可.</p><h3 id="AGC038E-Gachapon"><a href="#AGC038E-Gachapon" class="headerlink" title="[AGC038E] Gachapon"></a>[AGC038E] Gachapon</h3><p>设 $p_i&#x3D;\dfrac{A_i}{S}$, 枚举最后一个元素并在时间轴上分配标号:</p><p>$$<br>1+L(\sum_i p_i \dfrac{(p_ix)^{B_i-1}}{(B_i-1)! }\prod_{j\ne i} (e^{p_jx}-\sum_{k&#x3D;0}^{B_j-1}\dfrac{(p_jx)^k}{k! }))’\circ 1<br>$$</p><p>显然可以设 $P_i(x)&#x3D;e^{p_ix}-\sum_{j&#x3D;0}^{B_i-1} \dfrac{(p_ix)^j}{j! }$, $Q(x)&#x3D;p_i\dfrac{(p_ix){B_i-1}}{(B_i-1)! }$, 那么我们想求 $[y^1]\prod (P(x)+Q(x)y)$.</p><p>那么 $P, Q$ 都作为二元多项式 $Poly(x, e^x)$, 复杂度好像有点超标.</p><p>但是, 如果我们对每个 $y$ 维护 $x$ 的点值多项式, 则卷一次是 $n^2$, 一开始为每个 $P_i, Q_i$ 算点值复杂度是 $n^2$, 最后插值回来复杂度是 $n^3$!</p><p>也有min-max反演+dp的做法.</p><h3 id="AGC021F-Trinity"><a href="#AGC021F-Trinity" class="headerlink" title="[AGC021F] Trinity"></a>[AGC021F] Trinity</h3><p>考虑从左到右每次填一列, 那么容易想到设 $f_{i, j}$ 表示填了前 $i$ 列, 还有 $j$ 行没有填东西的方案数.</p><p>转移是分类讨论, 如果没有新占一列方案数显然是 $\binom j0+\binom j1+\binom j2$, 否则新占 $k$ 列, 如果贡献均来自新占的数, 方案数是 $\binom{k+j}{k}$, 如果只有一个来自其中是 $2\binom{k+j}{k+1}$(作为最大或最小乘 $2$), 否则都来自原来的数是 $\binom{j+k}{k+2}$.</p><p>于是 $f_{i, j}(\binom{j}{0}+\binom{j}{1}+\binom{j}{2})\to f_{i+1, j}, f_{i, j}\binom{j+k+2}{k+2}\to f_{i+1, j+k}$</p><p>加速转移, 对于第二个转移相当于egf卷 $\sum_k x^{k+2}$, 于是就ntt了.</p><p>然后可以不用ntt, 写成GF是二元($e^x, x$ 两元)$m$ 次的多项式, 可以直接转移做到 $m^3$</p><h3 id="CF1205F-Beauty-of-a-Permutation"><a href="#CF1205F-Beauty-of-a-Permutation" class="headerlink" title="CF1205F Beauty of a Permutation"></a>CF1205F Beauty of a Permutation</h3><p>见到这个是不是该考虑析合树, 只考虑每个点儿子的贡献, 析点有 $i$ 个儿子贡献 $i$, 合点贡献 $\dfrac{i(i+1)}{2}-1$(都不计算自身, 应该被父亲算).</p><p>然后直接对着这个dp就好了啊.</p><h3 id="ARC124F-Chance-Meeting"><a href="#ARC124F-Chance-Meeting" class="headerlink" title="[ARC124F] Chance Meeting"></a>[ARC124F] Chance Meeting</h3><p>容易想到两人坐标作差, 则实际上只有三个操作(A向下和B向上相同), 那么相当于从 $(0, 0)$ 开始每次向上&#x2F;左&#x2F;右走一步, 要求经过 $(0, n)$, 最后到达 $(0, 2n)$ 的方案数.</p><p>考虑从 $(0, 0)$ 用 $k$ 步走到 $(0, n)$ 方案数显然是 $\binom{k}{n, (k-n)&#x2F;2}$, 但这样可能多次穿过 $(0, n)$, 设这个方案数是 $g_i$. 而用 $k$ 步穿过一次的方案数显然是卡特兰数容易计算, 设卡特兰数 $c_i$, $C(x)&#x3D;\sum_i c_ix^i$, $f_i$ 表示走 $i$ 步第一次到达 $(0, n)$ 的方案数, $F(x)&#x3D;\sum_i x^i$, 则显然 $G&#x3D;F\dfrac{1}{1-C}$, 于是 $F&#x3D;G(1-C)$. 答案只要求 $F^2$.</p><h3 id="ABC254Ex-Multiply-or-Divide-by-2"><a href="#ABC254Ex-Multiply-or-Divide-by-2" class="headerlink" title="[ABC254Ex] Multiply or Divide by 2"></a>[ABC254Ex] Multiply or Divide by 2</h3><p>把乘 $2$ 看成对 $b$ 做除法, 则可以把值域控制下来, 且很有单调性.</p><p>于是考虑两个集合中的最大值, 若它们相等显然应该直接匹配掉, 否则尝试把大的除以 $2$ 或判断无解.</p><h3 id="ABC245Ex-Product-Modulo-2"><a href="#ABC245Ex-Product-Modulo-2" class="headerlink" title="[ABC245Ex] Product Modulo 2"></a>[ABC245Ex] Product Modulo 2</h3><p>看起来可以对每个质因子单独做. 现在对 $p^a$ 做 $n’&#x3D;n\bmod p^a$ 的子问题.</p><p>若 $n’\ne 0$</p><p>若 $n’$ 中 $p$ 的次数为 $x$, 那么可以把 $p$ 的因子分开, 如果一个位置选了 $p^i$, 那么非 $p$ 因子可以在模 $p^{k-i}$ 下选. 选 $p$ 因子的方案数显然是 $\binom{k+x-1}{k-1}$.</p><p>对于非 $p$ 因子部分, 相当于在以 $p^{a-x}$ 中与 $p$ 互质的数构成的乘法群里算, 容易发现得到每个元素的概率相等, 那么只要算总方案数除以 $\varphi(p^{a-x})$. 显然若位置 $i$ 选了 $p^i$, 那么它有 $\varphi(p^{a-i})&#x3D;p^{a-i-1}(p-1)$ 种方案. 这部分的方案数是 $\dfrac{p^{k(a-1)-x}(p-1)^k}{p^{a-x-1}(p-1)}&#x3D;p^{(k-1)(a-1)}(p-1)^{k-1}$.</p><p>若 $n’&#x3D;0$, 直接把所有不等于 $0$ 的减掉即可.</p><h3 id="ARC126E-Infinite-Operations"><a href="#ARC126E-Infinite-Operations" class="headerlink" title="[ARC126E] Infinite Operations"></a>[ARC126E] Infinite Operations</h3><p>先把数组排序.</p><p>容易发现最后一定都是平均值.</p><p>不容易发现最优策略一定是每次操作数组相邻两项, 而答案就是 $\dfrac{1}{2}\sum_{i&lt;j} \vert a_i-a_j\vert$.</p><p>有了这个直接动态开点线段树就好了.</p><p>[think] 不知道干啥你就排个序, 另外记得玩样例.</p><h3 id="ARC126F-Affine-Sort"><a href="#ARC126F-Affine-Sort" class="headerlink" title="[ARC126F] Affine Sort"></a>[ARC126F] Affine Sort</h3><p>考虑设 $f(x)$ 表示 $c&#x3D;x$ 时的对答案, 则 $F(k)&#x3D;\sum_{i&#x3D;1}^K f(x)$, 如果 $f(x)\sim ax^2$, 那么发现 $F(k)\sim \dfrac{1}{3}ax^3$. 于是如果能求得 $\dfrac{f(x)}{x^2}$ 的极限就赢了.</p><p>那么考虑要求 $ax_i+b$ 单调, 等价于要求 $\dfrac{ax_i+b}{k}$ 单调, $k$ 足够大时, 问题近似是 $[0, 1)$ 间连续的. 相当于对问题 $ax_i+b \bmod 1$ 单调, $a, b\in [0, 1]$ 的问题答案做二元积分.</p><p>那么对每个 $a$ 考虑合法的 $b$ 的范围, 则存在 $b$ 的条件是 $ax_i$ 是递增排列的循环位移, 或者说放在一个圆上它们顺时针转. 此时 $b$ 的范围是 $a(a_n-a_1)$.</p><p>考虑如何刻画循环位移, 等价于 $\sum_i w(x_i, x_{i+1\bmod n})&#x3D;1$, $w(a, b)$ 表示顺时针 $a\to b$ 的距离. 这个的意思是这么走只会在圆上转一圈.</p><p>则注意到 $w(x_i, x_{i+1})$ 是关于 $a$ 的 $O(\vert x_1-x_2 \vert)$ 段函数, 于是它们的和是不超过 $\sum_i x_i\le 5\times 10^5$ 段函数, 每段的值是一个常数, 分段对 $b$ 积分即可.</p><h3 id="ARC128F-Game-against-Robot"><a href="#ARC128F-Game-against-Robot" class="headerlink" title="[ARC128F] Game against Robot"></a>[ARC128F] Game against Robot</h3><p>设 $n$ 是 $\dfrac{N}{2}$</p><p>先考虑 $p$ 固定怎么做, 设你选择的第 $i$ 个数会被对面第 $r_i$ 次选, 那么能选它的条件是 $\sum_{j&lt;i} [r_j&lt;r_i]+i-1&lt;r_i$, 感觉很复杂.</p><p>注意这时两个人不是对称的, 考虑对面选的第 $i$ 个数它本来应该在第 $r_i$ 次选, 那么这个数满足 $r_i\le 2i$. 而你是倒数第 $i$ 次取的数在后 $2i$ 名.</p><p>那么直接把序列反过来, 要求你取的第 $i$ 个数满足 $r_i\in [1, 2i]$, 这时候就可以贪心了啊, 显然每次会选当前能选集合中的最大数. 每次加入前面两位, 再删掉集合最大值.</p><p>显然要拆贡献, 计算 $i$ 被计算的次数. 那么对这种比大小的考虑缩减值域, 可以变成算前 $k$ 大被算的总次数, 就可以把前 $k$ 大设为 $1$ 剩余的设为 $0$.</p><p>那么从前往后每两位分为一组, 设当前集合中 $1$ 的个数为 $x$, 每次显然是 $x\gets \max(0, x+c_i-1)$, 其中 $c_i$ 表示第 $i$ 组中 $1$ 的个数. 而 $x$ 取 $0$ 时就是选了一个 $0$.</p><p>画到平面上, 对应了一个每一步走 $(1, 1), (1, 0), (1, -1)$ 的折线, 对应 $c_i&#x3D;2, 1, 0$, 而如果这一步跨过 $y&#x3D;0$($c_i&#x3D;0$ 且 $x&#x3D;0$)就掰直成走 $(1, 0)$. 然后我们要数掰直次数不超过 $k$ 的折线.</p><p>考虑去掉max, 则原来每个掰直都会作为现在新的前缀min, 最后就要求全局最小值大于等于 $v(v&lt;0)$, 即选了 $n+v$ 个 $1$, 限制类似卡特兰数, 考虑反射容斥.</p><p>那么先要会算从 $(0, 0)$ 走到 $(x, y)$ 的方案数, 即 $[z^y] (z+2+z^{-1})^n$(注意 $c_i$ &#x3D;1的方案数是 $2$).</p><p>$$<br>\begin{gathered}<br>    [z^y] (z+2+z^{-1})^x\<br>    &#x3D;[z^y]z^{-x}(z^2+2z+1)^x\<br>    &#x3D;[z^{x+y}] (z+1)^{2x}\<br>    &#x3D;\binom{2x}{x+y}<br>\end{gathered}<br>$$</p><p>于是反射容斥, $\sum_i c_i&#x3D;k$ 所以要走到 $(n, k-n)$, 则若接触 $y&#x3D;v-1$ 反射后要走到 $(n, 2(v-1)-k+n)$ 就是 $\binom{2n}{n+k-n}-\binom{2n}{2(v-1)-k+2n}&#x3D;\binom{2n}{k}-\binom{2n}{k-2v+2}$. 那么最小值恰好为 $v$ 的方案数就是 $\binom{2n}{k-2v}-\binom{2n}{k-2v+2}$.</p><p>要求答案注意要再乘 $0$ 和 $1$ 内部相对顺序.</p><h3 id="ARC115E-LEQ-and-NEQ"><a href="#ARC115E-LEQ-and-NEQ" class="headerlink" title="[ARC115E] LEQ and NEQ"></a>[ARC115E] LEQ and NEQ</h3><p>简单题, 对条件容斥, 然后一段的权值是最小的 $a_i$, 直接dp+单调栈.</p><p>诶, 可以直接二维dp再数据结构优化一维.</p><h3 id="ARC112E-Cigar-Box"><a href="#ARC112E-Cigar-Box" class="headerlink" title="[ARC112E] Cigar Box"></a>[ARC112E] Cigar Box</h3><p>显然对一个数的操作只有最后一次有效.</p><p>考虑划分成不动, 到前面, 到后面 $3$ 个集合, 要求不动的集合递增, 然后三个集合的值域递增.</p><p>那么几乎做完了, 显然不动的集合在 $a$ 上一定是个区间, 那么确定这个区间后, 设左边有 $A$ 个, 右边有 $B$ 个, 则操作可以依据操作的数分成 $A+B$ 类, 方案数是 ${m\brace A+B}$, 对每个数的最后一次操作显然已经确定方向, 前面的任意, 所以乘 $2^{m-A-B}$, 向左和向右互不影响卷起来, 乘 $\binom{A+B}{A}$</p><h3 id="ARC124E-Pass-to-Next"><a href="#ARC124E-Pass-to-Next" class="headerlink" title="[ARC124E] Pass to Next"></a>[ARC124E] Pass to Next</h3><p>考虑设第 $i$ 个人传给下一个人 $x_i$, 要满足 $x_i\le a_i$, 则贡献是 $\prod_i (a_i+x_i-x_{i-1})$</p><p>那么考虑如果是个序列, 考虑经典的等于每一个里选一项乘起来算贡献, 那么对于当前第 $i$ 个括号, 若选择 $a_i$ 则不管这一位 $x$ 是多少都是 $a_i$, 若选择 $x_i$ 是一个等差数列求和, 若选择 $x_{i-1}$, 则需要和上一项合并是一个平方求和, 就能转移了.</p><p>然后因为是环需要断开, 枚举第一个括号选的哪一项即可.</p><h3 id="ARC138E-Decreasing-Subsequence"><a href="#ARC138E-Decreasing-Subsequence" class="headerlink" title="[ARC138E] Decreasing Subsequence"></a>[ARC138E] Decreasing Subsequence</h3><p>考虑让所有 $a_i\ne 0$ 的 $i$ 向 $a_i-1$, 形成 $n+1$ 个点的有向图, 则合法情况下每个点只能向前连边, 又因为互不相同一定形成若干条链, 每个链是有序的, 也就是相当于划分了若干个集合.</p><p>然后考虑一个长 $k$ 的下降序列, 表现为 $k$ 条边 $r_1\to l_1\ldots r_k\to l_k$, 满足 $l_1\le l_2\le \ldots l_k\le r_k \le \ldots r_2\le r_1$, 则容易发现所有点会被这些边分成值域不交的两部分. 于是直接枚举这两部分的大小 $x, y$, 先选出两部分点是 $\binom{n+1}{i+j}$, 两部分分别划分成 $k$ 条链, 方案数是 ${x\brace k}{y\brace k}$, 剩余的部分划分成若干条链是 $\sum_i {n+1-x-y\brace i}$, 就做完了.</p><h3 id="ARC131F-ARC-Stamp"><a href="#ARC131F-ARC-Stamp" class="headerlink" title="[ARC131F] ARC Stamp"></a>[ARC131F] ARC Stamp</h3><p>考虑反过来, 每次操作相当于把三个字符变成<code>? </code>, 这三个字符可以是<code>ARC</code>, <code>? RC</code>, <code>AR? </code>, <code>? ? C</code>, <code>? R? </code>, <code>A? ? </code>.</p><p>考虑<code>? </code>段一定是从<code>ARC</code>开始, 向右边扩展连续的<code>RC</code>和<code>C</code>, 向左扩展连续的<code>AR</code>和<code>A</code>, 然后可能有两段通过<code>? R? </code>合并. 而一个字符串可以唯一的划分成若干段 $(AR&#x2F;A)^aARC(RC&#x2F;C)^b$, 每段之间是一个单独的<code>R</code>或者连续的不可操作段<code>X</code>.</p><p>考虑设如<code>AR</code>, <code>A</code>等这样的是一段, 进行dp: $f_{i, j, 0&#x2F;1}$ 表示考虑前 $i$ 个段, 用了 $j$ 次操作, 是否当前段和下一段都要被操作成<code>? </code>.</p><p>然后此时要注意, 为了钦定不重, 如果一段始终没动, 不应该对它进行操作, 如一个固定的<code>ARC</code>, 如果前后没有依赖它变成<code>? </code>才能选的段, 那么若它本来是<code>ARC</code>也操作一次会和压根不动的方案重复. 此外对于两个连着的<code>ARC</code>如果中间没有东西, 因为后面的<code>ARC</code>不依赖前面应该在中间添加一个<code>X</code></p><p>复杂度 $nk$</p><h3 id="ARC139D-Priority-Queue-2"><a href="#ARC139D-Priority-Queue-2" class="headerlink" title="[ARC139D] Priority Queue 2"></a>[ARC139D] Priority Queue 2</h3><p>拆贡献, 枚举 $v$ 计算最后 $\ge v$ 的数个数.</p><p>这里甚至不用dp, 考虑若一开始有 $a$ 个 $1$, 加入了 $b$ 个 $1$, 那么每次操作是留下前 $n-x+1$ 大的数, 那么若 $a\le n-x+1$ 显然最后最多有 $n-x+1$ 个 $1$, 否则每次多一个 $1$, 则最后有 $\min(a+b, n-x+1)$ 个. 如果一开始 $a&gt;n-x+1$, 每次如果不加一个 $1$ 就会少一个 $1$, 即 $\max(a+b-k, n-x+1)$ 个.</p><h3 id="P9481-NOI2023-贸易"><a href="#P9481-NOI2023-贸易" class="headerlink" title="P9481 [NOI2023] 贸易"></a>P9481 [NOI2023] 贸易</h3><p>考虑算从每个点出发到其他所有点的距离和. 从父亲的答案转移到儿子, 则只要考虑最优解第一步不是走到父亲的点, 那么一定是起点为 $u$ 的第二类边. 那么现在若已有每个点到父亲的距离, 可以暴力更新第二类边的答案(一条第二类边 $u\to v$ 只影响 $v$ 的所有祖先), 于是复杂度是 $n\log^2 n$</p><h3 id="P9482-NOI2023-字符串"><a href="#P9482-NOI2023-字符串" class="headerlink" title="P9482 [NOI2023] 字符串"></a>P9482 [NOI2023] 字符串</h3><p>把正串和反串拼到一起SA, 然后就是数 $j$ 满足 $rank_i&lt;rank’<em>j$, $j\in [i, i+r-1]$, $lcp(s</em>{i\ldots j-1}, s_{2j-i\ldots j})&lt;j-i$.</p><p>第三个条件很难做, 但其实我们都知道放在这里只是防止它俩相等, 而相等就是回文串, 于是去掉第三个条件做二维数点, 再单独数回文串,<br>就做完了.</p><p>但是我不会求SA啊.</p><h3 id="P9478-NOI2023-方格染色"><a href="#P9478-NOI2023-方格染色" class="headerlink" title="P9478 [NOI2023] 方格染色"></a>P9478 [NOI2023] 方格染色</h3><p>喵的读成每次都要询问了.</p><p>那么横向&#x2F;竖向重叠的可以合并, 考虑显然就要求每条线段和其他线段的交集直接扫描线, 然后斜线可以每次枚举判断.</p><p>然后 $n, m$ 很大, 可以只管横竖线的情况离散化一下.</p><h3 id="P9479-NOI2023-桂花树"><a href="#P9479-NOI2023-桂花树" class="headerlink" title="P9479 [NOI2023] 桂花树"></a>P9479 [NOI2023] 桂花树</h3><p>注意 $k$ 很小.</p><p>称 $1\ldots n$ 为旧点, $n+1\ldots m$ 为新点.</p><p>首先 $T’$ 拿出 $1\ldots n$ 形成虚树一定是 $T$. 因为已知所有点lca肯定能构建唯一一棵树. 而你可以把任意形状的若干新点作为一组挂到叶子上或插到原树的一条边上.</p><p>看第二个限制, $1\ldots n$ 的点对已经确定了动不了, 有祖先关系的一定成立, 情况只有: 子树内最小值和当前组的一个点, 或者组内点对可能非法. 而子树内最小值的时候选旧点总是更优, 所以不会有组间非法.</p><p>考虑 $k&#x3D;0$, $n&#x3D;0$ 怎么做, 可以直接dp出 $f_{i}$ 表示 $i$ 个点的答案. $n\ne 0$ 之后, 注意对于一个组如果下面还有点相当于挂了一个 $-inf$, 然后此时因为只有大小关系可以直接卷.</p><p>但是考虑组的合并是没有前途的, 考虑第二个条件相当于 $1\ldots i$ 的虚树没有大于 $i+k$ 的点, 那么从小到大加点现在已经有一棵虚树, 虚树上有已经填了的点和一些还没填数的点(显然不超过 $k$ 个), 设当前虚树点数为 $c$, 往上新增一个点时可以选择</p><ul><li>填到边上或挂叶子, 有 $2c-1$ 种.</li><li>在一条边上加一个空点, 成为空点的叶子有 $c-1$ 种.</li><li>填一个空点, 然后有一个要求.</li></ul><p>注意每个空点创建时, 子树里最小值最大的两个点一定已经有了, 可以确定其是否能填 $i+1\ldots i+k$, 就做到 $tmk2^k$ 了.</p><h3 id="ARC127E-Priority-Queue"><a href="#ARC127E-Priority-Queue" class="headerlink" title="[ARC127E] Priority Queue"></a>[ARC127E] Priority Queue</h3><p>考虑如何判断一种状态合法, 那么最终一定互不相同, 那么从后往前做, 每次要么删掉一个集合中的数, 要么加入一个比当前集合中最大的数还大的未被加入过的数, 最终要变成空.</p><p>那么加入的时候应该加尽量小的数, 删的时候应该删尽量大的数, 而无解是因为加入数的时候没有数可以加.</p><p>那么考虑若最后数列是 $s_1\ldots s_{n-m}$, 则删的第 $i$ 个数就是 $s_{n-m-i+1}$, 设要删这个数的时候已经进行了 $p_i$ 次加数操作, 要满足 $n-s_{n-m-i+1}-(i-1)\ge p_i$(即, 这个数后面的空位数比要加的多).</p><p>问题就转化为求有序数列 $a$ 满足 $0\le a_i\le a_{i+1}\le m, a_i\ge p_i$ 的方案数. 可以暴力dp</p><p>实际上可以分治做到 $n\log^2 n$, 考虑把 $(i, a_i)$ 画到平面上是一个从左下到右上的线, $(i, p_i)$ 也是一条从左下到右上的线, 要求 $a$ 的线在 $p$ 的下面的方案数. 考虑分治, 把这个阶梯用 $x&#x3D;mid$, $y&#x3D;a_{mid}$ 两条线分成三部分: 两个子阶梯和中间一个正方形, 求出左下方子阶梯从右边线每个点出来的方案数, 通过一次卷积可以得到右上方的子阶梯从下面每个点进去的方案数, 就递归下去了.</p><p><img src="/img/2024-06-07-07-57-47-image.png" alt="picture 0"></p><h3 id="A-23省选二轮-day1-移动箱子"><a href="#A-23省选二轮-day1-移动箱子" class="headerlink" title="A. [23省选二轮 day1] 移动箱子"></a>A. [23省选二轮 day1] 移动箱子</h3><blockquote><p><img src="/img/2024-06-07-10-26-13-image.png" alt="picture 1">  </p><p>$y_i, n, m\le 10^5, x_i\le 10^{11}$</p></blockquote><p>你的操作肯定是从左往右, 如果大了就把多的移到右边. 设 $i\to i+1$ 的移动了 $b_i$, 显然有 $b_i&#x3D;\max(b_{i-1}+a_i-k, 0)$, $a_i$ 是这个位置数量.</p><p>注意相邻的两堆 $a_i, a_j$, 若 $[i, j]$ 中不存在 $b_k&#x3D;0$, 则可以 $a_i\gets a_i+a_j, a_j\gets 0$, 答案会变化的值是和 $k$ 无关的 $a_j(i-j)$.</p><p>于是从大到小扫 $m$, 用链表维护每个堆和前后合并的时间可以做到 $nm$, 因为要堆每个堆算 $\sum_j \max(0, a_i-jk)&#x3D;a_it-k\binom{t+1}2$, 其中 $t&#x3D;\lfloor\dfrac{a_i}{k}\rfloor$.</p><p>那么显然每个堆的共线是关于 $k$ 的 $O(\sqrt m)$ 段一次函数, 然后一共有一开始的 $m$ 个和合并后的 $m$ 个一次函数, 答案是这些一次函数的和 $O(m\sqrt m)$ 段就做完了.</p><h3 id="B-23省选二轮-day1-开黑团体"><a href="#B-23省选二轮-day1-开黑团体" class="headerlink" title="B. [23省选二轮 day1] 开黑团体"></a>B. [23省选二轮 day1] 开黑团体</h3><blockquote><p><img src="/img/2024-06-07-10-26-56-image.png" alt="picture 2">  </p><p>$n\le 28, m\le 5\times 10^5$</p></blockquote><p>暴力是直接FMT, 对 $x$ 处理 $b_x$ 表示 $\cup_{a_i\subset x} a_i$, $x$ 合法当且仅当 $b_x&#x3D;x$. 复杂度 $n2^n$.</p><p>考虑对每一位分开做, 处理 $c_{i, x}$ 表示 $x$ 在第 $i$ 位是否合法, 显然 $x$ 这位为 $0$ 的都合法, 那么把所有满足 $a_j$ 这一位为 $1$ 的 $c_{i, a_j}$ 位置赋值为 $1$ 对这些这位为 $1$ 的地方做FMT, 为 $0$ 的地方不做.</p><p>那么要对每一位做这个, 而且每一位恰好自己那一位不做FMT, 于是上个缺一分治, 复杂度是 $\dfrac{2^nn\log n}{w}$</p><h3 id="C-23省选二轮-day1-123-vs-321"><a href="#C-23省选二轮-day1-123-vs-321" class="headerlink" title="C. [23省选二轮 day1] 123 vs 321"></a>C. [23省选二轮 day1] 123 vs 321</h3><blockquote><p><img src="/img/2024-06-07-11-06-14-image.png" alt="picture 3">  </p><p>$n\le 5\times 10^7$</p></blockquote><p>考虑假设已经要选 $a$ 个上升, $b$ 个下降, 对上升一定是选最前面的 $1$ 和最后面的 $3$, 对下降一定是选最前面的 $3$ 和最后面的 $1$, 那么现在有 $a+b$ 个上升&#x2F;下降区间, 每个区间要匹配一个 $2$.</p><p>考虑Hall定理, 那么一定是选择一个 $l, r$, 所有在 $[l, r]$ 中的区间都选才是最紧的, 则分别是上升&#x2F;下降区间的一个区间</p><p>todo</p><h3 id="ABC249G-Xor-Cards"><a href="#ABC249G-Xor-Cards" class="headerlink" title="[ABC249G] Xor Cards"></a>[ABC249G] Xor Cards</h3><p>考虑把 $x$ 插到线性基 $A$ 同时记录对应 $y$, 那么有些元组插不进去, 此时这些元组可以被 $A$ 中的表示, 相当于可以任意选择, 把对应的 $y$ 插入到第二个线性基 $B$.</p><p>那么从高到低考虑 $K$ 的位和线性基当前选择的 $x$ 异或值 $X$, 分类讨论, 若 $X$ 和 $K$ 这一位都是 $0$ 则对应线性基元素不能选, $X$ 是 $1$, $K$ 是 $0$ 必须不选, 否则可以选择选&#x2F;不选, 若选择其中一个就继续, 另一个就可以后面的位和 $B$ 中任意选, 就做完了.</p><p>复杂度 $n\log W+\log^2 W$.</p><h3 id="CF936E-Iqea"><a href="#CF936E-Iqea" class="headerlink" title="CF936E Iqea"></a>CF936E Iqea</h3><p>注意剩余部分也连通说明给定的点不会成一个环, 考虑如果是个树问题就是点分树简单题了, 问题是可能有很大的块在图上.</p><p>考虑一行一个极长连续段作为一个点, 做完了.</p><h3 id="ARC140F-ABS-Permutation-Count-ver"><a href="#ARC140F-ABS-Permutation-Count-ver" class="headerlink" title="[ARC140F] ABS Permutation (Count ver. )"></a>[ARC140F] ABS Permutation (Count ver. )</h3><p>考虑 $M&#x3D;1$ 的时候, 满足条件的位置形成若干条链, 若确定了链的大小分别为 $a_1\ldots a_k$, 则方案数是 $k! 2^{\sum_i [a_i]&gt;1}$, 即一段贡献 $F(x)&#x3D;x+\sum_{i&#x3D;2} 2x^i$. 若钦定有 $i$ 个位置满足限制, 链的数量应为 $n-i$.</p><p>但这时候直接做 $n-i$ 次方提取 $k$ 项系数是不对的, 因为可能有两条链实际上是一条, 我们设长 $k$ 的链贡献 $c_k$, $C(x)&#x3D;\sum_i c_ix^i$, 有 $\dfrac{1}{1-C(x)}&#x3D;F(x)$, 就可以得到真实的系数了. 然后 $k$ 对的答案是 $(n-k)! [x^n]C^{n-k}(x)$ 对所有 $k$ 求, 实际上是对所有 $i$ 求 $[x^n]C^i(x)$, 转置原理就是对所有 $i$ 求 $[x^i]C^n(x)$ 了.</p><p>好吧这地方没必要转置原理吧, $F(x)&#x3D;\dfrac{2x}{1-x}-x$, $C(x)&#x3D;\dfrac{x(1+x)}{1-x}$, 则 $[x^n]C^i(x)&#x3D;\dfrac{x^i(1+x)^i}{(1-x)^i}&#x3D;\sum_j \binom{i}{j}\binom{n-j+i-1}{n-j}$, 对所有 $i$ 求这个, 拆开卷积就好了.</p><p>然后对 $M\ne 1$, 可以考虑 $P^{-1}$, 此时相当于要求不存在 $P_i$ 与 $P_{i+M}$ 的值相邻, 相当于把 $P$ 划分成若干个独立的子问题, 注意子问题的大小只有两种所以分别求答案再卷一下即可.</p><h3 id="ARC118E-Avoid-Permutations"><a href="#ARC118E-Avoid-Permutations" class="headerlink" title="[ARC118E] Avoid Permutations"></a>[ARC118E] Avoid Permutations</h3><p>注意对 $P$ 累加 $F(P)$ 等于对一条路径累加不能把障碍放到路径上, 放障碍的方案.</p><p>但是放障碍的时候要当一个排列放, 发现我们会算乱放的(还剩 $k$ 个没放就是 $k!$), 那么容斥, 算钦定了 $k$ 个在路径上的方案数, 放这些的时候要保证没有同行同列则只要设 $f_{i, j, k, 0&#x2F;1, 0&#x2F;1}$ 表示路径走到 $(i, j)$, 放了 $k$ 个, 是否在同行放过, 是否在同列放过的方案数. 复杂度 $n^3$</p><h3 id="AGC053C-Random-Card-Game"><a href="#AGC053C-Random-Card-Game" class="headerlink" title="[AGC053C] Random Card Game"></a>[AGC053C] Random Card Game</h3><p>设两堆是 $L, R$, 容易发现最大值不会被删, 所以最后留空的一堆事确定的, 不放设是堆 $L$.</p><p>那么只要最小化 $R$ 中元素被删的个数, 容易发现策略是若存在 $L$ 中的元素比 $R$ 中对应元素大就删掉满足这个条件的 $k$ 最大的. 否则删 $L$ 的第一个元素(显然 $L$ 中第一个元素肯定迟早要删). 分析操作次数, 设开始时 $L$ 中第 $i$ 个元素对应 $R$ 中 $k$ 最小的大于它的元素是 $p_i$, 发现答案是 $n+\max p_i-i$.</p><p>考虑再拆贡献, 计算 $\max p_i-i\le k$ 的方案数, 然后这个就要求对任意 $i\in [1, n]$, 存在一个 $j\in [1, i+k]$ 使得 $b_j&gt;a_i$.</p><p>然后这个直接组合数学乘起来.</p><h3 id="LGR-189-Div-2-核桃编程-6-月月赛-I-amp-JRKSJ-Round-8"><a href="#LGR-189-Div-2-核桃编程-6-月月赛-I-amp-JRKSJ-Round-8" class="headerlink" title="[LGR-189-Div. 2]核桃编程 6 月月赛 I &amp; JRKSJ Round 8"></a>[LGR-189-Div. 2]核桃编程 6 月月赛 I &amp; JRKSJ Round 8</h3><h4 id="T457265-JRKSJ-R8-网球"><a href="#T457265-JRKSJ-R8-网球" class="headerlink" title="T457265 [JRKSJ R8] 网球"></a>T457265 [JRKSJ R8] 网球</h4><p>设两个合法齿轮分别有 $x, y$ 个, 要求 $ay&#x3D;bx$, $g&#x3D;\gcd(a, b)$, 则一组解是 $x&#x3D;b&#x2F;g$, $y&#x3D;a&#x2F;g$.</p><p>显然你唯一能做的就是一起乘一个数.</p><h4 id="T375744-JRKSJ-R8-三七二十一"><a href="#T375744-JRKSJ-R8-三七二十一" class="headerlink" title="T375744 [JRKSJ R8] 三七二十一"></a>T375744 [JRKSJ R8] 三七二十一</h4><p>首先不能有 $\texttt{1, 2, 4, 8}$, 发现满足这个的二的次幂只有 $65536$, 然后随便做了.</p><h4 id="T387475-JRKSJ-R8-1-1"><a href="#T387475-JRKSJ-R8-1-1" class="headerlink" title="T387475 [JRKSJ R8] +1-1"></a>T387475 [JRKSJ R8] +1-1</h4><p>那么 $x$ 自己必须是<code>(</code>, 若 $x$ 旁边有一个<code>(</code>显然可以反复横跳得到大量的<code>(</code>, 如果没有只能是 $x$ 旁边都是<code>)</code>, 再一层必须有<code>(</code>, 再往外又是<code>)</code>这样才阻止我们刷括号. 相当于走正反括号交替的路径, 只保留连正反括号的边可以得到一张二分图, 如果 $x, y$ 在同一个连通块上显然直接就判完了, 否则要求 $x$ 去找一个两端都是<code>(</code>的边, $y$ 同理, 最后有个路径长度奇偶性限制.</p><h4 id="P10573-JRKSJ-R8-C0mp0nents"><a href="#P10573-JRKSJ-R8-C0mp0nents" class="headerlink" title="P10573 [JRKSJ R8] C0mp0nents"></a>P10573 [JRKSJ R8] C0mp0nents</h4><p>注意到 $k\ne 1$ 的时候模 $k$ 的同余类都是子问题, 所以规约到 $k&#x3D;1$.</p><p>此时要想变到 $s$, 因为一个值只出现一次, 变成 $s$ 的点的值一开始一定是一个连通块, 且每个位置数变化都是单调的, 则若最终 $<a href="s%5Cin%5Bl,r%5D">l, r</a>$ 变成 $s$, 和 $[l, r]$ 以外的点无关.</p><p>考虑 $s&#x3D;1$ 的情况, 发现充要条件是每个 $[1, r)$ 的点都能连向比自己大的点, 此时最大值才能不断下降(任意时刻, 最大值所在连通块的初始权值是一个 $[x, r]$ 的区间), 于是对于 $[l, r]$ 就分两部分限制即可. 只要每个点 $u$ 找到与自己连通的小于自己的最大值&#x2F;大于自己的最小值, 设为 $l_u, r_u$, 那么对 $[l, r]$ 限制是 $\forall i\in [s, r], r_u\lt r$, 另一边也一样.</p><p>然后可以扫描 $s$ 的过程中统计答案了.</p><h4 id="P10574-JRKSJ-R8-暴风雪"><a href="#P10574-JRKSJ-R8-暴风雪" class="headerlink" title="P10574 [JRKSJ R8] 暴风雪"></a>P10574 [JRKSJ R8] 暴风雪</h4><p>考虑一次修改 $x$ 对 $f$ 造成的影响, 表现为对到根的路径上的值 $u_i$ 和序列 $val_i$ 对应取max, $val_i$ 自然为 $u_i$ 在这一层的和. 那么注意到若存在 $val_i\ne val_{i-1}$, 必须是因为 $u_i$ 有这个链以外的另一棵子树深度不小于 $dep_x$, 那么容易发现最多有 $\sqrt n$ 个这样的段, 且因为 $val$ 单调递增可以看成 $\sqrt n$ 个根链取max, 树剖容易做到 $n\sqrt n\log n$</p><p>需要优化到$n\sqrt n$.</p><p>注意到 $u_i$ 满足的性质: 若第 $i$ 段长 $a_i$, 则 $a_i$ 的侧链必须至少长 $\sum_{j&#x3D;1}^{i-1} a_j$, 所以 $\sum_i \sum_{j&lt;i} a_j\le n$, 可得 $\sum_i \log(a_i)&#x3D;O(\sqrt n)$, 所以实际上拆到线段树上只有 $\sqrt n$ 个节点.</p><p>要能做到 $O(1)$ 定位包含一个区间的最小区间,这个东西考虑猫树,即线段树长度搞成$2^k$,那么只要用位运算求叶子的lca,定位全部区间依次修改并统一pushup就可以做到 $\sqrt n$.</p><p>然后要能不带log找所有分段点,那么根号分治,近$\sqrt n$个暴力,而对于后面的点只有存在一个轻子树内点深度大于$\sqrt n$的有可能,这样的点最多有$\sqrt n$个.</p><p>然后要能求点$u$子树内深度为$d$的点的和,考虑维护每个点轻子树每一层的和(总量为$n\log n$),在同一条重链上跳就可以直接加,然后用bit维护每层的和,在跳过轻边时查一下.</p><p>就$n\sqrt n$了!</p><h3 id="ZR-Day2-A-蝴蝶兰"><a href="#ZR-Day2-A-蝴蝶兰" class="headerlink" title="ZR Day2 A. 蝴蝶兰"></a>ZR Day2 A. 蝴蝶兰</h3><blockquote><p><img src="/img/2024-06-09-10-53-11-image.png" alt="picture 4">  </p><p>$n\le 2. 5\times 10^6$</p></blockquote><p>注意到只有前缀max造成贡献. 于是把 $h$ 从小到大排序选出前缀max的位置, $f_i$ 表示考虑 $i$ 后面的数, $i$ 为前缀max, 后面的数能承受多大风力, 显然 $h_j&lt;h_i$ 的 $j$ 不会造成影响, 转移就是 $f_i&#x3D;\max_j \min(f_j, {\dfrac{s_j}{h_j-h_i}})$.</p><p>每个数的转移是 $\dfrac{a}{b-x}$ 的形式, 注意到任意两个这样的函数最多有一个交点, 于是有决策单调性, 开个栈可以线性.</p><p>[think] 剔除不贡献的元素获得单调性</p><h3 id="ZR-Day2-B-风铃草"><a href="#ZR-Day2-B-风铃草" class="headerlink" title="ZR Day2 B. 风铃草"></a>ZR Day2 B. 风铃草</h3><blockquote><p><img src="/img/2024-06-09-11-23-37-image.png" alt="picture 5">  </p><p>$n\le 3\times 10^5$</p></blockquote><p>有点难绷, 读成在前面加<code>(</code>了. 那你策略肯定是先把总数弄对了, 然后设 $i$ 处前缀和为 $s_i$, 操作次数就是 $\sum_i \lceil \min(0, s_i-k)&#x2F;2\rceil$, 其中 $k$ 是在前面添加的<code>)</code>数量.</p><p>考虑怎么快速算答案, 一个位置的贡献其实是 $[s_i&gt;k] \lceil(s_i-k)&#x2F;2\rceil$, 后面的部分每个数在 $k$ 奇偶性确定的情况下是一个一次函数, 于是分块, 对于 $[s_i&gt;k]$ 一个块只有 $\sqrt n$ 种不同的情况, 每个情况维护奇&#x2F;偶分别对应的贡献即可. 而且注意由于 $s_i-s_{i-1}\in [-1, 1]$, 值域也是 $\sqrt n$ 不用开有序表二分而可以直接开桶维护.</p><p>复杂度 $n\sqrt n$</p><h3 id="ZR-Day2-C-香雪兰"><a href="#ZR-Day2-C-香雪兰" class="headerlink" title="ZR Day2 C. 香雪兰"></a>ZR Day2 C. 香雪兰</h3><blockquote><p><img src="/img/2024-06-09-11-41-52-image.png" alt="picture 6">  </p><p>$n\le 250$</p></blockquote><p>令 $f_{n, i}$ 表示连出长度为 $n$ 的链, 最后一次连链上的边后连了 $i$ 条非链边. $g_{n, i}$ 表示 $f_{n, i}$ 的前缀和. 转移是枚举 $k, L, R$ 表示最后 $f_{n, i}$ 子问题中最后连的链边是 $k\to k+1$, 在这之后左边部分连了 $L$ 条, 右边连了 $R$ 条, 则由 $g_{k, L}$ 和 $g_{n-k, R}$ 转移.</p><p>化一下卷积形式维护点值就做完了. 复杂度 $n^4$.</p><h3 id="YDRS-008-人团圆-梦也团圆-·-云斗六月-Silver-Round"><a href="#YDRS-008-人团圆-梦也团圆-·-云斗六月-Silver-Round" class="headerlink" title="[YDRS#008] 人团圆, 梦也团圆 · 云斗六月 Silver Round"></a>[YDRS#008] 人团圆, 梦也团圆 · 云斗六月 Silver Round</h3><h4 id="C-熙攘市场今何在"><a href="#C-熙攘市场今何在" class="headerlink" title="C. 熙攘市场今何在"></a>C. 熙攘市场今何在</h4><p>考虑先让第一个排列变成 $1\ldots n$. 第二个排列形成若干置换环, 限制只发生在每个环内部.</p><p>考虑再把一个点拆成两个表示选正面&#x2F;反面, 则一个置换环拆完了还是环, 限制是相邻两个点不能同时选.</p><p>对环算最大独立集是简单的, 就做完了.</p><h4 id="D-Yet-Another-Passing-Ball-Problem"><a href="#D-Yet-Another-Passing-Ball-Problem" class="headerlink" title="D. Yet Another Passing-Ball Problem"></a>D. Yet Another Passing-Ball Problem</h4><p>对不超过一半考虑容斥掉, 容斥系数显然是不满足一半限制的时刻 $i$ 的个数.</p><p>那么可以列出dp $f_{i, j}$ 表示考虑前 $i$ 个时刻, 有 $j$ 个人拿球的带容斥系数方案数, 则</p><p>$$<br>f_{i, j}{k-j \brace l}\binom{n}{l}\to f_{j, l}<br>$$</p><p>然后如果 $l&gt;\dfrac{k}{2}$ 要额外乘 $-1$.</p><p>发现第二维很小, 矩阵快速幂优化一下就做完了.</p><h4 id="E-Inverted-World"><a href="#E-Inverted-World" class="headerlink" title="E. Inverted World"></a>E. Inverted World</h4><p>考虑有 $i&#x3D;j^{k&#x2F;j}$, $j$ 要能开若干次方是一个很强的限制, 设 $g&#x3D;\gcd(k, j)$, 则 $j$ 要能开 $j&#x2F;g$ 次方, 对 $j&#x2F;g$:</p><p>若 $j&#x2F;g&#x3D;1, j&#x3D;g$, 问题变成 $i&#x3D;j^{k’}$, 限制题目 $i, k’j\le n$ 的限制, 显然除了 $j&#x3D;1$ 只有 $\log n$ 段不同的 $k’$, 直接做就行了.</p><p>若 $j&#x2F;g&#x3D;2, i&#x3D;j^{\frac{k’}{2}}$, 要求 $k’$ 是奇数和范围限制, 仍然枚举 $k’$ 计算.</p><p>否则 $j&#x2F;g\ge 3$, 则 $j\le n^{\frac13}$, 那么枚举 $j&#x2F;g$ 和 $j$(总共不到 $n\ln n$, 因为有大量 $j$ 不合法), 确定 $j’&#x3D;j^{\frac{g}{j&#x2F;g}}$, $k’$ 要满足 ${j’}^{k’}\le n$, $\gcd(k’, j&#x2F;g)&#x3D;1$, $k’, j&#x2F;g$ 都很小, 可以预处理后快速计算.</p><p>然后实际上枚举 $d&#x3D;j&#x2F;g$ 和 $j$ 不是 $n\ln n$ 因为还有 $j^{1&#x2F;d}$ 是整数的限制.</p><h3 id="ARC076F-Exhausted"><a href="#ARC076F-Exhausted" class="headerlink" title="[ARC076F] Exhausted?"></a>[ARC076F] Exhausted?</h3><p>相当于求人到椅子的最大匹配. 每个人 $i$ 可以匹配的是一个前缀 $[1, l_i]$ 加一个后缀 $[r_i, m]$.</p><p>考虑Hall定理, 我们要选一个集合最小化连向的前缀并连上的后缀.</p><p>枚举一个前缀位置 $p$, 则所有 $l_i&gt;p$ 的 $i$ 都不能选, 此时以 $s$ 为后缀就把所有 $r_i\ge s$ 的都选上最优, 那么从小到大扫描 $p$, 不断加入区间 $[l, r]$, 用线段树维护以 $s$ 为后缀的答案即可.</p><p>另一个做法是贪心, 考虑按 $l_i$ 从小到大扫人, 如果能匹配就匹配, 否则必须有一个人去右边匹配, 把左边 $r$ 最小的拿出来让他去右边匹配即可.</p><h3 id="CF725F-Family-Photos"><a href="#CF725F-Family-Photos" class="headerlink" title="CF725F Family Photos"></a>CF725F Family Photos</h3><p>考虑如果没有照片对中必须先选第一个的限制, 那么选一个会获得 $a_i$, 不选会损失 $b_i$, 可以A选获得 $a_i+b_i$, B选获得 $0$(实际上是不让A选), 那么方法是按照 $a_i+b_i$ 从大到小排序, 两人都从前往后选.</p><p>注意到若 $a_1+b_1&gt;a_2+b_2$ 那么限制已经天然满足了会先选 $1$, 考虑如果 $a_1+b_1&lt;a_2+b_2$, 那么后选这一对的人可以获得 $a_2+b_2$, 如果当前先手选它, 后手立刻选这一对的第二个, 其他位置和先后手都不会变, 那么先手先执行在剩下位置执行的操作是不劣的; 如果先手选它后手不选第二个说明其他地方有收益更高的先手也不应该选这个位置.</p><p>如果一个位置我们不选应该获得 $b_i$(一开始强制损失的值). 那么讨论 $a_1+b_1&lt;a_2+b_2$ 的对, 现在轮到 A(选完所有一定选的一定轮到A), 如果它不选第一个而B选了肯定获得 $a_2+b_2$, 如果两人都不选获得 $b_1+b_2$, 那么若 $a_1+b_1&lt;b_1+b_2$, A 不会选这个对.</p><p>同理有对B, 不选A获得 $b_1+b_2$, 选了A获得 $a_2+b_2$, 则当 $b_1+b_2&lt;a_2+b_2$ 时不会选这个对. 如果这个和上面的同时发生那么谁也不选它.</p><p>于是就分析完了. 感觉重点在, 抛去限制后, 每个对是相对独立的, 可以分析在A干的合理的情况下B会跟着A选这件事, 使得只要考虑一对.</p><h3 id="AGC023F-01-on-Tree"><a href="#AGC023F-01-on-Tree" class="headerlink" title="[AGC023F] 01 on Tree"></a>[AGC023F] 01 on Tree</h3><p>考虑如果一个位置是 $0$, 它应该在父亲被删掉的时候立刻删掉, 于是把它和父亲合并. 那么如果一个位置一定在父亲选后的下一次操作被选就可以把它和父亲合并. 设每个点 $u$ 有 $c_{u, 0}$ 个 $0$ 和 $c_{u, 1}$ 个 $1$.</p><p>考虑现在选完一个点, 接下来可以选 $u, v$, 那么 $c_{u, 1}c_{v, 0}&lt;c_{v, 1}c_{u, 0}$ 显然交换时贡献变小. 应该把 $u$ 放在前面, 于是 $\dfrac{c_{u, 1}}{c_{u, 0}}$ 最小的点应该紧接着自己的父亲被选.</p><p>重点是紧接着父亲被选的合并, 以及只和点对自身, 相对位置先关贡献的邻项交换.</p><h3 id="AGC007F-Shik-and-Copying-String"><a href="#AGC007F-Shik-and-Copying-String" class="headerlink" title="[AGC007F] Shik and Copying String"></a>[AGC007F] Shik and Copying String</h3><p>显然 $s_0$ 的每个字符 $s_{0, i}$ 可能扩展成一个区间 $[l_i, r_i]$, 满足 $l_i\ge i$. 同时 $[l_i, r_i]$ 是关于 $i$ 是有序的. 满足以上条件则合法.</p><p>而这个过程可以用折线描述, 每个 $s_{0, i}$ 形成从 $s_0$ 到 $t$ 的路径, 一条路径左右两侧, 不跨过下一条路径的点都可能是 $s_{0, i}$, 不难发现最优解下每个点都尽力往右跑直到到达自己目标区间的左端点.</p><p>用队列维护所有转折点(即每行折线上的第一个点), 那么发现第 $i$ 条折线在第 $j$ 行的转折点是第 $i+1$ 条折线在第 $j-1$ 行的转折点向左下移动一格. 于是只要每次删掉已经到达目的地的点, 平移一下即可维护.</p><p>复杂度线性.</p><h3 id="P5912-POI2004-JAS"><a href="#P5912-POI2004-JAS" class="headerlink" title="P5912 [POI2004] JAS"></a>P5912 [POI2004] JAS</h3><p>同时是 [AGC009D] Uninity</p><p>显然要求深度最浅的一棵点分树.</p><p>考虑设每个点的子树高度为 $h_i$, 那么 $\forall h_i&#x3D;h_j, \exists k, h_k&gt;h_i, h_k&gt;h_j$, 即 $k$ 要能把 $h$ 相等的点划分到两棵子树.</p><p>考虑现在一个子树 $u$, 设 $S_u$ 表示所有值 $v$ 构成的集合, 其中 $v$ 满足存在一个 $h_k&#x3D;v$, 使得 $k\to u$ 路径上不存在 $h_w&gt;h_k$. 那么现在合并儿子们到点 $u$, 那么如果存在两个儿子 $s_1, s_2$, $x\in S_{s_1}\cap S_{s_2}$, 则 $h_u$ 要大于 $x$. 同时如果 $h_u$ 是某个 $S$ 中的元素也不行. 就可以推出 $h_u$. 而 $S_u$ 就是所有 $S$ 和 ${h_u}$ 并起来, 去掉比 $h_u$ 小的元素.</p><p>复杂度 $O(n\log n)$, 可以用位运算压到 $O(n)$.</p><p>[think] 感觉把点分树转化成对 $h$ 的限制很厉害, 感觉把限制拆成很多这样更小的限制让它变得更局部了.</p><h3 id="AT-code-festival-2017-qualb-f-Largest-Smallest-Cyclic-Shift"><a href="#AT-code-festival-2017-qualb-f-Largest-Smallest-Cyclic-Shift" class="headerlink" title="AT_code_festival_2017_qualb_f Largest Smallest Cyclic Shift"></a>AT_code_festival_2017_qualb_f Largest Smallest Cyclic Shift</h3><p>感觉很困难, 做法是把当前问题变成有一个串的多重集 $M$, 拼成 $f(S)$ 最大的 $S$, 那么每次应该拿出 $M$ 中最小和最大的字符串 $m_1, m_k$, 把 $m_k+m_1$ 放回 $M$.</p><p>显然如果 $M$ 中元素各不相同最好的方式就是 $m_1+m_k+m_{k-1}\ldots m_2$, 然后现在有若干个 $m_1$, 每个都会作为一个起点, 容易发现按照上面的做法 $M$ 中最多有 $3$ 种不同的元素 $A, B, C$, 设分别有 $a, b, c$ 个.</p><p>如果 $a&lt;c$, 能拼成 $AC$ 是显然优的.</p><p>如果 $a&lt;b+c$, $f(S)$ 以 $AB$ 开头, 应该得到 $AB, AC, B$, 考虑如果存在一个 $C$ 没有这时拼上得到 $(AB, AC, B, C)$, 那么在以后某时刻终于 $c&gt;a$, 让我们留的 $C$ 派上用场, 我们一开始用这些 $c$ 在很早以前把这些 $a$ 干掉就很优.</p><p>对 $a&gt;b+c$, 变成 $(A, AB, AC)$ 同理.</p><h3 id="P4364-九省联考-2018-IIIDX"><a href="#P4364-九省联考-2018-IIIDX" class="headerlink" title="P4364 [九省联考 2018] IIIDX"></a>P4364 [九省联考 2018] IIIDX</h3><p>我们可以先建一棵树, 若 $i$ 解锁 $j$ 则 $i$ 是 $j$ 的父亲, 一个点的所有儿子按编号从左到右排, 限制就是要求儿子大于父亲, 求字典序(bfs序字典序)最大的解.</p><p>在 $d$ 不重复的时候是容易做的, 把权值从大到小排序, 然后每个儿子子树分配一个区间的权值递归下去.</p><p>但如果 $d$ 存在重复, 那么现在第一个儿子填什么仍然确定, 然后应该优先把这个值的全都丢进子树, 留下最大的若干个? 但这是不对的, 确定这个儿子的时候, 也有可能留下的若干个没有影响这个点的兄弟, 而到了兄弟的儿子中, 此时不如给当前儿子的儿子了.</p><p>考虑 $1\ldots n$ 逐位确定, 那么要保证当前点 $u$ 填完之后还合法, 只要保证还能有 $siz_u-1$ 个不小于当前值的数, 相当于存在一个每个 $u$ 匹配 $siz_u-1$ 的匹配</p><p>这个可以hall定理啊, 就成了要求对所有后缀, 后缀内被填了的 $u$ 的 $siz$ 之和不大于后缀长度了.</p><p>然后到一个点的时候要把它父亲的限制修正(不是要求 $fa_u$ 有 $siz_{fa_u}$ 个匹配, 要让 $u$ 子树内的匹配 $u$).</p><p>复杂度 $n\log n$.</p><h3 id="AGC010E-Rearranging"><a href="#AGC010E-Rearranging" class="headerlink" title="[AGC010E] Rearranging"></a>[AGC010E] Rearranging</h3><p>考虑如果第一个人已经确定了序列,若$i,j$不互质,那么我们不能交换它们,$i$在最终的序列一定在$j$左侧,对所有不互质的点对建条件就是完备的,得到一个 DAG,而最终序列就是DAG的拓扑序,只要在拓扑序的时候把队列换成堆就可以求字典序最大的拓扑序,这是对一个已经确定的序列的做法.</p><p>现在序列还没确定,那么把所有不互质的点对拿出来连边得到若干连通块,对每个连通块要最小化它的字典序,这里就贪心的看每个点,让最小的连到自己的定向到自己,得到一棵树即可,容易发现是最优的.</p><h3 id="CF526G-Spiders-Evil-Plan"><a href="#CF526G-Spiders-Evil-Plan" class="headerlink" title="CF526G Spiders Evil Plan"></a>CF526G Spiders Evil Plan</h3><p>以$x$为根,相当于选$2y$或$2y-1$($x$度数为$1$)个叶子</p><p>然后贡献是一个链并的形式不好求,注意到对$x$的一个$u$的子树内若存在叶子被选,则$u$所在长链叶子应该被选.考虑若没选而选了另一部分进行一些替换必然可以更好.于是可以让每个叶子的贡献是自己到长链头的父亲这段的边权和.</p><p>但不能对每个$x$跑一遍长剖,考虑经过$x$的最长链一定一端是直径端点,考虑以直径端点为$x$做,此时如果包含$x$可以直接输出,否则要么删掉贡献最小的叶子加入$x$子树中的,要么找到经过 离$x$最近的,有叶子被选的祖先 的一条路径,把后面的部分改成选到$x$子树中深度最大的点. 就做完了.</p><p>[think] 发现关于长链选叶子的单调性简化贡献计算,调整满足题目限制</p><h3 id="CF1477E-Nezzar-and-Tournaments"><a href="#CF1477E-Nezzar-and-Tournaments" class="headerlink" title="CF1477E Nezzar and Tournaments"></a>CF1477E Nezzar and Tournaments</h3><p>考虑如果没有这个取max,实际上$v_i&#x3D;c_i+k-c_1$,毕竟每次加入的是差分,那么我们设$w_i&#x3D;v_i-c_i$,只要考虑两个数列的$w$产生的差值,有$w_i&#x3D;\max(0,w_{i-1}+c_i)-c_i&#x3D;\max(-c_i,w_{i-1})$,$w_0&#x3D;k-c_1$.于是$w_i&#x3D;\max(k-c_1,\max_{j\le i} -c_j)$.</p><p>显然越靠后$w$越大,所以你会想到$b$降序排列后$a$升序排列,但$c_1$是一个特殊元素.</p><p>考虑若$c_1$在$b$中无疑让$w_1$变大,而不会改变$w_{m+1}$以后的东西(始终是对前面这些取$min$),一定不优.</p><p>那么如果把$a$中元素移过来,我们把$\max_{j\le i} -c_j$一定是一段上升然后后面不变,而$k-c_1$是一条直线,容易发现当直线没高出折线最大值时越往下越好,则实际上只有$a_{min},a_{max}$可能成为答案.</p><p>这样一来只要能快速求值,发现是简单线段树问题.</p><h3 id="CF1637H-Minimize-Inversions-Number"><a href="#CF1637H-Minimize-Inversions-Number" class="headerlink" title="CF1637H Minimize Inversions Number"></a>CF1637H Minimize Inversions Number</h3><p>考虑选一个数$p_i$移动到最前面,$\Delta ans&#x3D;(\sum_{j&lt;i}[p_j&gt;p_i]+\sum_{j&gt;i}[p_j&lt;p_i])-(\sum_{j&lt;i}[p_j&lt;p_i]+\sum_{j&gt;i}[p_j&gt;p_i])&#x3D;d_i$</p><p>我们希望贡献尽量局部,对于一个子序列$p_{q_1}\ldots p_{q_k}$,得到$\Delta ans&#x3D;\sum_i d_{q_i} - \sum_i \sum_{j&lt;i} [p_{q_i}&gt;p_{q_j}] + \sum_i \sum_{j&lt;i} [p_{q_i}&lt;p_{q_j}] &#x3D; \sum_i d_{q_i} + \binom{k}{2} - 2\mathrm{inversion_count}({q_1\ldots q_k})$</p><p>不知道怎么发现一个性质,一定存在一种不劣方案使得不存在逆序对$(i,j),i&lt;j$,$i$在$q$中而$j$不在.</p><p>考虑选择$j-i$最小的一对非法逆序对,则把$j$替换成$i$看贡献变化,会发现一定是负的.</p><p>于是$\mathrm{inversion_count}({q})&#x3D;\sum_i \sum_{j&gt;i} [p_{q_j}&lt;p_{q_i}]&#x3D;\sum_i\sum_{j&gt;q_i} [p_j&lt;p_{q_i}]$.</p><p>这样每个数贡献独立,排个序从大到小选就行了.复杂度$n\log n$</p><h3 id="AGC023D-回家"><a href="#AGC023D-回家" class="headerlink" title="[AGC023D]回家"></a>[AGC023D]回家</h3><p>乍一看很吓人的东西,考虑一开始的情况很复杂,分析最终情况:</p><p>最后一个回家的肯定来自$x_1$或$x_n$,若$x_1&gt;x_n$,则会先走到$x_1$再走到$x_n$,此时$x_n$的人只希望$x_1$早点回家,所以可以把它们合并,递归下去.</p><p>做完了?!</p><h3 id="P6168-IOI2016-railroad"><a href="#P6168-IOI2016-railroad" class="headerlink" title="P6168 [IOI2016] railroad"></a>P6168 [IOI2016] railroad</h3><p>容易想到一个图论模型,对速度离散化,每个速度$v_i$建一个点,$v_i \stackrel{0}{\longrightarrow} v_{i+1},v_{i+1} \stackrel{v_{i+1}-v_i}{\longrightarrow} v_i$,对每个特殊路段建 $s_i \stackrel{0}{\longrightarrow} t_i$,则要求把所有特殊路段的边走一遍.问题是我们可能多走很多两个速度之间的没用边.</p><p>考虑什么时候两个速度之间应该有一条边,如果对于$v_i \leftrightarrow v_{i+1}$有$a$条从小的连到大的跨过它的特殊路段,$b$条从大连到小的特殊路段,那么若$a&gt;b$需要减速方向走$a-b$次,$a&lt;b$需要加速方向走$b-a$次.如果$a&#x3D;b&#x3D;0$需要走一次.</p><p>发现我们的建边方式会平衡入度和出度,于是做完了.</p><h3 id="AGC041D-Problem-Scores"><a href="#AGC041D-Problem-Scores" class="headerlink" title="[AGC041D] Problem Scores"></a>[AGC041D] Problem Scores</h3><p>显然对于任意$k$,$S$是$a_{n-k+1}\ldots a_n$,$T$是$a_1\ldots a_{k+1}$.自然想到设前缀和$pre_n$,后缀和$suc_n$,则$sum(S)-sum(T)&#x3D;pre_{k+1}-suc_{k}&#x3D;s_k$.</p><p>注意到$s_k-s_{k-1}&#x3D;a_{k+1}-a_{n-k}$,又因为$a$是递增的,所以这个东西在$k&#x3D;\lceil \dfrac{n-1}{2} \rceil$的时候最小,设为$K$,只要满足此刻的限制.</p><p>[think] 不知道干什么就把东西列出来,试试差分,前缀和.</p><p>此时如果$n$是奇数,则每个数恰属于$S$或$T$,如果是偶数则有一个数不在集合中.</p><p>考虑设$b_i&#x3D;a_i-a_{i-1}$,每个位置有一个贡献系数$c_i$,要求$\sum_i b_i\le n,\sum_i b_ic_i\le 0$.这是一个二维的背包,不好做.</p><p>对$n$为奇数有$c&#x3D;1,0,1,-2\ldots -k+1,-k,-k+1\ldots -1$,对$n$为偶数$c&#x3D;1,0,1,-2\ldots -k+1,-k,-k+1\ldots -1$,拿出贡献系数为$1$的$b_1$,根据两个限制有$b_1\in [\sum_i b_ic_i,n-\sum_i b_i]$,于是一种方案的贡献是$n-\sum_i b_i(c_i+1)$,于是对$c_i+1$做完全背包即可.</p><p>[trick] 拿出背包中的一个元素让二维dp转化成一维dp</p><h3 id="AGC003F-Fraction-of-Fractal"><a href="#AGC003F-Fraction-of-Fractal" class="headerlink" title="[AGC003F] Fraction of Fractal"></a>[AGC003F] Fraction of Fractal</h3><p>分类讨论,如果把两个原图横&#x2F;竖放在一起都不连通,显然答案是$cnt^k$,$cnt$表示黑格数,如果均连通是$1$,现在考虑横着连通竖着不连通.</p><p>考虑左右有$c$个格子相连,迭代$k$次后会变成$c^k$个.</p><p>再考虑迭代$k$次我们可以看成把原图每个格子换成迭代$k-1$次的.因为纵向不连通所以每行可以单独看.设$f_i$表示迭代$i$次后的答案,对于一行里长$a$的极长连续黑格子段,换掉$k-1$后显然得到$af_{k-1}-c^{k-1}$.</p><p>那就做完了啊,统计每行连续段长度和为$A$,数量为$B$,$f_i&#x3D;Af_{i-1}-Bp^{k-1}$,矩阵快速幂或者生成函数都行.</p><h3 id="AGC040D-Balance-Beam"><a href="#AGC040D-Balance-Beam" class="headerlink" title="[AGC040D] Balance Beam"></a>[AGC040D] Balance Beam</h3><p>一定是一个前缀$[1,x]$可以追上.</p><p>所以我们要最大化这个前缀$x$,拆成$\lfloor x\rfloor$和${x}$,第一部分就是把所有元素划分成$S_1,S_2,S_3$(能追上的前缀,不能追上的前缀,追上后没啥用的),使得$\sum_{i\in S_2} (B_i-A_i)-\sum_{i\in S_1}A_i\ge 0$,最大化$\vert S_1\vert$.而确定第一部分之后第二部分可以快速计算.</p><p>那么一个元素进入$S_1$贡献$-A_i$,进入$S_2$贡献$B_i-A_i$,我们先把所有$B_i-A_i&gt;0$的元素放进$S_2$,再尝试最大化$S_1$,则$S_2$的元素进入$S_1$会贡献$-B_i$,其他贡献$-A_i$,排序一下从小到大选即可.</p><p>枚举$x$到底落在哪块上,上面的排序选值可以预处理后二分快速计算.</p><h3 id="P8500-NOI2022-冒泡排序"><a href="#P8500-NOI2022-冒泡排序" class="headerlink" title="P8500 [NOI2022] 冒泡排序"></a>P8500 [NOI2022] 冒泡排序</h3><p>注意到显然值可以离散化.注意到如果$i,j$的值可以交换且$a_i&gt;a_j$,交换后一定更优.</p><p>对性质B,一些位置已经确定而另一些位置任意,因为上面的交换性质,我们自己填的数内部一定不会有逆序对,递增,则只考虑和其他数的贡献,让每个数填最小化和其他数的贡献的数,这样也能保证你填的数递增,用线段树优化复杂度$n\log n$.</p><p>对性质C,因为可以交换而区间内一定有一个最小值,所以一定填在第一个位置,然后变成每个位置有一个要限制$&gt;lim_i$,此时既有和已经填好的数的贡献又要考虑到还没填的元素和当前元素的贡献,结论是直接贪心最小化和前面的贡献:若当前选择最小化前面的贡献值是$x$,而可以选择更小的数$y$,那么把后面还没填的数中$[x,y]$中的数都改成$y$是没有什么坏处的.</p><p>最后对整个问题,每个区间的最小值应该放在能填的最左位置,对最小值相同的区间跑一个线段覆盖贪心即可.</p><p>突破口在可以交换,难点在性质C的贪心,需要有充足时间.</p><h3 id="P7739-NOI2021-密码箱"><a href="#P7739-NOI2021-密码箱" class="headerlink" title="P7739 [NOI2021] 密码箱"></a>P7739 [NOI2021] 密码箱</h3><p>考虑合并完后若干项得到$\dfrac{a}{b}$,那么套一层后$\dfrac{a’}{b’}&#x3D;x+\dfrac{b}{a}&#x3D;\dfrac{b+ax}{a}$.</p><p>注意到若$a\bot b$,必然有$\gcd(b+ax,a)&#x3D;\gcd(a,b)&#x3D;1$,于是在运算过程中始终是最简分数.</p><p>可以把转移写成矩阵,则转移一次就是</p><p>$$<br>\left [a’,b’\right]&#x3D;\left [a,b\right] \times M_x\<br>M_x&#x3D;<br>\begin{Bmatrix}<br>    x&amp;1\1&amp;0<br>\end{Bmatrix}<br>$$</p><p>则如果确定$a$,答案可以看成从右往左每次左乘矩阵的连乘积.</p><p>我们要能快速维护操作,考虑把操作也写成矩阵,对于<code>W</code>,我们有矩阵<br>$W&#x3D;\begin{Bmatrix}1&amp;1\0&amp;1\end{Bmatrix}$使得$WM_x&#x3D;M_{x+1}$,对于<code>E</code>,对最后一项不为$1$设$H&#x3D;\begin{Bmatrix}1&amp;-1\0&amp;1\end{Bmatrix}$使得$HM_x&#x3D;M_{x-1}$,我们要的是$E&#x3D;M_1M_1H$,否则我们要的是$E’M_1M_x&#x3D;M_1M_{x+1}$,即$E’M_1&#x3D;M_1W$,分别计算发现$E&#x3D;E’&#x3D;\begin{Bmatrix}2&amp;-1\1&amp;0\end{Bmatrix}$,十分的巧啊.</p><p>剩下就是用平衡树维护矩阵乘积支持区间翻转反转单点插入了.</p><h3 id="P6775-NOI2020-制作菜品"><a href="#P6775-NOI2020-制作菜品" class="headerlink" title="P6775 [NOI2020] 制作菜品"></a>P6775 [NOI2020] 制作菜品</h3><p>考虑$m\ge n-1$时,每次取出最小的作为这道菜的一部分,如果不够就去拿最大的,显然可以递归到$m-1,n-1$或$m-1,n$.直到$m&#x3D;1,n\le 2$做完.</p><p>那么现在$m&#x3D;n-2$,考虑若一道菜用了$a,b$两种原料就连边$(a,b)$,则一个连通块必然有$m\ge n-1$.于是$m&#x3D;n-2$的情况必然有至少两个连通块,且为了保持$m\ge n-2$的性质每个集合都是$m&#x3D;n-1$,于是必然存在集合$S$使得$\sum_{i\in S} a_i&#x3D;k\vert S-1\vert$,用bitset优化01背包即可.</p><h3 id="P7740-NOI2021-机器人游戏"><a href="#P7740-NOI2021-机器人游戏" class="headerlink" title="P7740 [NOI2021] 机器人游戏"></a>P7740 [NOI2021] 机器人游戏</h3><p>他甚至好心给了样例解释$2$,容易想到基于容斥的暴力,考虑枚举集合$S$计算以$S$中的位置为起点可行的方案数.</p><p>那么机器人进行的修改是,把$p+i$处变成$0&#x2F;1&#x2F;X_i&#x2F;1-X_i$之一,我们处理出每个位置可能是哪几种情况,此时每个格子独立,对于一个格子:</p><ul><li>同时有$0$和$1$或同时有$X_i$和$1-X_i$,只能为空,有$1$种可能.</li><li>同时有$0&#x2F;1$中一个,$X_i&#x2F;1-X_i$中的一个,此时只有一种确定的$0&#x2F;1$或为空,$2$种可能.</li><li>否则空,$0&#x2F;1$有$3$种可能.</li></ul><p>复杂度是$nm2^n$.</p><p>考虑不枚举而使用dp,设$f_{i,S}$表示考虑前$i$个格子,其中$S$的位置可以作为起点,每次转移时枚举当前位置是否能作为起点并乘上方案数和容斥系数.第$i$个机器人超过位置$l_i$启动会爆炸,设$L&#x3D;\max l_i$,复杂度是$n^2m2^L$,而我们容斥的做法复杂度是$nm2^{n-L}$,结合就能做到$nm2^{n&#x2F;2}$</p><p>然后用bitset优化除掉一个$w$即可.</p><h3 id="P5469-NOI2019-机器人"><a href="#P5469-NOI2019-机器人" class="headerlink" title="P5469 [NOI2019] 机器人"></a>P5469 [NOI2019] 机器人</h3><p>考虑dp,显然两个机器人分别走到左侧第一个大于它的位置和右侧第一个大于等于它的位置.这是一个比较有局部性的东西,$[l,r]$这个子问题,设$x&#x3D;\max_{i\in [l,r]} h_i$,要求$h_{l-1}&gt;x,h_{r+1}\ge x$,于是设$f_{l,r,x}$表示这个子问题对应方案数.那么考虑最后一个为$x$的位置$p$,分裂成$\sum_{y\le x,z\lt x} f_{l,p-1,y}f_{p+1,r,z}$,然后$p$要满足到$l,r$的距离差不大.复杂度是$n^2V$.但是这个$p$限制很严,所以有用的区间不多.</p><p>考虑如果没有$h_i\in [A_i,B_i]$的限制,那么容易发现$f_{l,r,x}$是关于$x$的$O(r-l)$次函数,拉插.</p><p>那么现在有限制,把限制离散化,容易发现$f_{l,r,x}$在每个区间内是关于$x$的$O(r-l)$次函数,复杂度是$n^4$.</p><h3 id="P5472-NOI2019-斗主地"><a href="#P5472-NOI2019-斗主地" class="headerlink" title="P5472 [NOI2019] 斗主地"></a>P5472 [NOI2019] 斗主地</h3><p>考虑每次重排时如果第$i$个来自第一堆$b_i&#x3D;0$,否则$b_i&#x3D;1$,则每个$01$序列$b$的概率是相等的.那么设$f_{i,j}$表示$i$次重排之后第$j$个的期望:</p><p>那么有</p><p>$$<br>f_{i,j}&#x3D;\dfrac{1}{\binom n{a_i}}\sum_{k\le a_i} f_{i-1,k}\binom{j-1}{k-1}\binom{n-j}{a_i-k}+\sum_{k\le n-a_i}f_{i-1,a_i+k} \binom{j-1}{k-1}\binom{n-j}{n-a_i-k}<br>$$</p><p>但这个很难办啊,必须得有点性质,比如$f$是个多项式啥的,因为这里是组合数,先把多项式化成$F(x)&#x3D;\sum_i c_i\binom{x-1}{i}$的形式,代入$f_{i-1,k}&#x3D;\binom kc$,这里只考虑第一个求和号:</p><p>$$<br>\sum_{k\le a_i} \binom{k-1}{c}\binom{j-1}{k-1}\binom{n-j}{a_i-k}\<br>&#x3D;\binom{j-1}{c}\sum_{k\le a_i} \binom{j-1-c}{k-1-c}\binom{n-j}{a_i-k}\<br>&#x3D;\binom{j-1}{c}\binom{n-1-c}{a_i-1-c}<br>$$</p><p>是关于$j$的$c$次多项式!所以结论是若$f_{i-1}$是$k$次多项式则$f_i$也是,我们只要挑$3$个点值计算就做完了.</p><h3 id="AGC031D-A-Sequence-of-Permutations"><a href="#AGC031D-A-Sequence-of-Permutations" class="headerlink" title="[AGC031D] A Sequence of Permutations"></a>[AGC031D] A Sequence of Permutations</h3><p>找规律题</p><p>[note] 别忘了排列复合的形式是$p&#x3D;a\circ b\Leftrightarrow p_i&#x3D;a_{b_i}$</p><p>所以题目这个是$f(p,q)&#x3D;qp^{-1}$.找规律:</p><p>$$<br>\begin{gathered}<br>    a_1&#x3D;p\<br>    a_2&#x3D;q\<br>    a_3&#x3D;qp^{-1}\<br>    a_4&#x3D;qp^{-1}q^{-1}\<br>    a_5&#x3D;qp^{-1}q^{-1}pq^{-1}\<br>    a_6&#x3D;qp^{-1}q^{-1}ppq^{-1}\<br>    a_7&#x3D;qp^{-1}q^{-1}pqpq^{-1}\<br>    a_8&#x3D;qp^{-1}q^{-1}pqp^{-1}qpq^{-1}<br>\end{gathered}<br>$$</p><p>变换是,把$p\to q,p^{-1}\to q^{-1},q\to qp^{-1},q^{-1}\to pq^{-1}$.</p><p>且注意到$P&#x3D;qp^{-1}q^{-1}p$变成自身,$P^{-1}&#x3D;p^{-1}qpq^{-1}$,发现结论是$a_n&#x3D;Pa_{n-6}P^{-1}$</p><h3 id="ARC144D-AND-OR-Equation"><a href="#ARC144D-AND-OR-Equation" class="headerlink" title="[ARC144D] AND OR Equation"></a>[ARC144D] AND OR Equation</h3><p>显然可以变成集合$a_S+a_T&#x3D;a_{S\cap T}+a_{S\cup T}$,令$T&#x3D;{i},i\notin S$,有$a_S+a_&#x3D;a_{S\cup {i}}+a_{\varnothing}$,于是一个集合的值是$\sum_{i\in S} a_i-(\vert S\vert-1)a_\varnothing$,令$v_i&#x3D;a_i-a_\varnothing$,我们去数$(v,a_0)$满足$a_0+\sum_i w_i$</p><p>而要满足值域限制,即$a_0+\sum_i w_i[w_i&gt;0]\le k,a_0+\sum_i w_i[w_i&lt;0]\ge 0$,$a_0$的取值范围是$k+1-\sum_i \vert w_i\vert$,那直接GF:</p><p>$$<br>\sum_{i&#x3D;0}^k (k+1-i)[x^i] (-1+2\sum_{j\ge 0} x^j)^n<br>$$</p><p>复杂度$O(n)$.</p><h3 id="ZR-Day3-A-d"><a href="#ZR-Day3-A-d" class="headerlink" title="ZR Day3 A. d"></a>ZR Day3 A. d</h3><blockquote><p><img src="/img/2024-06-17-10-17-31-image.png" alt="picture 7">  </p><p><img src="/img/2024-06-17-10-17-43-image.png" alt="picture 8">  </p></blockquote><p>容易发现关键在长$2$的黑色方块,考虑一个方案方案是否可见,从上往下扫,如果遇到一个长奇数的黑色短就表明必须有一个新的塔,于是dp,记录当前一共有多少塔,黑色&#x2F;非黑色方块用了多少,当前高度,就做完了.</p><h3 id="ABC260Ex-Colorfulness"><a href="#ABC260Ex-Colorfulness" class="headerlink" title="[ABC260Ex] Colorfulness"></a>[ABC260Ex] Colorfulness</h3><p>球是区分的,设第$i$种球有$c_i$个,$a_i$序列乘$\prod_i c_i$就是球的序列.</p><p>先考虑怎么计算分数为$x$的方案数$f_x$,设钦定有$y$个相邻值相同的方案数为$g_y$,第$i$种球有$b_i$个相邻对($\sum_i b_i&#x3D;y$),则方案数是</p><p>$$<br>\begin{gathered}<br>    \binom{n-\sum_i b_i}{c_1-b_1,c_2-b_2\ldots c_m-b_m}\prod_i \binom{b_i+c_i-2}{b_i}\<br>    &#x3D;(n-y)!\prod_i \dfrac{1}{(c_i-b_i)!}\binom{b_i+c_i-2}{b_i}<br>\end{gathered}<br>$$</p><p>于是设一个颜色的GF是$F_i(z)&#x3D;\sum_j \dfrac{1}{(c_i-j)!}\binom{c_i-2+j}{j}z^j$就有$g_y&#x3D;<a href="n-y">z^y</a>!\prod_i F_i(z)$.分治NTT.</p><p>然后二项式反演也是NTT求得$f$,接下来要求</p><p>$$<br>\sum_i f_ii^k&#x3D;[x^k](\sum_i f_ix^i)\circ e^x<br>$$</p><p>于是复合$e^x$即可.也是分治NTT.</p><h3 id="P10611-故事结局"><a href="#P10611-故事结局" class="headerlink" title="P10611 故事结局"></a>P10611 故事结局</h3><p>考虑对修改操作颜色段均摊,每个颜色段存在时间是一个区间,线段树分治,可以变成横向线段取max矩形max.</p><p>对线段树分治的每个节点,把它包含的所有询问和修改拿出来,那么容易发现这个总和是$q\log q$的很好.</p><p>于是对平面用横线分治,把每个4side矩形拆成贴着横线的两个3side矩形(rprmq的trick)然后扫描线,就是简单的区间checkmax区间max问题,复杂度是修改3log查询2log(查询只会在一层被遍历,而修改每层都有)</p><p>或者也可以换个方向分治问题变成单点checkmax,区间历史max,全局加,都不太可优化.</p><p>然后这题正解其实是考虑树套树,外层行内层列,然后我们对外层树的叶子修改完了,发现可以在外层pushup,因为我们可以只pushup在内层修改过的点,复杂度就对了.</p><p>需要离线对外层逐层处理.</p><h3 id="JOI-Open-2024-Examination2"><a href="#JOI-Open-2024-Examination2" class="headerlink" title="JOI Open 2024 Examination2"></a>JOI Open 2024 Examination2</h3><p>第一步肯定是直接建表达式树,问题变成给定一棵二叉树,每个点上标着<code>|</code>,<code>&amp;</code>,<code>^</code>之一,叶子是$x$是否大于某值.</p><p>那你直接扫$x$,叶子会逐个由$0$到$1$,写个ddp就行了,复杂度$n\log n$.</p><p>或者你考虑每个叶子是一个分两段的函数,每次启发式合并两个儿子的函数得到当前点的函数,这个感觉更难写一点,复杂度相同.</p><h3 id="JOI-Open-2024-Heat"><a href="#JOI-Open-2024-Heat" class="headerlink" title="JOI Open 2024 Heat"></a>JOI Open 2024 Heat</h3><blockquote><p>有一个长$L$的链,第$i$条边连接$i,i+1$,每个点有容量$c_i$,$n$次在一条边$x_i$上放一个球,你需要把球放到这条边的剩余容量不为$0$的一个端点并消耗$1$容量,两边都满了扔掉,求扔掉的最大数量.</p><p>$L,n\le 8000$.</p></blockquote><p>考虑一个前缀$i$个点,$i-1$条边的子问题,我们需要确定:第$i$个点最后的容量$j$和第$i$个点获得的球的最大编号$k$,以及第$i-1$条边是否扔了东西$w&#x3D;0&#x2F;1$,现在分配第$i$条边上的球,则分成$A,B,C$三个集合分别是到$i$的,到$i+1$的和扔掉的.要满足:</p><ul><li>$\vert A\vert\le j$,若$w&#x3D;1$则$\vert A\vert&#x3D;j$.</li><li>$\vert B\vert\le c_{i+1}$</li><li>若$\vert A\vert \ne j$,$C&#x3D;\varnothing$.</li><li>$\min_{i\in C} t_i&gt;\max(k,\max_{j\in B} t_j)$</li></ul><p>我们希望转移到的$k$尽可能小,所以元素优先放$B$,然后放$A$,最后放$C$,只要确定放了$B$的元素数,剩下的就确定了,转移可以做到$O(1)$,注意到$j$这一维是只要到$i$这条边上的人数的,所以总复杂度是$n^2$.</p><h3 id="JOI-Open-2024-Library3"><a href="#JOI-Open-2024-Library3" class="headerlink" title="JOI Open 2024 Library3"></a>JOI Open 2024 Library3</h3><blockquote><p>交互题,存在一个排列$p_n$,你每次可以询问一个排列$q_n$,获得按照以下策略执行的步数:若$p\ne q$,设$x$为最小的数满足$p_x\ne q_x$,$y$满足$q_y&#x3D;p_x$,交换$x,y$.要求你确定排列$p$.</p><p>$n\le 500$,你可以问$5000$次.</p></blockquote><p>考虑你实际上是在问什么,对于一个长$l$的置换环需要$l-1$次,所以我们可以确定$a&#x3D;q^{-1}\circ p$的环数.</p><p>那么询问$q$和$q’$,$q’$为$q$交换$q_i,q_j$得到的排列,就可以确定$a$中$i,j$是否在同一个环中,因为若在一个环中会分裂,否则会合并,那么不断分裂到最后有$n$个环就得到答案,可以假设现在$1\ldots i$在不同的环中,加入一个$i+1$,只要把它和前$i$个都问一遍,就能保证$1\ldots i+1$在不同的环中.复杂度$n^2$.</p><p>考虑优化,看起来像个$n\log n$的东西,现在假设我们确定$1\ldots i$在不同的环中,显然$i+1$和前面的元素中最多一个在一个环,注意我们可以把若干元素合并到一个环,然后问它们和$i+1$是否是一个环,就可以二分了.复杂度$n\log n$.</p><h3 id="NowCoder-某数数"><a href="#NowCoder-某数数" class="headerlink" title="NowCoder 某数数"></a>NowCoder 某数数</h3><p>数有多少个$n$个点DAG满足每个点出发的最长路等于SG值.</p><p>枚举扫描线方向,应该每次加一层叶子,把新的叶子和前面的点归并,前面每个点要连到这层的点至少一个.</p><p>剩下的比较简单了,相当于从后往前,每次往前追加一个新点&#x2F;前面层点,dp预处理即可.</p><p>复杂度$n^2$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APIO</title>
      <link href="/2024/05/17/apio/"/>
      <url>/2024/05/17/apio/</url>
      
        <content type="html"><![CDATA[<h1 id="APIO2024"><a href="#APIO2024" class="headerlink" title="APIO2024"></a>APIO2024</h1><h2 id="Day1-概率论"><a href="#Day1-概率论" class="headerlink" title="Day1-概率论"></a>Day1-概率论</h2><h3 id="AGC060C"><a href="#AGC060C" class="headerlink" title="AGC060C"></a>AGC060C</h3><p>考虑拿出最左边和最右边两条链共 $2(n-1)$ 个点, 归并它们, 然后以钦定顺序得到一棵新树(合并成一条链), 于是设 $f_{i, j}$ 为左边链到第 $i$ 个右边到第 $j$ 个答案, 看起来贡献计算简单.</p><p>复杂度 $n^2$.</p><h3 id="Pro"><a href="#Pro" class="headerlink" title="Pro"></a>Pro</h3><p>数据范围都是 $10^7$</p><p>首先原问题你直接就会了, 枚举最大值个数和最大值的值然后上一个二项式反演.</p><p>但是重点是怎么处理从最大值中等概率选一个这件事, 设最大值位置随机选一个选到 $1$, 问题相当于算 $\dfrac{P(x&#x3D;1, a_1\ge r, sum_i a_i&#x3D;s)}{P(a_1\ge r, sum_i&#x3D;s)}&#x3D;\dfrac{P(x&#x3D;1, \max a_i\ge r, sum_i a_i&#x3D;s)}{P(a_1\ge r, sum_i&#x3D;s)}$, 发现此时分子对每个元素是等价的, 于是直接分子等于 $\dfrac{1}{p}P(\max a_i\ge r, \sum_i a_i&#x3D;s)$, 剩下部分简单线性.</p><h3 id="ARC150D"><a href="#ARC150D" class="headerlink" title="ARC150D"></a>ARC150D</h3><p>考虑每个点被选的次数之和, 先认为是从所有点中选且跳过不合法的, 那么对于一个点 $u$, 从根到 $u$ 上这 $d$ 个点每个点概率相等, 所以对于任意时刻这 $d$ 个点被选的期望次数相等, 于是只要求总次数, 然后设前 $i$ 个已经被选过(剩下的可能选过), 于是选到下一个的概率是 $\dfrac{1}{d-i}$</p><h3 id="ABC270Ex"><a href="#ABC270Ex" class="headerlink" title="ABC270Ex"></a>ABC270Ex</h3><p>操作可以转化成, $T$ 时给一个位置 $i$ 打一个时间标记 $e_i&#x3D;T$, 要求 $T-e_i\ge a_i$ 时可以结束. 则对于长度为考虑一个位置可以结束的限制就是 $\forall i$, $(T-a_i, T]$ 不能选 $i$.</p><p>考虑设答案PGF是 $F(x)&#x3D;\sum_i p_ix^i$, 但问题是一个前缀 $1\ldots i$ 有若干可能成为结束的前缀, 所以容斥, 答案是 $\sum_{S, a_n\le s_1&lt;s_2\ldots &lt;s_n} (-1)^{S} \prod_i g_{s_i-s_{i-1}}$(看上一段的限制, 发现一段的答案只和长度相关, 且长度大于 $a_n$ 时都和 $a_n$ 一样).</p><p>于是写GF就好了:</p><p>$$<br>\begin{gathered}<br>Q(x)&#x3D;\sum_i x^i g_i\<br>G(x)&#x3D;Q(x)+g_{a_n}\dfrac{x^{a_n+1}}{1-x}\<br>F(x)&#x3D;\dfrac{1}{1-x}-\dfrac{1}{1-x}\cdot g_{a_n}\dfrac{x^{a_n}}{1-x}\dfrac{1}{1+G(x)}\<br>F(1)<br>&#x3D;\dfrac{1}{1-x}(1-\dfrac{g_{a_n}x^{a_n}}{1-x}\dfrac{1}{1+G(x)})\<br>&#x3D;\dfrac{1}{1-x}(1-g_{a_n}x^{a_n}\dfrac{1}{(1+Q(x))(1-x)+g_{a_n}x^{a_n+1}})\<br>&#x3D;\dfrac{1}{1-x}(\dfrac{(1+Q(1))(1-x)+g_{a_n}x^{a_n}(x-1)}{(1+Q(1))(1-x)+g_{a_n}x^{a_n+1}})\<br>&#x3D;\dfrac{1+Q(1)-g_{a_n}}{g_{a_n}}<br>\end{gathered}<br>$$</p><p>注意只要算 $F(1)$, 则只要算 $g_{a_n}$ 和 $Q(1)$. 这两部分是平凡的.</p><p>但是这题有直接dp的做法啊! 发现对于任意状态, 答案只和 $s&#x3D;\max a_i-b_i$ 有关, 然后调下顺序发现dp式子是线性递推就做完了.</p><h3 id="ARC113F"><a href="#ARC113F" class="headerlink" title="ARC113F"></a>ARC113F</h3><p>考虑把概率拆分成 $f(m)$ 表示最小值大于等于 $m$ 的概率, 则对 $f$ 积分就是期望.</p><p>考虑求 $f$, 要求任意两个间距大于 $m$ 的概率, 相当于 $a_i-mi$ 递增的概率, 于是转化成有若干个区间, 每个变量在区间内均匀随机, 要求递增的概率, 则设二元函数 $g_i(m, x)$, 表示前 $i$ 个, 最后一个数值为 $x$ 的概率, 然后这个是关于 $m$ 有 $n^2$ 段, 关于 $x$ 有 $n$ 段的函数, 看起来可以直接维护!</p><h3 id="qoj6413"><a href="#qoj6413" class="headerlink" title="qoj6413"></a>qoj6413</h3><p>todo</p><h3 id="寻找图的包含至少一半边的二分子图"><a href="#寻找图的包含至少一半边的二分子图" class="headerlink" title="寻找图的包含至少一半边的二分子图"></a>寻找图的包含至少一半边的二分子图</h3><p>随机黑白染色. todo</p><h2 id="Day1-组合计数"><a href="#Day1-组合计数" class="headerlink" title="Day1-组合计数"></a>Day1-组合计数</h2><h3 id="LOJ177-生成子群计数"><a href="#LOJ177-生成子群计数" class="headerlink" title="LOJ177 生成子群计数"></a>LOJ177 生成子群计数</h3><p>考虑 $a_1&#x3D;x$, 那么只考虑这个可以对每个置换 $p$ 让 $i\to p_i$ 连无向边(复合若干次一定能得到 $p^{-1}$ 所以有反向边), 于是一种复合方案对应一个 $1\to x$ 的路径, 而任意拿出图一个生成树, $1\to x$ 路径一定可以拆分成一个树上路径和一个经过 $1$ 的可能非简单圈(可能重复走边), 而对于一条非树边可以唯一确定一个简单环, 发现这些圈又可以由简单环生成, 把每个环依次复合应该可以得到一个首位是 $1$ 的排列, 而就要求这些排列任意复合的结果数, 于是问题到了 $n-1$ 规模.</p><p>但是直接做的话 $m$ 上升很快</p><p>[trick] $n$ 阶置换群最多取 $n$ 个排列使得不能各自复合出, 于是只保留 $n$ 个即可.</p><p>一个智慧法说的是随机 $n$ 种对当前 $k$ 个排列的复合方式, 把它们作为生成元做下去.</p><h3 id="CF1909I"><a href="#CF1909I" class="headerlink" title="CF1909I"></a>CF1909I</h3><p>对每个 $m$ 分别做.</p><p>对 $k&#x3D;n-1$ 的情况, 考虑把所有数按 $\min(i, m-i)$ 排序, 则有任意两个数和大于 $m$ 只取决于前面那个数的位置, 这个条件让你想到插入连续段的方式dp排列, 于是从小到大扫值, 一开始有 $t&#x3D;1$ 空, 插入大于 $m$ 的数时 $T$ 每次加 $1$, 然后空交替减 $1$ 加 $1$, 而方案数就是过程中 $t$ 的乘积.</p><p>对 $k\ne n-1$ 的时候, 二项式反演, 钦定有 $i$ 个位置满足条件, 则剩下 $n-i$ 满足条件, 相当于最后插入出 $t$ 个连续段不需要合并. 然后需要再次容斥避免空段.</p><p>两个反演直接做复杂度是 $n^2$, 需要NTT加速是经典的, 最后复杂度 $n^2\log n$</p><h3 id="CF1896H"><a href="#CF1896H" class="headerlink" title="CF1896H"></a>CF1896H</h3><p>令 $n$ 是题目中的 $2^n$</p><p>若要求两个串是好的, 即对每个循环为恰好相等的 $1$ 数量都少于 $\dfrac{n}{2}$(恰好相等的 $0$ 数量与 $1$ 相等).</p><p>用多项式刻画 $f$, 设 $A(x)&#x3D;\sum_{i&#x3D;0}^{2n-1} a_ix^i$, $B(x)&#x3D;\sum_{i&#x3D;0}^{2n-1} b_{2n-1-i} x^i$, $I(x)&#x3D;\sum_{i&#x3D;0}^{2n-1} x^i$, 则 $(a, b)$ 为好的当且仅当 $A(I-B)+B(I-A)&#x3D;2^nI$, 即 $AB&#x3D;2^{n-1}I$. 注意到右边DFT后为全 $0$, 则左边DFT后为全 $0$.</p><p>喵的啥? todo</p><h3 id="CF1774G"><a href="#CF1774G" class="headerlink" title="CF1774G"></a>CF1774G</h3><p>先考虑一次怎么做</p><p>容斥, 钦定 $k$ 个关键点未被覆盖, 则一个区间包含至少一个关键点则不可选, 而若存在一个区间不包含关键点则这个区间变一下会更改区间数奇偶性, 对答案贡献 $0$, 所以变成要求每个区间包含至少一个关键点, 贡献 $(-1)^{k}$</p><p>于是考虑dp, 设 $f_i$ 为考虑 $1\ldots i$, $i$ 必须选的情况下, 前 $i$ 个的带系数方案和, 则 $f_i&#x3D;\sum_{j\ge p_i} -f_j$, $p_i$ 为右端点小于 $i$ 的区间中左端点最大值. 因为是简单求和形式于是令 $s_i&#x3D;\sum_{j&#x3D;0}^i f_j$, 有 $s_i-s_{i-1}&#x3D;-(s_{i-1}-s_{p_i-2})$, 即 $s_i&#x3D;s_{p_i-2}$.</p><p>于是直接倍增处理每个 $i$ 往前跳的位置求 $s$ 即可处理多次询问.</p><h3 id="CF1889E"><a href="#CF1889E" class="headerlink" title="CF1889E"></a>CF1889E</h3><p>考虑限制是, 若 $T_1$ 上 $e_1&#x3D;(u, v)$, 若 $e_1$ 选则所有 $T_2$ 上的边 $e_2$ 满足 $u\to v$ 经过 $e_2$ 也要被选.</p><p>于是建立新图, 若存在限制”若选 $T_1$ 上 $e_1$ 则选 $T_2$ 上 $e_2$”则连边 $e_1\to e_2$, 然后缩点得到一个DAG, 每次可以选择一个点及其所有可达点交换. 而一次交换边集后, $e_1\to e_2$ 的边会反转成 $e_2\to e_1$, 但这种操作并不影响缩点结构. 发现我们可以得到DAG的任意局面, 即答案是 $2^{\text{SCC个数}}$, 然后需要特殊处理一些原边集和新边集完全相同的SCC, 换&#x2F;不换是一种方案.</p><h3 id="Qoj8049"><a href="#Qoj8049" class="headerlink" title="Qoj8049"></a>Qoj8049</h3><p>见sdptt1</p><h3 id="Qoj5016"><a href="#Qoj5016" class="headerlink" title="Qoj5016"></a>Qoj5016</h3><p>考虑如果给定一个 $b$, 可以按值从小到大, 每次把当前值填入所有当前值能填的位置, 则可以唯一生成一个 $a$, 形成双射.</p><p>那么考虑这样的 $a$ 的特点, 对于 $a$ 一个极长的, 值 $\ge v$ 的段 $[l, r]$, 必然要满足所有被 $[l, r]$ 包含的区间的并恰好为 $[l, r]$, 于是预处理所有这样的区间, 然后dp设 $f_{l, r, i}$ 表示 $[l, r]$ 的值都要 $\ge i$ 的情况下对应合法 $a$ 数量, 转移考虑枚举 $i$ 第一次出现位置 $x$ 要求 $[l, x-1]$ 要求合法然后两边拼, 复杂度 $n^3c$</p><p>容易发现答案是 $n$ 次多项式, 于是拉格朗日插值做完了.</p><h3 id="Qoj7759"><a href="#Qoj7759" class="headerlink" title="Qoj7759"></a>Qoj7759</h3><p>考虑把 上升 和 上升段 对应起来, 显然若有 $c$ 个上升则有 $n-c$ 个极长上升段.</p><p>那么容斥, 钦定 $p, p^{-1}$ 排列分别有 $a, b$ 个上升段, 但这里容斥系数得用上升推(按照上升段的话, 真正的上升段可能是已有的上升段向两边延伸, 还可能合并等, 但按照上升推的话直接是二项式反演).</p><p>考虑从左到右加入 $p^{-1}$ 的上升段, 那么在 $p$ 中相当于按值域从小到大插入, 每个上升段会被填一个前缀. 容易发现若设 $a\times b$ 的矩阵 $w_{i, j}$ 表示插入 $p^{-1}$ 中第 $i$ 段上升段时在 $p$ 的第 $j$ 个上升段插入了 $w_{i, j}$ 个数, 则可以唯一确定排列 $p$, 而对 $w$ 的限制为, 不存在一行&#x2F;一列全为 $0$ 且总和为 $n$.</p><p>于是只要数 $w$, 再二项式反演有 $i$ 行 $j$ 列全为 $0$ 即可.</p><p>复杂度 $n^3$</p><h3 id="Agc061F"><a href="#Agc061F" class="headerlink" title="Agc061F"></a>Agc061F</h3><p>建模到图上, 相当于下标取模的情况下不能碰到重复点且最后回到原点.</p><p>令发生取模后到的点(左下角为 $(0, 0)$, 左边和下边上的点)为关键点, 则能对应出右上方边角处的点, 此时要数互不相交路径数, 想到LGV, 但发现此时可能会连出多个环. 然后分析出只有一个环当且仅当左边和下边上关键点数量互质.</p><p>于是问题变成有 $n+m$ 阶方阵, 前 $n$ 个表示下边, 后 $m$ 个表示左边, 则要求选 $k_1+k_2$ 阶子方阵, 其中 $k_1, k_2$ 分别为前 $n$ 个, 后 $m$ 个中选的行列数量, 要求 $\gcd(k_1, k_2)&#x3D;1$.</p><p>于是在对角线前 $n$ 个元素加 $x$, 后 $m$ 个元素加 $y$, 行列式变成二元多项式最后提取系数就是答案, 插值做到 $n^5$, 特征多项式做到 $n^4$.</p><h2 id="Contest"><a href="#Contest" class="headerlink" title="Contest"></a>Contest</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>模拟.</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><p>赛时想了一个单根号但一直T, 赛后过了.</p><p>肯定考虑点边互换, 容易发现 $(u_i, v_i, a_i, b_i, c_i)$ 要想更新 $(u_j, v_j, a_j, b_j, c_j)$ 会满足 $a_i\lt b_i\lt a_j\lt b_j$, 于是可以扫时间去更新. 同时饭肯定尽量在车上吃, 所以设到第 $i$ 条边终点的花费为 $w_i$, 转移是 $w_j&#x3D;w_i+c_j+\mathrm{cost}(b_i, c_j)\cdot T_{b_i}$, $\mathrm{cost}(l, r)$ 表示被 $l, r$ 完全包含的吃饭区间数量.</p><p>于是扫描线扫边的起点时间 $a$, 则每次会:</p><ul><li>插入一条边, 即单点修改某个 $w_i$.</li><li>加入一个新的吃饭区间 $[l, r] (r\lt a)$ 的贡献, 即所有 $b_i&lt;l$ 的区间 $\mathrm{cost}$ 值加一.</li><li>算当前边的答案, 即给定 $k$ 查 $\min_{b_i&#x3D;k} w_i+\mathrm{cost}(b_i+c_j)T_{b_i}$.</li></ul><p>没有 $k$ 的限制的话是KTT板子, 即可以把每个 $i$ 的贡献看成 $T_{b_i}x+w_i$ 的一次函数, 要支持单点修改和区间对函数平移, 查询最小值. 有的话看着很难Poly log考虑分块, 对序列分块, 仿照KTT对每个块维护每个 $k$ 的答案和这个块发生线段切换的时间, 单点修改直接重构, 区间加如果超过切换时间暴力重构, 就是对的.</p><p>诶但这个势能怎么分析? 显然对一个颜色, 答案关于平移的值 $x$ 是一个下凸壳, 最多有 $O(n)$ 段, 再发现每次修改都是把函数向下平移, 不可能露出新的段, 所以一个块最多切换 $\sqrt n$ 次, 复杂度 $n\sqrt n$.</p><p>如果可能向上平移呢? 相当于再支持删线段, 发现相当于每个线段有一个 $x&lt;lim_i$ 的范围限制. 由上包络线结论切换次数仍然是线性的.</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>考虑exCRT, $i\to i+j$ 连边表示模 $i$ 余 $j$, 再加上一些随机化即可.</p><h2 id="Day2-网络流"><a href="#Day2-网络流" class="headerlink" title="Day2-网络流"></a>Day2-网络流</h2><h3 id="CF1662J"><a href="#CF1662J" class="headerlink" title="CF1662J"></a>CF1662J</h3><p>让 $(i, j)$ 向同行&#x2F;同列所有比自己小的位置连边, 题目转化为选择 $n$ 个点使得不存在一个被选的点可以走一步&#x2F;两步到另一个被选的点.</p><p>注意到你不会连续走两次横着&#x2F;竖着的边, 于是实际上相当于不存在一个可以到另一个, 即选一个长 $n$ 的反链要求价值最大.</p><p>然后dilworth说的是不带权的情况, 你发现我把一个点直接复制点权份就是带权情况(若你可选这个点, 那么拆出来的点一定都可选, 所以一定一起选&#x2F;不选), 于是变成带权最小链覆盖, 你发现就是最小链覆盖改改边权就结束了吧.</p><h3 id="CF1630F"><a href="#CF1630F" class="headerlink" title="CF1630F"></a>CF1630F</h3><p>首先注意到图是偏序集, 二分图等价于不存在三元环, 于是每个点要么没有入度要么没有出度.</p><p>拆点, 令 $x, x’$ 分别表示 $x$ 被选入无入度集合或无出度集合. 若 $x\to y$($y\vert x$), 要求 $(x, x’), (x, y), (x’, y’), (x’, y)$ 不同时出现, 于是是最大独立集问题.</p><p>可以把边定向让它变成偏序集, 定向 $x’\to x, x\to y’, x\to y, x’\to y$, 于是求最小链覆盖.</p><h3 id="CF1416F"><a href="#CF1416F" class="headerlink" title="CF1416F"></a>CF1416F</h3><p>一定会连成内向基环树, 环上点 $S$ 值必须一样, 其他位置父亲必须比自己小.</p><p>一个位置周围存在一个位置比自己小则可以在树上, 否则必须在环上.</p><p>发现一个大环不如若干个小环, 于是直接拆成若干个长度为 $2$ 的偶环, 于是成了求匹配.</p><p>这就能做了! 黑白染色, 若一个点必须在环上, 根据黑白连向S&#x2F;T连 $[1, 1]$(流量上下界)的边, 否则连 $[0, 1]$, 就做完了.</p><h3 id="CF513F2"><a href="#CF513F2" class="headerlink" title="CF513F2"></a>CF513F2</h3><p>考虑通配符没有用, 可以直接知道红蓝都有 $k$ 个.</p><p>二分答案, 考虑让红子匹配和它最后在一个点的蓝子, 于是每个红子连到能在时间内走到的点, 每个篮子能在时间内走到的点连到篮子, 而这些中间被走到的点拆成流量为 $1$ 的边即可.</p><h3 id="CF1835F"><a href="#CF1835F" class="headerlink" title="CF1835F"></a>CF1835F</h3><p>图好是有完美匹配, 紧指对于图的一个完美匹配 $i\to p_i$, 集合 ${p_i\vert i\in S}$</p><h3 id="CF1383F"><a href="#CF1383F" class="headerlink" title="CF1383F"></a>CF1383F</h3><p>最大流的局部性质不好, 考虑最小割, 考虑处理出 $2^k$ 种特殊边割掉的集合对应的其他边代价.</p><p>暴力跑流复杂度比较爆炸, 考虑先跑出一个解, 然后剩下每种状态都是在一个已有状态下加一条边, 加边复杂度是FF的 $O(mw)$, 总复杂度 $q2^k+2^kwm$</p><h3 id="CF704D"><a href="#CF704D" class="headerlink" title="CF704D"></a>CF704D</h3><p>容易想到网格图行列匹配的套路, 而数量相差不超过相当于限制这一行的红点个数在 $[l_i, r_i]$ 之间, 也就是流量限制, 然后根据 $r&gt;d$ 还是 $r&lt;d$ 做有源汇上下界可行最大流或最小流.</p><h3 id="CF925F"><a href="#CF925F" class="headerlink" title="CF925F"></a>CF925F</h3><p>上下界可行流可以通过补流转化成最大流, 存在可行解的条件是最大流满流, 满流的值是一个一次函数, 最大流可以转化到最小割, 最小割一定是关于 $t$ 的下凸分段一次函数.</p><h2 id="Day3-构造"><a href="#Day3-构造" class="headerlink" title="Day3-构造"></a>Day3-构造</h2><h3 id="Eg-1"><a href="#Eg-1" class="headerlink" title="Eg. 1"></a>Eg. 1</h3><blockquote><p>n个点完全图划分成边集不交的生成树</p></blockquote><p>之字形, 旋转</p><h3 id="Eg-2"><a href="#Eg-2" class="headerlink" title="Eg. 2"></a>Eg. 2</h3><blockquote><p>2n个点划分成边集不交的匹配</p></blockquote><p>一个点放中间, 对称着连, 旋转</p><h3 id="Eg-3"><a href="#Eg-3" class="headerlink" title="Eg. 3"></a>Eg. 3</h3><blockquote><p>完全图边的排列, 使得任意连续 $n-1$ 条边是一棵生成树</p></blockquote><p>奇数时, 用Eg. 1的做法, 发现可以做到把一个之字形逐条边的转化成一个旁边的之</p><p>偶数时, 用Eg. 2的做法, 相邻两个匹配是一个生成树, 发现也可以</p><h3 id=""><a href="#" class="headerlink" title=". . ."></a>. . .</h3><p>不懂</p><h2 id="试机赛T1"><a href="#试机赛T1" class="headerlink" title="试机赛T1"></a>试机赛T1</h2><p>tocheck: 转化成后缀minmax段数上单侧递归线段树</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二轮省集</title>
      <link href="/2024/05/02/sdptt2/"/>
      <url>/2024/05/02/sdptt2/</url>
      
        <content type="html"><![CDATA[<h1 id="二轮省集"><a href="#二轮省集" class="headerlink" title="二轮省集"></a>二轮省集</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="模拟赛"><a href="#模拟赛" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h4><blockquote><p>数 $1\ldots 10^L$ 内有多少个数满足, 通过每次删三个连续且相同的数位可以删空($\texttt{011100}\to \texttt{000}$)</p><p>$L\le 10^7$</p></blockquote><p>提前几个观察: 前导 $0$ 不重要, 只要不管然后乘 $\dfrac{9}{10}$ 即可.</p><p>考虑建树, 容易发现对于一个序列, 可以建一棵树, 每三个匹配的作为一个节点, 两个空隙往下连儿子, 于是设树的GF是 $T(x)$, 最后长恰好 $3n$ 的串个数就是 $[x^n]\dfrac{1}{1-10T(x)}$, 答案就是 $[x^n]\dfrac{9}{10(1-x)}\dfrac{1}{1-10T(x)}$, 显然有 $T(x)&#x3D;\dfrac{x}{(1-9T(x))^2}$, 于是想到设 $T$ 的复合逆是 $R(x)$, 代入得 $x&#x3D;\dfrac{R(x)}{(1-9T(x))^2}$, 拉反有 $[x^n]T(x)&#x3D;\dfrac{1}{n}[x^{n-1}]\left(\dfrac{x}{R(x)}\right)^n&#x3D;\dfrac{1}{n}[x^{n-1}]\dfrac{1}{(1-9x)^{2n}}$.</p><p>然后其实在列方程那步就知道这是微分有限的了, 高斯消元复杂度线性. 到这里之后可以列出 $\dfrac{1}{n}[x^{2n}y^{2n}]\dfrac{x^2}{1-\dfrac{1}{(1-9x^2)y}}$, 于是根据EI结论二元GF对角线是整式递推.</p><p>然后你就真的开始高消, 然后这里有个很大的坑, 对整式递推时因为所有系数都是 $0$ 总是一组解, 所以你会钦定一些东西为 $1$, 然后这里我设总和为 $1$, 然后发现总是解不出来, 因为这个题递推式系数和总是 $0$. 反正就是如果解不出来就是归一系数错了.</p><h4 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h4><blockquote><p>称一个排列合法当且仅当按任意顺序操作每个 $i$ 至多一次使得排列升序, 操作是交换 $i, i+1$. 求所有的 $f_{i, j}$ 表示有 $j$ 个 $k$ 满足 $\vert k-a_k\vert&#x3D;i$ 本质不同的合法序列.</p><p>做到 $n^2\log n$</p></blockquote><p>&#x2F;bx&#x2F;bx&#x2F;bx dwt</p><p>考虑置换环, 则不容易发现对于任意一个环一定是占据整个一个区间, 并且一定是先从左往右跳再从右往左跳. 证明归纳.</p><p>二项式反演, 钦定有 $i$ 个边跨度为 $k$, 记往左连的边是 $0$, 往右的是 $1$, $0\to 0, 1\to 1$ 只能在头&#x2F;尾出现, $0\to 1, 1\to 0$ 只在一个环的头尾出现. 于是发现两个钦定的边的交的长度不超过 $2$.</p><p>于是考虑dp, 设 $f_{i, j}$ 表示前 $i$ 个点, 钦定了 $j$ 条边, dwt说转移有很多细节.</p><p>考虑复杂度, 发现 $j\le \dfrac{i}{k-1}$, 复杂度 $n^2\log n$.</p><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>&#x2F;bx&#x2F;bx&#x2F;bx zyz</p><blockquote><p>给一棵有根树, 点 $i$ 上有值 $a_i$, 你可以按照 $1\ldots n$ 的顺序, 每次交换点 $i$ 和一个子树内的点上的 $a$, 使得 $a_i&#x3D;i$, 构造方案或判断无解.</p><p>$n\le 5\times 10^5$</p></blockquote><p>连边 $a_i\to i$ 表示 $a_i$ 要到 $i$, 考虑置换环&#x2F;fn, 容易发现置换环不在一条链上无解. 此外考虑同一条链上, 则一个置换环上除了深度最低点都可以操作, 而一个 $n$ 点的置换环会拆成 $n-1$ 个二阶置换, 意味着所有点都要能操作, 于是进行一次交换后必须要满足交换后这个点为环内最低点, 于是应该是顺着走到第一个比当前点低的点交换. 于是写数据结构(zyz写了启发式分裂, 或者可以写平衡树)维护这个东西即可.</p><h3 id="树上问题"><a href="#树上问题" class="headerlink" title="树上问题"></a>树上问题</h3><h4 id="Qoj8547-Whose-Land"><a href="#Qoj8547-Whose-Land" class="headerlink" title="Qoj8547 Whose Land?"></a>Qoj8547 Whose Land?</h4><p>扫描线, 每个点维护编号最大的特殊点编号, 问题变成邻域赋值&#x2F;查询全局编号大于某值的个数, 则按照bfs序编号, 显然每个邻域操作拆出 $k$ 个bfs序区间贡献(每个深度), 于是颜色段均摊+BIT即可. 复杂度 $(nk+q)\log n$</p><p>[trick] 一个点到一个点集的距离最小值在dfn的前驱&#x2F;后继取到.</p><h4 id="CF1610H-Squid-Game"><a href="#CF1610H-Squid-Game" class="headerlink" title="CF1610H Squid Game"></a>CF1610H Squid Game</h4><p>dwt秒3100</p><p>链的话扫描线+贪心, 尽量在右边选即可.</p><p>对于树, 从下往上走, 对于祖孙链最晚肯定是在祖先在链上的儿子处删, 不断重复着贪心, 用bit+dfs序维护, 而发现若以第一次操作的点为根, 则树上就只剩下祖孙链了.</p><p>考虑随便一个点为根跑刚才的做法, 发现对于非祖孙链, 往上的点一定比往下的优, 而上面做法找到的解满足每个点深度都最小, 所以此时一定需要再操作一次, 在根处即可.</p><p>$n\log n$</p><h4 id="P10107"><a href="#P10107" class="headerlink" title="P10107"></a>P10107</h4><p>考虑链怎么做, 那么类比 CF1511G Chips on a Board 倍增的处理异或, 设 $f_{i, j}$ 表示询问 $(i, 2^j-1)$(恰好是考虑低 $j$ 位的答案, 因为低 $j$ 位和高为是独立的), 然后倍增跳就行了.</p><p>对树上的考虑对每层做前缀和. 即维护 $f_{i, j}$ 表示点 $i$ 及其同深度且bfs序小于自己的点查询距离为 $2^j-1$ 的答案之和, 此外为了合并需要维护 $g_{i, j}$ 表示点 $i$ 及其同深度且bfs序小于自己的点的子树中二进制第 $j$ 位 $1$ 的数量, 就行了.</p><p>而还有一个很厉害的做法是考虑直接把链上做法套个长剖, 把询问挂到点上自底向上在合并的同时统计答案, 这个做法不需要差分性感觉很强大.</p><p>复杂度都是单 $\log n$(倍增跳).</p><h4 id="CF1876E-Ball-Stackable"><a href="#CF1876E-Ball-Stackable" class="headerlink" title="CF1876E Ball-Stackable"></a>CF1876E Ball-Stackable</h4><p>结论: 存在一个点使得其作为根时, 所有未定向的边都朝外. (其实都朝外这件事较符合直觉)</p><p>对已经确定的定向, 考虑对每个点定义高度 $h$, 满足若 $u\to v$, 则 $h_v&#x3D;h_u+1$, 则发现同色边一定是一个连通块边缘上指向连通块内部的边, 是极大的除边界外 $h_u&gt;$ 某值的连通块. 此时考虑若根在连通块外则恰有一条边是外向, 否则所有边都内向. 于是当根位于 $h$ 最小处时每个连通块对应一条外向边, 就证明出来了.</p><p>复杂度线性.</p><h4 id="P10305-THUWC-2020-序排泡冒"><a href="#P10305-THUWC-2020-序排泡冒" class="headerlink" title="P10305 [THUWC 2020] 序排泡冒"></a>P10305 [THUWC 2020] 序排泡冒</h4><blockquote><p>$n$ 个点树, $q$ 次询问对链上点权序列 $a_1\ldots a_m$, 有多少个长 $m$ 的序列进行 $k$ 轮冒泡排序之后得到 $a$.</p><p>$n, q\le 5\times 10^5$</p></blockquote><p>二合一题, 先考虑给定 $m$ 的情况怎么算, 则有经典结论</p><p>[trick] 一轮冒泡排序, 排序前前缀 $[1, i]$ 和排序后 $[1, i-1]$ 的数集只差一个最大值, 则 $k$ 轮后 $[1, i+k]$ 和 $[1, i]$ 差前 $k$ 大.</p><p>于是考虑比较 $a’<em>{[1, i]}, a</em>{[1, i+k]}$ 和 $a’<em>{[1, i+1]}, a</em>{[1, i+k+1]}$, 考虑 $a’<em>{i+1}$, 若其是前缀最大值则可能原序列 $p$ 任意空位($[1, i+k+1]$ 且不是 $a’</em>{[1, i]}$), 否则恰是 $a_{i+k+1}$</p><p>转化之后就是求前缀最大值数量, 因为没有修改所以不用楼房重建+lct, 一个2log做法是离线点分治+可撤销栈, 一个1log做法是直接在原树上搞, 维护 $g_u$ 表示 $u$ 祖先上第一个比它大的值, 则到lca之前的部分显然直接倍增, 后面的部分注意到前缀最大值相当于要求 $g_u$ 比lca浅, 并且要求值比 $u$ 左边那边更大, 于是dfs维护线段树就能做了. 复杂度单 $\log n$</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="模拟赛-1"><a href="#模拟赛-1" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A-1"><a href="#A-1" class="headerlink" title="A."></a>A.</h4><p>把每条边拆成两条边, 先强制选其中大的一条, 则此时大的那条边不影响连通性, 于是钦定其一定选, 若不连通增加边权即可, 从小到大扫边权模拟Kru, 状态设 $f_{i, j, S}$ 表示扫描权值到 $i$, 选了 $j$ 条 $a_i$ 的边, 且并查集状态为 $S$, 复杂度 $m^2\mathrm{Bell}(9)$</p><h4 id="B-1"><a href="#B-1" class="headerlink" title="B."></a>B.</h4><p>考虑如果所有指针都指向父亲那么就是一个欧拉环游序, 循环节长 $O(n)$, 问题出在一开始指针不指向父亲到全部指向父亲的过程会经历 $n^2$ 步. 考虑把每个点的儿子分成两类, 在父亲前的(向左画)&#x2F;在父亲后的(向右画), 则发现每次会走所有向左的边遍历树, 并把走过的点向右连的儿子也变成向左的, 于是把点按祖先路径上向右走的边的数量从小到大排序, 相当于不断在欧拉序上插入一个点(但始终是整棵树欧拉序的子序列, 所以线段树), 复杂度 $(n+q)\log n$</p><p>然后这题可以不要线段树, 用并查集支持找下一个还没有被加入到欧拉序上的点可做到 $n\alpha(n)+q\log q$</p><h4 id="C-1"><a href="#C-1" class="headerlink" title="C."></a>C.</h4><p>首先连通性显然是拆成若干个段且 $[l, r]$ 的值域恰好是 $[l, r]$.</p><p>左&#x2F;右是对称的, 只考虑左边.</p><p>把点 $(x, p_x)$ 画到平面上, 两步能当前点能到的范围内最左的点和最小的点决定, 推得每次都是由上步范围内最左的和值最小的得到, 需要 $k$ 步以上的点是一个2side矩形. 于是可以把一个范围记为 $(a, b)$ 表示某个点到达最左的点是 $a$, 最小的点是 $b$ 的情况下不能到的范围, 也即 $i\le a\And p_i\le p_b$ 的范围.</p><p>考虑每个点都会这样扩展出一串点对, 拆贡献为每个点对贡献为所对应区域内点数, 建树, 如果树大小可接受就是二维数点 $n\sqrt n$ 矩形查询 $n$ 次单点修改就赢了.</p><p>考虑分析树的大小, 对于点 $(x, p_x)$, 设与它构成逆序对的点序列为 $(a_k, p_{a_k})$, 设前 $B$ 个点是好的, 则一共有 $nB$ 个好点. 进行跳跃(找儿子)的过程中, 若当前位于一个与当前点为逆序对, 且非好点, 则至少会让范围的一条边长缩小 $B$(因为下次至少可以跳到 $(a_1, p_{a_1})$ 这个点), 于是对一个点, 其跳的坏点个数是 $\dfrac{n}{B}$, 总个数 $\dfrac{n^2}{B}$, 平衡得 $n\sqrt n$.</p><p>总复杂度 $n\sqrt n$</p><p>建树的时候直接哈希常数比较大, 更好的方法考虑从大到小扫描 $x$, 则容易发现越小的 $x$ 的父亲的 $y$ 越小, 于是给每个 $x$ 开一个有序 vector 维护所有的 $y$, 则插入父亲的时候只要判定是否和最后一个元素相同即可.</p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><h4 id="CF1762G-Unequal-Adjacent-Elements"><a href="#CF1762G-Unequal-Adjacent-Elements" class="headerlink" title="CF1762G Unequal Adjacent Elements"></a>CF1762G Unequal Adjacent Elements</h4><p>注意到相当于要把序列划分成两个子序列, 间隔放置保证没有相邻相同元素.</p><p>容易猜到如果有一个数次数超过 $\lceil \dfrac{n}{2} \rceil$ 就无解.</p><p>如果存在绝对众数, 则显然把它们划分成一个子序列, 剩下的放到另一个子序列, 就是对的.</p><p>于是考虑把原序列划分成若干个有绝对众数的区间, 于是从前往后, 钦定当前 $a_1$ 为绝对绝对众数(总长奇数情况下)往后找极长区间, 现在问题是划到了最后可能剩下一段, 这段单独看是无解的,</p><p>此时把最后一段中的绝对众数拿出来和上一段合并.</p><p>todo</p><h4 id="P9924-POI-2023-x2F-2024-R1-Satelity"><a href="#P9924-POI-2023-x2F-2024-R1-Satelity" class="headerlink" title="P9924 [POI 2023&#x2F;2024 R1] Satelity"></a>P9924 [POI 2023&#x2F;2024 R1] Satelity</h4><p>先考虑没有互不相同的限制, 则先A公司都填A, B公司都填B, 第 $i$ 个A公司的让第 $i$ 位为 $C$, 让所有与它相连的B对应位为C, 于是加上互不相同就再加一段在B处二进制编码, 现在用了 $n+\log_2 n$</p><p>考虑A连边相同的可以用一位去连边, 然后再在等价类中编码. 于是现在设A, B小的一边有 $x$ 个等价类, 最大的等价类大小分别为 $a, b$, 需要用是 $M&#x3D;x+\log_2 a+\log_2 b$, $a, b\le n-x+1$, $M\le x+2\log_2(n-x+1)$, 发现当且仅当 $n-x+1&#x3D;3, 5$ 时要用 $M&#x3D;n+2$ 次.</p><p>但这里默认A公司, B公司之间都有交, 发现当有编码部分&#x2F;等价类大于3的时候都是可以的, 于是特殊处理 $n&#x3D;2$ 即可.</p><p>于是仍然要处理 $n+2$ 的问题, 注意这里不仅是要 $n-x+1&#x3D;3$, 因为我们刚才用了 $a, b\le n-x+1$ 这个放缩, 所以只有两边都是最大等价类是 $3$(或都是 $5$), 剩下的都是 $1$ 的情况才会错, 考虑此时我们用2位编码 $3$ 个不同的卫星是很浪费的, 于是对于 $3$ 的情况把编码位拿出来构造, 此时两个编码类分别赋值(<code>ACC</code>和<code>CCA</code>), 可重的去连边, 发现就行了. 对于 $5$ 的情况类似构造<code>CCAAC</code>, <code>CAACC</code>, <code>AACCC</code>)(横过来读只要抄 $1\ldots 7$ 的二进制表示). 基本就是避免编码位浪费.</p><h4 id="gym104821H"><a href="#gym104821H" class="headerlink" title="gym104821H"></a>gym104821H</h4><p>容易发现我们容易的铺 $2\times 4$ 的矩形, 所以直接解决了 $n&#x3D;4k$ 的情况.</p><p>对于 $n&#x3D;2k$ 的情况, 容易发现先铺完剩一行, 最后一行铺剩一个 $2\times 2$, 用经典套路黑白染色数格子得到不可能铺满所以这就是最优情况.</p><p>对 $n&#x3D;4k+3$ 的情况, 观察样例得到 $3\times 3$ 可以做到只缺一个, 于是可以规约到 $4k+1$.</p><p>对 $4k+1$, 如果仿照上面的有一个 $5\times 5$ 缺 $1$ 的就赢了, 发现不行, 但tyy说搜 $9\times 9$ 缺 $1$ 的就有了. 于是做完了, 需要打表 $n&#x3D;5, 13, 1$.</p><h4 id="CF1646F"><a href="#CF1646F" class="headerlink" title="CF1646F"></a>CF1646F</h4><p>不容易想到考虑一个中间状态: 每个人都有 $1\ldots n$. 则此状态到最终状态只要考虑把每个人的作为行, 让每列是一个排列循环位移若干位, 则发现需要用 $\dfrac{n(n-1)}{2}$</p><p>而考虑如何让其他状态到 $\dfrac{n(n-1)}{2}$, 则编一个策略, 每个人优先给相同的, 否则给上一个人给过来的.</p><p>证明考虑势能分析: 仅考虑颜色 $c$, 设第 $i$ 个人有 $a_i$ 个该颜色的牌, 循环移位使 $a_n$ 为最小值, 设势能为 $\sum_i ia_i$, 则最后显然是 $\sum_i i$, 而只要保证 $a_n$ 作为最小值不给 $a_1$, 就使得每次操作会让势能减小 $1$, 总次数 $\sum_i i-\sum_i ia_i\le \dfrac{n(n-1)}{2}$</p><p>于是就做完了.</p><p>[trick] 考虑中间状态.</p><h4 id="gym104891K"><a href="#gym104891K" class="headerlink" title="gym104891K"></a>gym104891K</h4><p>注意到表示 $n$ 个点需要用 $16n$ 个bit, 而你询问得到恰好 $16n$ bit, 所以你必须要做到完全利用信息. 即构造每条路径恰好长面积的一半, 任意 $k$ 条路径交是面积的 $\dfrac{1}{2^k}$ 这样的.</p><p>考虑分治, 则重点是考虑用一个分形的线去铺(希尔伯特曲线), 使得下层可以沿着分形的线去铺, 构造略.</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="模拟赛-2"><a href="#模拟赛-2" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A-2"><a href="#A-2" class="headerlink" title="A."></a>A.</h4><p>从小到大扫值域插入, 记录当前 $k$ 个集合的大小构成的集合即可, 状态数是带限制的划分数. 钦定上一个数放的集合大小以避免相同的数放到同一集合. 复杂度 $nkS$, $S$ 为一个划分数.</p><h4 id="B-2"><a href="#B-2" class="headerlink" title="B."></a>B.</h4><p>考虑序列上扫描线扫右端点, 维护平面上每个点最右边能覆盖它矩形的编号, 把这些东西放在树状数组上就可以查询答案, 现在维护这个只要考虑把平面拆成若干个矩形的不交并, 然后因为数据随机所以任意时刻矩形个数在 $1000$ 左右, 直接就过了.</p><h4 id="C-2"><a href="#C-2" class="headerlink" title="C."></a>C.</h4><p>注意到短边边长最大 $17$, 考虑轮廓线dp, 记录当前格子位置和轮廓线上是否有从上到下延伸的位置, 状态是 $nm2^n$, 转移 $O(m)$.</p><p>对带修改的时候考虑正&#x2F;反各做一次dp在修改位置合并. 合并要保证这行对应位置相等, 用一个And卷积.</p><h3 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h3><h4 id="ABC313Ex-Group-Photo"><a href="#ABC313Ex-Group-Photo" class="headerlink" title="ABC313Ex Group Photo"></a>ABC313Ex Group Photo</h4><p>考虑如果 $a$ 确定, 显然把 $b$ 从小到大排序往里放</p><p>注意到一个位置只和相邻两个位置中最小值相关, 于是从小到大插入 $a$, 就能从小到大的确定所有间隔. 于是设状态 $f_{i, j, 0&#x2F;1&#x2F;2}$ 表示已经插入前 $i$ 小的 $a$, 序列两个端点是否插入, 已经形成 $j$ 个连续段. 复杂度 $n^2$</p><h4 id="ARC171-E"><a href="#ARC171-E" class="headerlink" title="ARC171 E"></a>ARC171 E</h4><p>容易发现一定是偶数步.</p><p>很难发现操作序列唯一对应棋子放置方案.</p><p>那么只要数操作序列, 考虑棋子经过的行上一定是若干相邻点匹配, 列上同理, 而再把行和列上的 若干对匹配 匹配起来就能得到一组棋子方案. 于是行和列实际上是独立的, 方案数相乘即可.</p><p>那么现在考虑行, 这个点原来在 $A$, $A$ 可能和 $A+1$ 或 $A-1$ 匹配, 考虑若和 $A+1$ 匹配, 枚举其左边有 $i$ 哥匹配, 右边有 $\dfrac{m}{2}-i-1$ 个匹配, 选出这些是简单组合数, 然后再乘上它们的顺序 $(m-2)! i$($A$ 一定在头上, 最后一步必须从左边跳过来).</p><h4 id="Gym104081D-Devil-May-Cry"><a href="#Gym104081D-Devil-May-Cry" class="headerlink" title="[Gym104081D] Devil May Cry"></a>[Gym104081D] Devil May Cry</h4><p>相当于 $S_1\ldots S_m$ 构成 $1\ldots n$ 的划分, 限制 $\vert S_i\vert\le lim_i$ 且 $S_i\subseteq T_i$</p><p>于是优化自己卷积, 考虑如何对每个 $i$ 快速计算其某个位置的值(因为实际上是把 $T_i$ 所有满足大小限制的子集做FWT再相加的值).</p><p>即<br>回顾<br>$$<br>FWT(F)_i&#x3D;\sum_j (-1)^{\vert i\And j\vert}f_j<br>$$</p><p>$$<br>FWT(F_k(x))<em>i &#x3D; \sum</em>{\vert j\vert\le lim_k, j\subseteq T_k} (-1)^{\vert i\And j\vert}x^j&#x3D;<a href="1+x">x^{\le lim_k}</a>^{T_k-\vert i\And T_k\vert}(1-x)^{\vert i\And T-k\vert}<br>$$</p><p>然后求这些东西复杂度是 $nm2^n$, 瓶颈在于把上面的 $m$ 个 $2^n$ 集合幂级数卷起来, 容易想到先 $\ln$ 再 $\exp$, 因为上面每个东西形式都是 $[x^{1\ldots C}] (1-x)^A(1+x)^B$, 所以本质不同只有 $n^3$, 都 $\ln$ 掉复杂度 $n^5$.</p><p>最后复杂度就是多项式相加的 $nm2^n$</p><h4 id="QOJ-8180-Bridge-Elimination"><a href="#QOJ-8180-Bridge-Elimination" class="headerlink" title="QOJ 8180 Bridge Elimination"></a>QOJ 8180 Bridge Elimination</h4><p>首先众所周知点权之和乘积等于每个边双内选一个点乘起来再求和, 注意到可以先对确定的图乱填点, 容易发现是对称的, 也就是说点权可以最后乘上去, 剩下的部分就是对每个 $k$ 计算, 有 $k$ 个边双的图的边双大小乘积之和, 这个东西只要先能算 $n$ 点大小的边双, 再把这个卷起来就行了.</p><p>而对于边双我们有厉害的东西, 设无向连通图的GF是 $G$, 边双的GF是 $F$, 考虑 $1$ 所在边双, 则其向外连的都是割边, 相当于每个点上可以挂若干个无向连通图, 即 $G(x)&#x3D;F(x\exp G(x))$, 其中 $G$ 已知, $F$ 未知.</p><p>记 $H&#x3D;xe^G$, 有 $G(x)&#x3D;F(H(x))$, , 代入 $H^{-1}(x)$ 有 $F(x)&#x3D;G(H^{-1}(x))&#x3D;$, 于是</p><p>$$<br>[x^n]F(x)&#x3D;[x^{n-1}]\dfrac{1}{n}G’(x)\dfrac{x^n}{H^n(x)}<br>$$</p><p>暴力 $n^2$, 用多项式快速幂是单 $\log n$.</p><p>所以这个题是不是可以做到俩log, 我们考虑第一部分背包实际上是求</p><p>$$<br>p_n&#x3D;[x^n]\prod_i (1+a_ix)<br>$$</p><p>显然分治FFT. 然后我们单 $\log n$ 求了 $F$, 现在只要求</p><p>$$<br>\sum_k p_k <a href="xF'(x)">x^n</a>^k<br>$$</p><p>转置是</p><p>$$<br>\sum_k c_k<a href="xF'(x)">x^k</a>^n<br>$$</p><p>单 $\log n$.</p><h4 id="Qoj8171"><a href="#Qoj8171" class="headerlink" title="Qoj8171"></a>Qoj8171</h4><p>考虑设 $i$ 次结束的概率是 $p_i$.</p><p>显然你没有什么好策略, 某时刻的情况是前 $i-1$ 位已知, 第 $i$ 位排除了一部分, $i+1$ 位往后完全不知道. 考虑第 $i$ 位此时会被问多少次, 因为完全未知可以认为我们依次尝试, 则发现在第 $i$ 位问 $0\ldots n-i$ 次的概率都是相同的 $\dfrac{1}{n-i+1}$.</p><p>于是可以直接写PGF, $P(x)&#x3D;\sum_i p_ix^i$, 则 $P(x)&#x3D;\prod_{i&#x3D;1}^n \dfrac{1}{n-i+1}\dfrac{1-x^{n-i+1}}{1-x}&#x3D;\prod_{i&#x3D;1}^n \dfrac{1}{i}\dfrac{1-x^i}{1-x}$.</p><p>而我们要求的是 $[x^{m-1}]\dfrac{1}{1-x}P(x)&#x3D;[x^{m-1}]\dfrac{1}{(1-x)^{n+1}}\prod_i (1-x^i)$, 后面这个东西是五边形数, 就做完了.</p><h4 id="Qoj8217"><a href="#Qoj8217" class="headerlink" title="Qoj8217"></a>Qoj8217</h4><p>容易发现等价于在 $(n+1)\times (n+1)$ 的矩形内填 $2\times 3$ 的矩形.</p><p>然后发现 $n\times n$ 到 $(n+6)\times (n+6)$ 是容易的.</p><p>于是去手动构造 $n&#x3D;2\ldots 7$</p><h4 id="Qoj8174-Set-Construction"><a href="#Qoj8174-Set-Construction" class="headerlink" title="Qoj8174 Set Construction"></a>Qoj8174 Set Construction</h4><p>考虑对 $n, m$ 归纳减小规模, 并保持 $m$ 大约小于 $\dfrac{n(n-1)}{2}$</p><p>若 $m$ 为偶数, 直接把 $n&#x2F;2, m&#x2F;2$ 的答案弄过来, 令 $x$ 变成 $n-1, m&#x2F;2$ 继承过来(最后一位添 $0&#x2F;1$)</p><p>若 $m$ 为奇数, 变成 $n-1, m-1$(把所有数后面填 $1$, 最后加入一个 $0$)</p><h4 id="Qoj7637-Exactly-Three-Neighbors"><a href="#Qoj7637-Exactly-Three-Neighbors" class="headerlink" title="Qoj7637 Exactly Three Neighbors"></a>Qoj7637 Exactly Three Neighbors</h4><p>发现当使用 $n&#x3D;1$ 时(用长条填充), 发现容易得到所有 $\le \dfrac{2}{3}$ 的比例.</p><p>剩下的写一个精细实现的搜索(? ? ! ! )</p><p>试着证明最大值是 $\dfrac{4}{5}$, 把边分为黑黑之间, 黑白之间和白白之间, 而前两类是固定的, 发现 $\dfrac{4}{5}$ 搜出来的解没有任何白白边.</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="模拟赛-3"><a href="#模拟赛-3" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A-3"><a href="#A-3" class="headerlink" title="A"></a>A</h4><p>对每个颜色考虑, 则建虚树, 发现一个当前颜色对当前询问贡献 $1$ 当且仅当询问的链和虚树有交, 于是虚树的点加 $1$ 边减 $1$ 贡献就是对的了.</p><p>需要动态维护 $n$ 个虚树, 写起来很爆炸.</p><p>需要处理链加链求和复杂度是 $n\log^2 n$, 显然可以麻烦的用全局平衡二叉树搞到单 $\log n$.</p><p>靠靠靠, 不用维护虚树, 你是对所有点加 $1$, 所有边减 $1$, 这不是我们 异象石 dfs序加一圈就做完了吗&#x2F;&#x2F;&#x2F;fn</p><p>然后还有些其他做法, 再把路径有交拆成 虚树根在路径上 或 路径lca在虚树边上, 分别做.</p><h4 id="B-3"><a href="#B-3" class="headerlink" title="B"></a>B</h4><p>你看这个 $16$, 基本上就是让你选个方向开始状压dp, 要控制轮廓线很小才能压下, 于是直接极角排序轮廓线dp可以做到 $N2^{m+1}$, $N$ 为点数大概是 $\pi nm$.</p><p>另一个做法是沿着 $y&#x3D;-x$ 斜着dp.</p><h4 id="C-3"><a href="#C-3" class="headerlink" title="C"></a>C</h4><p>看成是选 $k$ 组匹配, 选每个点有一个代价, 同组匹配之间付出差的绝对值的贡献, 于是有费用流做法: 建图 $i \stackrel{\inf, 1}{\longleftrightarrow} i+1, S \stackrel{1, a_i}{\longrightarrow} i, i \stackrel{1, b_i}{\longrightarrow} i+1<br>$ 即可.</p><p>然后就模拟费用流手动跑即可.</p><p>让我们看看这个可以做到什么, 考虑维护中间每个边被正向经过的次数 $c_i$(反向为负, 显然不会同时存在两个方向的反向边), 只需要考虑向右走的, 此时一个区间的权值是 $b_l+d_r+\sum_i [c_i\ge 0]w_i$, 要查询全局值最小的区间, 并支持区间加减 $1$, ban 掉单点.</p><p>然后这个看起来可以规约区间加减 $1$ 区间大于 $0$ 数个数, 考虑控制每个点附加的那个权值(即题目中 $b, d$ 的值)就可以控制区间位置, 然后问完一次之后反向问一次可以抹平修改, 而因为每个端点只会用一次, 所以控制第 $k$ 次修改的  附加权值是 $-k\cdot \inf$ 即可, 这个东西不能 $\mathrm{poly(\log n)}$, 直接考虑根号算法, 又因为区间加区间大于 $0$ 的个数就已经 $n\sqrt n$ 困难(叠! ), 考虑 $n\sqrt n\log n$.</p><p>此时这个东西很简单, 显然只要考虑一个方向的答案(这里考虑从左到右), 序列以 $B$ 大小分块分块, 每个块维护块内答案, 从某个位置开始到右端点的答案, 从左端点开始到某个位置结束的答案, 大于 $0$ 数个数, 这些信息显然只有 $B$ 种不同的值(每个数从负数变成正数), 然后这个处理一块可以 $B\log B$(线段树, 也是维护这 $4$ 个信息), 需要每个块记录一个指针指向当前对应答案, 区间加减 $1$ 只会移动 $O(1)$.</p><p>区间修改直接打标记并重构散块, 单点修改直接重构散块, 查询直接扫一遍求一下大于 $0$ 个数的前缀和, 然后就是最小化 $a_i-b_j$, 要求 $j&lt;i$, 则直接记录 $b_j$ 前缀最大值即可.</p><p>分析复杂度, 查询是 $\dfrac{n}{B}$, 修改是 $B\log B+\dfrac{n}{B}$, 平衡得复杂度 $m\sqrt {n\log n}$.</p><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><h4 id="ABC276Ex"><a href="#ABC276Ex" class="headerlink" title="ABC276Ex"></a>ABC276Ex</h4><p>考虑某些子矩阵至少有一个 $0$, 其他的位置不能有 $0$, 于是不需要考虑 $0$ 的部分, 只要填所有非 $0$ 的部分剩下的全 $0$.</p><p>容易想到原根和前缀和, 于是现在有 $4q$ 个变量和 $q$ 个方程组.</p><p>然后注意到原根只关心奇偶性, 可以bitset优化高消, 做到 $q^3&#x2F;w$ 过了.</p><h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p>记个结论</p><p>若 $P(x)$ 是矩阵 $M$ 的特征多项式, $P_1(x)$ 是最小的零化多项式, 有结论<br>若 $P(x)&#x3D;\prod_i (1-\lambda_i)^{a_i}$ 则 $P_1(x)&#x3D;\prod_i (1-\lambda_i)^{b_i}, b_i\in [1, a_i]\cap Z$.</p><p>于是要求 $M^k$ 你就先把 $x^k$ 多项式取模就行了. 复杂度就是 $n^4$</p><h4 id="QOJ-7612-Matrix-Inverse"><a href="#QOJ-7612-Matrix-Inverse" class="headerlink" title="QOJ 7612 Matrix Inverse"></a>QOJ 7612 Matrix Inverse</h4><p>容易想到NOI2013 那个矩阵乘向量题, 考虑随一个向量一次乘 $AC$, 作为行一次作为列一次可以得到包含错的 $12$ 个行和 $12$ 个列, 得到 $144$ 个可能错的位置.</p><p>于是每一行单独拉出来列方程, 判它是不是单位矩阵就行了. 解方程复杂度是 $12^3n$, 列方程是 $12n^2$.</p><h4 id="n-阶范德蒙德矩阵行列式"><a href="#n-阶范德蒙德矩阵行列式" class="headerlink" title="$n$ 阶范德蒙德矩阵行列式"></a>$n$ 阶范德蒙德矩阵行列式</h4><p>是 $\prod_{1\le j&lt;i\le n}(x_i-x_j)$</p><h4 id="n-阶循环矩阵行列式"><a href="#n-阶循环矩阵行列式" class="headerlink" title="$n$ 阶循环矩阵行列式"></a>$n$ 阶循环矩阵行列式</h4><p>设 $f(x)&#x3D;\sum_{i&#x3D;0}^n a_ix^i$, 则行列式是 $\prod_i f(w_n^i)$, $w$ 是单位根.</p><h4 id="CF917D"><a href="#CF917D" class="headerlink" title="CF917D"></a>CF917D</h4><p>令重合的边权是 $x$, 没重合的是 $1$, 于是用点值跑矩阵树可以到 $n^4$.</p><p>但上面做法可以对任意图做, 对于树可以做的更快, 考虑直接容斥, 则钦定 $k$ 条边相同, 然后Caylay+ $n^2$.</p><h4 id="gym102978A"><a href="#gym102978A" class="headerlink" title="gym102978A"></a>gym102978A</h4><p>对分割线用LGV, 然后需要把起点终点平移以允许重合.</p><p>因为钦定了一个点的点值, 所以会要求某条分隔线在这个点的左&#x2F;右, 所以让所有经过这个点左边的有权值 $x$ 右边的有权值 $1$ 就做完了.</p><p>然后这个题和上个题的行列式都可以特征多项式优化, 因为刚才我们特征多项式 $n^3$ 可以求, 所以所有 $\vert Ix+A\vert$ 都可以优化.</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><h3 id="模拟赛-4"><a href="#模拟赛-4" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A-4"><a href="#A-4" class="headerlink" title="A."></a>A.</h4><p>容易发现你改一个点整棵树都要变, 但这个问题看起来很像那种dp每次改一条链的东西, 然后注意到一个子树内答案是关于子树根父亲的二次函数, 设点 $u$ 的函数是 $f_u(x)$, 容易发现 $f_u(x)&#x3D;\min_t f_{lson}(t)+f_{rson}(t)+(t-x)^2$, 则 $t$ 可以直接求, 然后还是二次函数, 然后做完了, 复杂度 $n2^n$.</p><h4 id="B-4"><a href="#B-4" class="headerlink" title="B."></a>B.</h4><p>观察给了个 $\sum k^2$ 的条件.</p><p>容易发现显然能直接走的肯定直接走, 考虑 $u$ 不能直接走的点 $v$, 若路径是 $u\to x\to t_1\ldots t_k\to v$, 则其中 $x$ 是 $u$ 一步走到的, 而 $t_1\ldots t_k$ 都是 $u$ 不能走到的, 于是问题变成一个 $k$ 大小子图, 每个点有一个初值($u\to x\to t_1)$ 长度), 要在里面求最短路, 这部分是 $\sum k^2$.</p><p>然后只要对所有 $u\to v$ 边不存在的点对 $(u, v)$ 求 $u\to x\to v$ 的最小值, 然后这种不存在边的经典做法是拆成 $k$ 个区间, 于是开一个线段树存每个点出边值, 枚举 $v$ 统一算 $u$, 则 $v$ ban掉若干个点, $u$ 去查拆出来的区间最小值即可. 这里要对同一个 $v$ 一起处理是因为 $\sum k_{in} k_{out}$ 是可以很大的, 统一处理就成 $\sum_k$ 了.</p><p>哦, 也可以不线段树, 开一个堆塞所有点, 枚举 $v$ 删掉所有不连向 $v$ 的点, 再逐个枚举 $u$ 删点并撤销删点.</p><p>最后复杂度 $(\sum k^2)\log n$</p><h4 id="C-4"><a href="#C-4" class="headerlink" title="C."></a>C.</h4><p>&#x2F;bx&#x2F;bx&#x2F;bx alan_zhao</p><p>考虑你选出来一定是个凸包, 于是对凸包dp就行了, 先枚举一个点钦定其是凸包上纵坐标最小的点, 对剩下的点按极角序dp, 设 $f_i$ 表示dp到 $i$ 的时候的答案, 枚举下一个点转移, 此时要算一个三角形内有多少 牛肉 . 想到叉积算面积那个方法, 于是记录前缀和容斥即可.</p><p>复杂度 $n^3$</p><p>&#x2F;bx&#x2F;bx&#x2F;bx cxm</p><p>一个经典trick是把所有边拿出来跑, 和zyz的做法本质相同.</p><h3 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h3><h4 id="gym103447A"><a href="#gym103447A" class="headerlink" title="gym103447A"></a>gym103447A</h4><p>回文自动机的结构很差! 只有一半!</p><p>容易想到从两边往中间走, 左边匹配到 $l$, 右边匹配到 $r$, 左边&#x2F;右边还剩 $i$ 个没匹配的方案数是 $f_{l, r, i}$, 状态数是 $n\sum len$, 转移 $O(1)$.</p><h4 id="USACO-24Feb-Platinum-B"><a href="#USACO-24Feb-Platinum-B" class="headerlink" title="USACO 24Feb Platinum B"></a>USACO 24Feb Platinum B</h4><p>考虑每两个被固定位置之间的排列是确定的, 一定是从左到右选, 此时答案就是 $\sum a_i+max-min$, 只要管极差的部分. 也就是划分成 $k+1$ 个集合, 每个集合贡献其并上两个额外元素后的极差.</p><p>发现一个性质, 因为是极差, 所以每两个集合选出的值域要么包含, 要么不交, 于是可以把包含关系建树, 则 $f_{l, r, S}$ 表示 $[l, r]$ 这个区间, 已经填好了 $S$ 集合的集合, 则每次可以</p><ul><li>向左向右扩展一个, 放到一个新背包(这里先不转移)</li><li>把当前区间内用上面那个转移转移的的放到一个新背包(可以根据区间长度判断)</li><li>拆成两个子区间</li></ul><p>拆成两个子区间的时候可以钦定两个子区间都是刚刚用第二个转移转移过(没有空余元素), 就不需要枚举划分点, 复杂度是 $m^23^k$</p><h4 id="CF301E"><a href="#CF301E" class="headerlink" title="CF301E"></a>CF301E</h4><p>良好序列可以对应括号序列, 考虑折线, 然后cxm和zyz说做过一个题是钦定折线每层有多少个数, 数方案数的题. 做法是经典的从下往上在值域上扫折线, 此时折线上有若干个洞需要填入更大的数.</p><p>而优秀数列实际上是在让你数多重集, 于是把刚才那个东西像dp套dp一样放在里面, 即 $f_{i, j, k, l}$ 表示从小到大插入到 $i$ 这个数, 已经用了 $j$ 个数, 有 $k$ 个洞, 有 $l$ 种方案, 则插入的时候容易转移出这个问题.</p><p>为什么这个dp套dp不像一般的dp套dp一样只有一维不是指数呢? 感觉是因为外层dp和内层dp结构高度一致.</p><h4 id="Ternary-String-Counting"><a href="#Ternary-String-Counting" class="headerlink" title="Ternary String Counting"></a>Ternary String Counting</h4><p>暴力是记录 $f_{i, j, k}$ 表示前 $i$ 个位置, 最近的与 $i$ 不同的颜色是 $j$, 第二近的是 $k$.</p><p>$$<br>f_{i, j, k}\to f_{i+1, j, k}, f_{i+1, i, k}, f_{i+1, i, j}<br>$$</p><p>然后你会限制 $j$, $k$, 发现每次只会让增加一行是非 $0$ 值, 也就是说暴力清空非 $0$ 位置就是对的. 为了实现这个可以开 $n$ 个deque.</p><h4 id="Gym-103470I"><a href="#Gym-103470I" class="headerlink" title="Gym 103470I"></a>Gym 103470I</h4><p>你看这个路径很菜, 虽然弯来弯去只有不同的 $2H$ 种状态, 显然设 $f_{i, 0&#x2F;1}$ 表示从 $i$ 出发, 当前方向向上&#x2F;向下的最大贡献, 做上面的路径转化之后就直接做了.</p><p>复杂度排序外线性.</p><h4 id="AGC028E"><a href="#AGC028E" class="headerlink" title="AGC028E"></a>AGC028E</h4><p>So strong</p><p>见字典序想贪心, 然后现在固定 $S$ 的一个前缀, 即固定了 $A$ 和 $B$ 各一段前缀最大值, 考虑判定.</p><p>考虑 $p$ 序列中的前缀最大值, 它们一定在 $A$ 或 $B$ 中是前缀最大值, 而若 $p_i$ 非前缀最大值但是在 $A&#x2F;B$ 中是前缀最大值, 则说明 $i$ 前面的前缀最大值在 $B&#x2F;A$ 中, 于是对非 $p$ 前缀最大值的两个元素 $i, j$, 若其对应序列中前面最近的前缀最大值是 $m_i, m_j$, 且因为 $p_{m_i}&gt;p_i, p_{m_j}&gt;p_j$, 所以 $m_i$ 和 $i$ 在不同的序列, $j$ 同理, 所以交换 $i$ 和 $j$ 所在的序列, 一定能同时删去这两个元素, 于是可以让还没填的部分中 $A$ 或 $B$ 中的一个中所有元素都是 $p$ 的前缀最大值.</p><p>于是只考虑B中存在非前缀最大值的情况, 从前往后走, 设 $A$, $B$ 前面已经钦定的部分分别有 $c_a, c_b$ 个前缀最大值, $A$ 后面选了 $h_a$ 个 $p$ 中前缀最大值, $B$ 后面的前缀最大值中有 $h_b$ 个 $p$ 中前缀最大值和 $n_b$ 个非 $p$ 中前缀最大值, $p$ 后面一共有 $h_p$ 个前缀最大值. 有 $c_a+h_a&#x3D;c_b+n_b+h_b$, $h_a+h_b&#x3D;h_p$, 于是 $c_a-c_b+h_p&#x3D;2h_b+n_b$ 为定值. 只要存在一个这样的序列 $B$ 算出来是对的就行.</p><p>而且发现, 你总可以把一个 $B$ 中前缀最大值元素放到 $A$ 以把它减小 $2$, 所以其取值在奇数&#x2F;偶数分别是一个前缀. 于是要求分别情况的最大值, 然后这个可以从后往前dp. 然后这个是简单dp+线段树优化. (这个线段树的算出来的值对A和B是一样的只要写一遍)</p><p>复杂度 $n\log n$.</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><h3 id="模拟赛-5"><a href="#模拟赛-5" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A-5"><a href="#A-5" class="headerlink" title="A"></a>A</h4><p>靠, 智障完了.</p><p>容易发现任意时刻你选了的位置一定是一个前缀扣掉至多两个点, 于是智障dp是 $f_{i, j, k}$ 记录三个点, 则每次钦定进行一段连续的 $3$ 操作再进行一次已操作, 则任意时刻最多扣掉一个点, 只要记录 $f_{i, j}$ 表示前 $i$ 个, 扣掉 $j$. 转移显然.</p><p>然后唐处在于这个dp只要记录能否达到这个状态而不用记值, 因为你每个状态对应的值是确定的, 于是bitset优化到 $\dfrac{n^3}{w}$ 过了.</p><h4 id="B-5"><a href="#B-5" class="headerlink" title="B"></a>B</h4><p>怎么大家都这么厉害</p><p>mikefeng的做法: 考虑合并值域上连续的连通块, 设 $f_{l, r, i, j}$ 表示 $[l, r]$ 这个值域区间组成的连通块, $i, j$ 为其中最小值, 最大值位置, 则若合并 $f_{l_1, r_1, i_1, j_1}$ 和 $f_{l_2, r_2, i_2, j_2}$($l_2&#x3D;r_1+1$)时, 讨论 $j_1, i_2$ 是否相邻, 若不相邻只能转移到 $i_1, j_2$, 否则若相邻且其中一个是单点则最大&#x2F;最小值位置可能变化.</p><p>然后连通块合并显然是 $O(n)$ 的, $i, j$ 都只用 $O(1)$ 种. 复杂度线性吧.</p><p>zyz的做法:</p><p>考虑一个极大的置换环, 设其中的最小值是 $u$, $u$ 连着的值是 $x$, 则作为置换环的一部分 $u$ 要想换一定是当时 $x$ 的位置是 $u+1$, 容易发现形态一定是 $u+1\ldots x-1$ 都连在 $x$ 上, 此时 $1\ldots x-2$ 都不可能再换, 但 $x-1$ 可能是由子树内换上来的, 发现是个子问题, 于是这么找下去. 这样做可以获得所有合法的置换环, 于是在值域上dp一遍就可以得到用置换环组合出整个序列的方案数.</p><p>juefan的做法:</p><p>考虑一个很典的dp, $f_{u, v, w}$ 表示 $u$ 子树换出去 $v$, 换进来 $w$. 然后 $w$ 必然是 $v-1$ 或 $v+1$, 优化掉一维, 再考虑 $f_{u, v, 0&#x2F;1}$ 中, $v$ 一定距离 $u$ 距离不超过 $2$, 于是要么把 $u$ 换出去, 要么传到下面去要求儿子给出来. 复杂度也是线性.</p><h4 id="C-5"><a href="#C-5" class="headerlink" title="C"></a>C</h4><p>垃圾分讨</p><h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h4 id="CF718E"><a href="#CF718E" class="headerlink" title="CF718E"></a>CF718E</h4><p>预处理颜色到点的最短路 $dis_{u, c}$ 和颜色到颜色的最短路 $w_{c_1, c_2}$, , 则 $x\to y$ 的最短路是 $\min{\vert x-y\vert, \min_c dis_{x, c}+dis_{c, y}+1}$. 枚举 $x$, 考虑右边的东西最大值很小($2S$), 枚举 $x$ 前 $2S$ 个点暴力计算, 对于选择 $dis_{x, c}+dis_{c, y}+1$ 的点对, 前面只有 $S2^S$ 种点(对应点的颜色, 以及这个点到 $x$ 对应颜色), 枚举点的种类统计答案即可.</p><h4 id="CF1062F"><a href="#CF1062F" class="headerlink" title="CF1062F"></a>CF1062F</h4><p>拓扑排序时, 任意时刻队列中的点一定无法相互到达. 在正图反图分别跑一遍是充分的, 于是在删除每个点时更新每个点和它互相不可达的点的个数.</p><p>需要证明正图反图分别跑是充分的, 考虑 $x, y, z$, $x, z$ 相互不可达, 那么正图遍历时 $x, z$ 不同时在队列里一定是因为存在 $z$ 可到达的点 $y$, $x, y$ 是同一层的而 $z$ 在 $x$ 之前的层, 而 $x, y$ 同时在队列, 那么发现反图就不会有这样的 $y$, 于是 $x, z$ 在同一层.</p><h4 id="CF1250K"><a href="#CF1250K" class="headerlink" title="CF1250K"></a>CF1250K</h4><p>考虑分配普通投影仪使得之后任意时刻高清投影仪使用数量少于 $y$, 若一个时刻要用 $a$ 个投影仪, 则普通投影仪至少要用 $a-y$ 个, 至多能用 $x$ 个, 时刻 $i$ 用 $i\stackrel{[a-y, x]}{\longrightarrow} i+1$ 表示, 对一个研讨会连边 $r\stackrel{[1, 1]} l$ 就做完了.</p><h4 id="loj养猫"><a href="#loj养猫" class="headerlink" title="loj养猫"></a>loj养猫</h4><p>对第 $i$ 个时刻设变量 $x_i$, $x_i&#x3D;1$ 为睡觉, $x_i&#x3D;0$ 为吃, 则限制是 $\forall i, L\le \sum_j x_j\le R$, 变成 $L+y_i&#x3D;\sum_{j&#x3D;i}^{i+k} x_j&#x3D;R-z_i$, 然后相邻两个作差可以得到 $x_{i+k+1}-x_i&#x3D;z_{i+1}-z_i&#x3D;y_{i+1}-y_i$, 最后还有两个 $\sum_{j&#x3D;1}^{k}x_i\in [L, R]$ 的式子, 则都移动到一边, 每个变量出现一正一负两次, 于是转费用流, 每个等式对应一个点, 每个边对应一个变量即可.</p><h4 id="WF17-小小水管工"><a href="#WF17-小小水管工" class="headerlink" title="WF17 小小水管工"></a>WF17 小小水管工</h4><p>猜测 $W$ 关于 $F$ 一定是凸的, 于是直接三分 $F$, 然后用上下界最大流限制 $F$ 跑一遍最大流, 再在剩下的部分跑 $W$ 的最大流即可.</p><p>但是实际上这东西很厉害, 说的是不考虑 $W$, $F$ 最大值是 $F_m$, 不考虑 $F$ 设 $W$ 的最大值是 $W_m$, $F+W$ 的最大值是 $V_m$, 则 $F_m \le F, W\le W_m, F+W\le V_m$ 是存在合法方案的充要条件, 证明考虑先流好 $F$, 在这个基础上跑 $W$ 一定能跑到 $V_m$, 我们有方法得到 $(F_m, V_m-F_m)$ 的方案, 有方法得到 $(V_m-W_m, W_m)$ 的方案, 则满足上面条件的 $F, W$ 都可以表示成这两组方案的每条边分别乘上 $a, (1-a)$ 对应加起来得到的方案, 就对了.</p><p>然后直接求最大值.</p><h4 id="Gym101194J"><a href="#Gym101194J" class="headerlink" title="Gym101194J"></a>Gym101194J</h4><p>典是把 L形 拆成左右选一个, 上下选一个.</p><p>网格黑白染色, 每个格子拆出点入点, 对黑点出点决定横管, 入点决定竖管, 白点用出点决定竖管, 入点决定横管, 每个点的入点连向相邻点的出点, 就做完了.</p><p>[trick] 黑白染色, 相邻匹配不是很典吗&#x2F;fn</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><h3 id="模拟赛-6"><a href="#模拟赛-6" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A-6"><a href="#A-6" class="headerlink" title="A"></a>A</h4><p>手玩小样例注意到 $k&#x3D;2^{n-1}$.</p><p>考虑在 $n$ 的基础上获得 $n+1$ 的答案, 则把 $2^{n-1}$’个图每个复制一份获得 $2^n$ 个, 而 $n+1$ 这个点和其他点的连边方式有 $2^n$ 种, 只要保证由同一个方案复制得到的两个图对应的 $n+1$ 连边方案互补.</p><p>还有什么神奇方法, 打表发现存在一组解是所有完全二分图.</p><h4 id="B-6"><a href="#B-6" class="headerlink" title="B"></a>B</h4><p>注意到每次用循环移位的把最小值移动到第一位复杂度是调和级数的 $\ln n$, 且期望在 $1$ 左右, 于是随机一个排列 $p$, 先把初始排列变到 $p$ 再变到正确的就期望对了.</p><p>另一种做法是固定所有 $p_i&#x3D;i$ 的位置移动其他的, 期望也不到 $1$, 也用上面的做法.</p><p>正解是类似对值域分治, 但要把同一分治层内所有区间一起做, 则现在问题就是有 $2^k$ 个 $\dfrac{n}{2^k}$ 的区间, 每个区间内有一半 $0$ 和一半 $1$, 要把这些 $1$ 弄到后面, 此时只要每次选中每一段第一个数和其中所有的 $1$ 进行移动, 可以用 $\dfrac{n}{2^{k+1}}$ 次操作.</p><h4 id="C-6"><a href="#C-6" class="headerlink" title="C"></a>C</h4><p>注意到进行下面的操作可以把两个环上的 $0$ 和 $1$ 交换(位置并非不变, 但所在环是对的). 就做完了.</p><p>$\texttt{xxx1xxx}, \texttt{yyy0yyy}\to\texttt{yyyxxx}, \texttt{yyy0xxx1}\to\texttt{0xxxxxx}, \texttt{yyyyyy1}$</p><h3 id="杂题选讲"><a href="#杂题选讲" class="headerlink" title="杂题选讲"></a>杂题选讲</h3><h4 id="WF2021-E"><a href="#WF2021-E" class="headerlink" title="WF2021 E"></a>WF2021 E</h4><p>考虑Bob和Alice的策略不是你能想到的, 应该是Alice和Bob约定Bob的每一种局面Bob应该猜几. 而发现每种颜色在局面是独立的, 所以得到答案是</p><p>$$<br>\sum_ \dfrac{1}{\binom{n}{k}}\min{\sum_i \binom{c_i}{a_i}, \sum_i \binom{c_i}{a_i-1}\prod_j\binom{c_j}{a_j}}<br>$$</p><h4 id="CCPC-FInal-2023-B-Periodic-Sequence"><a href="#CCPC-FInal-2023-B-Periodic-Sequence" class="headerlink" title="CCPC FInal 2023 B Periodic Sequence"></a>CCPC FInal 2023 B Periodic Sequence</h4><p>注意不到, 任意时刻字符串一定形如 $s_{1\ldots k} + s_{1\ldots a_1} + s_{1\ldots a_2} + \ldots + s_{1\ldots a_m}$, 其中 $s$ 为第一次的字符串(一定长 $n$, )$\forall i, a_i\le k$.</p><p>于是直接开始数数:</p><p>$$<br>[x^n]\dfrac{1}{1-x} \sum_{k&#x3D;1}^n \dfrac{x^k}{1-\dfrac{1-x^{k+1}}{1-x}}&#x3D;[x^n]\sum_k \dfrac{x^k}{1-2x+x^{k+1}}<br>$$</p><p>todo</p><h4 id="CF1456E"><a href="#CF1456E" class="headerlink" title="CF1456E"></a>CF1456E</h4><p>考虑一个点没有上下界, 那么它应该和前面的一样. 将连续的这些点合并, 就只要管不同的位置, 则从高到低dp, 逐渐会有点没有上&#x2F;下界限制, 于是设 $f_{k, l, r}$ 表示从高位开始dp到第 $k$ 位, 当前扩展到 $[l, r]$, $[l, r]$ 有限制, 从高位往低位转移就对了.</p><h4 id="CF1270I-Xor-on-Figures"><a href="#CF1270I-Xor-on-Figures" class="headerlink" title="CF1270I Xor on Figures"></a>CF1270I Xor on Figures</h4><p>这个题很像GDKOI 染色. (南外省选集训NOI模拟赛27 B)</p><p>考虑现在一个点 $(p, q)$ 操作一次是给所有 $(p+x_i, q+y_i)$ 翻转, 那么在所有 $p+x_i, q+y_i$ 再操作一次, 注意到此时所有 $(p_x+x_i+x_j, p_y+y_i+y_j)&#x3D;(p_x+x_j+x_i, p_y+y_j+y_i)$ 都消了, 相当于进行 $(p_x+2x_i, p_y+2y_i)$ 的操作, 于是每次乘 $2$ 的操作, 则到 $p_x+2^kx_i, p_y+2^ky_i$ 的时候就只操作单点, 就构造出来了方案.</p><h4 id="CF1276E-Four-Stones"><a href="#CF1276E-Four-Stones" class="headerlink" title="CF1276E Four Stones"></a>CF1276E Four Stones</h4><p>考虑这么跳的时候, $3$ 块石头之间的间距的 $\gcd$ 应该不会变, 且考虑过程是可逆的, 只需要实现把间距变成 $\gcd$ 操作再变回去.</p><p>设三个间距分别为 $d_1, d_2, d_3$ 设 $d&#x3D;d_1+d_12+d_3+d_4$, 若 $d_1\in [\dfrac{d}{4}, d-\dfrac{d}{4}]$ 则发现把第一个点关于第二个点对称至少可以让 $d\gets \dfrac{3d}{4}$, 只要做到这件事.</p><p>那么不满足条件要么是 $d_1, d_3$ 都很小 $d_2$ 很大, 要么是 $d_1, d_2$ 很小 $d_3$ 很大, 则只要倍增的缩小, 对于第一种把 $1$ 号点关于 $3, 4$ 号点各对称一次就能把一边变大另一边的 $2$ 倍, 第二种把 $1, 2, 3$ 不断用最远的点离最近的点对称就对了.</p><p>然后需要支持把这样的一个东西平移一个距离, 只要再支持把每个点之间距离各变大一倍, 然后倍增着跳就对了.</p><h2 id="Day5-1"><a href="#Day5-1" class="headerlink" title="Day5"></a>Day5</h2><h3 id="模拟赛-7"><a href="#模拟赛-7" class="headerlink" title="模拟赛"></a>模拟赛</h3><p>怎么又搬一遍一轮D1T1 fib.</p><h4 id="B-7"><a href="#B-7" class="headerlink" title="B"></a>B</h4><p>看懂了0</p><blockquote><p><img src="/img/2024-05-09-21-42-14-image.png" alt="图 0">  </p></blockquote><h4 id="C-7"><a href="#C-7" class="headerlink" title="C"></a>C</h4><p>这个东西很像endpos集合啊, 所以反过来建SAM考虑贡献, 发现同一等价类的直接贡献就做完了, 对于后缀树上不同的两个等价类 $a, b$, 其endpos分别为 $E_a, E_b$, $a$ 是 $b$ 的祖先, $E_a\mathrm{xor} E_b$ 的集合是 $E_a$ 的一个前缀, 且其设中最小的元素 $p$, 则 $(a, b)$ 贡献 $\max(0, len_b-p)$.</p><p>但直接做贡献点对是 $n^2$ 量级的, 考虑对每个等价类 $a$, $E_a$ 删去前若干元素后得到 $E_b$ 则连边 $a\to b$, 则构成一个以空集为根的内向树 $T$, 发现一个点对自己每个子树的贡献是相同的(因为 $p$ 是 $E_a$ 中 $mn_b&#x3D;\min_{i\in E_b} i$ 的前驱, 之和 $p$ 有关), 于是只要想怎么在SAM找到每个点会连向谁.</p><p>考虑对于点 $u$, 连向 $u$ 的一定是一个到根链上的区间, 其中每个点 $v$ 满足不存在 $u$ 子树外的endpos $&gt;mn_u$, 这个可以倍增&#x2F;单调栈上二分得到最高的区间, 但问题是覆盖一个点的所有这些区间中 $mn$ 最小的才是它 $T$ 上的父亲, 于是用并查集支持修改即可.</p><p>比较震撼的是, 这种东西可以用SA做, 先做SA考虑对Height建笛卡尔树然后从小到大合并的时候考虑状态. 不过好像要写7k(比我上面那玩意还长).</p><p>然后实际上上面不需要显示建树 $T$, 直接在原后缀树上考虑就行, 而且新树上一条祖孙链在原树上对应一个区间, 可以大大降低码量.</p><p>复杂度都是单log.</p><h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><p>官方题解:</p><blockquote><p>考虑将 $nm$ 球标号为 $1$ 到 $nm$, 如果我们能把球按标号排序的话, 最后把答案调整到每根柱子同色就很简单了. 先考虑将第 $i$ 根柱子的球的集合变成 $[(i - 1) \cdot m + 1, i \cdot m]$. 考虑冒泡排序, 我们需要做的就是考虑相邻两根柱子, 将小的一半放到左边, 大的一半放在右边. 此时可以把小的看成白色, 大的看成黑色. 此时我们可以把两根空柱子挪到这两根旁边. 然后从上向下扫描这两根柱子, 把白色的扔左边, 黑色的扔右边. 会出现问题的情况是左边第一个是黑色, 右边第一个是白色. 此时需要交换两根柱子(交换两根柱子的情况可以自行思考一下, 在此不多做描述). 下面考虑将一根柱子排序, 由于有两根空柱子, 考虑基数排序, 每次将二进制为 $0$ 的放右边, 为 $1$ 的放左边即可. 需要注意的是移动空柱子时原来柱子上的球会 reverse, 在排序的时候需要考虑一下这种情况.</p></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="SCOI2014-方伯伯的玉米田"><a href="#SCOI2014-方伯伯的玉米田" class="headerlink" title="SCOI2014 方伯伯的玉米田"></a>SCOI2014 方伯伯的玉米田</h4><p>显然一个dp. 然后数据结构优化一下做完了.</p><h4 id="出处不明题"><a href="#出处不明题" class="headerlink" title="出处不明题"></a>出处不明题</h4><blockquote><p><img src="/img/2024-05-09-21-42-39-image.png" alt="图 1">  </p><p>$n, m\le 10^5$</p></blockquote><p>这种玩意肯定得离线把时间维加进去, 则相当于找一个时间递增的路径 $t_1\ldots t_k$, 于是考虑点分治, 若再时刻 $T$ 询问颜色 $c$, 就要求点 $c$ 到分治中心 $rt$ 的最早时间 $st_c$, 和从 $rt$ 开始, 值在 $[st_c, T]$ 的递增路径到达的点的数量.</p><p>对第一部分, 每个点记录 $f_{u, i}$ 表示从从第 $i$ 次让 $u$ 和父亲 $fa_u$ 交换情报开始 $u$ 最早能走到根的时间即可转移(去父亲那查一下后继).</p><p>对于第二部分, 扫描 $T$, 维护 $f_x$ 表示 $rt$ 最晚从 $f_x$ 开始能走到 $x$(从 $T$ 时刻出发逆着时间走的最短时间), 用第二种视角发现又容易转移了. 然后用BIT支持查 $f$ 大于某值的即可.</p><h4 id="CF1408H-Rainbow-Triples"><a href="#CF1408H-Rainbow-Triples" class="headerlink" title="CF1408H Rainbow Triples"></a>CF1408H Rainbow Triples</h4><p>二分答案 $k$, 则 $0$ 一定是最左边 $k$ 个 $0$ 和最右边 $k$ 个 $0$ 匹配, 而且包含不如交叉, 则一定是从左到右依次匹配, 于是直接确定了 $k$ 个区间去和区间内的非 $0$ 点二分图匹配. 于是上Hall定理, 此时要求 区间并颜色数 减 区间数 的最小值, 考虑这些区间的结构, 显然你选的区间的左端点在所有区间的左端点集合的rank构成一个区间(就是选一段左端点 “连续” 的区间), 于是直接扫描线, 扫描线维护颜色数是广为人知的.</p><p>现在复杂度是 $n\log^2 n$, 发现你的二分什么也不做, 实际上选择从 $l$ 到第 $r$ 个区间左端点对应的区间的限制是若 $k\ge \max(i, j)$, 则有一个答案最大值限制, 于是去掉二分复杂度单log.</p><h4 id="GYM102586A"><a href="#GYM102586A" class="headerlink" title="GYM102586A"></a>GYM102586A</h4><p>qyc的分析收录在ds</p><h4 id="P6256-ICPC2019-WF-Directing-Rainfall"><a href="#P6256-ICPC2019-WF-Directing-Rainfall" class="headerlink" title="P6256 [ICPC2019 WF] Directing Rainfall"></a>P6256 [ICPC2019 WF] Directing Rainfall</h4><p>容易找到一种拓扑序, 使得不存在后面的板子上的水落到前面上的, 这个直接set+扫描线.</p><p>然后就dp, $f_{i, j}$ 表示后 $i$ 个线段, 其中第 $i$ 个线段在第 $j$ 个区间下落的答案, 转移是区间加 $1$ 和做前&#x2F;后缀min, 考虑这玩意有均摊: 对于一个区间求一次前缀min再求一次后缀min就一样了, 所以Segment Tree Beats, 每个区间记录当前是否是单调增&#x2F;减, 然后对一个已经有序的区间操作时可以转化成一次区间赋值, 对无序的区间, 假设是取前缀min, 从左到右每次二分出下一个前缀min转化成区间赋值.</p><p>分析复杂度, 取势能是前缀min&#x2F;max个数的最大值, 每次可以用 $\log n$ 的代价消去一个, 同时一次修改会最多令 $O(\log n)$ 个区间增加 $O(1)$ 个, 所以总复杂度是 $n\log^2 n$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>省队集训</title>
      <link href="/2024/04/28/sdptt1/"/>
      <url>/2024/04/28/sdptt1/</url>
      
        <content type="html"><![CDATA[<h1 id="一轮省集"><a href="#一轮省集" class="headerlink" title="一轮省集"></a>一轮省集</h1><h2 id="Day1-2"><a href="#Day1-2" class="headerlink" title="Day1, 2"></a>Day1, 2</h2><h3 id="模拟赛"><a href="#模拟赛" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="fibonacci串"><a href="#fibonacci串" class="headerlink" title="fibonacci串"></a>fibonacci串</h4><blockquote><p><img src="/img/2024-04-28-07-53-17-image.png" alt="picture 0">  </p><p>$n&#x3D;\vert t\vert\le 1. 5\times 10^5$</p></blockquote><p>首先考虑不存在连续三个字符相同, 答案长度是 $O(n)$ 的. 再考虑超过 $\vert s\vert$ 超过答案长度后后面的都是重复, 所以合理的 $\vert s\vert$ 也是 $O(n)$ 的.</p><p>对斐波那契串这个递归结构应该想到建树, 对 $s_n$ 中间切一刀连向两个子节点, 树高是 $\log n$ 的, 于是像线段树一样任意一个区间可以拆成 $\log n$ 个完整的 $s_k$ 相拼</p><p>考虑枚举起点的话, 我们需要能 $\log n$ 找到对应终点, 也就是 $O(1)$ 跳一个完整的 $s_k$, 则预处理 $f_{i, j}$ 表示从 $t_j$ 开始完整匹配过一个 $s_i$ 能匹配多少即可.</p><p>复杂度 $n\log n$</p><h4 id="水龙头"><a href="#水龙头" class="headerlink" title="水龙头"></a>水龙头</h4><blockquote><p><img src="/img/2024-04-28-07-59-38-image.png" alt="picture 1">  </p><p>$n\le 5\times 10^5$</p></blockquote><p>考虑期望的线性性, 则期望值是每个水龙头被打开的概率和. 另外容易想到建图, 每个点向两个下方的点连边.</p><p>则一个点被打开当且仅当自己在所有前驱之前, 概率显然, 只要建图.</p><p>从下往上扫描线随便做吧!</p><h4 id="多边形"><a href="#多边形" class="headerlink" title="多边形"></a>多边形</h4><blockquote><p><img src="/img/2024-04-28-08-04-47-image.png" alt="picture 2">  </p><p>$n\le 5\times 10^5, a_i\le 50$</p></blockquote><p>也就是对每个数求大于剩下所有数的概率. 注意不到 $x_i$ 和 $2^a_i-x_i$ 分布相同所以相当于所有数和超过 $x_i$ 的概率.</p><p>并且实数实在太难了, 考虑拆成 $x_i&#x3D;y_i+z_i$, $y_i\in[0, 1], z_i\in [0, 2^{a_i}-1]\cap Z$, 对于实数的部分要求它大于 $k$ 的概率, 只能积分, 考虑:</p><p>$$<br>\begin{gathered}<br>    \int^1_0\int^1_0\ldots \int^1_0[\sum_t z_t\le k]dz_1dz_2\ldots dz_n\<br>    &#x3D;\int\int\ldots \int[\sum_t z_t\le k]\prod_t ([z_t\ge 0]-[z_t\ge 1])dz_1dz_2\ldots dz_n\<br>    &#x3D;\sum_i (-1)^i \binom{n}{i} \dfrac{(k-i)^n}{n! }<br>\end{gathered}<br>$$</p><p>对于整数部分就很熟悉了, 如果直接求的话要卷 $(1-x^a_i)$ 复杂度是 $na\log^2 n$, 考虑因为所有数都是 $2^k-1$ 要求值的点都是 $2^k$, 可以拆位卷, 则复杂度变成 $na\log n$, 做完了.</p><p>[trick] 实数拆成小数部分和整数部分</p><p>[trick] 容斥积分&#x2F;求和边界.</p><h4 id="反转了"><a href="#反转了" class="headerlink" title="反转了"></a>反转了</h4><blockquote><p><img src="/img/2024-04-28-09-51-08-image.png" alt="picture 5">  </p><p>$n\le 2\times 10^5, \vert a_i\vert \le 10^9$</p></blockquote><p>显然对于某个前缀最优方案是反转负数前 $k$ 小, 容易发现最优前缀随 $k$ 递增, 于是分治决策单调性加数据结构支持单 $log$ 前 $k$ 大就做完了.</p><h4 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h4><blockquote><p><img src="/img/2024-04-28-17-17-24-image.png" alt="picture 8">  </p><p>$\vert S\vert \le 10^5, T\le 20$</p></blockquote><p>考虑相当于一个括号串. 那么如果最后能成功 $k$ 轮, 取走 $4k$ 个括号, 发现Bob总是取最前最后的, 而Alice要取最好括号串是匹配的, 所以相当于只看最前的 $2k$ 个左括号和最后 $2k$ 个右括号组成的串, 看是否能全取完.</p><p>注意到这件事后剩下的容易了, 二分答案, 只要取成不匹配的括号串, 就要尽量减前缀和, Bob总是取最前最后的, 而Alice就要做到保证Bob取的时候总是只有一个根, 则统计每个点子树外的点个数和深度判断即可. 复杂度 $n\log n$</p><h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><blockquote><p><img src="/img/2024-04-28-18-30-45-image.png" alt="picture 9">  </p><p>$n\le 10^6, k\le 60, x\le 2^k$</p></blockquote><p>考虑大多数情况下自己一段是很优的.</p><p>如果 $X&#x3D;0$, 显然段数就是非 $0$ 数个数, 简单题.</p><p>否则数分成 $0&#x2F;X&#x2F;\text{Other}$ 三类, 称非 $0, X$ 的数为好的.</p><p>则关注极长的不好的段, 此时只有两种分配方式: 第一个 $X$ 向左匹配一个好的数, 或者第一个 $X$ 向右匹配下一个 $X$, 若做前缀异或和, 分别对应了在所有前缀和为 $X$ 的位置断和在所有前缀和为 $0$ 的位置断.</p><p>类似 鸡 那个题, 拆贡献, 好的段的贡献直接算, 当它在前&#x2F;后缀的时候直接算, 在中间时, 长 $l$ 的段的期望应该是先乘上这一段每个数都不好的概率, 然后直接考虑前缀和(也是每一位 $0&#x2F;X$ 等概率), 考虑其中 $0&#x2F;1$ 多的情况下的期望, 简单组合算即可.</p><p>复杂度线性.</p><h3 id="课"><a href="#课" class="headerlink" title="课"></a>课</h3><h4 id="ICPC-Jinan-2023-B"><a href="#ICPC-Jinan-2023-B" class="headerlink" title="ICPC Jinan 2023 B"></a>ICPC Jinan 2023 B</h4><blockquote><p><img src="/img/2024-04-28-08-49-52-image.png" alt="picture 3">  </p></blockquote><p>直接dp, $f_{u, i}$ 表示 $u$ 的子树分完, 包含 $u$ 的一块大小为 $i$ 的方案数, 转移就是直接卷加点单点改.</p><p>当 $k\le \sqrt n$ 复杂度显然 $nk$, 当 $k\ge \sqrt n$ 则一个子树只能分 $t\le n&#x2F;k$ 个大小为 $k$ 的块, 此时 $i&#x3D;(siz-t)\bmod (k+1)$, 所以本质不同只有 $\sqrt n$ 个, 复杂度也是 $n\sqrt n$.</p><h4 id="ECFinal-2023-C"><a href="#ECFinal-2023-C" class="headerlink" title="ECFinal 2023 C"></a>ECFinal 2023 C</h4><blockquote><p><img src="/img/2024-04-28-08-52-08-image.png" alt="picture 4">  </p></blockquote><p>todo</p><h4 id="ARC168E-Subsegments-with-Large-Sums"><a href="#ARC168E-Subsegments-with-Large-Sums" class="headerlink" title="[ARC168E] Subsegments with Large Sums"></a>[ARC168E] Subsegments with Large Sums</h4><p>显然直接wqs是没凸性的, 想到判定.</p><p>考虑把划分转成选出不交的 $x$ 段, 要求没选的位置个数不小于 $k-x$, 即选一段支付 $r-l$ 代价, 要求总代价小于 $n-k$, 此时容易直接wqs二分+dp了.</p><p>[trick] 把划分段, 每个段贡献 $0&#x2F;1$ 变成选出有贡献的段.</p><h4 id="ABC311Ex-Many-Illumination-Plans"><a href="#ABC311Ex-Many-Illumination-Plans" class="headerlink" title="[ABC311Ex] Many Illumination Plans"></a>[ABC311Ex] Many Illumination Plans</h4><p>暴力dp肯定是 $f_{u, i, 0&#x2F;1}$ 表示 $u$ 子树内, 重量是 $i$, 外面选的颜色是 $0&#x2F;1$ 的最大权值, 复杂度是 $nX^2$ 的. 显然爆炸了. 不能出现背包合并.</p><p>考虑从上往下加点, 先只考虑求全局答案, 代码写出来是</p><p><img src="/img/2024-04-28-12-02-10-image.png" alt="picture 6">  </p><p>即我们带着dp数组往下走, 当遍历到 $u$ 时里面存储着dfs序在它之前的点和子树中的点的信息, 最后加入自己, 此时复杂度是 $X2^n$ 级别的, 因为重复访问了两次儿子.</p><p>考虑轻重剖分先遍历重儿子, 则它只被遍历了一次, 复杂度降为 $n^{\log_2 3}X$.</p><p>对于所有子树, 只要对每个重链分别跑, 复杂度不变.</p><h4 id="CF1874F-Jellyfish-and-OEIS"><a href="#CF1874F-Jellyfish-and-OEIS" class="headerlink" title="CF1874F Jellyfish and OEIS"></a>CF1874F Jellyfish and OEIS</h4><p>考虑对可能不合法的 $\sum_i m_i-i+1$ 个区间容斥, 发现如果钦点了两个相交区间 $l_1&lt;l_2\le r_1&lt; r_2$, 其和择 $[l_1, l_2-1], [l_2, r_1], [r_1+1, r_2]$ 的效果是一样的, 则可以构造双射, 若存在相交区间, 则切换 $[l_1, l_2-1]$ 是否存在即可系数相消.</p><p>现在只要考虑钦点完之后区间不交的情况, 则可以表示成树状(添加一个 $[1, n]$), 显然方案数是树上每个点不被子节点覆盖的位置数的阶乘再乘起来, 于是考虑dp: $f_{l, r}$ 表示以 $[l, r]$ 区间为根下带容斥系数的方案数, $g_{l, r, i}$ 表示根完全被 $[l, r]$ 的森林, 且森林外有 $i$ 个散点的方案数来辅助 $f$ 的转移, 则 $g_{l, r, i}\to g_{l, r+1, i+1}, g_{l, r, i}f_{r+1, r+k}\to g_{l, r+k, i}, g_{l, r, i}i! \to f_{l, r}$, 复杂度 $n^4$.</p><p>[trick] 构造双射容斥系数相消</p><h4 id="AGC066D-A-Independent-Set"><a href="#AGC066D-A-Independent-Set" class="headerlink" title="[AGC066D] A Independent Set"></a>[AGC066D] A Independent Set</h4><p>考虑最终的串, 一定是若干个 $AB$ 交替段加上若干个 $B$ 段, 在最后添加一个没有影响的 $B$ 可以使得交替串都是 $AB$ 重复得到. 同时容易发现 $B$ 串一定不参与交换.</p><p>则考虑dp, 设最小代价为 $f_i$, 则若 $[j, i]$ 中 $A, B$ 数量相等可以把它变成一个 $AB$ 交替串, 如果只有 $B$ 可以作为一个全 $B$ 串.</p><p>发现若 $[j, i]$ 可以拆成 $[j, k], [k, i]$ 分布满足 $AB$ 数量相等, 则这么转移没什么坏处, 于是转移其实是有 $O(n)$ 个的.</p><p>于是要计算 $w_{l, r}$ 表示把区间 $[l, r]$ 变成 $AB$ 交替的代价, 因为不存在某个位置使得其能拆分成两个, 所以对于任意不是本身的前缀都有 $A$ 的数量减 $B$ 的数量恒大于&#x2F;小于 $0$, 可以说明所有的 $A$ 一定都往左&#x2F;都往右跑, 于是前缀和简单计算.</p><p>复杂度线性.</p><p>[trick] 考虑最优串状态</p><p>[trick] 对转移拆分</p><h4 id="CF1930G-Prefix-Max-Set-Counting"><a href="#CF1930G-Prefix-Max-Set-Counting" class="headerlink" title="CF1930G Prefix Max Set Counting"></a>CF1930G Prefix Max Set Counting</h4><p>考虑重复走过一个点没有影响, 不妨让它可以重复随便走.</p><p>于是状态为 $f_u$ 表示走到 $u$ 且 $u$ 是走过的点中最大值的方案数, 每次若子树内有比自己大的点必须往下走, 否则向上走到第一个点满足其子树内有比 $u$ 大的再向下走. 直接dp, 则向下走的转移是子树加单点查.</p><p>但这样会算重, 因为对于从上到下的祖孙链 $u\to v\to w$, 从 $u$ 转移到 $w$ 和从 $v$ 转移到 $w$ 是重复的, 即我们要求向下走过一次的不允许接着往下转移. 也就是按照上面的走法, 第一次从根到某个点, 后面都是先上后下的转移.    </p><h4 id="Qoj5312-Icpc-Hangzhou-2022-L-Levenshtein-Distance"><a href="#Qoj5312-Icpc-Hangzhou-2022-L-Levenshtein-Distance" class="headerlink" title="Qoj5312 Icpc Hangzhou 2022 L. Levenshtein Distance"></a>Qoj5312 Icpc Hangzhou 2022 L. Levenshtein Distance</h4><p>先考虑怎么求这个距离, $f_{i, j}$ 表示让 $s$ 前 $i$ 个和 $t$ 前 $j$ 个相同的最小代价, 可以转移, 复杂度 $30n$. 看一下各维度大小想到交换值域和状态, 于是 $f_{i, j}$ 表示用 $i$ 代价使得最大的 $p$ 满足 $s_{1\ldots p}&#x3D;t_{1\ldots p+j}$, 此时状态是 $k^2$ 的, 而每次转移就是当前位置进行一个修改然后求两个后缀的lcp, 用SA可以 $O(1)$, 最后对每个后缀跑上面这个东西复杂度 $O(nk^2)$</p><h4 id="PKUWC-2024-Day1-T2"><a href="#PKUWC-2024-Day1-T2" class="headerlink" title="PKUWC 2024 Day1 T2"></a>PKUWC 2024 Day1 T2</h4><blockquote><p><img src="/img/2024-04-28-15-44-04-image.png" alt="picture 7">  </p></blockquote><p>注意 $d$ 是不包含自身的.</p><p>一个比较显然的策略: 先找到最小值, 可以直接算出它的值, 然后给所有边同时减去最小值, 此时没有跨过最小值的贡献, 有了递归结构. 但不知道最小值所以考虑dp:</p><p>$f_{l, r, v}$ 表示区间 $[l, r]$ 整体减去 $v$ 是否可行, 转移要枚举最小值位置和值. 此时状态 $n^2V$ 复杂度 $n^3V^2$.</p><p>注意到若 $f_{l, r, v}$ 可行, 那么 $f_{l, r, v-k(r-l)}$ 一定可行(相当于每个元素加 $1$), 于是 $f_{l, r, v}$ 表示模 $r-l$ 意义下减去 $v$ 的话最大的 $v$, 同余最短路转移, 复杂度变成 $n^5$, 可以通过.</p><h4 id="Qoj-7905-Icpc-Jinan-2023-L-Ticket-to-Ride"><a href="#Qoj-7905-Icpc-Jinan-2023-L-Ticket-to-Ride" class="headerlink" title="Qoj. 7905 Icpc Jinan 2023 L. Ticket to Ride"></a>Qoj. 7905 Icpc Jinan 2023 L. Ticket to Ride</h4><p>首先想到简单的dp: $f_{i, j}$ 表示只考虑前 $i$ 个线段, 涂红 $j$ 个的答案, 转移是要么 $f_{i, j}&#x3D;f_{i-1, j}$, 要么 $f_{i, j}&#x3D;f_{i-k-1, j-k}+w(i-k+1, i)$, $w(l, r)$ 表示被 $[l, r]$ 包含的区间的权值和, 现在的状态不太好, 转移时第二维会被影响, 不如第二维改成 $i-j$, 容易用线段树优化, 要求做到: 前缀加, 在最后单点改, 全局max.</p><p>那么真的用线段树吗? 要注意到操作的特殊性, 前面的若比后面的大后面的就没用了, 于是并查集维护所有前缀max, 每次前缀加的时候把后面的合并到前面即可. 复杂度 $nq\alpha(n)$.</p><h4 id="P8294-省选联考-2022-最大权独立集问题"><a href="#P8294-省选联考-2022-最大权独立集问题" class="headerlink" title="P8294 [省选联考 2022] 最大权独立集问题"></a>P8294 [省选联考 2022] 最大权独立集问题</h4><p>todo</p><h4 id="UOJ840-龙门考古"><a href="#UOJ840-龙门考古" class="headerlink" title="UOJ840. 龙门考古"></a>UOJ840. 龙门考古</h4><p>考虑如果已知不确定的位置怎么求 $b$, 则 $c_i&#x3D;0$ 相当于没有限制, $c_i&#x3D;1$ 相当于 $b_i\ge \max_{j\in [1, nxt_i-1]}$, 其中 $nxt_i$ 表示下一个 $c_k&#x3D;1$ 的位置 $k$.</p><p>考虑对于 $c_i&#x3D;0$ 的位置, 不可辨认的位置一定是递增的, 如果所有 $c_i&#x3D;1$ 都是可辨认的则这是充要的.</p><p>对于 $c_i&#x3D;1$ 的位置, 考虑其什么时候可以不可辨认, 此时一定有不存在不可辨认的位置 $j$, $j&gt;i, b_j&lt;b_i$ 且交换 $i, j$ 后符合限制, 设 $s_i$ 为 $[1, nxt_i-1]$ 的次大值, 即 $s_i\lt b_j\lt b_i, j\gt nxt_i$ 的 $j$ 必须可以辨认. 发现这个条件是充分的.</p><p>此时问题变成了每个 $c_i&#x3D;0$ 的位置可以选择是否可辨认, 若所有满足 $b_j\in [s_i, b_i]$ 的 $j$ 都可以辨认则 $i$ 可以不可辨认(贡献 $\times 2$)(若 $b_j&gt;s_i, i\ne j$, 则 $j&gt;nxt_i$).</p><p>于是对 $c_i&#x3D;0$ 的部分dp, 设 $f_i$ 表示以 $i$ 结尾的前缀, $i$ 可辨认的方案数, 则 $f_i2^{w(b_i, b_j)}\to f_j$ 当且仅当 $b_i&lt;b_j$. 其中 $w(l, r)$ 表示有多少个区间 $[s_i, b_i]$ 被 $[l, r]$ 包含.</p><p>注意到 $[s_i, b_i]$ 互不包含, 用BIT优化到 $n\log n$</p><h4 id="UOJ823-UR-26-铁轨回收"><a href="#UOJ823-UR-26-铁轨回收" class="headerlink" title="UOJ823. [UR #26]铁轨回收"></a>UOJ823. [UR #26]铁轨回收</h4><p>用 $A_i’$ 表示原始 $A_i$, $A_i$ 表示当前 $A_i$.</p><p>考虑对 $B_n\le 4$ 的部分分可以直接从前往后dp, 记录数组 $c$ 表示后面被加了 $j$ 的数有 $c_j$ 个, 转移时考虑自己会是几, 再加到后面去(也就是把考虑自己是几的方案数这件事延迟到后面计算了).</p><p>考虑容斥, 把 $A_i&#x3D;B_i$ 的位置容斥成总方案数减去 $A_i&lt;B_i$ 的方案数计算.</p><p>于是设 $f_{i, S, j}$ 表示考虑后 $i$ 个点中, 需要被加的 $A$ 的集合为 $S$, 且有 $j$ 个点被钦定计算总方案数, 考虑第 $i$ 个点转移:</p><ul><li>$i$ 被加到 $j$ 个点中, 则 $j\to j+1$.</li><li>$A_i&#x3D;B_i$, 加上总方案数贡献, 则 $k\to k+1$, 并把 $S$ 中一个元素减去 $B_i$</li><li>$A_i&#x3D;B_i$, 减去其他贡献, 则 $S$ 中一个元素减去 $B_i$, 加入一个 $t&lt;B_i$ 的 $t-A_i’$</li><li>$A_i&lt;B_i$ 加入一个 $A_i-A_i’$</li></ul><p>重点是过程中 $S$ 的和单调不升, 一开始和为 $B$, 所以 $S$ 状态数是分拆数级别的, $i, j$ 是 $O(n)$ 的.</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="模拟赛-1"><a href="#模拟赛-1" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A"><a href="#A" class="headerlink" title="A"></a>A</h4><p>考虑对出边邻接矩阵 $M$, 定义矩阵 $A_{ij}&#x3D;M_{ij}x^i$, 则 $\mathrm{tr} \dfrac{A^l}{l}$ 统计了所有长 $l$ 的环. 于是所有的环就是</p><p>$$<br>\mathrm{tr} \sum_i \dfrac{A^i}{i}<br>$$</p><p>我们进行容斥, 钦定一些环存在, 剩下的点随便连, 则要求没有偶环, 有 $k$ 个奇环的方案贡献 $2^k$, 则偶环容斥系数为 $-1$, 奇环系数为 $1$(这 $k$ 个奇环每个选&#x2F;不选都贡献 $1$, 共 $2^k$ 种). 此时环的贡献应<br>该是</p><p>$$<br>\mathrm{tr}\sum_i \dfrac{A^i}{i}(-1)^{i+1}&#x3D;\mathrm{tr}\ln (I+A)<br>$$</p><p>已知 $\exp \mathrm{tr}\ln M&#x3D;\det M$ 下面类比矩阵树定理推导, 所求即为:</p><p>$$<br>\begin{gathered}<br>    [x_1x_2\ldots x_n]\prod_i(1+deg_ix_i) \exp \mathrm{tr}\ln(I+A)\<br>    &#x3D;[x_1x_2\ldots x_n]\prod_i(1+deg_ix_i) \det(I+A)\<br>    &#x3D;[x_1x_2\ldots x_n]\det{((1+deg_ix_i)([i&#x3D;j]+M_{i, j}x_i))<em>{i, j}}\<br>    &#x3D;\det{([i&#x3D;j]deg_i+M</em>{i, j})_{i, j}}\<br>\end{gathered}<br>$$</p><h4 id="B"><a href="#B" class="headerlink" title="B"></a>B</h4><p>注意到 $A&#x3D;\begin{bmatrix}1&amp;u\0&amp;1\end{bmatrix}$ 和 $\begin{bmatrix}1&amp;-u\0&amp;1\end{bmatrix}$ 互为逆元, $v$ 的同理设为 $B$ 和 $B^{-1}$.</p><p>则猜测在去掉平凡的 $AA^{-1}BB^{-1}$ 这种情况之后, 也就是对操作序列 $M_1\ldots M_k$ 来说 $M_iM_{i+1}\ne I$ 的情况下, 不同的 $M$ 得到的结果不同.</p><p>如果这个是对的就很简单了, 可以看成是一个四元环形状的自动机上走, 数据范围一眼常系数线性递推, 推GF然后求就行了.</p><p>但是这个结论怎么证啊! 发现上面不同的 $M$ 得到的结果不同 等价于 有所有 $M$ 序列生成的矩阵组成的群 $G$ 是自由群, 或者说 $G$ 是 $A$ 和 $B$ 的自由积. 并有一个判定自由积的乒乓引理:<strong>设群 $G$ 作用在集合 $X$ 上, $H_1, H_2$ 是 $G$ 的非平凡子群, $H$ 是 $H_1, H_2$ 生成的群, 若 $X$ 有两个不交的非空子集 $X_1, X_2$ 使得 $\forall 1\ne a\in H_1, a(X_2)\subset X_1$ 且 $\forall 1\ne b\in H_2, b(X_1)\subset X_2$, 则有 $H$ 是 $H_1, H_2$ 的自由积</strong>. (看起来就像 $H_1, H_2$ 把元素从 $X_1, X_2$ 打到对面去, 所以乒乓)</p><p>然后解释一下(自己体会的), 自由群的概念是存在子群 $S$ 对所有元素有唯一的极简生成路径(就是去掉 $AA^{-1}$ 这种到不能去了). 自由积看起来就是以这两个元素为生成元生成循环群然后它是自由群.</p><p>则对于上面的问题, 把 $A, B$ 作用到 $1\times 2$ 向量 $[a, b]$ 得到 $[a, b+au]$ 和 $[a+bv, b]$, 发现只要让 $X_1, X_2$ 分别对应 ${[a, b]\vert a&gt;b}$ 和 ${[a, b]\vert a&lt;b}$ 即可证明.</p><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><p>恶心玩意</p><p>对于 $k&#x3D;1$ 显然.</p><p>对 $k&#x3D;2$, 若为左右结构就用 $k&#x3D;1$ 的方法求前缀&#x2F;后缀答案再枚举位置合并, 若为上下结构, 考虑建出笛卡尔树, 则一定是选择有祖先关系的两个点 $u, v$($u$ 是 $v$ 祖先), 设两个点的宽度高度(从底部开始)分别为 $w_u, h_u, w_v, h_v$, 则贡献是 $w_uh_u+w_vh_v-w_vh_u$, 一眼斜率优化形式, 于是用李超树合并维护决策从下往上即可.</p><p>对 $k&#x3D;3$ 进行分类, 若为左中右结构又直接线性dp秒了.</p><p>若为<code>凸口</code>形(两个成上下, 合起来再成左右), 则也秒了.</p><p>若为上中下形, 考虑实际上 上 和 下 比较独立, 也就是做两遍即可.</p><p>最后剩下凹形, 考虑 $u$ 子树内两个不为祖孙的点 $x, y$, 最后的式子是 $h_uw_u+w_x(h_x-h_u)+w_y(h_y-h_u)$, 于是对于一组 $x, y$, 我们需要的信息是 $k&#x3D;w_x+w_y$ 和 $b&#x3D;w_xh_x+w_yh_y$, 然后求最大的 $kw_x+b+w_uh_u$, 也就是枚举 $u$ 之后单点求值, 发现求值直线只要保留 $(k, b)$ 为点的情况下凸包上的点(这个是半平面交于凸包对应关系), 而 $(k, b)$ 显然是 $(w_x, w_xh_x)$ 做闵和得到, 所以分别保留凸包再闵和, 可以把没有祖孙限制的做到线性.</p><p>加上限制之后考虑用dfs序表示为子树区间不交, 用线段树结构, 每个点维护 $L, R$ 两个集合, 则对区间 $[l, r]$ 找到线段树上 $r$ 点叶子到根的路径, 若某个点为右儿子则上面插入到集合 $R$ 中, 左边同理, 则自底向上合并 $L, R$ 即可. 每个点被插入 $n\log n$ 次, 总复杂度单log.</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h4 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h4><blockquote><p><img src="/img/2024-04-30-11-14-51-image.png" alt="picture 10">  </p><p>$n\le 3\times 10^7$</p></blockquote><p>考虑要尽量让累加的东西和 $n$ 无关, 再换下形式 $i&#x3D;k-m$, 于是</p><p>$$<br>\sum_k^n \sum_i^k \binom{k}{i}\binom{i}{i&#x2F;2}2^{n-i}<br>$$</p><p>然后我的思路是</p><p>$$<br>\begin{gathered}<br>    &#x3D;\sum_i \binom{i}{i&#x2F;2}2^{n-i}\sum_k\binom{k}{i}\<br>    &#x3D;\sum_i \binom{i}{i&#x2F;2}2^{n-i}\binom{n+1}{i+1}<br>\end{gathered}<br>$$</p><p>可以单独看 $i$ 是偶数&#x2F;奇数再加起来, 这里对偶数, 并且对 $n$ 差分得到 $\binom{n+1}{i+1}-\binom{n}{i+1}&#x3D;\binom{n}{i}$, 只要求 $\binom{i}{i&#x2F;2}2^{n-i}\binom{n}{i}$ 累加</p><p>$$<br>\begin{gathered}<br>    \binom{2i}{i}2^{n-2i}\binom{n}{2i}\<br>    &#x3D;<a href="1+2x">x^n</a>^n\dfrac{1}{\sqrt{1-4x}}<br>\end{gathered}<br>$$</p><p>奇数同理, $\binom{2i+1}{i}$ 的生成函数应该是 $\dfrac{\dfrac{1}{\sqrt{1-4x}}-1}{2x}$</p><p>于是显然微分有限, 求两次前缀和都是乘 $\dfrac{1}{1-x}$ 也微分有限. 然后直接跑高消可以出一个答案的二阶二次递推式.</p><p>但是感觉我们是闲的没事干才推这些, 实际上</p><p>$$<br>\binom{2i}{i}2^{n-2i}\binom{n+1}{2i+1}\<br>$$</p><p>是超几何级数吧!</p><p>复杂度线性.</p><p>但是题解更智慧, 注意到一开始我们不把 $k$ 换出来, 就要 $O(n)$ 的对所有 $k$ 求 $\sum_i^k \binom{k}{i}\binom{i}{i&#x2F;2}2^{k-i}$, 然后这个居然组合意义一下等于 $\binom{2n+1}{n}$ &#x2F;xia&#x2F;xia&#x2F;xia</p><h4 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h4><blockquote><p><img src="/img/2024-04-30-11-15-11-image.png" alt="picture 11"> </p><p>$n\le 3\times 10^5, M\le 200$</p></blockquote><p>列一下生成函数发现二元要拆拉普拉斯变换做不了, 考虑dp.</p><p>于是设 $f_{i, j}$ 表示已经摸出来 $i$ 种球, 其中有 $j$ 种只出过一次, 有</p><p>$$<br>\begin{gathered}<br>f_{i, j}&#x3D;\dfrac{i-j}{n}f_{i, j}+\dfrac{j+1}{n}f_{i, j+1}+\dfrac{n-(i-1)}{n}f_{i-1, j-1}\<br>f_{i, j}&#x3D;\dfrac{n-i+1}{n-i+j}f_{i-1, j-1}+\dfrac{j+1}{n-i+j}f_{i, j+1}<br>\end{gathered}<br>$$<br>复杂度 $n^2+nm$</p><p>然后优化肯定是改成算期望而非概率, 但看到若干次考虑斯特林数拆成二项式, 现在设 $g_{i, m}$ 表示 $\sum_j f_{i, j}\binom{j}{m}$, 求递推式是 $nm$ 的. 做完了</p><h4 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h4><blockquote><p><img src="/img/2024-04-30-11-54-15-image.png" alt="picture 12">  </p><p>$n, Q\le 1. 5\times 10^5$, 3s</p></blockquote><p>todo</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><h3 id="模拟赛-2"><a href="#模拟赛-2" class="headerlink" title="模拟赛"></a>模拟赛</h3><h4 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h4><blockquote><p><img src="/img/2024-04-30-11-59-28-image.png" alt="picture 13">  </p></blockquote><p>简单题, 容易确定出哪些点是 $C&#x2F;D$, 直接染了, 剩下的二分图染色即可.</p><h4 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h4><blockquote><p><img src="/img/2024-04-30-14-50-19-image.png" alt="picture 14">  </p><p>$m\le n\le 100$ 你要保证操作次数少于 $n^3$</p></blockquote><p>群论题.</p><p>相当于用一些循环位移置换构造 $p^{-1}q$, 则考虑位移偶数是一定偶置换, 奇数不一定, 又经过打表发现偶数能成一半奇数都行, 去猜结论.</p><p>开始构造, 对奇数构造相邻交换:</p><h4 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h4><p>容易发现联通块数等于加边时两点都有边的边的数量, 于是容斥成钦定 $i$ 条比相邻的早, 剩下的无所谓的方案数. 这里容斥系数应该是 $(-1)^{i-k}f(n-2k, i-k)$, $f(a, b)$ 表示在 $a$ 个点的完全图中选 $b$ 个不相交的边的方案数. 这个 $f$ 看起来很显然.</p><p>然后计数的话, 这个直接想的话感觉限制是一个DAG做不了(要求与这 $i$ 条边有一个公共点的比它晚, 有两个公共点的比它俩都晚), 但容易发现这 $i$ 条边是对称的, 可以钦定它们之间的顺序, 于是有两个公共点的只要连到两条边中晚的一个, 变成一棵树, 可以做了.</p><p>总复杂度线性.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top Tree</title>
      <link href="/2024/02/17/toptree/"/>
      <url>/2024/02/17/toptree/</url>
      
        <content type="html"><![CDATA[<h1 id="Top-Tree"><a href="#Top-Tree" class="headerlink" title="Top Tree"></a>Top Tree</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIWC</title>
      <link href="/2024/01/30/noiwc2024/"/>
      <url>/2024/01/30/noiwc2024/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIWC2024"><a href="#NOIWC2024" class="headerlink" title="NOIWC2024"></a>NOIWC2024</h1><h2 id="Day1-lxl"><a href="#Day1-lxl" class="headerlink" title="Day1-lxl"></a>Day1-lxl</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>部分持久化, 完全持久化, 可合并的持久化: 只能在最后一个版本改&#x2F;可以在任意版本改&#x2F;可以合并历史版本, 版本之间连有向边分别是链, 树, 图</p><p>离线建操作树可以解决完全持久化</p><p>实现可持久化的三种方式: 路径复制, 肥节点和节点分裂. 设修改和查询次数分别为 $m_1$ 和 $m_2$</p><h4 id="路径复制类似主席树状物"><a href="#路径复制类似主席树状物" class="headerlink" title="路径复制类似主席树状物"></a>路径复制类似主席树状物</h4><p>可以支持可合并的持久化</p><h4 id="肥节点"><a href="#肥节点" class="headerlink" title="肥节点"></a>肥节点</h4><p>对每个节点用可持久化数组记录不同时间的版本, 查询时在这个节点的版本序列上二分, 可以实现部分可持久化, veb可以平衡到 $(m_1, m_2)\log \log m_1$</p><p>对于完全可持久化, 考虑版本树的括号序, 相当于可以插入一对括号和在括号序列上二分, 查询某个版本的值这三个操作, 因为有二分要求插入log查询 $O(1)$, 方法是开重量平衡树(深度 $\log n$, 每次调整 $\log n$ 个点), 每个点维护值域区间, 父亲区间 $[l, r]$ 则两个儿子分别是 $[l, mid]$ 和 $[mid+1, r]$, 另一个点的标号为 $\dfrac{l+r}{2}$, 则修改时修改区间和标号, 查询时只要比较两个点的标号. 平衡树treap&#x2F;替罪羊即可.</p><p>感觉就是如何在不打标记的情况下解决平衡树在有key的情况下动态插入点.</p><p>另一种解决刚才的问题的方案是一个链表, 每次插入元素取前驱后继平均值比较标号, 复杂度 $O(1)-O(1)$, 但是精度要求节点数不超过 $O(w)$, 嵌套 $O(1)$ 层复杂度 $O(w^{O(1)})$, 于是把序列按 $B$ 分块, 块间平衡树块内用刚才链表的方法去一个log.</p><p>感觉还挺问号, 再想想.</p><h4 id="节点分裂"><a href="#节点分裂" class="headerlink" title="节点分裂"></a>节点分裂</h4><p>就是, 一种波尔方式是直接可持久化数组记录所有指针</p><p>然后它每 $w$ 个版本分一块, 每次改边的时候只把边指向对面的节点版本所在块, 每次新增块的时候修改连向当前块的点们, 给它们增加一个修改操作</p><h4 id="可持久化平衡树"><a href="#可持久化平衡树" class="headerlink" title="可持久化平衡树"></a>可持久化平衡树</h4><p>除了splay, 都行&#x2F;cf</p><p>替罪羊树可以部分持久化(均摊)</p><p>其他的都可以完全持久化</p><h4 id="可合并持久化的平衡树"><a href="#可合并持久化的平衡树" class="headerlink" title="可合并持久化的平衡树"></a>可合并持久化的平衡树</h4><p>这里定义合并是序列拼接</p><p>可以用路径复制实现平衡树的分裂合并, 于是可以支持区间复制</p><p>但是复杂度仍然是 $\log len$, 于是受限</p><p>treap的合并可持久化: 不能存随机值否则反复复制一个点随机值是一样的, 于是按子树大小随机就行了, 复杂度未知反正没人会卡</p><h3 id="P8263-Ynoi-Easy-Round-2020-TEST-8"><a href="#P8263-Ynoi-Easy-Round-2020-TEST-8" class="headerlink" title="P8263 [Ynoi Easy Round 2020] TEST_8"></a>P8263 [Ynoi Easy Round 2020] TEST_8</h3><p>倍增合并, treap显然复杂度是 $\log^2 n$ 的, 过不了, 但是WBLT合并大小为 $a, b$ 的树复杂度是 $\log \dfrac{a}{b}$. 于是复杂度变为单log</p><h3 id="P8524-Ynoi2078-lt-A-theory-of-consciousness-from-a-theoretical-computer-sciencepers"><a href="#P8524-Ynoi2078-lt-A-theory-of-consciousness-from-a-theoretical-computer-sciencepers" class="headerlink" title="P8524 [Ynoi2078] &lt;A theory of consciousness from a theoretical computer sciencepers"></a>P8524 [Ynoi2078] &lt;A theory of consciousness from a theoretical computer sciencepers</h3><p>直接做的化, 用可合并持久化平衡树, 然后对除以 $2$ 维护每个数除了 $1, 2, \ldots$ 次的 $\log n$ 个数, 就复杂度单log\了.</p><p>然而空间俩log爆炸了, 考虑因为我们不需要维护之前的版本于是直接每 $\dfrac{n}{\log n}$ 次重构, 或者直接智能指针就做完了.</p><h3 id="CF702F-T-Shirts"><a href="#CF702F-T-Shirts" class="headerlink" title="CF702F T-Shirts"></a>CF702F T-Shirts</h3><p>设 $f_{i, j}$ 为从 $i$ 开始往后走有 $j$ 元最后的答案, 转移发现是区间复制和区间加, 结束啦.</p><h3 id="Hdu5118-Gre-Words-Once-More"><a href="#Hdu5118-Gre-Words-Once-More" class="headerlink" title="Hdu5118 Gre Words Once More"></a>Hdu5118 Gre Words Once More</h3><p>同上, 可持久化平衡树的区间复制维护dp</p><p>DAG链剖分!</p><h3 id="树套可持久化平衡树"><a href="#树套可持久化平衡树" class="headerlink" title="树套可持久化平衡树"></a>树套可持久化平衡树</h3><h4 id="可持久化作为标记-BZOJ3946"><a href="#可持久化作为标记-BZOJ3946" class="headerlink" title="可持久化作为标记: BZOJ3946"></a>可持久化作为标记: BZOJ3946</h4><p>开两个可持久化平衡树分别维护当前节点所有字符串都被加了序列 $s$ 和当前节点序列的lcp序列 $t$, 下传直接区间复制, 于是外层线段树序列, 查询在内层多个持久化平衡树二分. 复杂度 $q\log^3 n$</p><p>可以优化到俩log, 考虑差分, 维护相邻两个字符串的lcp长度, 答案就是区间 $\min$, 仍然用上面方法维护字符串, 每次修改只需要重新计算边界的 $f$, 中间的是区间加.</p><h4 id="可持久化作为信息-CF1340F-Nasty-and-CBs"><a href="#可持久化作为信息-CF1340F-Nasty-and-CBs" class="headerlink" title="可持久化作为信息: CF1340F Nasty and CBs"></a>可持久化作为信息: CF1340F Nasty and CBs</h4><p>可持久化平衡树维护区间括号hash, 合并就是区间查询相等和区间拼接拆分</p><h3 id="可持久化可并堆"><a href="#可持久化可并堆" class="headerlink" title="可持久化可并堆"></a>可持久化可并堆</h3><p>斜二项堆介绍. . .</p><h4 id="BZOJ3489"><a href="#BZOJ3489" class="headerlink" title="BZOJ3489"></a>BZOJ3489</h4><blockquote><p>强制在线</p></blockquote><p>每个数贡献一个区间, 变成了二维平面上矩形取max单点求值, 于是可以线段树套堆给它可持久化掉</p><h4 id="Luogu7651"><a href="#Luogu7651" class="headerlink" title="Luogu7651"></a>Luogu7651</h4><p>考虑对单个点求直接持久化线段树扫描线就行, 求前 $k$ 近就不断删最小的即可.</p><h2 id="Day1-xtq"><a href="#Day1-xtq" class="headerlink" title="Day1-xtq"></a>Day1-xtq</h2><p>不听了</p><h2 id="Day1-营员交流内容"><a href="#Day1-营员交流内容" class="headerlink" title="Day1-营员交流内容"></a>Day1-营员交流内容</h2><h3 id="浅谈一种互质数对与最大公约数的维护算法"><a href="#浅谈一种互质数对与最大公约数的维护算法" class="headerlink" title="浅谈一种互质数对与最大公约数的维护算法"></a>浅谈一种互质数对与最大公约数的维护算法</h3><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>互质数对与最大公约数的维护算法?</p><p>$P(x)$ 为 $x$ 最大质因子</p><p>基本解决问题是, 要求初始全为 $0$ 的序列 $a_n$, 要求你进行 $m$ 次修改, 使得对于任意 $i\in [1, n]$ 存在时刻 $t$ 满足 $\forall j, b_j&#x3D;[i \perp j]&#x2F;\gcd(i, j)$, 应用类似莫队的一个玩意.</p><p>基本思想是拆贡献, $[i\perp j]&#x3D;1-[\exists p\ne 1, p\vert i, p\vert j]$, $\gcd(i, j)&#x3D;\prod_p p^c [p^c\vert i, j][p^{c+1}\not \vert i, j]$</p><p>于是直接爆搜决定 $p$, 对于互质的情况, dfs状态为 $(i, x)$ 表示小于 $x$ 的部分决定乘上的乘积为 $i$, 当前要决定 $p_x$ 是否被乘上. 当乘上素数 $p_x$ 的时候把 $p_x$ 的倍数 $a_j(j&#x3D;kp_x)$ 设为 $0$, 回溯时撤销, 当 $ip&gt;n$ 的时候直接退出, 得到一个爆搜算法. 正确性显然.</p><p>对于 $gcd$ 的情况一样爆搜, 只不过对 $p$ 应该枚举 $c$ 表示 $p$ 的次数, 剩下的完全一样.</p><p>对于复杂度显然两个复杂度都低于 $\sum_i \dfrac{n}{P(i)}\approx n\sqrt n$(在 $10^6$ 附近, 只维护互质对的情况常数较小)</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><blockquote><p>给定 $a_n$, $q$ 次给定 $l, r, x$ 询问 ${a_{\gcd(x, i)}, i\in[l, r]}$ 的最大子段和.</p></blockquote><p>直接用上面的方法转化成单点改区间最大子段和即可. 复杂度 $n\sqrt n\log n$</p><h3 id="浅谈一些信息合并的处理方式"><a href="#浅谈一些信息合并的处理方式" class="headerlink" title="浅谈一些信息合并的处理方式"></a>浅谈一些信息合并的处理方式</h3><p>典</p><h4 id="无旋treap带值域交合并"><a href="#无旋treap带值域交合并" class="headerlink" title="无旋treap带值域交合并"></a>无旋treap带值域交合并</h4><p><a href="https://www.cnblogs.com/-Wallace-/p/merge-treaps.html">网上其实早就有了</a></p><p>基本就是, 要合并两棵树, 考虑两个根节点 $a, b$, 设 $a$ 的优先级高(作为根), 则把 $b$ 按 $a$ 的权值分裂, 左右递归下去.</p><h4 id="线段树合并卡空间"><a href="#线段树合并卡空间" class="headerlink" title="线段树合并卡空间"></a>线段树合并卡空间</h4><h3 id="线性拟阵奇偶"><a href="#线性拟阵奇偶" class="headerlink" title="线性拟阵奇偶"></a>线性拟阵奇偶</h3><p>啥玩意? ? ? ? ? ?</p><h3 id="浅谈静态数据结构的合并与分裂"><a href="#浅谈静态数据结构的合并与分裂" class="headerlink" title="浅谈静态数据结构的合并与分裂"></a>浅谈静态数据结构的合并与分裂</h3><h4 id="点分树-边分树合并-静态toptree合并"><a href="#点分树-边分树合并-静态toptree合并" class="headerlink" title="点分树, 边分树合并, 静态toptree合并"></a>点分树, 边分树合并, 静态toptree合并</h4><p>点分树先建哈夫曼树二度化, 然后两个都直接照抄线段树合并即可.</p><p>静态toptree深度也是 $\log n$ 的, 现在要合并 $u\to v$ 的链, 要分情况讨论:</p><ul><li>$u, v$ 有祖先关系</li><li>$u, v$ 无祖先关系</li><li>$u, v$ 分别在重儿子左右的两个 rake tree 上.</li><li>$u, v$ 其中一个是重儿子, 即不在 rake tree 上.</li><li>$u, v$ 在同一个rake tree 上</li></ul><p>要处理一个叶子和一个子树的合并, 维护簇界点之间路径的标记和簇其他部分的标记.</p><h4 id="点分树-边分树-toptree分裂"><a href="#点分树-边分树-toptree分裂" class="headerlink" title="点分树, 边分树, toptree分裂"></a>点分树, 边分树, toptree分裂</h4><p>点分树, 边分树因为到重心这一信息的不可分裂性通常不能分裂, 能分裂当且仅当信息可以分裂, 如信息是线段树用线段树分裂</p><p>toptree按子树分裂: 设关于 $u$ 分裂, $u$ 的子树表现为compress tree在他右侧的点, 以及这些点的rake tree, 那直接对它所在compress tree分裂是简单的, 对自己所在的rake tree把自己分出来也只要 $O(\log n)$ 的修改量, 于是就分裂了.</p><p>对于链的分裂, 他说只用compress的双层toptree, 感觉是直接造了一个leafy的全局平衡二叉树&#x2F;cf, 而全局平衡二叉树拿走一条链是简单的.</p><h3 id="范围修改查询问题相关算法及其应用"><a href="#范围修改查询问题相关算法及其应用" class="headerlink" title="范围修改查询问题相关算法及其应用"></a>范围修改查询问题相关算法及其应用</h3><p>线段树能维护修改和区间信息都为半群的问题</p><h4 id="lxl的离线范围修改查询算法"><a href="#lxl的离线范围修改查询算法" class="headerlink" title="lxl的离线范围修改查询算法"></a>lxl的离线范围修改查询算法</h4><blockquote><p>问题描述为给定若干点, 若干次针对某个集合的修改和查询, 都是半群信息</p></blockquote><p>定义等价关系为两个点所属的修改和查询集合相同. 由此定义出等价类. 定义一个划分 $R_{l, r}$ 为仅考虑 $[l, r]$ 中的修改查询得出的等价类集合的集合.</p><p>考虑维护有根森林, 即每个叶子为原问题中的点, 一个等价类为一棵子树, 每个节点子树和, 子树修改标记, 合并等价类就是建一个父亲把等价类挂上去, 拆分就是把父亲删掉并下传修改标记, 而可以用这种方式在不同的 $R_{l, r}$ 划分之间移动. 假设现在要处理 $R_{l, r}$ 这个问题, 先移动森林状态到 $R_{l, mid}$ 递归, 再移动到 $R_{mid+1, r}$ 递归即可.</p><p>然后设 $F(x)$ 是 $x$ 个操作最多可以把点分成多少等价类, $B$ 是最大的 $x$ 满足 $F(x)\le n$, 于是可以 $B$ 个操作分一块, 复杂度 $T(n, m)&#x3D;\dfrac{m}{B}T_1(B), T_1(n)&#x3D;2T_1(\dfrac{n}{2})+O(F(n))$, 对于半平米, 圆可以做到 $m\sqrt n$, 对任意集合可以做到 $\dfrac{nm}{\log n}$, 对序列可以 $m\log n$</p><h4 id="分块旋转扫描线"><a href="#分块旋转扫描线" class="headerlink" title="分块旋转扫描线"></a>分块旋转扫描线</h4><p>略</p><h3 id="浅谈一类树上范围相关问题"><a href="#浅谈一类树上范围相关问题" class="headerlink" title="浅谈一类树上范围相关问题"></a>浅谈一类树上范围相关问题</h3><h4 id="树剖"><a href="#树剖" class="headerlink" title="树剖"></a>树剖</h4><p>理解为树上链分治结构</p><blockquote><p>单点询问, 树链距离 $d$ 以内的点加. 范围都是 $10^5$</p></blockquote><p>重链剖分, 考虑一次操作的影响, 发现会对重链上的区间的点的轻子树作前 $d$ 层加, 此外端点处有对当前点的子树前 $d$ 层加或向祖先方向的前 $d$ 层加.</p><p>那么后两种都相当于给定 $u$, 对范围内点 $v$ 加 $d-dis(u, v)$, 于是能做了: 用树套树维护标记, 查询时要查到根的路径上每个链头的标记, 子树内点的标记, 祖先点的标记三种, 直接做3log, 把树剖换成全局平衡二叉树是2log.</p><h4 id="毛毛虫剖分"><a href="#毛毛虫剖分" class="headerlink" title="毛毛虫剖分"></a>毛毛虫剖分</h4><blockquote><p>对一条链距离为 $d$ 以内的点加, 对一条链距离为 $d$ 以内的点求和, 子树加子树和链加链和.<br>$d$ 为常数且 $d\le 3$</p></blockquote><p>原来只见过距离为 $1$ 的毛毛虫剖分, 不过容易发现扩展是平凡的, 假设距离为 $d$, 要给当前重链标号, 自然先给重链标号, 再给挂在当前重链的所有轻儿子的前 $d$ 级后代标号, 再递归下去, 则每条链只有前 $d$ 个标号不连续. $d$ 一般很小不然复杂度就爆了.</p><h4 id="点分树维护传递性问题"><a href="#点分树维护传递性问题" class="headerlink" title="点分树维护传递性问题"></a>点分树维护传递性问题</h4><blockquote><p>$n$ 点树, 一开始均未激活, 若 $i$ 激活会激活距离 $r_i$ 以内的点, $q$ 次询问激活一点后被激活点的点权和.</p></blockquote><p>todo</p><h4 id="Toptree-P8498-树上邻域数点"><a href="#Toptree-P8498-树上邻域数点" class="headerlink" title="Toptree: P8498 树上邻域数点"></a>Toptree: P8498 树上邻域数点</h4><p>建toptree, 设 $f_{u, 0&#x2F;1, d}$ 表示距离簇 $u$ 内距离左&#x2F;右界点 $d$ 以内的信息, $g_{u, 0&#x2F;1, d}$ 表示簇 $u$ 外距离左&#x2F;右界点距离为 $d$ 以内的点的信息, 则询问 $u$ 时, 找到任意一条边 $u, v$, 然后找到最浅的完全被询问的区域包含的簇 $x$, 则答案就是 $x$ 的两个界点各向外一部分以及簇 $x$ 自身合并出来的, 于是可以先把自身和一个端点的合起来, 查询时只需要一次.</p><p>问题变成如何求 $f$ 和 $g$, $f$ 根据 $f$ 的定义显然可以直接用rake和compress得到, 而 $g$ 考虑对簇换根, 假设现在祖先的 $g$ 已经求出, 则簇 $u$ 的内容就是父亲的 $g$ 和兄弟的 $f$ 的合并.</p><p>$f$ 的 $d$ 只要开到簇路径长度, $g$ 的 $d$ 只要开到父亲的簇路径长度, 总复杂度 $n\log n$</p><h2 id="Day2-qlr"><a href="#Day2-qlr" class="headerlink" title="Day2-qlr"></a>Day2-qlr</h2><h3 id="CF1753C"><a href="#CF1753C" class="headerlink" title="CF1753C"></a>CF1753C</h3><p>nfls里面有</p><h3 id="Yogyakarta-Elevators"><a href="#Yogyakarta-Elevators" class="headerlink" title="Yogyakarta Elevators"></a>Yogyakarta Elevators</h3><p>考虑 $m$ 很小, 而且图的边集是若干团, 于是考虑线图把点边互换, 以电梯为点, 每个楼把所有经过这个楼的电梯连起来, 于是一个区间连通的条件是只保留这个区间中的边只有一个不为单点的连通块.</p><p>然后直接枚举 $r$, 从大到小加 $[1, r]$ 之间的楼的边, 我们只关心连通性变化, 于是不断加边的过程中一共只有 $O(m)$ 种本质不同的情况, 总复杂度 $nm\alpha(n)$.</p><p>如何做到只枚举这 $O(m)$ 种情况? 每次加的边是图的最大生成树, 于是只要从小到大加边不断维护最大生成树即可(树只有 $m$ 个点)</p><h3 id="CF1753D"><a href="#CF1753D" class="headerlink" title="CF1753D"></a>CF1753D</h3><p>对这种题想到看成格子移动的模型, 则对每个砖块 $(a, b), (a, b+1)$, 连边 $(a, b-1)\to (a, b+1), (a, b)\to (a+1, b+1), (a, b)\to (a-1, b+1)$, 各个方向连起来, 跑最短路即可. 注意到黑白染色黑白格独立, 找两个相邻格子最短路相加就是答案.</p><p>然后为什么是对的, 即证明一个格子不会移动两次, 若出现过这种情况, 则一定存在某个时刻它已经空出这个位置, 就不会有后面的移动了.</p><h3 id="CF1750F"><a href="#CF1750F" class="headerlink" title="CF1750F"></a>CF1750F</h3><p>见count</p><h3 id="ARC148D"><a href="#ARC148D" class="headerlink" title="ARC148D"></a>ARC148D</h3><p>考虑 $2n$ 为偶数, 所以最后两布一定是ALice先Bob后, 于是若最后两个数 $x, y$ 满足 $y-x\ne x-y$ 即 $2x\ne 2y$ 不相等Alice的两种方案总能赢一个, 于是最后两个数相等, 那么照着归纳, 假设已经有最后 $2k$ 步必须 $2x&#x3D;2y$ 的数可以匹配, 则对于倒数 $2k+1$ 和 $2k+2$ 两个数, 显然如果不相等则交换这两个数的情况就不一样了, 于是Bob想获胜必然满足开始状态可以一一配对, 每对满足 $2a&#x3D;2b\pmod M$.</p><p>而当前所有数都满足之后, 直接模拟, 看最后会得到 $\dfrac{M}{2}$ 或 $0$ 即可, 做完了.</p><h3 id="ARC151E"><a href="#ARC151E" class="headerlink" title="ARC151E"></a>ARC151E</h3><p>注意不能删成空</p><p>则发现如果没有公共子串那么先转到它一定是最优的, sam即可</p><p>如果没有相当于先删到一个字符, 然后不断变成另一个字符变到 $Y$ 有的最后再变回去, 那就是相邻两字符连边跑最短路.</p><h3 id="BJOI2018-染色"><a href="#BJOI2018-染色" class="headerlink" title="BJOI2018 染色"></a>BJOI2018 染色</h3><p>容易发现奇环无解, 现在是二分图.</p><p>容易把连通块分别判断, 同时一度点不影响任何事, 现在是无一度点的连通图.</p><p>然后现在一个连通块应该有一些环, 发现对于一个长 $n$ 的偶环我们可以确定其上的 $n-2$ 个点, 选一条长 $n-2$ 的链全放 ${1, 2}$, 剩下两个点放 ${1, 3}$ 和 ${2, 3}$, 设链与 ${1, 3}$ 相连的头为 $u$, 则容易发现 $u$ 若选 $1$ 则链尾是 $2$, 与 $u$ 相连的另一个点只能是 $3$, 最后一个点 ${2, 3}$ 就没有可选的了, 于是固定了一条链.</p><p>由此可以得到, 一个连通块不可能有两个交的点数小于等于 $2$ 的环, 否则分别固定一条链就给它搞死了. 于是现在是彼此之间交路径长度大于 $1$ 的环.</p><p>再看, 度数大于等于 $4$ 意味着两个环的唯一交点肯定寄了, 同样发现多于两个三度点也无解, 最后只有两个三度点的情况, 图的形态是两个点之间三条路径.</p><p>最后, 如果存在 $\ge 2$ 条路径边数 $&gt;2$ 也无解, 考虑任意一个偶环可以确定 $n-2$ 个点, 于是把两个 $n-2$ 个点的部分重合一下就死了. 这样路径长度为奇数的不能是大于 $2$ 的就不存在了(重边应该扔了), 路径长度为偶数的只能是恰好两条路径长恰为 $2$, 就做完了.</p><p>有解情况: 删完一度点后啥也不剩, 环, 三度点且两条路径长度为 $2$.</p><h3 id="IOI2023-封锁时刻"><a href="#IOI2023-封锁时刻" class="headerlink" title="IOI2023 封锁时刻"></a>IOI2023 封锁时刻</h3><p>第一种情况是没有点贡献 $2$, 则 $x, y$ 独立, 中间切开, 直接贪心就是对的.</p><p>第二种情况是存在点贡献 $2$, 那么如果是序列应该是把每个点看成投入 $d_1$ 获得代价 $1$, 再投入 $d_2-d_1$ 的物品做贪心, 此时可以分成两组, 对于 $d_2-d_1&gt;d_1$ 的部分直接是凸函数max+卷积, 对于 $d_2-d_1&lt;d_1$ 因为是上凸容易证明最多只有一个没有选满, 排序后枚举选了多少个 $2$ 即可.</p><p>而对于当前树形的问题则有依赖要求. 考虑如果儿子比父亲劣(代价比父亲高)则依赖被贪心满足, 则发现只有 $x\to y$ 的链上这个条件不满足, 而如果存在有点贡献 $2$ 这条链上一定每个点都至少贡献 $1$, 于是就做出来了.</p><h3 id="P9605-IOI2023-机器人比赛"><a href="#P9605-IOI2023-机器人比赛" class="headerlink" title="P9605 [IOI2023] 机器人比赛"></a>P9605 [IOI2023] 机器人比赛</h3><p>考虑把 $0, 1$ 单独拿出来, $2, 3, 4, 5$ 分别看作上下左右标记.</p><p>首先要求最短路, 作为第一阶段, 考虑bfs, 需要有一种方法逐层扩展节点. 从左上角开始bfs, 先把左上角指向下(或右)并朝该方向移动一格. 每当第一次到大一个节点, 将移动到的格子向回指向父亲(唯一一个指向自己的格子)并移动到父亲; 若当前节点不是第一次到达, 不断将指针逆时针旋转, 若指向格子未访问过就访问, 若是父亲就退回去, 于是每次最靠右下的所有格子会向外扩展一个距离, 同时机器人最终回到左上角, 是一个逐层加深的dfs过程, 并且任意时刻所有格子的指针为边构成机器人为根的根向树, 按照访问顺序构成以左上角为根的bfs树. 当机器人到达右下角时到第二阶段.</p><p>第二阶段要给最短路染色, 现在是以右下角为根的根向树, 则顺着树边dfs, 到达叶子时如果叶子是左上角就设为 $1$ 否则设为 $0$, 然后开始回溯, 回溯过程若相邻节点为 $1$ 设为 $1$ 否则设为 $0$, 容易发现满足要求.</p><h2 id="Day2-量子计算"><a href="#Day2-量子计算" class="headerlink" title="Day2-量子计算"></a>Day2-量子计算</h2><p>不听了不听了</p><h2 id="Day3-比赛"><a href="#Day3-比赛" class="headerlink" title="Day3-比赛"></a>Day3-比赛</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><blockquote><p>给定序列 $a_n$, 每个位置有随机类型 $c_i$, 按照类型为第一关键字, 下标为第二关键字排序后前缀和小于 $T$ 的元素 $i$ 会贡献 $b_i$, 求所有 $c_i$ 对应的贡献和的和.<br>$n\le 200, T\le 3\times 10^5$</p></blockquote><p>简单题, 考虑拆贡献, 对于一个元素 $i$, 如果 $c_i&#x3D;0$ 则所有后面的元素不可能在他前面, 于是答案就是前面元素的 $1+x^{a_i}$ 卷起来前 $T-t_i$ 项和为方案数, 同理 $c_i&#x3D;1$ 的前面的一定贡献后面的卷起来前 $T-\sum_{j\le i} t_j$ 项的和为方案数, 复杂度 $nT$.</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><blockquote><p>给定序列 $h_n$, 求有多少区间 $[l, r]$ 满足存在正实数 $L$ 使得存在序列 $r$ 满足 $r_i\in {h_i, 2L-h_i} \forall i \in[l, r]$, 且 $r$ 单调递增.</p><p>$n\le 5\times 10^5$</p></blockquote><p>赛时做法事考虑对于一个给定的 $L$, 每个元素使关于 $L$ 对称的两个值 $a_i$ 和 $b_i$, 合法的区间一定是连续的一段取 $a_i$ 接着一段 $b_i$, 于是设相邻两元素 $\vert h_i-L\vert&lt;\vert h_{i+1}-L\vert$ 则它们只能是位于 $b$ 那一段设为 $1$, 否则如果是 $&gt;$ 只能是 $a$ 那一段设为 $0$, 则合法区间一定是连续的一段 $0$ 右边一段 $1$. 同时注意到 $\vert h_i-L\vert$ 和 $\vert h_{i+1}-L\vert$ 的关系只会在 $\dfrac{h_i+h_{i+1}}{2}$ 变化 $1$ 次, 于是直接用数据结构修改 $01$ 同时找到最长合法区间, 最后是一个2side矩形覆盖.</p><p>注意到以上内容等价于不存在 $i$ 使得 $i, i+1$ 之间是 $1$ 而 $i+1, i+2$ 之间是 $0$, 而这个可以直接提出一个对 $L$ 的区间限制不属于某区间, 则问题变化为给定 $m$ 个区间问有多少个区间的区间并不是全集, 直接用不带删双指针做就是线性. &#x2F;bx znb</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><blockquote><p>给定长 $n$ 序列的广义线段树(左闭右开)和 $m$ 个区间, 求有多少个线段树节点集合的子集 $S$(共 $2^{2n-1}$ 种)满足若 $S$ 中节点的和已知则可以已知所有 $m$ 个区间的和.</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>首先肯定转化成前缀和, 然后每个区间 $[l, r)$ 连边 $l\to r$, 能表示 $[a, b)$ 的和等价于 $a, b$ 连通</p><p>图存在分治结构对应到线段树上是子树</p><p>$m&#x3D;1$ 时, dp, 记录两个区间端点和 $L, R$ 的连通性的 $2^4$ 种状态就dp出来了. 可以根据实现过 $m\le 5$.</p><p>关键性质是这个图是一个平面图, 则对于当前线段树节点, 若左右端点不连通, 则一定是左边一部分和左边连右边一部分和右边连, 中间可能剩一些不和两边连的不管它. 设 $f_{u, x}$ 为线段树节点 $u$, $[l, x]$ 与左边连, $[x+1, r]$ 与右边连, $g_u$ 为 $u$ 子树连通的方案数, 则可以做了, 不过当合并 $f_{l, x}$ 和 $f_{r, y}$ 合并的时候可能会中间有一块和两边不连通, 只要要求进行这个转移的时候必然有没有跨过 $x$ 和 $y$ 两处分界的要求必须连通的区间, 则现在把这个状态看成 $f_{u, x}$ 或 $f_{u, y}$ 对答案是没有影响的. 通过树形背包的复杂度可以做到 $n^2$</p><p>用线段树合并维护整体dp, 复杂度 $n\log n$</p><h2 id="Day4-EI"><a href="#Day4-EI" class="headerlink" title="Day4-EI"></a>Day4-EI</h2><h3 id="组合类与生成函数"><a href="#组合类与生成函数" class="headerlink" title="组合类与生成函数"></a>组合类与生成函数</h3><h4 id="复习OGF"><a href="#复习OGF" class="headerlink" title="复习OGF"></a>复习OGF</h4><p>组合类, 组合对象, 数列, 生成函数</p><p>不会打组合类的记号, 下面大写是生成函数或组合类, 小写是数列或组合对象.</p><p>数列与生成函数: $A(x)&#x3D;\sum_i a_ix^i$ 组合类与生成函数 $A(x)&#x3D;\sum_{a\in A} x^{\vert a\vert}$</p><p>然后是组合对象符号化方法</p><h4 id="MSET反演"><a href="#MSET反演" class="headerlink" title="MSET反演"></a>MSET反演</h4><p>我自己起的名字, 考虑MSET的逆变换是可以快速求的.</p><p>MSET是这样的:<br>$$<br>\begin{gathered}<br>\mathrm{MSET} A(x)&#x3D;\prod (\dfrac{1}{1-x^i})^{a_i}\&#x3D;\exp \sum_i -a_i\ln (1-x^i)\&#x3D;\exp \sum_i a_i \sum_{j&#x3D;1} \dfrac{x^{ij}}{j}<br>\&#x3D;\exp \sum_{i&#x3D;1} \dfrac{A(x^i)}{i}<br>\end{gathered}\<br>$$</p><p>考虑解这个东西的逆变换</p><p>$$<br>A(x)&#x3D;\mathrm{MSET}(B(x))\<br>A(x)&#x3D;\exp \sum_{i&#x3D;1} \dfrac{B(x^i)}{i}\<br>\ln A(x)&#x3D;\sum_{i&#x3D;1}\dfrac{B(x^i)}{i}\<br>[x^n] \ln A(x)&#x3D;\dfrac{1}{i}\sum_{i\vert n} [x^i] B(x) \<br>B(x)&#x3D;\sum_{k&#x3D;1}\dfrac{\mu(k)}{k}\ln A(x^k)<br>$$</p><p>最后一步是怎么搞的? 考虑 $\ln A$ 是 $B$ 和 $\dfrac{1}{i}$ 的狄利克雷卷积, 所以要求 $\dfrac{1}{i}$ 的逆元, 因为是积性函数可以用质数点值确定, 考虑其狄利克雷生成函数是</p><p>$$<br>F(x)&#x3D;\sum_i \dfrac{1}{i^{x+1}}<br>\&#x3D;\prod_{p\in P} \sum_i \dfrac{1}{p^i(p^i)^x}<br>\&#x3D;\prod_{p\in P}\sum_i p^{-i(x+1)}<br>\&#x3D;\prod_p \dfrac{1}{1-p^{-x-1}}<br>\\mathrm{INV} F(x)&#x3D;\prod_p (1-p^{-x-1})&#x3D;\prod_p(1-\dfrac{1}{p\cdot p^x})&#x3D;\sum_i \dfrac{\mu(i)}{i}<br>$$<br>于是<br>$$<br>[x^n]B(x)&#x3D;\sum_{i\vert} \dfrac{\mu(i)}{i} [x^{\frac{n}{i}}] A(x)\<br>B(x)&#x3D;\sum_i\dfrac{\mu(i)}{i}A(x^i)<br>$$</p><p>考虑什么是 $\mathrm{MSET}$ 关系, 举了两个例子: 字符串和它的lyndon分解, 和多项式和其唯一分解成不可约的因子乘积. 于是要计数后者可以用前者做反演.</p><p>$\mathrm{PSET}$ 是不是也可以这么搞啊回去尝试一下.</p><p>颁奖典礼来尝试, $\mathrm{PSET}$ 应该是</p><p>$$<br>\begin{gathered}<br>\mathrm {PSET} A(x))&#x3D;\prod (1+x)^{a_i}&#x3D;\exp \sum_i a_i \ln (1+x)\<br>&#x3D;\exp \sum_{i&#x3D;0} a_i \sum_{j&#x3D;1} \dfrac{(-1)^{j-1}x^{ij}}{j}\<br>&#x3D;\exp \sum_{j&#x3D;1} \dfrac{(-1)^{j-1}}{j}\sum_{i&#x3D;0}a_ix^{ij}\<br>&#x3D;\exp \sum_{j&#x3D;1}\dfrac{(-1)^{j-1}}{j} A(x^j)<br>\end{gathered}<br>$$</p><p>也考虑解逆变换</p><p>$$<br>\begin{gathered}<br>A(x)&#x3D;\mathrm {PSET}(x)&#x3D;\exp \sum_{j&#x3D;1}\dfrac{(-1)^{j-1}}{j} B(x^j)\<br>[x^n] \ln A(x)&#x3D;\sum_{i\vert n} \dfrac{(-1)^{i-1}}{i}<br>[x^i]B(x)<br>\end{gathered}<br>$$</p><p>也可以用dgf去解 $\dfrac{(-1)^i}{i}$ 的逆, 要对 $p&#x3D;2$ 分类, 不过其实提取系数可以直接单log递推.</p><h4 id="复习EGF"><a href="#复习EGF" class="headerlink" title="复习EGF"></a>复习EGF</h4><p>乘法会分配标号, $\mathrm{MSET}(A(x))&#x3D;\exp(A(x))$.</p><p>为啥没听说过EGF的 $\mathrm{PSET}$ 啊, 考虑一下应该是</p><h4 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h4><p>EGF上微分是给组合对象大小减 $1$, OGF上微分会再乘 $n$.</p><p>是我们组合意义的”指定”运算(OGF钦定一个元素拿走有大小种方案, EGF中拿走特定元素有 $1$ 种方案).</p><p>然后我们的微分基本法则, 链式法则, 莱布尼茨微分公式都可以拿我们的组合意义推了.</p><h4 id="利用微分做EGF多重集的递推式"><a href="#利用微分做EGF多重集的递推式" class="headerlink" title="利用微分做EGF多重集的递推式"></a>利用微分做EGF多重集的递推式</h4><p>对应如何 $n^2$ 做多项式exp</p><p>经典例子是我们的有标号无向连通图, 方法是先对无向图求导得到无向图的微分方程, 再带到exp的式子去求导就有了微分方程从而递推式.</p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><blockquote><p>求长 $n$ 且没有相邻两个数相差为 $1$ 的数量</p></blockquote><p>考虑容斥, 先钦点序列由若干个差为 $1$ 的连续段构成, 则直接对 $-1$ 的个数容斥, 考虑一个长 $n$ 的负一的连续段应该有 $2-[n&#x3D;1]$ 种方案系数是 $(-1)^n$ 容易推出带容斥系数的GF $G(x)&#x3D;x-2x^2+2x^3-2x^4\ldots&#x3D;\dfrac{x(1-x)}{1+x}$, 则答案的GF的 $F(x)&#x3D;\sum_{n&#x3D;0} n! G^n(x)$. 设 $S(x)&#x3D;\sum_{n&#x3D;0}n! x^n$</p><p>于是可以对 $S$ 求导 $S(x)&#x3D;1+(xS(x))’x$, 从而 $S(G)&#x3D;1+GS(G)+G^2(S’(G))$, 替换出 $F&#x3D;1+GF+\dfrac{G}{G’}F’$ 我们知道($F’&#x3D;(S(G))’&#x3D;S’(G)G’$)</p><p>带入 $G(x)&#x3D;x\dfrac{1-x}{1+x}$ 即可.</p><h4 id="有标号二正则图计数"><a href="#有标号二正则图计数" class="headerlink" title="有标号二正则图计数"></a>有标号二正则图计数</h4><p>EI的思考题, 考虑二正则图就是一些长度大于等于 $2$ 的环, 显然是把它们的EGF exp起来, 一个环的EGF就是 $\dfrac{1}{2}(\sum_{i&#x3D;1} \dfrac{x^i}{i}-x-\dfrac{x^2}{2})&#x3D;-\dfrac{1}{2}\ln (1-x)-\dfrac{1}{2}x-\dfrac{x^2}{4}$, 除以 $2$ 是环可以翻转. 于是exp之后就是 $\dfrac{\exp (-\dfrac{1}{2}x-\dfrac{x^2}{4})}{\sqrt {1-x}}$</p><h3 id="整式递推"><a href="#整式递推" class="headerlink" title="整式递推"></a>整式递推</h3><h4 id="生成函数级别"><a href="#生成函数级别" class="headerlink" title="生成函数级别"></a>生成函数级别</h4><p>对于有理生成函数可以 $\log n$ 计算第 $n$ 项, 对于微分有限可以线性或 $M(\sqrt n)$ 做, 对于微分代数可以 $R(N)$(半在线卷积复杂度)做.</p><p>微分有限: 可以被自己的有限阶导数线性表示. 微分代数: 可以被有限阶导数用多项式方程表示.</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>整数拆分是微分代数的. 具有禁止结构子排列的一般问题不能多项式时间计算.</p><h4 id="微分有限"><a href="#微分有限" class="headerlink" title="微分有限"></a>微分有限</h4><p>若果 $F(x)$, $G(x)$ 微分有限, 则 $F+G, FG, F&#x2F;G$ 均为微分有限. 如果 $F$ 是代数的而 $G$ 是微分有限的则 $F(G)$ 微分有限. $exp, ln$ 是微分有限.</p><p>例子: $\exp(-dfrac{x}{2}-\dfrac{x^2}{4})\dfrac{1}{\sqrt{1-x}}$ 是微分有限的.</p><h4 id="二元有理分式的对角线"><a href="#二元有理分式的对角线" class="headerlink" title="二元有理分式的对角线"></a>二元有理分式的对角线</h4><p>是微分有限的, 如 $\dfrac{1}{1-x-y}&#x3D;\sum_{n, m} binom{n+m}{n} x^ny^m$</p><p>证明: 设为 $Q(x, y)$, 带入 $x, a&#x2F;x$ 求 $x$ 的 $0$ 次项然后分式分解, 提取常数项, 都是代数的.</p><h2 id="Day4-核仁"><a href="#Day4-核仁" class="headerlink" title="Day4-核仁"></a>Day4-核仁</h2><h3 id="P9601-IOI2023-最长路程"><a href="#P9601-IOI2023-最长路程" class="headerlink" title="P9601 [IOI2023] 最长路程"></a>P9601 [IOI2023] 最长路程</h3><p>直接考虑 $D&#x3D;1$, 因为图很稠密考虑哈密顿路, 不过容易发现可能出现图不连通, 此时考虑选取一个连通块中点 $u, v$ 与另外连通块中的点 $w$, 则因为 $w$ 与 $u, v$ 无边则 $u, v$ 有边, 另一个连通块一定为完全图.</p><p>考虑如何维护哈密顿路, 常见套路是不断加点, 但是维护一整条哈密顿路会寄, 不能保证已经加入的哈密顿路部分和当前点之间一定有边. 考虑实时维护两条哈密顿链, 然后每次问当前点和两个端点, 如果有边显然加上, 如果和这两个点之间都没有边则这两个点之间一定有边则把这两条链可以合成一个, 当前点作为第一个. 最后要合并两条链, 显然直接问端点, 端点不连只能是两条环, 再在两条环之间二分即可做到 $2n+2\log n$ 次.</p><p>考虑继续优化比如 $1. 5n$, 考虑 $3$ 次加 $2$ 个点, 想到这个基本就赢了, 考虑两点 $u, v$, 链头 $a, b$. 此时 $u, a, b$ 之间一定有边, $u, v, a$ 之间一定有边.</p><ul><li>问 $u\to v$ 有边, 则因为 $a, b, u$ 之间一定有一条边两次问出来赢了.</li><li>否则 $u\to v$ 没边, 问 $u\to a$ 如果没边则 $v\to a$ 一定右边, 搞定另一个也一次.</li></ul><p>于是就是 $1. 5n+2\log n+O(1)$ 了.</p><h3 id="P9602-IOI2023-足球场"><a href="#P9602-IOI2023-足球场" class="headerlink" title="P9602 [IOI2023] 足球场"></a>P9602 [IOI2023] 足球场</h3><p>考虑合法图形的样子, 显然不能出现两个空位中间一个障碍的情况(至少 $3$ 次), 于是每行一个连续段, 容易发现如果两行的区间不是包含的肯定不行, 于是中间的最大向两边递减.</p><p>于是一个朴素dp是 $f_{u, d, l, r}$ 表示考虑 $[u, d]$ 之间的行, 当前对行的区间的最小限制是 $[l, r]$, 转移显然就是扩展 $u&#x2F;d&#x2F;l&#x2F;r$.</p><p>考虑优化, 固定 $l, r$ 显然 $u, d$ 一定顶到头上于是只可能有 $n$ 组, 再考虑 $l$ 固定时 $r$ 也一定是极大的, 且当 $r$ 不断右移时, $u, d$ 的可行区间不断分裂. 于是遂着 $r$ 的增加可以把 $u, d$ 组按照区间包含关系连出树, 于是固定 $l$ 只有 $r$ 极大, $u, d$ 为树节点对应区间的 $O(n)$ 个状态, 状态数变成了 $n^2$.</p><p>转移预处理后做到 $O(1)$.</p><h3 id="CF1175G-Yet-Another-Partiton-Problem"><a href="#CF1175G-Yet-Another-Partiton-Problem" class="headerlink" title="CF1175G Yet Another Partiton Problem"></a>CF1175G Yet Another Partiton Problem</h3><p>核仁提示: 这个函数没有四边形不等式.</p><p>那你瞪着这个 $k\le 100$ 容易想到每个 $k$ 跑一遍, 然后考虑上数据结构, 扫描当前的 $i$, 则这个 $\max$ 显然考虑单调栈, $j$ 的贡献可以表示为 $D_j(i-j)+f_j&#x3D;(f_j-jD_j)+iD_j$(其中 $D_j$ 为 $\max_{k\in [j, i]} a_k$), 则贡献是关于 $i$ 一次函数. 显然每个连续段只需要保留贡献最大的一个. 而因为是单调栈只要支持插入一次函数和撤销一次函数. 可撤销李超树秒了. 复杂度单log.</p><h3 id="TopCoder-14379-RPSRobots"><a href="#TopCoder-14379-RPSRobots" class="headerlink" title="TopCoder 14379 RPSRobots"></a>TopCoder 14379 RPSRobots</h3><p>剪子包袱锤前两天是不是做过一个ARC132F.</p><p>感觉这个东西不变的性质很难被人脑想象. 上技术.</p><p>考虑剪子包袱锤分别设为 $0, 1, 2$, 则结果对应模 $3$ 意义下的差. 看到模转单位根, 于是 $A, B$ 两个人在没转情况的值是 $v&#x3D;\sum_i w_3^{a_i}w_3^{b_i}$, 发现不同的值对应不同的结果, 于是只要考虑值相等. 同时设 $p_i&#x3D;w_3^{a_i}, q_i&#x3D;w_3^{-b_{-i}}$, $h&#x3D;p*q$(长度为 $k$ 的循环卷积), 则 $h_i$ 就是移动 $i$ 位的结果.</p><p>于是要求 $h$ 全相等, 因为循环卷积考虑做dft转点积, 就要考虑什么东西idft后全相等. 众所周知idft是对单位根倒数多点求值, 则是常函数, 则要求 $p, q$ 做dft后点积在 $i&gt;0$ 的部分有值的集合无交.</p><p>此时应该想到子集卷积就是有交的不贡献, 但问题是 $p_i$ 和 $q_i$ 定义不同. 需要进一步发现性质, 观察dft后 $p$ 得到序列的 $p’$ 和 $q$ 得到的序列 $q’$, $q’<em>i&#x3D;\sum_j w_k^{ij} w_3^{-b</em>{-j}}&#x3D;\sum_j w_k^{-ij}w_3^{-b_j}, p’_i&#x3D;\sum_j w_k^{ij}w_3^{a_i}$, 发现两个结果是共轭的. 又因为我们只关心它们是不是 $0$ 于是可以都用 $p$ 的定义做dft.</p><p>于是复杂度是子集卷积的 $k^22^k$</p><h3 id="loj2462-完美的集合"><a href="#loj2462-完美的集合" class="headerlink" title="loj2462 完美的集合"></a>loj2462 完美的集合</h3><p>容易想到固定 $x$ 后就是包含根, 有一些点不能选的连通块个数, 但直接去子树内去卷积是 $nm^2$ 的. 关键暴力卷积合并是不如逐个加入的, 不如按照dfs序每次逐个加入元素. 容易做到 $nm$</p><p>而最后若干个连通块的交一定是一个连通块. 树上的连通块满足 $V-E&#x3D;1$, 于是考虑容斥, 求出每个点的答案和每个边两个点同时被包含的答案, 即可容斥出 $K&#x3D;1$ 的答案 $ans$.</p><p>对于 $K$ 很大时, 发现就是要求 $\binom{ans}{k}$($ans$ 是真实值因为 $n\le 60$ 开<code>ll</code>完全能存下. )</p><p>考虑exlucas说的是先对所有 $p^k$ 求答案再crt合并, 其中对所有 $p^k$ 求的时候先提出阶乘中所有 $p$ 的倍数, 把 $p$ 提出, 有等式 $n! &#x3D;p^{c}(\dfrac{n}{p})! M$, 其中 $M$ 是所有不是 $p$ 倍数的数的乘积, 中间的是子问题, 左边的显然好处理. 于是要处理 $M$.</p><p>$$<br>M&#x3D;\prod_{i}^{n&#x2F;5}\prod_{j&#x3D;1}^4 (5i+j)<br>$$</p><p>考虑 $i$ 分成两半, 则一边是 $\prod_i^{n&#x2F;5&#x2F;2}\prod_{j&#x3D;1}^4 (5i+j)$, 一边是 $\prod_i^{n&#x2F;5&#x2F;2}\prod_{j&#x3D;1}^4 (\dfrac{5}{2}n +5i+j)$, 于是考虑维护多项式 $\prod_i^n \prod_{j&#x3D;1}^4 (x+5j+4)$, 则可以用多项式乘法和多项式平移的倍增合并出 $\prod_i^{2n}$ 的情况, 就做完了.</p><h3 id="loj2461-完美的队列"><a href="#loj2461-完美的队列" class="headerlink" title="loj2461 完美的队列"></a>loj2461 完美的队列</h3><p>从询问的颜色数出发, 考虑某次修改什么时候全都没了. 但这个还是不好做, 于是分块, 一个修改拆成 $O(\sqrt n)$ 个, 则只要解决 整块&#x2F;单个数 的情况.</p><p>考虑整块, 有若干整块插入和若干单点修改, 先给每个位置都减去 $a_i$, 相当于以每个整块插入时间作为左端点插入问最小的右端点使得进行中间这段时间的操作后所有位置大于等于 $0$, 容易考虑出双指针, 则现在要支持单点加减 $1$ 和全局最小值, 可以用开桶做到单次 $O(1)$.</p><p>对于散点询问要考虑复杂度要只能关于对于当前点的修改, 于是对每个整块先处理出时间上关于操作上的前缀和, 则可以容易的只扫对于当前散点修改做相同的双指针.</p><p>现在复杂度是 $n\sqrt n$, 可以进一步优化, 发现整块和散块结构有相似性, 考虑分治结构, 上线段树, 每个修改拆成 $\log n$ 个, 现在对一个节点, 修改有祖先上的, 子树中的和自身的 $3$ 种, 而子树中的和自身的总数是 $n\log n$ 的, 于是对于当前节点可以拿所有自身的和子树中的元素跑双指针, 对于祖先上的修改记录前缀和, 复杂度 $n\log^2 n$</p><h3 id="loj2339-通道"><a href="#loj2339-通道" class="headerlink" title="loj2339 通道"></a>loj2339 通道</h3><p>考虑两棵树怎么做, 有很多种方法:</p><ul><li>对第一棵树点分治, 然后对当前分治的点集在第二棵树上的对应点建虚树, 枚举虚树上的 lca.</li><li>枚举第一棵树上路径lca $u$, 考虑现在 $a, b$ 答案是 $dep_a+dep_b-2dep_u+dist_2(a, b)$, 于是在第二棵树上点 $u$ 挂深度为 $dep_u$ 的叶子, 则问题就是子树点集中叶子距离最大值, 可以用经典的维护点集直径方法解决.</li></ul><p>现在三棵树只要合并两种方法, 第一棵树点分治, 第二棵树建虚树并枚举lca, 在第三棵树建虚树并按照 $d_u+dep_u$ 挂叶子, 则 $u, v$ 的答案是 $dist_3(u, v)$.</p><p>然后现在看起来复杂度是俩log, 但lca都可以 $O(1)$, 建虚树的排序可以在点分治时归并, 复杂度仍然是 $n\log n$</p><p>想到一个暴躁做法, 第一棵树点分治, 第二棵树建虚树, 再在虚树上点分治, 再在第三棵树对应第二棵树点分治区域建虚树, 再在虚树上枚举lca, 复杂度应该是俩log吧!</p><h3 id="CF506E-Mr-Kitayuta’s-Gift"><a href="#CF506E-Mr-Kitayuta’s-Gift" class="headerlink" title="CF506E Mr. Kitayuta’s Gift"></a>CF506E Mr. Kitayuta’s Gift</h3><p>相当于填长 $m&#x3D;n+\vert s\vert$ 的回文串要求 $s$ 是子序列. 容易想到暴力dp, 因为是回文串所以考虑从两边往中间填, 设 $f_{i, j, k}$ 表示填了两边的前 $i$ 个, 匹配长度分别是 $j, k$, 显然过不了.</p><p>实际上可以去优化建图, 后面两维就是要一个能表示 $s$ 双向匹配且匹配完整截止的自动机, 直接建图是一个二维网格图, 每个点 $(i, j)$ 连向 $(i+1, j), (i, j+1)$ 或连向 $(i+1, j+1)$, 长这样:</p><p><img src="/img/2024-02-03-14-13-26-image.png" alt="图 0">  </p><p>因为 $m$ 是 $10^9$ 想矩阵? 但是后面的状态太大, 这时候感觉dfa minimize很有道理直接过了?</p><p>好吧实际上是过不了的, 最小化后仍然很大. 因为这个dfa是用来匹配的而不是用来数数的有很多无用信息. 注意到每条起点到终点的链的答案只和红点&#x2F;绿点个数相关而和位置无关, 再优化建图即可.</p><p>然后偶数的时候直接做, 奇数的时候只有最后一步走的是由长度为 $2$ 的绿点到终点的边的情况下不合法减去即可.</p><p>然后这个题可以 $s^3+\log n$ 的, 考虑回到刚才的dp</p><p>$$<br>f_{i, j, k}&#x3D;<br>\begin{cases}<br>f_{i-1, j-1, k-1}+25f_{i-1, j, k}, \ if\ s_i&#x3D;s_{\vert s\vert-j+1}\<br>f_{i-1, j-1, k}+f_{i-1, j, k-1}+24f_{i-1, j, k}\ else<br>\end{cases}<br>$$</p><p>于是写成GF, $[x^k]F_{i, j}&#x3D;f_{k, i, j}$ 形式, 对 $i, j$ 都有</p><p>$$<br>\begin{gathered}<br>F_{i, j}&#x3D;x(AF_{i, j}+BF_{i-1, j}+CF_{i, j-1}+DF_{i-1, j-1})+E\<br>F_{i, j}&#x3D;\dfrac{x}{1-Ax}(BF_{i-1, j}+CF_{i, j-1}+DF_{i-1, j-1}+E-AEx)\<br>\end{gathered}<br>$$</p><p>其中 $A, B, D, C, E$ 为常数. 并且 $A$ 只能是 $24, 25, 26$ 中的.</p><h2 id="Day4-营员交流内容"><a href="#Day4-营员交流内容" class="headerlink" title="Day4-营员交流内容"></a>Day4-营员交流内容</h2><p>感觉很不可听</p><h3 id="PGF"><a href="#PGF" class="headerlink" title="PGF"></a>PGF</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p>EGF很适合在时间轴上分配标号, 但PGF的性质参照OGF, 于是定义 $L(F)&#x3D;\sum_i i! [x^i]F$, 他说 $L$ 是拉普拉斯算子.</p><p>简单性质: $L$ 是线性的, $L(x^ae^{bx})&#x3D;\dfrac{a! x^a}{(1-bx)^{a+1}}$</p><p>然后就是PGF基本性质, 代入 $1$ 是概率求导代入 $1$ 是期望.</p><h4 id="例题-Gachapon"><a href="#例题-Gachapon" class="headerlink" title="例题-Gachapon"></a>例题-Gachapon</h4><blockquote><p>现有一随机数生成器, 每次生成 $1&lt;i&lt;n$ 的概率为<br>$A_j&#x2F;\sum_{i&#x3D;1}^n A_i$, 使用其不断独立随机生成.<br>当对任意 $1\le j\le n$ 都有被生成了至少 $B$ 次时过程停时. 求期望停时.<br>$A_i, B_i\le N^+, 1 \le n, \sum A_i, \sum B_i\le 400.$</p></blockquote><p>$S&#x3D;\sum_i A_i, P_i&#x3D;\dfrac{A_i}{S}$, 考虑最后一步选的 $i$, 则 $i$ 选了恰好 $B_i-1$ 步, 其它的 $j$ 选了任意大于 $B_j$ 步, 就是:</p><p>$$<br>1+L\left(\sum_{i&#x3D;1}^n<br>    \dfrac{(P_ix)^{B_i-1}}{(B_i-1)! }<br>    \prod_j \left(\exp(P_jx)-\sum_{k&#x3D;0}^{B_j-1}\dfrac{P_j^kx^k}{k! }\right)<br>\right)’\circ 1<br>$$</p><p>$1$ 是最后一步, 里面枚举选的 $i$, 则 $i$ 被选了 $B_i-1$ 次, $\prod$ 后面是每个其他元素被选任意次再减去少于 $B_j$ 次, 最后转化OGF再求导带入算期望.</p><h3 id="例题-猎人杀"><a href="#例题-猎人杀" class="headerlink" title="例题-猎人杀"></a>例题-猎人杀</h3><blockquote><p>给定一个由 $n$ 个人组成的集合, 每个人有一个权值 $w_i$. 在每次操作中, 从剩余的人中以 $\frac{w_i}{\sum w_i}$ 的概率独立随机选择第 $i$ 个人离开, 直到所有人都离开. 求最后离开的人是第一个人的概率, 并对 $998244353$ 取模.</p></blockquote><p>概率变化这件事很困难, 考虑让已经离开的人仍然可以被选只是被跳过, 然后钦点了最后一个人, 和上个题一样的写答案</p><p>$$<br>\dfrac{w_1}{S}L(\prod_{j&#x3D;2}^n \exp(\dfrac{w_j}{S}x)-1)\circ 1<br>$$</p><p>分治乘法或先 $\ln$ 再 $\exp$</p><h3 id="uoj514-通用测评号"><a href="#uoj514-通用测评号" class="headerlink" title="uoj514 通用测评号"></a>uoj514 通用测评号</h3><blockquote><p>$n$ 个变量 $c_i$ 初始为 $0$, 每次随机 $c_i&lt;a$ 的 $i$ 使 $c_i$ 加 $1$, 当所有变量不小于 $b$ 时停止, 求最后期望有多少个 $i$ 满足 $c_i&#x3D;a$.</p><p>$n\le 250, b&lt;a\le250$</p></blockquote><p>和上题一样认为是所有的中随机并跳过不满足条件的. 只要考虑 $c_1$ 爆掉的概率乘 $n$.</p><p>可以写PGF, 仍然枚举最后一步选择的变量(肯定不能是 $c_1$):</p><p>$$<br>\dfrac{n-1}{n}L\left(<br>    (\exp \dfrac{x}{n}-\sum_{j&#x3D;0}^{a-1}\dfrac{x^j}{n^jj! })<br>    (\exp \dfrac{x}{n}-\sum_{j&#x3D;0}^{b-1}\dfrac{x^j}{n^jj! })^{n-2}<br>    \dfrac{x^{b-1}}{n^{b-1}(b-1)! }<br>\right)<br>\circ 1<br>$$  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024冬令营</title>
      <link href="/2024/01/26/thuwc/"/>
      <url>/2024/01/26/thuwc/</url>
      
        <content type="html"><![CDATA[<h1 id="THUWC"><a href="#THUWC" class="headerlink" title="THUWC"></a>THUWC</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><blockquote><p>有 $n$ 个人, $m$ 个任务, 第 $i$ 个人完成第 $j$ 个任务的收益是 $a_{i, j}$, 雇佣第 $i$ 个人的代价是 $c_i$, 一个人可以完成多个任务, 雇佣代价不重复计算, 最大化收益减代价.</p><p>$n\le 15, m\le 3000$</p></blockquote><p>最显然的暴力是 $f_{i, S}$ 表示前 $i$ 个人, $S$ 中任务要被完成的最大收益, 复杂度 $nm2^n$, 过不了.</p><p>预处理 $g_S$ 表示一个人完成 $S$ 的任务的最大收益, 则答案就是 $g_S$ 子集卷积, 暴力 $3^n$ 就过了.</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><blockquote><p>给定长 $n$ 的环 $a$, $m$ 次随机位置 $p\in [0, n]$ 和 $l\in [1, n]$, 把环上从 $p$ 开始的长 $l$ 的区间随机等概率重排, 求最后每个位置的期望.<br>$n&#x3D;2^k, k\le 17, m\le 10^9$</p></blockquote><p>容易发现相当于有固定的 $c_{i, j}$ 使得变换一次后的期望 $a’<em>i&#x3D;\sum_j a_j c</em>{i, j}$, 而列 $c$ 的式子的时候容易发现其只和 $\min \vert i-j\vert, n-\vert i-j\vert$ 有关, 即设 $c_d$ 表示 $\vert i-j\vert&#x3D;d$ 时 $j$ 对 $i$ 的贡献, 容易就是和 $c$ 数组做模 $n$ 的循环卷积, 又因为 $n$ 都是 $2$ 整次幂所以直接dft然后对点值快速幂再idft就 $n(\log n+\log m)$ 了.</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><blockquote><p>有一个 $n\times m$ 的矩阵 $a$, 每次可以询问一个矩形内是否有 $1$, 求最大的 $i+j$ 使得存在 $a_{i, j}&#x3D;1$<br>要求询问次数为 $n$, 询问的矩形的长边的总和不超过 $\dfrac{3}{2}n\log n$</p></blockquote><p>不会.</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><blockquote><p>有 $n\times m$ 的网格, 每次给一行的区间($(i, l), (i, l+1)\ldots (i, r)$)区间设为 $1$, 对于当前风速 $c$ 一个格子 $(i, j)$ 可用当且仅当 $(i, j-c+1)$ 到 $(i, j)$ 这个区间全部为 $1$, 定义连通为四连通, 求 $(a, b)$ 到 $(c, d)$ 连通的最大的 $c$.<br>$n\le 10^5, m\le 10^9, q\le 3\times 10^5$</p></blockquote><p>容易发现如果有相邻两行 $的两个1$ 的区间, 能从一个区间走到另一个区间的最大的 $c$ 是两个区间交的长度, 而答案就是以交的长度为权值在相邻两行之间的区间连边后从起点到终点的边权的最小值的最大值, 和使得起点和终点两个点可用的最大值取 $min$, 而容易发现这么连边边的条数是 $O(q)$ 的(对于一共有 $k$ 个区间的两行), 以相交的形式连出的边不超过 $k$(少的那一行每个提供两个端点), 而包含的形式连出的边不超过 $k$(必然有一个区间只有这一条边). 于是直接lct维护最小瓶颈生成树, 加边加边即可.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024省选准备</title>
      <link href="/2024/01/18/reviewforsx2024/"/>
      <url>/2024/01/18/reviewforsx2024/</url>
      
        <content type="html"><![CDATA[<h1 id="省选准备"><a href="#省选准备" class="headerlink" title="省选准备?"></a>省选准备?</h1><h3 id="P3726-AH2017-x2F-HNOI2017-抛硬币"><a href="#P3726-AH2017-x2F-HNOI2017-抛硬币" class="headerlink" title="P3726 [AH2017&#x2F;HNOI2017] 抛硬币"></a>P3726 [AH2017&#x2F;HNOI2017] 抛硬币</h3><p>要求</p><p>$$<br>\sum_i \sum_j [j&lt;i] \binom{a}{i}\binom{b}{j}<br>$$</p><p>这就不会了, 然而这是双射题, 考虑 $a&#x3D;b$ 的时候赢的翻转能映输的, 就只需要求平局的 $\sum_i \binom{a}{i}^2$ 是经典问题.</p><p>现在 $a&gt;b$, 设实际各证明 $x, y$ 次, 则 $a$ 输&#x2F;平的翻转都会变成赢($x\le y, a-x&gt;b-y$), 而问题就是A赢的可能仍然是赢, 这种情况要求 $a-x&gt;b-y, x&gt;y$, 于是 $x-y\in [0, a-b]$, 而 $a-b$ 很小, 枚举个差, 就是 $\sum_d \sum_i \binom{a}{i+d}\binom{b}{i}&#x3D;\sum_d \sum_i \binom{a}{i+d}\binom{b}{b-i}&#x3D;\sum_d \binom{a+b}{b+d}$ 暴力算就行了.</p><p>最后你需要用exlucas算组合数</p><h3 id="P5279-ZJOI2019-麻将"><a href="#P5279-ZJOI2019-麻将" class="headerlink" title="P5279 [ZJOI2019] 麻将"></a>P5279 [ZJOI2019] 麻将</h3><p>dpofdp, 先考虑如何判定是否胡牌, 那么顺子这种性质肯定是扫值域, 从小到大, 设 $f_{i, j, 0&#x2F;1}$ 表示前 $i$ 种牌, 形成 $j$ 个 $i, i-1$ 的对, 是否已经出现刻字, 转移显然, 可以对着转移建自动机.</p><p>发现节点并不对, $S\approx 2000$ 个</p><p>然后求期望可以累加前缀 $1\ldots i$ 加入之后还没胡的概率, 于是 $f_{i, j, k}$ 表示前 $i$ 种牌, 一共加入了 $j$ 张牌, 走到自动机的节点 $k$ 的期望步数.</p><p>转移是枚举当前种牌加了多少张, 复杂度是 $n^2S$ 的.</p><h3 id="P3307-SDOI2013-项链"><a href="#P3307-SDOI2013-项链" class="headerlink" title="P3307 [SDOI2013] 项链"></a>P3307 [SDOI2013] 项链</h3><p>先数珠子有几种, 正三棱柱的置换包括3种, 横着转一&#x2F;二下和左右翻转, 只要数互质数对个数, 莫反板子.</p><p>然后数项链是模板ploya吧?</p><h3 id="P4916-MtOI2018-魔力环"><a href="#P4916-MtOI2018-魔力环" class="headerlink" title="P4916 [MtOI2018] 魔力环"></a>P4916 [MtOI2018] 魔力环</h3><p>先上一套burnside, 现在变成要求对每个 $d$, 设 $l&#x3D;gcd(d, n)$, 求 $f_l$ 表示长 $l$ 的环(不可旋转), 有 $\dfrac{mn}{l}$ 个黑色珠子, 不能连续出 $k$ 个黑色的方案数.</p><p>先把白色放好开始插入黑色, 枚举插入的空隙数, 设黑色个数为 $b$, 得到</p><p>$$<br>\sum_i \binom{l-b}{i}g(b, i)<br>$$<br>于是求 $g(n, c)$ 表示把 $n$ 个不区分的球分成 $c$ 个区分的盒子每份大小不超过 $k$ 的方案数, 于是</p><p>$$<br>g(n, c)&#x3D;<a href="%5Cdfrac%7B1-x%5E%7Bk+1%7D%7D%7B1-x%7D">x^n</a>^c&#x3D;(1-x^{k+1})^c(1-x)^{-c}&#x3D;(\sum_i \binom{c}{i}x^{ik+i})(\sum_i \binom{c+i-1}{i}x^i)<br>$$</p><p>于是可以 $\dfrac{n}{k}$ 算一项, 而枚举插入的空隙数是 $O(k)$ 的, 所以算一次是 $O(m)$, 于是算所有 $f$ 的复杂度是关于 $n$ 约数和线性, 而约数和最大是 $n\log n$ 的(根号为界分开分析), 于是总复杂度是单log的.</p><h3 id="ARC120F-Wine-Thief"><a href="#ARC120F-Wine-Thief" class="headerlink" title="[ARC120F] Wine Thief"></a>[ARC120F] Wine Thief</h3><p>考虑对每个元素计算贡献, 要算挖去一个区间后两边选 $k-1$ 个元素的方案数. 是两边的方案卷起来, 不可做.</p><p>考虑设从 $n$ 个中选 $i$ 个且满足限制的方案数为 $f_{n, i}$, 从 $n$ 个中选 $i$ 个且第 $j$ 个强制选的方案数为 $g_{n, i, j}$, 则对于 $i\in [D, n-D+1]$, $g_{n, i, j}$ 就是先选一个 $j$, 然后要求 $[j-D+1, j+D-1]$ 这块不能选, 相当于挖掉这块添加一个长 $d$ 的空段(使得两边互不影响), 那么你不能选到空段上, 于是 $g_{n, i, j}&#x3D;f_{n-D, i-1}-\sum_{k\in [i, i+D-1]} g_{n-D, i-1, k}$.</p><p>这可以看成卷积: $G_{n, i}(x)&#x3D;\sum_j x^j g_{n, i, j}$, 则 $G_{n, i}&#x3D;\dfrac{1}{1-x}f_{n-D, i-1}-G_{n-D, i-1}*(\sum_{j&#x3D;0}^d -x^{-j})$</p><p>而初始状态应该是 $G_{n-kD, 0}&#x3D;0$, 每次区间加并卷上一个平移的多项式, 对于变换 $m$ 次的多项式, 发现满足性质前 $mD$ 项和后 $mD$ 项对称相等而中间全部相等, 于是直接卷起来复杂度就从 $n^2\log n\log k$ 变为 $n\log n\log k$</p><h3 id="P4500-ZJOI2018-树"><a href="#P4500-ZJOI2018-树" class="headerlink" title="P4500 [ZJOI2018] 树"></a>P4500 [ZJOI2018] 树</h3><p>考虑要求 $\sum_{a\in A} s^k(a)$, 其中 $s(a)$ 为 $a$ 这一无根树对应有标号树个数, 则要设出乘法&#x2F;加法复合意义的GF, 设 $a$ 的GF为 $F_k(a)&#x3D;\dfrac{s(a)^k x^{\vert a\vert}}{(\vert a\vert! )^k}$, 容易发现满足条件, 而一个组合类的GF自然是 $F_k(A)&#x3D;\sum F_k(a)&#x3D;\sum_i \dfrac{f_ix^i}{(i! )^k}$.</p><p>则现在建立树形方程, 有 $\mathrm{xD}F&#x3D;\mathrm{MSET} F$, 其中 $\mathrm{xD}, \mathrm{MSET}$ 分别是使组合类大小减少 $1$ 和多重集构造.</p><p>考虑推出这个特殊GF的 $\mathrm{MSET}$, 则显然是</p><p>$$<br>\begin{gathered}<br>    \mathrm{MSET}(A)<br>    &#x3D;\prod_{a\in A} \sum_{i&#x3D;0} \dfrac{s(a)^{ki}x^{\vert a\vert i}}{(i! )^k(\vert a\vert! )^i}<br>    &#x3D;\exp \sum_{a\in A} \ln  \sum_{i&#x3D;0} \dfrac{s(a)^{ki}x^{\vert a\vert i}}{(i! )^k(\vert a\vert! )^i}\<br>    let\ G(x)<br>    &#x3D;\ln \sum_{i&#x3D;1} \dfrac{x^i}{(i! )^k}<br>    \<br>    \mathrm{MSET}(A)<br>    &#x3D;\exp \sum_a G(\dfrac{s(a)^{k}x^{\vert a\vert}}{(\vert a\vert! )})\<br>    &#x3D;\exp \sum_a \sum_{i&#x3D;1} g_i \dfrac{s(a)^{ki}x^{\vert a\vert i}}{(\vert a\vert! )^i}\<br>    &#x3D;\exp \sum_{i&#x3D;1} g_i \sum_a \dfrac{s(a)^{ki}x^{\vert a\vert i}}{(\vert a\vert! )^i}\<br>    &#x3D;\exp \sum_{i&#x3D;1} g_i F_{ki}(x^i)<br>\end{gathered}<br>$$</p><p>于是有</p><p>$$<br>\mathrm{xD} F&#x3D;\exp \sum_{i&#x3D;1} g_{i} F(x^i)\<br>\ln (\mathrm{xD} F)-g_1F(x)&#x3D;\exp \sum_{i&#x3D;2} g_{i} F_{ki}(x^i)<br>$$</p><p>于是可以提取系数递推了, $F_i$ 从大到小推, 则推 $F_{i}$ 时, $F$ 只用推到第 $\dfrac ni$ 项, 于是等号左边推 $\exp$ 和右边算 $\ln$ 得到 $g$ 的复杂度是 $\sum_i \dfrac{n^2}{i^2}&#x3D;O(n^2)$, 而右边的求和只求 $\sum_i \dfrac{n}{i}\ln \dfrac{n}{i}&#x3D;n\ln^2 n$ 项即可.</p><p>总复杂度 $n^2$</p><p>重点应该是构造满足乘法性质的特殊GF并整出对应运算.</p><h3 id="ARC154F-Dice-Game"><a href="#ARC154F-Dice-Game" class="headerlink" title="[ARC154F] Dice Game"></a>[ARC154F] Dice Game</h3><p>应该想到叶开WC的论文选讲!</p><p>列GF, 设 $F(x)$ 为 $PGF$, 所求即 $F(e^x)$, $F(x)$ 应该枚举最后一次是几得到, 除了最后这次其他的元素用EGF分配时间轴上标号, $L$ 为拉普拉斯变换:</p><p>$$<br>\begin{gathered}<br>    F(x)&#x3D;L(x(e^{\frac{x}{n}}-1)^{n-1})\<br>    &#x3D;L\left(<br>        \sum_{i&#x3D;0} \binom{n-1}{i}(-1)^ix\exp(\frac{ix}{n})<br>    \right)\<br>    \because L(x\exp(\frac{ix}{n}))&#x3D;L\left(\sum_{j&#x3D;0} (\dfrac{i}{n})^j\dfrac{x^{j+1}}{j! }\right)\<br>    &#x3D;\sum_{j&#x3D;0} (\dfrac{i}{n})^j(j+1)x^{j+1}\<br>    &#x3D;\dfrac{n}{i}\sum_{j&#x3D;1}j(\dfrac{ix}{n})^j\<br>    &#x3D;\dfrac{nx}{i(1-\dfrac{ix}{n})^2}\<br>    \therefore<br>    F(x)&#x3D;\sum_{i&#x3D;0} \binom{n-1}{i}(-1)^i\dfrac{nx}{i(1-\dfrac{ix}{n})^2}<br>\end{gathered}<br>$$</p><p>我们要求 $F(e^x)$, 这里不能先求 $F$ 再复合 $e^x$ 因为 $F$ 其实是无限项 $H&#x2F;G$ 的形式, $e^x$ 有常数项 $1$ 使得后面的项有贡献, 应该先求 $H$ 和 $G$, 分别复合之后再求逆.</p><p>先求 $F$ 的话, 可以考虑求 $F(x+1)$ 的系数, 复合 $e^x-1$, 就没有刚才的问题了.</p><p>复合 $e^x$ 怎么做?</p><p>$$<br>F(e^x)&#x3D;\sum_{i&#x3D;0} f_ie^{ix}&#x3D;\sum_i f_i\sum_{j&#x3D;0} \dfrac{(ix)^j}{j! }<br>$$</p><p>$j!$ 可以最后除, 去掉之后就简单了:</p><p>$$<br>\sum_i f_i\sum_{j&#x3D;0}(ix)^j&#x3D;\sum_i \dfrac{f_i}{1-ix}<br>$$</p><p>分治FFT!</p><h3 id="ARC117E-Zero-Sum-Ranges-2"><a href="#ARC117E-Zero-Sum-Ranges-2" class="headerlink" title="[ARC117E] Zero-Sum Ranges 2"></a>[ARC117E] Zero-Sum Ranges 2</h3><p>考虑前缀和, 折线模型, 相等元素个数, dp扫序列不行自然扫值域, 则从上往下不断插入数, 插入规则是相等相邻的两个数之间必须插入至少一个, 设当前已经用了 $i$ 个数, 已经有 $j$ 对相等, 当前能插入的位置有 $k$ 个, 转移时这一层插入几个数 $c$, 则 $f_{i, j, k}\to f_{i+c, j+\binom{c}{2}, c-k-2}$($-2$ 是序列两端必须插入一个), 转移系数是 $c$ 个数放到 $k+2$ 个盒子中, 即 $\binom{c-1}{k+1}$.</p><p>然后这样求出的是所有值都在某条线上的, 于是按照 $\ge 0, &lt;0$ 部分合并即可: $\sum_{i, j, k} f_{i, j, k}f_{2n-i, K-j, k-1}$</p><p>复杂度是 $n^5$</p><h3 id="ARC096E-Everything-on-It"><a href="#ARC096E-Everything-on-It" class="headerlink" title="[ARC096E] Everything on It"></a>[ARC096E] Everything on It</h3><p>$\ge 2$ 这个 $2$ 很小, 考虑容斥, 先容斥没有选恰好一次的数的方案数:</p><p>$$<br>f_n&#x3D;\sum_c \binom{n}{c}(-1)^c \cdot 2^{2^{n-c}}\sum_i {c\brace i} 2^{(n-c)i}<br>$$</p><p>再容斥没有不选的</p><p>$$<br>\begin{gathered}<br>ans&#x3D;\sum_k \binom{n}{k}f_k (-1)^{n-k} \<br>&#x3D;\sum_{k&#x3D;0}^n \binom{n}{k} (-1)^{n-k} \sum_{c&#x3D;0}^k \binom{k}{c}(-1)^c \cdot 2^{2^{k-c}}\sum_{i&#x3D;0}^c {c\brace i} 2^{(k-c)i}\<br>a&#x3D;n-k+c\<br>ans&#x3D;\sum_{a&#x3D;0}^n (-1)^a \sum_{c&#x3D;0}^a \binom{n}{a}\binom{a}{c}2^{2^{n-a}}\sum_{i&#x3D;0}^c {c\brace i}2^{(n-a)i}\<br>&#x3D;\sum_{a&#x3D;0}^n(-1)^a2^{2^{n-a}}\binom{n}{a}\sum_{i&#x3D;0}^n2^{(n-a)i}\sum_{c&#x3D;i}^n\binom{a}{c}{c\brace i}<br>\end{gathered}<br>$$</p><p>注意 $\binom{a}{c}{c\brace i}$ 的组合意义, 即选择 $c$ 个元素再划分成 $i$ 组, 那么剩下的元素划分成一组, 再添加一个元素用来标识这个组, 即这个式子等于 ${a+1\brace c+1}$ 于是做完了.</p><h3 id="ARC119F-AtCoder-Express-3"><a href="#ARC119F-AtCoder-Express-3" class="headerlink" title="[ARC119F] AtCoder Express 3"></a>[ARC119F] AtCoder Express 3</h3><p>走的过程一定最多往回走一格切换颜色方便往后跳. 考虑已知划分的话怎么求最短路, 可以记录前 $i$ 个点中最后一个 $A&#x2F;B$ 类点(包括自己)到起点距离 $d_0, d_1$, 设当前点为 $A$ 类, 若下个点为 $A$ 类则 $d_0’&#x3D;d_0+1, d_1’&#x3D;d_1$, 否则 $d_0’&#x3D;\min(d_0, d_1+2), d_1’&#x3D;\min(d_0+1, d_1+1)$. 于是dpofdp思想可以得到一个 $n^3$ 的状态: $f_{i, j, k, c}$ 表示填到第 $i$ 个位置, $d_0, d_1$ 和当前点颜色.</p><p>感觉可能这种题都跑dfa最小化能赢. 接下来两种走法, 一种是人脑出等价且更小的自动机, 一种是发现性质, 对于一个 $A$ 类点首先总有 $d_0\ge d_1-1$ 因为当前点是由这个 $B$ 点后一格格走的. 而如果 $d_1&lt;d_0-2$, 那么以后一定直接用这个 $d_1$ 的B类点跳过去更好, 所以这样的都和 $d_&#x3D;d_0-2$ 的等价, 于是就只有 $n^2$ 状态了.</p><p>后面这个分析感觉很像小N的独立集? 但是树上问题显然不能搞dfa.</p><h3 id="P5206-WC2019-数树"><a href="#P5206-WC2019-数树" class="headerlink" title="P5206 [WC2019] 数树"></a>P5206 [WC2019] 数树</h3><p>好强的题.</p><p>想到容斥, 此时能想到对两棵树的集合容斥, 但系数不好确定, 不如对两棵树的边的交集大小容斥.</p><p>然后因为是交集求 $\sum_A\sum_B f(A\cap B)$, 我们希望有一种容斥是 $f(S)&#x3D;\sum_{T\subseteq S} f(T)c(T)$.</p><h4 id="trick"><a href="#trick" class="headerlink" title="[trick]"></a>[trick]</h4><p>$f(S)&#x3D;\sum_{T\subseteq S}\sum_{P\subseteq T}f(P)(-1)^{\vert T\vert-\vert P\vert}$.</p><p>证明:<br>$$<br>\begin{gathered}<br>&#x3D;\sum_{P\subseteq S} f(P)\sum_{T\supseteq P}(-1)^{\vert T\vert-\vert P\vert}\<br>&#x3D;\sum_{P\subseteq S} f(P)\sum_{i&#x3D;0}^{\vert S\vert-\vert P\vert} \binom{\vert S\vert-\vert P\vert}{i}(-1)^i\&#x3D;f(S)<br>\end{gathered}<br>$$</p><p>有了这个的话会很好, 比如对于subtask3:</p><p>$$<br>\begin{gathered}<br>    ans&#x3D;\sum_A \sum_B \sum_{S\subseteq A\cap B}\sum_{T\subseteq S} (-1)^{\vert S\vert-\vert T\vert}y^{n-\vert T\vert}\<br>    &#x3D;\sum_S \sum_{T\subseteq S} y^{n-\vert T\vert}(-1)^{\vert S\vert-\vert T\vert}\sum_{A\supseteq S}\sum_{B\supseteq S}\<br>    &#x3D;\sum_S F(S)^2 \sum_{T\subseteq S} y^{n-\vert T\vert}(-1)^{\vert S\vert-\vert T\vert}\<br>    &#x3D;y^{n}\sum_S F(S)^2 y^{-\vert S\vert}\sum_{T\subseteq S} (-y)^{\vert S\vert-\vert T\vert}\<br>    &#x3D;y^{n}\sum_S F(S)^2 y^{-\vert S\vert}\sum_i \binom{\vert S\vert}{i}(-y)^{\vert S\vert-i}\<br>    &#x3D;y^{n}\sum_S F(S)^2 (\dfrac{1}{y}-1)^{\vert S\vert}\<br>    let\ K&#x3D;\dfrac{1}{y}-1\<br>    ans&#x3D;y^nn^{-4}K^{n}\sum_P K^{-\vert P\vert} n^{2\vert P\vert} \prod_i p_i^2<br>\end{gathered}<br>$$</p><p>$P$ 是枚举划分, 则大小为 $i$ 的集合贡献 $\dfrac{n^2}{K}i^i$(一个有 $i^{i-2}$ 种方式组成连通块), exp即可.</p><p>对Subtask2, 把上面的转化式子抄一份下来:</p><p>$$<br>ans&#x3D;y^{n}\sum_{S\subseteq A} F(S) K^{\vert S\vert}\<br>&#x3D;y^n K^nn^{-2}\sum_{P\subseteq P_A}K^{-\vert P\vert}n^{\vert P\vert}\prod_{p_i}p_i<br>$$</p><p>树上选连通块, 大小为 $i$ 的连通块贡献 $w&#x3D;K^{-1}ni$. 考虑dpGF, 设考虑点 $u$ 子树, $u$ 所在连通块为 $i$ 的方案数为 $[x^i]H_u$(常数为 $0$)转移是 $H_u: &#x3D;H_uH_v+KH_v’(1)H_u$(第一个是并入连通块, 第二个是这里断开乘上贡献), 对这个式子求导带入1得到:</p><p>$$<br>H_u’(1)&#x3D;H_u’(1)H_v(1)+H_v’(1)H_u(1)+KH_v’(1)H_u’(1)<br>$$</p><p>答案只要用到 $H_1(1)$, 于是只要维护 $H’_u(1)$ 和 $H_u(1)$ 即可做到线性. 可以用来维护转移是GF, 最后要点值的dp.</p><h3 id="AGC058D-Yet-Another-ABC-String"><a href="#AGC058D-Yet-Another-ABC-String" class="headerlink" title="[AGC058D] Yet Another ABC String"></a>[AGC058D] Yet Another ABC String</h3><p>GF熟练题, 容斥好题.</p><p>首先最好想的做法是, 建出一个简单的DFA去匹配这 $3$ 个串, 每个点设一个 $3$ 元GF $F_i(x, y, z)$, 可以简化到 $3$ 个GF方程, 转移很好写, 就是要解一个很麻烦的GF方程再很麻烦的提取系数.</p><p>更简单的做法是直接GF凑容斥系数, 题目相当于可以用若干个长度不超过 $2$ 的连续段拼出这个序列, 设长 $i$ 的段系数为 $a_i$, 我们希望 $\dfrac{1}{1-(\sum_i a_ix^i)}&#x3D;1+x+x^2$, 设 $a_i$ 的GF为 $A$. 然后是求 $\dfrac{1}{1-B(x, y, z)}$, $[x^iy^jz^k]B&#x3D;[x^{i+j+k}]a$.</p><p>更简单的容斥, 容易想到对极长的段 $l, r$ 容斥, 其中 $[l, r]$ 是 $abc$ 不断循环的区间, 但只对这样的段的个数容斥的话, 其实方案数很好求, 因为只要确保段长大于等于 $3$, 可以直接组合数.</p><h3 id="ARC100F-Colorful-Sequences"><a href="#ARC100F-Colorful-Sequences" class="headerlink" title="[ARC100F] Colorful Sequences"></a>[ARC100F] Colorful Sequences</h3><p>拆贡献! 考虑 $[p, p+M]$ 恰为 $A$ 的满足第一个限制的序列数量. 那么分类:</p><ul><li>$A$ 包含长 $k$ 两两不同的子区间: 显然.</li><li>$A$ 中有相同元素, 设极长无相同元素的前缀, 后缀为 $a, b$, 容斥求不合法的, 设 $f_{i, j, 0&#x2F;1}$ 表示从 $p+M+1$ 或 $p-1$ 开始, 长 $j$ 的区间包含 $j$ 种不同的元素, 且不出现长 $k$ 的互不相同段的方案数, 初始状态 $(0, p)&#x3D;1, (0, q)&#x3D;1$, 是否已经存在满足要求的区间, dp完了卷起来即可.</li><li>$A$ 中无相同元素但长度不足 $k$, 此时所有长度相同的 $A$ 本质相同, 此时发现不如不钦定位置, 直接算一个序列长度等于 $m$ 的合法区间的个数的期望, 设 $f_{i, j}, g_{i, j}$ 分别表示方案数和期望即可.</li></ul><h3 id="CF1086F-Forest-Fires"><a href="#CF1086F-Forest-Fires" class="headerlink" title="CF1086F Forest Fires"></a>CF1086F Forest Fires</h3><p>应该是典的了, 考虑矩形并可以写成容斥的式子, 而任意个矩形的交也是一个不断扩散变大的矩形, 随时间也是二次函数, 于是某个时刻 $t$ 的格子个数就会了, 而最后答案就是对这个时间区间求和, 也就变成三次函数, 做完了, 拉插即可. 分段函数当且仅当两个矩形出现交的 $n^2$ 个时间点变化.</p><h3 id="P7468-NOI-Online-2021-提高组-愤怒的小-N"><a href="#P7468-NOI-Online-2021-提高组-愤怒的小-N" class="headerlink" title="P7468 [NOI Online 2021 提高组] 愤怒的小 N"></a>P7468 [NOI Online 2021 提高组] 愤怒的小 N</h3><p>感觉这个作差推式子的思路不太熟.</p><p>容易想到dp, 设 $A_i(x)$ 表示迭代 $i$ 次后, 设 $a$ 位置集合为 $S$, $\sum_{i\in A}f(i+x)$ 的值, 同理设 $B_i(x)$, 有 $A_{i+1}(x)&#x3D;A_i(x)+B_i(x+2^i), B_{i+1}(x)&#x3D;B_i(x)+A_i(x+2^i)$, 但是直接做是 $nk^2$(最多大常数 $nk\log n$)的.</p><p>此时, 因为式子形式对称又线性, 考虑作差, $D_{i+1}(x)&#x3D;A_{i+1}(x)-B_{i+1}(x)&#x3D;A_i(x)-B_i(x)-A_i(x+2^i)+B_i(x+2^i)&#x3D;D_i(x)-D_i(x+2^i)$, 而重点是, 这样做一定会消掉最高次项, 于是迭代 $k$ 次后就 $D(x)&#x3D;0$.</p><p>可以 $n^3$ 算出所有 $D$, 而我们要求的是若干段 $A$ 的值, 我们知道 $A_i(x)+B_i(x)&#x3D;\sum_j^{2^i}f(x+j)$, $A+\dfrac{A+B+D}{2}$, $D$ 已经解决, 只要求 $A+B$, 简答画式子得到就是 $\sum_{i&#x3D;0}^N f(i)$, 于是拉插做完了.</p><p>[trick] 作差是关键一步, 对形式对称的递推式考虑其和, 差式子的递推式.</p><h3 id="ARC142D-Deterministic-Placing"><a href="#ARC142D-Deterministic-Placing" class="headerlink" title="[ARC142D] Deterministic Placing"></a>[ARC142D] Deterministic Placing</h3><p>容易发现一定是来会跳, 但要想到对于若干条不交的链跳起来互不影响, 于是就算求把树划分成若干条链的带权方案数, 有 $k$ 条链的权值为 $2^k$.</p><p>有了这个后下面的是模板树形dp, 有点讨论, 复杂度线性.</p><h3 id="ARC111F-Do-you-like-query-problems"><a href="#ARC111F-Do-you-like-query-problems" class="headerlink" title="[ARC111F] Do you like query problems?"></a>[ARC111F] Do you like query problems?</h3><p>[think] 既想着序列上拆期望贡献, 值域上拆期望也别忘了.</p><p>困难是某次求和可能和前面一个遥远的位置有关, 考虑拆贡献, 每个位置单独计算, 且按值域拆成是否大于 $i$, 然后写式子就行了.</p><h3 id="ABC241Ex-Card-Deck-Score"><a href="#ABC241Ex-Card-Deck-Score" class="headerlink" title="[ABC241Ex] Card Deck Score"></a>[ABC241Ex] Card Deck Score</h3><p>简单题, 显然多项式是</p><p>$$<br>\prod_i \dfrac{1-(a_ix_i)^{b_i+1}}{1-(a_ix_i)}<br>$$</p><p>于是分子分母乘起来, 分子只有 $2^16$ 项, 每项要想贡献到 $[x^m]$ 对应的分母那项是确定的, 也就是 $2^16$ 个对 $\prod_i \dfrac{1}{1-(a_ix_i)}$ 求远处系数的询问, 显然部分分式做完了.</p><h3 id="ARC135E-Sequence-of-Multiples"><a href="#ARC135E-Sequence-of-Multiples" class="headerlink" title="[ARC135E] Sequence of Multiples"></a>[ARC135E] Sequence of Multiples</h3><p>显然 $a_i&#x3D;\lfloor \dfrac{a_{i-1}}{i}\rfloor i+i$ 考虑 $b_i&#x3D;\dfrac{a_i}{i}$, 则 $b_i&#x3D;1+\lfloor \dfrac{b_{i-1}(i-1)}{i}\rfloor&#x3D;b_{i-1}+1-\lceil \dfrac{b_{i-1}}{i}\rceil$, 于是 $b_{i-1}-b_i&#x3D;\dfrac{b_{i-1}}{i}-1$, 是不增的(上取整). 分析 $b$ 的上界, $a_i\le x+\sum_{j&#x3D;2}^i j\le x+i^2$, $b_i\le \dfrac{x}{i}+i$, 于是 $b_i-i$ 是有根号分治的, 但数据范围看起来要整到 $\sqrt[3] n$.</p><p>[trick] $\dfrac{x}{i-1}-\dfrac{x}{i}$ 的不同值的个数是 $\sqrt[3] n$ 的, 通分一下和 $\dfrac{x}{i^2}$ 是同级的.</p><p>于是就做完了.</p><p>见到这种玩意打表找规律就对了&#x2F;fn另外就是没规律就差分.</p><h3 id="ARC093F-Dark-Horse"><a href="#ARC093F-Dark-Horse" class="headerlink" title="[ARC093F] Dark Horse"></a>[ARC093F] Dark Horse</h3><p>显然每个位置概率相等, 钦定你在 $1$, $1$ 的祖先上会进行 $N$ 次比赛, 而且这些点之中编号小的胜利, 也就是剩下的点大小为 $1\ldots 2^{n-1}$ 的组, 每组的最小值不为 $A_i$. 考虑容斥, 钦定一个最小值相当于一个值域限制. 从小到大填数, $f_{i, S}$ 表示填前 $i$ 大的数, $S$ 中的组填过数(最小值确定), 问题是不能把剩余大小设进去, 于是想每次填满一整组, 于是从大往小dp, 每次可以选择把当前 $A_i$ 填到一个组中并把剩下元素选了, 或者什么也不做等着被更小的 $A$ 塞到组里.</p><p>复杂度 $2^nnm$</p><h3 id="AGC058F-Authentic-Tree-DP"><a href="#AGC058F-Authentic-Tree-DP" class="headerlink" title="[AGC058F] Authentic Tree DP"></a>[AGC058F] Authentic Tree DP</h3><p>很神奇的东西啊</p><p>给奇怪的式子找一个组合意义, 乘法看成概率, 则它描述了删一条边, 剩余两个连通块分别满足性质的概率, 区别是分母应该是 $n-1$, 若是则答案是 $1$, (把一棵树删空的概率). 两边的问题是独立的,</p><p>于是考虑给点&#x2F;边赋权让系数总和是 $n$ 且仍然有组合意义, 改成删点, 每个点有 $1$ 的权重, 每个边建一个点有 $1$ 的权重, 边点挂一个点有 $-1$ 的权重, 满足了权重和是 $n$. 显然原图上一组删边方案等价于在新图上每次删一个边点的方案, 只要保证边点比相邻的点先删. 所以答案就是这个条件(边点比周围点先删)的概率.</p><p>树上双向边拓扑序计数, 容斥典题.</p><h3 id="ABC236Ex-Distinct-Multiples"><a href="#ABC236Ex-Distinct-Multiples" class="headerlink" title="[ABC236Ex] Distinct Multiples"></a>[ABC236Ex] Distinct Multiples</h3><p>考虑容斥, 钦定若干集合相等, 考虑容斥系数.</p><p>一个集合可能被小集合任意组合得到, 而最后只有大小为 $0$ 和 $1$ 的系数是 $1$ 其他的是 $0$, 所以大小为 $i$ 的集合系数是 $[x^i]\ln(1+x)&#x3D;(-1)^{i-1}(i-1)!$.</p><p>则可以算出每个相等集合的方案数, 再集合幂级数exp一下就好了.</p><h3 id="P5576-CmdOI2019-口头禅"><a href="#P5576-CmdOI2019-口头禅" class="headerlink" title="P5576 [CmdOI2019] 口头禅"></a>P5576 [CmdOI2019] 口头禅</h3><p>建广义SAM, 则一个点的endpos出现的串形成若干连续段, 一开始连续段数显然 $O(n)$, 用set维护, 启发式合并连续段复杂度是 $n\log n\log v$, 每次合并出新连续段($O(n)$ 次)更新答案(显然只有每个连续段第一次合并出来的时候有贡献因为越浅越短).</p><p>另一个做法基于一个结论:</p><p>[trick] 广义SAM中设点 $i$ 出现的字符串的集合为 $S_i$, 则 $\sum_i \vert S_i\vert&#x3D;O(n\sqrt n)$.</p><p>于是扫描线, 维护当前 $r$ 的每个向左的连续段, 暴力更新所有含有 $r$ 的端点即可.</p><h3 id="P9167-省选联考-2023-城市建造"><a href="#P9167-省选联考-2023-城市建造" class="headerlink" title="P9167 [省选联考 2023] 城市建造"></a>P9167 [省选联考 2023] 城市建造</h3><p>我怎么会没写过这个的题解?</p><p>选出点集使得删掉这些点之间的边后每个点恰在一个连通块且限制连通块大小.</p><p>考虑性质, 原来的一个连通块只有一个点向外连边, 这个点一定是割点, 一个点双一定属于同一个连通块, 割点所在的所有点双中只有一个中全是连通块中点, 其他的不能是当前连通块的点, 得到结论其他的每个都是一个割点. 即被删的点集也恰好是若干完整点双.</p><p>于是建圆方树, 要求删若干方点使得剩下的圆点构成连通块, 连通块大小满足限制.</p><p>发现重心一定会被删, 考虑如果不删重心一定有一棵子树大于一半, 所以以它为根, 这样每个连通块都是一个子树, 这就很好.</p><p>于是对于 $k&#x3D;0$, 枚举子树大小 $s$, 对当前 $u$ 的某个儿子子树 $\ge s$ 一定要删, 儿子子树小于 $s$ 则一定不能删, 方案唯一.</p><p>对 $k&#x3D;1$ 枚举子树大小 $s, s+1$, 同理有 $&lt;s$ 一定不删 $&gt;s$ 一定删, 但如果 $&#x3D;s$ 可以留着让连通块大小是 $t+1$, 只能留一个, 枚举留哪个等于 $s$ 的儿子剩下的也都要删.</p><p>现在单次复杂度线性, $k&#x3D;0$ 复杂度 $nd(n)$, $k&#x3D;1$ 复杂度 $n\sqrt n$.</p><p>todo</p><h3 id="P8571-JRKSJ-R6-Dedicatus545"><a href="#P8571-JRKSJ-R6-Dedicatus545" class="headerlink" title="P8571 [JRKSJ R6] Dedicatus545"></a>P8571 [JRKSJ R6] Dedicatus545</h3><p>AC机可以 $O(\vert s\vert+\sum \vert t\vert)$ 的算匹配, 具体的, 不断跳转移边, 则当前点parent tree上祖先中的终止节点都会被匹配.</p><p>长于根号的串直接每个跑一遍匹配+建线段树</p><p>短于根号的串, ac机上会标 $\sqrt n$ 个节点, 相当于 $\sqrt n$ 个询问到根的链上编号在 $[l, r]$ 的终止节点个数, 那么再转到dfs序上, 就是矩形加单点和, 用 $O(\sqrt n)-O(1)$ 的分块秒了.</p><p>然后这个复杂度看起来很爆炸? 但设块长为 $B$, 其实是平衡 $\dfrac{l}{B}n+qB$, 平均起来2e5的样子.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转置原理</title>
      <link href="/2024/01/04/transposition/"/>
      <url>/2024/01/04/transposition/</url>
      
        <content type="html"><![CDATA[<h1 id="转置原理"><a href="#转置原理" class="headerlink" title="转置原理"></a>转置原理</h1><p>其实两年前就集训听过了但是懂了0</p><p>向量用小写字母, 矩阵用大写字母</p><p>基本内容是对于一个问题给定 $v$ 计算 $vM$ 的问题, 考虑如果给定 $v$ 计算 $vM^T$ 的转置问题是容易的就可以直接改造出一个复杂度相同的算法计算原问题.</p><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>要求算法是线性的, 可以表示成上面的计算 $vM$ 的形式, 或者具体的对于输入的 $v$, 算法全程没有关于 $v$ 的判断类语句, 所有关于 $v$ 的运算都是赋值和线性运算.</p><h2 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h2><p>一个非奇异矩阵 $M$ 可以拆成若干个初等矩阵的积 $M&#x3D;E_1E_2\ldots E_k$, 则 $M^T&#x3D;E_k^TE_{k-1}^k\ldots E_1^k$, 于是只要转置每一步并倒序算法.</p><p>对于不同的初等矩阵的转置($v$ 为输入向量, 其他均为常数):</p><ul><li>交换 $v_i, v_j$: 不变</li><li>$v_i&#x3D;cv_i$: 不变</li><li>$v_i&#x3D;v_i+cv_j$: $v_j&#x3D;v_j+cv_i$</li><li>$v_i&#x3D;v_j$: 先拆成 $v_i&#x3D;0v_i, v_i&#x3D;v_i+v_j$, 于是得到 $v_j&#x3D;v_j+v_i, v_i&#x3D;0$</li><li>$v_i&#x3D;c$, 在 $v$ 中增加一个常数, $v_i&#x3D;0v_i, v_i&#x3D;v_i+v_j$, 后果是 $v_i&#x3D;0$</li></ul><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>就是列出那个矩阵然后翻转一下.</p><p>比如DFT就是翻转范德蒙德矩阵($M_{i, j}&#x3D;w^{ij}$), 翻了等于没翻, 所以计算的是原问题.</p><p>常见形式是BGF的矩阵($M_{i, j}&#x3D;[x^iy^j]F(x, y)$)乘向量, 如计算 $f_i&#x3D;\sum_i a_i[x^iy^j]F(x, y)$, 翻转后的问题变为计算 $f_i&#x3D;\sum_i a_i[x^jy^i]F(x, y)$</p><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><h3 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h3><p>刚才说了DFT翻了等于没翻, 所以计算的是原问题, 那么把它改造成翻转之后因为顺序反转位逆序变换变成最后一步, 不翻转的IDFT的第一步也是位逆序变换, 就抵消了, 就不需要变换了.</p><h3 id="多点求值"><a href="#多点求值" class="headerlink" title="多点求值"></a>多点求值</h3><p>等于计算 $fM$, 其中 $f_i&#x3D;[z^i]F(z)$, $M_{i, j}&#x3D;x_j^i$, 那么转置问题是计算 $fA$, 其中 $A_{i, j}&#x3D;x_i^j$, 也就是对每个 $i$ 计算 $\sum_j f_jx_j^i&#x3D;[z^i] \sum_j\dfrac{f_j}{1-x_jz}$, 那么后面这个直接分治FFT维护分子分母通分累加就能计算, 再把刚才的算法改造成转置的就是原问题算法了.</p><h3 id="Do-Use-FFT-Gym102978D"><a href="#Do-Use-FFT-Gym102978D" class="headerlink" title="Do Use FFT Gym102978D"></a>Do Use FFT Gym102978D</h3><blockquote><p>给定序列 $a_n, b_n, c_n$, 对每个 $k$ 求</p><p>$$<br>f_k&#x3D;\sum_{i&#x3D;1}^nc_i\prod_{j&#x3D;1}^k(a_i+b_j)<br>$$<br>$n\le 2\times 10^5$</p></blockquote><p>把 $c$ 作为输入向量, 则矩阵为 $M_{i, j}&#x3D;\prod_{k&#x3D;1}^j(a_i+b_k)$, 转置之后 $M_{i, j}&#x3D;\prod_{k&#x3D;1}^i(a_j+b_k)$, 相当于计算<br>$$<br>f_k&#x3D;\sum_{i&#x3D;1}^nd_i\prod_{j&#x3D;1}^i(a_k+b_j)<br>$$</p><p>相当于计算多项式 $\sum_{j&#x3D;1}^nd_i\prod_{j&#x3D;1}^i(x+b_j)$ 带入每个 $a_k$ 的值, 只要分治FFT+多点求值都转置一下就行了.</p><h3 id="P7440-「KrOI2021」Feux-Follets"><a href="#P7440-「KrOI2021」Feux-Follets" class="headerlink" title="P7440 「KrOI2021」Feux Follets"></a>P7440 「KrOI2021」Feux Follets</h3><blockquote><p>设 $\text{cyc}_\pi$ 将长为 $n$ 的排列 $\pi$ 当成置换时所能分解成的循环个数. 给定两个整数 $n, k$ 和一个 $k-1$ 次多项式 $G(x)$, 对 $1\leq m\leq n$ 求:</p><p>$$<br>\sum\limits_{\pi}G(\text{cyc}_{\pi})<br>$$</p><p>其中 $\pi$ 是长度为 $m$ 且不存在位置 $i$ 使得 $\pi_i&#x3D;i$ 的排列.</p></blockquote><p>先写GF, 考虑排列个数是 $\dfrac{1}{1-x}$, 对环做exp应该得到排列, 一个环的就是 $\ln(\dfrac{1}{1-x})$, 去掉自环减去 $x$, 再带上另一个元 $exp$ 回去得到BEGF:</p><p>$$<br>F(x, y)&#x3D;\exp(y(\ln(\dfrac{1}{1-x})-x))<br>$$</p><p>则要求</p><p>$$<br>\sum_i G(i)[x^my^i]F(x, y)<br>$$</p><p>转置就是</p><p>$$<br>\sum_i G(i)[x^iy^m]F(x, y)<br>$$</p><p>考虑<br>$$<br>\begin{gathered}<br>    F(x, y)&#x3D;\dfrac{(\dfrac{1}{1-x})^y}{e^{xy}}\<br>    \dfrac{\delta F}{\delta x}&#x3D;\dfrac{xyF}{1-x}<br>\end{gathered}<br>$$</p><p>于是设 $H_i(x)&#x3D;[x^i]F(x, y)$, 同时提取 $x^{n-1}$ 的系数有 $nH_{n}&#x3D;(n-1)H_{n-1}+yH_{n-2}$, 则设转移矩阵是 $T$, 相当于求</p><p>$$<br>\sum_{i&#x3D;0}^m G(i)[y^m]H_0T_1\ldots T_i<br>&#x3D;[y^m]\sum_{i&#x3D;0}H_0T_1\ldots T_iG(i)<br>$$<br>然后分治计算, 维护区间的矩阵乘积 $S$ 和贡献 $V$, 则 $S_{l, r}&#x3D;S_{l, mid}\times S_{mid+1, r}, V_{l, r}&#x3D;V_{l, mid}+S_{l, mid}V_{mid+1, r}$, 最后算出一个多项式取第 $m$ 项即可.</p><h4 id="trick"><a href="#trick" class="headerlink" title="[trick]"></a>[trick]</h4><p>上面最后的问题, 是已知BGF $F(x, y)$, 求 $\sum_ia_i[x^iy^n]F(x, y)$, 此时若 $F$ 在 $x$ 上微分有限则可以写出关于 $[x^i]F$ 的递推式, 然后按照上文的方法分治做.</p><h3 id="Loj3640集训队互测-细菌"><a href="#Loj3640集训队互测-细菌" class="headerlink" title="Loj3640集训队互测 细菌"></a>Loj3640集训队互测 细菌</h3><blockquote><p>求从 $a, b, c$ 开始走 $d$ 步不走出 $n\times m\times k$ 的长方体的方案数</p><p>$a, b, c, n, m, k, d\le 1\times 10^5$</p></blockquote><p>首先显然可以卷起每一维的, 而一维的方案数可以反射容斥, 设以 $i$ 为终点的路径的容斥系数是 $c_i$, 则走 $n$ 步的方案数为 $f_n&#x3D;\sum_i c_i[x^i] (x+x^{-1})^n&#x3D;c_i[x^iy^n]\dfrac{1}{1-y(x+x^{-1})}$, 转置后是 $c_i[x^ny^i]\dfrac{1}{1-y(x+x^{-1})}&#x3D;c_i[x^n] (x+x^{-1})^i&#x3D;[x^n]c_i(x+x^{-1})^i$, 也就是 $f$ 的OGF相当于 $c$ 的OGF复合 $x+x^{-1}$.</p><h4 id="trick-二次式的复合"><a href="#trick-二次式的复合" class="headerlink" title="[trick]二次式的复合"></a>[trick]二次式的复合</h4><p><a href="https://www.luogu.com.cn/blog/Fly37510/FUHE-ERCIFENSHI">参考</a></p><ul><li>复合普通二次函数 $ax^2+bx+c$ 可以先配方成 $a(x+b’)^2+c’$, 而算 $F(x^2)$ 和 $F(x+c)$ 都是简单的.</li><li>对于 $\dfrac{1}{ax^2+bx+c}$ 的情况可以先算 $x^{k}F(\dfrac{1}{x})$($k$ 为多项式次数)也就是直接把多项式系数翻转, 再按照上面的方法复合.</li><li>对于 $F(\dfrac{x^2}{ax^2+bx+c})$ 可以先翻转变成要算 $F_R(\dfrac{c}{x^2}+\dfrac{b}{x}+a)$ 而这个等于 $F_R(cx^2+bx+a)$ 复合 $\dfrac{1}{x}$.</li><li>对于剩下的就一般二次式配方可以变成 $F(\dfrac{(x+e)^2}{ax^2+bx+c}+d)$ 的形式, 先复合 $x+d$ 再复合里面的最后复合 $x+e$ 即可.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 多项式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南外省选集训</title>
      <link href="/2023/12/11/nflssxjx/"/>
      <url>/2023/12/11/nflssxjx/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP后南外省选集训"><a href="#NOIP后南外省选集训" class="headerlink" title="NOIP后南外省选集训"></a>NOIP后南外省选集训</h1><h2 id="NOI2024省选训练赛5"><a href="#NOI2024省选训练赛5" class="headerlink" title="NOI2024省选训练赛5"></a>NOI2024省选训练赛5</h2><h3 id="A-两棵树"><a href="#A-两棵树" class="headerlink" title="A. 两棵树"></a>A. 两棵树</h3><p>原题是BZOJ crash和陶陶的游戏</p><blockquote><p><img src="/img/2023-12-12-18-57-55-image.png" alt="picture 0">  </p><p>$n\le 10^5$</p></blockquote><p>考虑加入一个 $A$ 树的叶子对答案的贡献是 $B$ 中的祖孙链上的子串数, 更好的是 $A$ 这个叶子作为 $B$ 字典树上的后缀的个数, 加入 $B$ 的叶子相当于对 $A$ 的字典树的一条从根的链求和.</p><p>具体的考虑如何解决 $A$, 相当于求字典树的子串出现次数, 相当于阿狸的打字机带修. 或者考虑直接求出 $B$ 字典树上所有字符串的字典序排序, 这样包含一个串的一定是一个后缀, 就是区间问题了.</p><p>考虑如何解决 $B$, 需要先匹配一下 $B$ 这个叶子往上跳多远还在 $A$ 里, 然后随便求和.</p><p>于是可以维护出 $B$ 中每个点 $u$ 向上跳 $2^i$ 步的hash值, 这个可以同时用于求字典序排序和 $B$ 这个叶子往上跳多远的问题.</p><h3 id="B-头文字-O"><a href="#B-头文字-O" class="headerlink" title="B. 头文字 O"></a>B. 头文字 O</h3><blockquote><p>你在无限的数轴上从 $0$ 开始随机游走 $n$ 步, 每次位置 $+- 1$, 由 $m$ 个给定的区间, 若你的路径中存在一段以 $s_i$ 开头, $t_i$ 结尾则会获得 $v_i$ 价值, 求价值期望.</p><p>$n\le 2\times 10^5, m\le 5\times 10^5$</p></blockquote><p>一眼反射容斥.</p><p>然后做这个题的时候以为它数轴有界, 这时候两边都要反射情况有点多.</p><p>首先期望线性性, 对每个 $s, t$ 算, 如果 $s&lt;0$ 你可以把 $s, t$ 都取负, 如果 $t&lt;s$ 可以把 $t$ 对称到另一边,<strong>这样走到 $s$ 之后的路径对称构成双射</strong>.</p><p>于是很棒的, $0&lt;s&lt;t$, 这意味着我们只用管经过 $t$ 这个条件, 这就先求不经过 $t$ 的, 枚举终点后是经典反射容斥, 对所有终点累加是上指标均为 $n$ 的组合数之和, 前缀和即可.</p><p>如果没有观察到双射怎么处理, 那就枚举一个步数 $l$, 先走到 $s$ 的方案数和从 $s$ 出发走 $l$ 步不经过 $t$ 的方案数卷起来, 硬推组合式应该也能做.</p><h3 id="C-慈善"><a href="#C-慈善" class="headerlink" title="C. 慈善"></a>C. 慈善</h3><blockquote><p><img src="/img/2023-12-12-19-29-50-image.png" alt="picture 1">  </p><p>$n, m\le 2\times 10^5, C, a, b, c, d\le 10^{18}$</p></blockquote><p>考虑一些dp, 比如 $f_{i, j, k}$ 表示 $i$ 时刻两人收益分别为 $j, k$, 然后你会想到相当于维护点集 $(j, k)$, 在处理两人一起抽卡的时候应该发现维护 $k-j, k$ 比 $j, k$ 好, 然后三种情况(小H抽, 小X抽, 一起抽)就是点集和向量做闵和, 然后你又想到点集其实只有 $y$ 最大的有用也就成了函数, 于是开始维护函数.</p><p>那么设这个时间段长为 $t$, 小H抽卡是和 $(t, t)$ 做闵和, 小X抽卡是和 $(-t, 0)$ 做闵和, 同时抽卡是一部分点和 $(t, 0)$, 一部分点和 $(2t, 0)$ 做闵和.</p><p>考虑如何维护这个分段函数直接维护显然做不了, 发现这个函数可以分成若干段, 其中每一段中的点是经由相同的转移过来的, 值相同, 而段的端点就可以代表这个走的过程, 设左右端点分别是 $(l, y_1), (r, y_2)$, 这个段内的点 $(x, y)$ 可能是由左边放弃若干X抽卡得到 $(x, y_1)$, 也可能是右边放弃若干H抽卡得到 $(x, y_2-r+x)$, 也就是一个段内的点是它俩取 $max$ 得到, 于是我们只维护关键点的 $y$ 值即可, 则 $-t$ 和 $t, t$ 可以直接平移和全局加, 而第三种操作会让 $[-C, C]$ 内的点路径和两边的不同, 于是要新插入 $C, -C$ 作为关键点, 然后给它们之内的点整体加.</p><p>可以写平衡树, 也可以先模拟一遍操作 $1, 2$ 的平移得到关键点实际上应该都插入到哪用线段树.</p><h3 id="D-卡牌高手"><a href="#D-卡牌高手" class="headerlink" title="D. 卡牌高手"></a>D. 卡牌高手</h3><blockquote><p>背包, 第 $i$ 种物品有 $c_i$ 种体积为 $w_i$, $m$ 次操作单点修改 $c$ 或者询问编号在 $[l, r]$ 中的物品的多重集体积和不超过 $k$ 的有多少种.<br>$n, m, w_i\le 5000$, 任意时刻 $\sum_i c_iw_i\le 5000$</p></blockquote><p>显然让你卷区间的 $\dfrac{1-x^{w_i(c_i+1)}}{1-x^{w_i}}$</p><p>赛时没注意到任意时刻那部分, 对着加起来的ln不会优化exp.</p><p>于是可以直接线段树维护点值, 然后每次询问都乘起来做一次idft, 复杂度是 $8192(n+m\log n+m\log 8192)$</p><p>此外, 求点值不如直接把单位根带到封闭形式里.</p><p>极度卡常, 不如暴力</p><h2 id="NOI2024省选训练赛6"><a href="#NOI2024省选训练赛6" class="headerlink" title="NOI2024省选训练赛6"></a>NOI2024省选训练赛6</h2><p>A, C, D是<a href="https://fireinicecode.github.io/2022/10/10/contest-records/#ZSTEST230830">之前做过的模拟赛大原题</a></p><h3 id="B-最大战略储备"><a href="#B-最大战略储备" class="headerlink" title="B 最大战略储备"></a>B 最大战略储备</h3><p>原题是 P4809 [CCC2018] 最大战略储备</p><blockquote><p>有 $N$ 个星球, 编号为 $1\ldots N$. 每个星球有 $M$ 座城市, 编号为 $1\ldots M$. 我们将 $e$ 星球上的城市 $f$ 记作 $(e, f)$.</p><p>有 $N\times P$ 条双向航线, 对于每个星球 $e(1\le e\le N)$, 有 $P$ 条航线, 编号为 $1$ 到 $P$. 第 $i$ 条航线连接城市 $(e, , a_i)$ 和 $(e, , b_i)$, 且每天需要花费 $c_i$ 的代价维护.</p><p>有 $M\times Q$ 个双向港口. 对于所有编号为 $f(1\le f\le M)$ 的城市, 有 $Q$ 个港口, 编号为 $1$ 到 $Q$. 第 $j$ 个港口可以连接城市 $(x_j, , f)$ 和 $(y_j, , f)$, 且每天需要花费 $z_j$ 的代价维护.</p><p>现在需要拆除一些港口和(或)取消一些航线, 使得城市之间仍能保持联通, 且节省的代价之和最大.</p><p>对于全部的数据, $1\le N, , M, , P, , Q\le10^5$.</p></blockquote><p>考虑把 $(e, f)$ 画成一个网格, 则一开始每行连的边相同, 每列连的边相同, 那么可以先分别求出最小生成树.</p><p>现在把两个的最小生成树的边合到一起排序从小到大加边, 一次加一排有环的跳过显然就是对的, 一个很显然的结论是若与当前加边方向不同的边加了 $x$ 条, 当前方向本来要加 $n$ 条, 则现在只要加 $n-x$ 条, 就是因为与当前方向不同的每加一次相当于减少一列点, 于是就做完了.</p><h2 id="ICPC模拟赛2"><a href="#ICPC模拟赛2" class="headerlink" title="ICPC模拟赛2"></a>ICPC模拟赛2</h2><p>看起来是 2023牛客暑期多校训练营9</p><h3 id="E-Puzzle-Square-Jam"><a href="#E-Puzzle-Square-Jam" class="headerlink" title="E. Puzzle: Square Jam"></a>E. Puzzle: Square Jam</h3><blockquote><p>$n \times m$ 网格, 划分成正方形使得没有任何一个点和四个正方形相邻.</p></blockquote><p>简单想想发现每次都取短边长度贴着一边放即可递归下去辗转相减.</p><p>坐标输出反了wa了一发&#x2F;fn</p><h3 id="D-Non-Puzzle-Error-Permutation"><a href="#D-Non-Puzzle-Error-Permutation" class="headerlink" title="D. Non-Puzzle: Error Permutation"></a>D. Non-Puzzle: Error Permutation</h3><blockquote><p>给定长度为 $n$ 的排列, 计算有多少个子区间满足子区间第 $k$ 小的数不在<br>子区间第 $k$ 位. $n \le 5000$.</p></blockquote><p>考虑枚举左端点和区间内一个点, 要使得这个点不在第 $k$ 位, 考虑其限制右端点不能在一个区间, 这个区间的限制也就是区间内有几个比它小的数, 直接预处理出小于 $i$ 的数的位置 $p_{i, \ldots}$ 和 $i$ 在小于 $j$ 的数中是从前到后第几个 $id_{j, i}$, $n^2$</p><p>多测清空没清干净wa了两发&#x2F;fn</p><h3 id="I-Non-Puzzle-Segment-Pair"><a href="#I-Non-Puzzle-Segment-Pair" class="headerlink" title="I. Non-Puzzle: Segment Pair"></a>I. Non-Puzzle: Segment Pair</h3><blockquote><p>给定 $n$ 对区间 $l_i, r_i, l_i’, r_i’$, 每对中选择一个使得所有选择的至少包含一个公共点, 问方案数.</p><p>$n\le 5\times 10^5$</p></blockquote><p>首先最后的交肯定是个区间, 那么考虑直接计算包含某一点有多少种方法, 这个只要算有多少对区间的交&#x2F;并包含当前点, 但这样会算重, 考虑钦定当前点是最后交的左端点, 这样只要减掉同时包含 $i, i-1$ 的就做完了.</p><p>下标偏了一位wa了三发.</p><h3 id="G-Non-Puzzle-Game"><a href="#G-Non-Puzzle-Game" class="headerlink" title="G. Non-Puzzle: Game"></a>G. Non-Puzzle: Game</h3><blockquote><p>Alice 和 Bob 博弈, Alice先手. 黑板上原有 $n$ 个数 $a_i$, 每次当前行动方可以选择一对 $(i, j)$, 并在黑板上写上 $a_i \mathrm{xor} aj$. 先写下 $k$ 的人胜利. 问博弈结果, 或者平局(无穷局下两人谁也不会写出 $k$).</p><p>$n\le 10^6, a_i\le 2^{30}$</p></blockquote><p>考虑拿到 $k$ 前的那一步显然谁走那一步谁就输, 所以大家会不断开摆进行无效操作(重复之前的某次操作即可), 那么要想不平只有大家都没有之前的步子可重复的清空, 即只要判定Alice能不能第一步直接获胜和有没有Alice不管怎么走Bob第二步直接获胜, 第一个判定显然, 第二个判定就等价于 $a_i\mathrm{xor} a_j&#x3D;a_p\mathrm{k}\Rightarrow (a_i\mathrm{xor} k) \mathrm{xor}(a_j\mathrm{xor} k)&#x3D;a_p\mathrm{xor} k$, 于是就是判定 ${a_i}$ 在异或 $k$ 下封闭, 只要求线性基然后判断不同元素个数是否是能表示的所有数.</p><p>[trick] 利用异或性质写式子.</p><h3 id="F-Non-Puzzle-The-Lost-Array"><a href="#F-Non-Puzzle-The-Lost-Array" class="headerlink" title="F. Non-Puzzle: The Lost Array"></a>F. Non-Puzzle: The Lost Array</h3><blockquote><p>对于序列 $a_n$, 令 $num_i$ 表示数字 $i$ 出现的次数, 统计满足条件的序列个数:</p><ul><li>$1 \leq a_i \leq m$</li><li>给定一些 $x_i, y_i$, 满足 $a_{x_i} \neq y_i$</li><li>给定一些 $x_i, y_i$, 满足 $num_{x_i} \neq y_i$.</li><li>将 $num$ 排序后, 得到一给定序列 $B$.</li></ul><p>$n\le 16, m\le 30$</p></blockquote><p>正经人dp肯定是扫值, $f_{i, S, T}$ 表示当前扫了前 $i$ 个数, 能填的位置集合还有 $S$, 剩下还没填的值的出现次数的多重集是 $T$, 注意到 $T$ 很小, 爆搜完了最大 $72$, 复杂度是 $3^nnm72$(转移时要枚举子集).</p><p>考虑优化掉集合 $S$ 这一维, 容斥它:</p><p>实际上要做的是从 $m$ 个数选出 $n$ 个数组成值集合, 然后到位置集合 ${1\ldots n}$ 做双射, 那么现在改成, 设 $f(S)$ 表示值集合和位置集合 $S$ 做双射的方案数(所以 $S$ 为全集时就是答案), $g(S)$ 表示值集合和位置集合任意映射的方案数(一个位置可以填多个值), 那么有 $g(S)&#x3D;\sum_{T\subseteq S}f(T)$, 于是 $f(S)&#x3D;\sum_{T\subseteq S}g(T)(-1)^{\vert S\vert-\vert T\vert}$</p><p>[trick] 填排列都可以转化成值和位置做映射容斥掉每个位置只能填一次的限制. 同样例题还有ZJOI小星星.</p><p>于是复杂度 $2^nnm72$. 很厉害啊这个trick.</p><h2 id="NOI2024省选模拟赛7"><a href="#NOI2024省选模拟赛7" class="headerlink" title="NOI2024省选模拟赛7"></a>NOI2024省选模拟赛7</h2><h3 id="A-小-W-的滑雪比赛"><a href="#A-小-W-的滑雪比赛" class="headerlink" title="A. 小 W 的滑雪比赛"></a>A. 小 W 的滑雪比赛</h3><blockquote><p>小W要参加滑雪比赛啦! 滑雪场有一条主干道, 从海拔为 $H$ 的山顶到海拔为 $0$ 的山脚. 主干道两边有 $n$ 个检查站, 第 $i$ 个距离主干道 $X_i$(为正在右边, 为负在左边), 海拔为 $Y_i$, 如果通过会获得分数 $S_i$. 多次经过同一个检查站分数只会计一次, 没有两个检查站位置相同.</p><p>小W想要通过其中一些检查站, 最大化自己的得分. 为了防止在小G面前出丑, 小W基于实地考察评估了每个检查站的容易程度 $E_i$(越大越容易), 能够从 $i$ 滑到 $j$ 当且仅当 $\max(\vert X_i - X_j\vert , Y_i - Y_j) \leq E_i$ 且 $Y_i \geq Y_j$, 并且从山顶可以到达任何检查站, 从任何检查站可以到达山脚.</p><p>请你帮助小W计算出得分之和的最大值.</p><p>$n, H\le 10^5$</p></blockquote><p>不是, 为啥kdt的根号过不了1s $2\times 10^5$ &#x2F;fn</p><p>总之这是简单dp题, 按照 $y$ 排序, 设到第 $i$ 个点的代价为 $f_i$, 可以化成单点改矩形max.</p><p>考虑把修改查询均衡一下, 那么可以变成每次对纵向线段取max, 查询一条横向线段的最大值, 这样在 $y$ 从小到大的过程中, 纵向建线段树, 每个点维护单调栈, 标记永久化, 复杂度2log.</p><p>好强好强, kdt单点加矩形max, 查询时大于当前值就不查了, 加剪纸跑的飞快.</p><h3 id="B-数树"><a href="#B-数树" class="headerlink" title="B. 数树"></a>B. 数树</h3><blockquote><p>给定连通图 $G(V, E)$, 保证不存在从节点 $1$ 开始经过 $8$ 个点的简单路径, 求生成树个数, 模 $2^30$</p><p>$n\le 5\times 10^4, m\le 10^5$</p></blockquote><p>你就不能模的质数吗(</p><p>考虑dp, 建出以 $1$ 为根的dfs树显然深度不超过 $8$, 而对于一个点其连边方案只和到根的路径上的点的连通性有关, 状压记录这个即可转移, 状态数是 $m\cdot Bell(7)$, 转移的时候需要合并子树内的连通性可能不对?</p><p>考虑按照dfs序dp, 你仍然只需要记录刚才我们说的内容, 但变成了逐个加点, 转移就 $O(1)$ 了.</p><h3 id="C-LJJ的农场"><a href="#C-LJJ的农场" class="headerlink" title="C. LJJ的农场"></a>C. LJJ的农场</h3><blockquote><p>给定 $a_n, b_n$, 并 $q$ 次单点改大 $a, b$, 每次询问后求 $\min_{i, j} j\cdot a_i+i\cdot b_j$</p><p>$n, q\le 10^5$</p></blockquote><p>乍一看是二元变量, 但实际上固定住一个之后仍然是正常斜率优化, 常见的斜率优化是 $y&#x3D;kx+b$ 最小化 $b$, 这个相当于 $ax+by&#x3D;c$ 最小化 $c$, 那么直接平衡树维护凸壳就做完了, 是下凸壳改大, 所以要倒着做改小变成向凸壳加点而不是删点.</p><p>更简答的直接李超树, 然后也是需要倒着走变成每次加线段而不能删.</p><h3 id="D-黑白点"><a href="#D-黑白点" class="headerlink" title="D. 黑白点"></a>D. 黑白点</h3><blockquote><p>平面上给定 $n$ 个黑点, 进行 $m$ 轮操作, 每轮加入一个白点.</p><p>你需要在每次加点操作后求出: 最少删去多少黑点和白点使得不存在黑点 $(x, y)$ 和白点 $(x’, y’)$ 满足 $x\le x’, y\le y’$.</p><p>$n\le 10^5$</p></blockquote><p><img src="/img/2023-12-15-21-49-38-image.png" alt="picture 2">  </p><h2 id="NOI2024省选训练赛8"><a href="#NOI2024省选训练赛8" class="headerlink" title="NOI2024省选训练赛8"></a>NOI2024省选训练赛8</h2><h3 id="A-气球"><a href="#A-气球" class="headerlink" title="A. 气球"></a>A. 气球</h3><blockquote><p>有 $n$ 个气球, 一开始都是空的. 然后按照从 $1$ 到 $n$ 的顺序依次充气, 其中第 $i$ 个气球在充气过程中始终与地面 $x_i$ 位置接触, 保证 $x_i$ 单调增. 当气球碰到前面的某个气球, 或者达到半径最大限制 $r_i$ 时, 就会停止充气. 请求出每个气球最终半径是多少.</p><p>$n\le 5\times 10^5$</p></blockquote><p>列出式子发现若气球 $1, 2$ 接触, 则 $2\sqrt{r_1}\sqrt{r_2}&#x3D;x_1-x_2$, 斜率优化即可.</p><h3 id="B-mwhak"><a href="#B-mwhak" class="headerlink" title="B. mwhak"></a>B. mwhak</h3><blockquote><p>小 A 和小 B 是两条蛇, 他们正在一棵特殊的树上做游戏.</p><p>这棵树的结构如下: 首先有一条长度为 $n$ 的链, 称为”主链”. 主链由 $1$ 至 $n$ 这 $n$ 个节点构成. 在主链上, 编号相邻的点有边相连, 否则则没有.</p><p>主链上的每一个点都挂着一条链, 称为”副链”. 主链上的第 $i$ 个点挂的副链长度(链上的点数)为 $x_i$.</p><p>小 A 和小 B 初始时都在主链上, 具体而言, 小 A 的蛇尾在点 $a$, 蛇头在点 $b$, 小 B的蛇头在点 $c$, 蛇尾在点 $d$. 满足 $1\leq a&lt;b&lt;c&lt;d\leq n$.</p><p>他们的游戏规则如下:</p><p>小 A 和小 B 轮流移动, 小 A 先手.</p><ul><li>每条蛇移动时, 他会尝试整体向某一方向移动一个节点, 但不能向原来蛇尾方向移动, 也就是蛇不能倒退. 需满足移动后蛇头不得与另外一条蛇的任意部分重合.</li><li>当一条蛇无法移动时, 游戏结束, 对手获胜.</li></ul><p>现在 $mwh$ 有 $q$ 次询问, 每次询问给定 $a$, $b$, $c$, $d$, $mwh$ 想知道当两条蛇都采取最优策略时, 哪一条蛇会获胜.</p><p>$n, q\le 10^6$</p></blockquote><p>考虑两条蛇什么时候会拐入一条副链 $x_k$, 一定是进去之后能赢, 也就是要满足不存在在这条链以后不存在另一条副链使得对方拐进去会赢, 对方不能跟着自己进入自己的副链. 然后求出两方会拐入的副链, 更早拐入的胜, 下面对A分析.</p><p>第二个限制是 $k-a&gt;c-k\rightarrow k&gt;\dfrac{a+c}{2}$, 第一个限制是 $k-b+x_k\ge c+ \max_{j\in [k+1, c-(k-b)]} x_j-j$ 可以化简成 $x_k+k\ge b+c+\max_{j\in [k+1, b+c-k]} x_j-j$, 发现 $b+c$ 一起出现, 并且固定 $k$ 这个式子关于 $b+c$ 单调, 于是每个 $k$ 能拐的情况下 $b+c$ 是一个前缀.</p><p>那就好做了, 先二分出每个 $k$ 对应的 $lim_k$ 表示 $b+c\le lim_k$, 询问时再去二分第一个 $lim_k\ge b+c$ 的位置即可.</p><h3 id="C-数据结构"><a href="#C-数据结构" class="headerlink" title="C. 数据结构"></a>C. 数据结构</h3><blockquote><p>给定一个有 $n$ 个 $01$ 字符串的字符串集合, 每个字符串有一个代价. 再给定 $01$ 字符串 $T$. 你有一个串 $S$, 初始为空串, 每次你可以从字符串集合内选一个字符串, 将其任意长度的前缀或后缀加入到 $S$ 的末尾, 代价为该字符串的代价. 字符串集合内的字符串可以重复使用. 最小化代价总和使得操作完成后 $S &#x3D; T$, 或说明不存在这样的方案.</p><p>$n, m, L\le 2\times 10^5, c_i\le 10^9$</p></blockquote><p>dp设 $f_i$ 表示 $i$ 为结尾的串表示出来的最小代价, 看到总长想根号分治, 那么长度小于根号的可以直接每次枚举这个长度的, 贡献可以用trieac机随便什么算. 大于根号的可以直接每个串单独算, 那么需要知道每个位置向前向后能在这个串上匹配多远, kmp就能做, 做完了之后会转化成区间取min单点查和单点修改区间min, 用分块平衡以下即可.</p><p>总复杂度单根号.</p><h3 id="D-礼物"><a href="#D-礼物" class="headerlink" title="D. 礼物"></a>D. 礼物</h3><blockquote><p>有一棵 $n$ 点树, 给定删掉点 $a$ 及其相连的边并打乱点的编号后得到的森林 $A$, 以及删掉 $b$ 并打乱点的编号后得到的森林 $B$, 给定 $A, B$, 求一个可能的原树.</p><p>$n\le 2000$</p></blockquote><p>考虑枚举 $A$ 上的点 $b$, $a$ 和 $B$ 中的点 $a$, 如何判断是否合法, 最直接的想法是都删掉判断剩下的集合对不对, 但这个是假的, 如图不能区分 $a’$ 和 $a’’$:</p><p><img src="/img/2023-12-18-16-45-33-image.png" alt="picture 3">  </p><p>假的原因是没有判断连通块的位置关系, 对于 $a’$ 那个最大的连通块是在 $a, b$ 中间的, 而 $a’’$ 中这个大连通块与 $a$ 相连而不与 $b$ 相邻, 加上这个条件:</p><p><img src="/img/2023-12-18-16-48-06-image.png" alt="picture 5">  </p><p>如图, 枚举之后, 把连通块分成与 $a$ 相连, $a, b$ 之间, 与 $b$ 相连的和单点四部分, 那么对于图 $A$, 与 $a$ 相连的部分就是删掉 $b$ 前和 $b$ 不在同一连通块的点, $a, b$ 之间的就是与 $b$ 相连的连通块中枚举一个, 剩下的是与 $b$ 相连的, 单点直接判断了, 于是会获得 $n^2$ 个连通块集合对 $(S_1, S_2, S_3, S_4)$ 表示四部分, 只要都树哈希掉, 再和 $B$ 中枚举 $a$ 获得的集合对找相等的即可.</p><h2 id="NOI2024省选训练赛9"><a href="#NOI2024省选训练赛9" class="headerlink" title="NOI2024省选训练赛9"></a>NOI2024省选训练赛9</h2><h3 id="A-圆弧"><a href="#A-圆弧" class="headerlink" title="A. 圆弧"></a>A. 圆弧</h3><blockquote><p>圆上 $3n$ 个点, 点有颜色, $n$ 种颜色每种色出现恰好 $3$ 次, 你要给每个颜色 $c$ 的两个点画一条弧, 满足不经过第三个为颜色为 $c$ 的点, 要求 $n$ 条弧互不相交(也不能包含). 求方案数模 $998244353$</p><p>$n\le 2\times 10^5$</p></blockquote><p>枚举一个颜色的弧, 就可以把环转成序列问题.</p><p>然后暴力是 $f_{i, j}$ 表示前 $i$ 个点画 $j$ 条弧的方案数, 那么因为最后 $j&#x3D;n-1$, 发现大部分 $j$ 是到不了的, 实际上是对最大画线方案计数, 所以每个 $i$ 对应了唯一的 $j$, 复杂度 $O(n)$</p><h3 id="B-整除"><a href="#B-整除" class="headerlink" title="B. 整除"></a>B. 整除</h3><blockquote><p>给定 $m, a_n, c_n$, 求有多少正整数 $x$ 满足 $(\sum_{i&#x3D;0}^{m-1} x_i)\vert (\sum_{i&#x3D;0}^{a_i} c_ix^{a_i})$($\vert$ 指整除), $n\le 10^5$</p></blockquote><p>容易想到左边变成 $\dfrac{x^m-1}{x-1}$, 然后乘到右边 $(x-1)$, 再对 $x^m-1$ 多项式取模得到新的多项式, 设为 $\sum_{i&#x3D;0}^{m-1} b_ix^i$</p><p>容易发现若 $x&gt;maxb+1$, 则 $x^{m-1}$ 和 $x^m$ 的差距就不能靠系数了, 也就是 $x\le maxb+1$, 只有 $O(n)$ 个, 问题在于如何判定.</p><p>这个判定很巧妙, 考虑若 $b_i&gt;x$, 则 $b_i: &#x3D; b_i-x, b_{i+1\bmod m}: &#x3D; b_{i+1\bmod m}+1$ 原式不变, 处理完之后所有系数都小于 $x$, 则 $x^m-1$ 能整除它当且仅当</p><ul><li>都是 $0$</li><li>都是 $x-1$</li><li>都是 $1-x$</li></ul><p>而最关键的是, 因为每一步会把 $a_i$ 缩小 $x-1$, 所以枚举所有的 $x$ 之后步数是 $n\ln n$ 的, 于是拿map维护就俩log过了.</p><h3 id="C-词典"><a href="#C-词典" class="headerlink" title="C. 词典"></a>C. 词典</h3><p>哇原题[2022SDFZ省选模拟赛6] 词典, 在杂题选做中.</p><p>重要的是先考虑</p><p>现在看来更套路一点了, 见到这个肯定想字典树, 然后就是dp-&gt;猜凸性-&gt;闵和min+卷积套路.</p><p>此外不太常见的就是这个dp式子列出来相当于”半在线min+卷积”, 但都是能做的.</p><h3 id="D-蒲公英"><a href="#D-蒲公英" class="headerlink" title="D. 蒲公英"></a>D. 蒲公英</h3><blockquote><p>给一棵直径小于 $4$ 条边的树, 要求给点重新编号 $1\ldots n$ 使得每条边两边的的差的绝对值构成排列</p><p>$n\le 10^5$</p></blockquote><p>智慧题啊.</p><p>我们可以轻易地发现, 如果取直径的中点为根, 那么树的高度不会超过2. 因此, 我们可以用 $a_1, a_2, \ldots, a_k$ 来描述树的形态, 其中根有 $k$ 个子节点, 第 $i$ 个节点有 $a_i$ 个儿子.</p><p>首先, 我们考虑所有的 $a_i$ 都不为零, 且 $k &#x3D; 2m + 1$ 为奇数的情况. 我们让根节点的重标号为 $1$. 然后, 我们按照奇偶性将 $a_i$ 分离, 将奇数置于前面, 偶数置于后面. 接下来, 我们需要交替地填入”还没有填入的最小标号”和”还没有填入的最大编号”, 我们分别用 $L$ 和 $R$ 来表示. 首先, 我们给根节点的所有儿子交替填入 $L$ 和 $R$ (按照奇偶性分离后的结果). 然后, 我们依次考虑根节点的各个儿子, 对于前面的奇数部分, 我们依次给它的子节点交替填入 $L$ 和 $R$ ; 对于后面的偶数部分, 我们先留下它的一个子节点, 对于剩下的奇数个子节点, 我们交替填入 $L$ 和 $R$ . 最后, 我们倒序考虑根节点的儿子, 如果它有偶数个儿子, 我们就把原来留下的那个按照目前交替到的情况填数. 这个填法的正确性是比较容易验证的.</p><p>如果 $k &#x3D; 2m$ 为偶数, 我们随便取根节点的一个儿子, 让这个点重标号为 $n$ . 假设它有 $p$ 个儿子, 那么我们给它的儿子标号 $1, 2, \ldots, p$ , 根节点标号 $p + 1$ . 这时, 我们会发现删掉这个子树后, 剩下的部分就相当于一个 $n - p - 1$ 的情况. 只有根节点受到了限制, 但这个限制和刚才的填法是吻合的, 所以我们可以直接填入.</p><p>最后, 如果有的 $a_i$ 为零, 我们可以根据非零的 $a_i$ 的数目的奇偶性来确定两种情况. 对于第二种情况, 我们先完成删掉子树的部分. 然后, 我们把这些没有子节点的节点都填入 $R$ (“还没有填入的最大编号”)即可.</p><p>时间复杂度为 $O(n)$ .</p><h2 id="NOI2024省选训练赛10"><a href="#NOI2024省选训练赛10" class="headerlink" title="NOI2024省选训练赛10"></a>NOI2024省选训练赛10</h2><h3 id="A-炮塔"><a href="#A-炮塔" class="headerlink" title="A. 炮塔"></a>A. 炮塔</h3><blockquote><p>$1\times n$ 的网格, 每个位置是空地<code>. </code>, 炮塔<code>#</code>和干扰器<code>*</code>, 你从第一个格子出发可以往左往右走, 你有一个背包, 你可以把地上的干扰器放入背包或者把背包里的干扰器放到地上, 你可以走过一个炮台当且仅当炮台相邻格子存在干扰器, 问任意长时间后背包里最多有多少干扰器.</p><p>$n\le 3\times 10^6$</p></blockquote><p>分类讨论题, 主要就是很难考虑全情况, 以及清晰的分类.</p><p>发现可以把曾经走过的部分的干扰器分成两类, 需要一个干扰器可以拿到并走回当前位置的和需要两个干扰器可以拿到并走回来的, 假设你在字符串中的<code>x</code>上, <code>*#x</code>需要一个, 而可以发现手拿两个干扰器可以拿到没被挡住的所有干扰器, 被挡住指<code>##</code>后面不是<code>*</code>的情况.</p><p>所以维护两类干扰器的数量和现在手里的数量, 从左往右扫一遍字符串即可.</p><h3 id="B-小U-与解密游戏"><a href="#B-小U-与解密游戏" class="headerlink" title="B. 小U 与解密游戏"></a>B. 小U 与解密游戏</h3><blockquote><p>给定 $\texttt{01}$ 串 $s$, 每次同时交换所有的位置 $i$ 满足 $s_i&#x3D;0, s_{i+1}&#x3D;1$, 问 $k$ 次后字符串的样子.</p><p>$n, k\le 5\times 10^6$</p></blockquote><p>可以看成所有的 $1$ 在往前走, 容易发现一个 $1$ 和前面的 $1$ 相邻时, 后面的 $1$ 会原地停一轮然后复制前面的 $1$ 的移动, 一个 $1$ 的移动可以看成一个斜率为 $0$ 和 $1$ 的线段交替的折线, 写了个维护折线的无旋treapTLE了, 然后把一个合并分裂查函数值的东西改成静态的BST上查询就过了.</p><p>然后这个东西其实deque能维护, 傻了吧.</p><h3 id="C-欢乐豆"><a href="#C-欢乐豆" class="headerlink" title="C. 欢乐豆"></a>C. 欢乐豆</h3><blockquote><p>有一个 $n$ 点有向完全图, $u\to v$ 的边权为 $a_u$, $m$ 次修改一条边的边权, 求出所有修改完成后图上所有点对的最短路之和.</p><p>$n\le 10^5, m\le 3000$</p></blockquote><p>容易想到把这些新边拿出来成一个图, 那么要求的贡献有两类: 点对两个点都在新图上和起点在新图上. 然后注意如果你走通过非新图上边走到一个没被修改涉及的点那么一定一步到位.</p><p>对于起点在新图上终点不在新图上, 或者起点终点不在同一连通块, 一定是沿着新图走到某个位置, 然后走图外边到达终点, 直接对每个点跑dij求最短路即可.</p><p>对于两个点都在新图上的则复杂一些, 因为最优解可能走两个点都在新图上但边不在新图上的路, 如果暴力添加这些边就会 $n^3$, 考虑数据结构优化dij, 虽然不好直接维护一个没有规律的集合, 但是一个全集减去 $k$ 个点可以拆成 $k+1$ 段, 所以拿线段树实现对这些边操作, 就是区间取min, 此外要支持单点修改($m$ 条边中的边)和查最小值.</p><h3 id="D-Musician"><a href="#D-Musician" class="headerlink" title="D. Musician"></a>D. Musician</h3><p>ZR原题 “22冲刺day18-D-Melody”, 然是ZR搬的nfls</p><h2 id="随机化专题"><a href="#随机化专题" class="headerlink" title="随机化专题"></a>随机化专题</h2><p>放到随机化那篇文章里吧</p><h2 id="NOI2024省选训练赛11"><a href="#NOI2024省选训练赛11" class="headerlink" title="NOI2024省选训练赛11"></a>NOI2024省选训练赛11</h2><h3 id="A-小明去旅游2"><a href="#A-小明去旅游2" class="headerlink" title="A. 小明去旅游2"></a>A. 小明去旅游2</h3><blockquote><p>$n$ 个三维点, $m$ 次每次给一个长方体打一个标记, 求不同的标记集合把点分成了多少种.</p><p>$n, m\le 5\times 10^4$</p></blockquote><p>哈希秒了, 然后上KDT&#x2F;三维偏序维护即可.</p><p>写了KDT差分(单点修改区间查询)被卡常, 点数大, 换成单点查询区间修改懒标记被卡常, 换成标记永久化过了.</p><h3 id="B-问题出现我再告诉大家"><a href="#B-问题出现我再告诉大家" class="headerlink" title="B. 问题出现我再告诉大家"></a>B. 问题出现我再告诉大家</h3><blockquote><p>给一棵 $1$ 为根的 $n$ 个点的树和 ${c_n}, {d_n}$, 表示可以以 $c_u$ 代价覆盖 $u$ 子树中与 $u$ 距离不超过 $d_u$ 的点, 求每个点都被至少一个点覆盖的代价最小值.</p><p>$n\le 10^6$</p></blockquote><p>暴力dp就是 $f_{u, i}$ 表示 $u$ 的子树其中最上面 $i$ 层已经被覆盖了的情况下完全覆盖的代价最小值, 然后转移是 $f_{u, i}&#x3D;\min (\sum_v f_{v, i-1}, \sum_v f_v{d_u-1}+c_u)$, 所以线段树合并维护整体dp, 相当于先累加, 再平移, 再对一个值取min.</p><p>其实状态用深度就可以避免那个平移了, 然后这个是有区间修改的线段树合并, 要保证复杂度是对的需要判断, 当合并的两个点中有一个点是空点(没有孩子只有标记)的时候就直接合并退出, 于是还要再写区间加.</p><p>这样复杂度是时间 $n\log n$, 空间 $n\log n$, 已经能过了, 然后线段树每次先进重儿子+垃圾回收就可以优化成线性空间.</p><h3 id="C-路"><a href="#C-路" class="headerlink" title="C. 路"></a>C. 路</h3><blockquote><p>给定 $n\times m$ 的网格, 有些位置有障碍物, 求有多少方式选择一个没有障碍物的点的集合使得每一条 $(0, 0)$ 走到 $(n-1, m-1)$ 且不经过障碍物的路径都经过恰好一个集合中的点.</p><p>$n, m\le 30$</p></blockquote><p>输出 $n+m-1$ 获得没有障碍物的40分.</p><p>先建出原平面图, 有障碍的位置不连, 再转对偶图, 但是这里要求一条路上恰好经过一个被选中的点, 所以仍然以区域为新点, 新点是穿过原点从右上到左下的边, 那么路径条数就是答案. 然后要乘上那些到不了起点和终点的位置的乱选方案.</p><h3 id="D-一般难度的推式子题"><a href="#D-一般难度的推式子题" class="headerlink" title="D. 一般难度的推式子题"></a>D. 一般难度的推式子题</h3><blockquote><p>求 $n$ 个点的树的高度期望.</p></blockquote><p>问题是怎么表示树的高度, 考虑去掉根节点的平面树和合法括号序列是双射, 而树高就是最深的嵌套层数, 也就是对括号序列做前缀和之后的最大值.</p><p>那么考虑高度不高于 $h$ 的, 也就是数每一步可以走 $(1, -1)$ 或 $(1, 1)$, 从 $(0, 0)$ 走到 $(0, 2n-2)$, 不能碰到 $y&#x3D;-1$ 和 $y&#x3D;h$ 的方案数.</p><p>转化成了反射容斥典题, 考虑如果碰到上面的线记录一个 $\texttt A$, 碰到下面的线记录 $\texttt B$, 把连续的 $\texttt A$ 和 $\texttt B$ 缩成一个, 就要用系数容斥出 $\texttt {AB}$ 交替串为空, 可行的方式是对所有 $\texttt{AB}$ 串做, 系数为 $(-1)^{len}$, 然后注意到对于 $\texttt{ABABABAB}$ 这样的串, 每反射两次终点向上平移 $2h+2$, 则只要 $O(\dfrac{n}{h})$ 次方案数就是 $0$ 了, 所以求一个的复杂度是 $O(\dfrac{n}{h})$, 对所有的求复杂度就是 $n\ln n$ 了.</p><p>两条线反射容斥是EI生成函数败北里介绍的典型啊</p><h2 id="NOI2024省选训练赛12"><a href="#NOI2024省选训练赛12" class="headerlink" title="NOI2024省选训练赛12"></a>NOI2024省选训练赛12</h2><h3 id="A-聚会"><a href="#A-聚会" class="headerlink" title="A. 聚会"></a>A. 聚会</h3><p>原题 P7201 [COCI2019-2020#1] Džumbus</p><blockquote><p>Marin 是一个心地善良的人, 因此他将为他的 $N$ 个朋友组织 $Q$ 次宴会. 宴会上唯一的饮料被称为 <em>džumbus</em>.</p><p>每位朋友对这种饮料的需求量是已知的. 在这些朋友中, 有 $M$ 组朋友. 每一组中的两位在同时满足他们各自的需求量后, 将开始互相核对自己对往届 COCI 题目的答案.</p><p>当朋友 $A$ 把自己的答案分享给朋友 $B$ 时, 朋友 $B$ 可以决定是否要以相同的方式进行分享. 然而, 这 $M$ 组朋友不可能将 $A$ 分享给别人的答案重新分享给 $A$. (无环)</p><p>对于 $100%$ 的数据, $0 \le M \lt N \le 1000, 1 \le Q \le 2 \times 10^5, 1 \le D_i \le 10^9, 1 \le S_i \le 10^9$.</p></blockquote><p>一眼dp, 因为答案数量小而 $s, d$ 大维度互换, 设 $f_{u, i, 0&#x2F;1&#x2F;2}$ 表示 $u$ 子树内有 $i$ 个人传递答案, $u$ 自己没有满足需求量&#x2F;满足需求量但没有与子节点传递&#x2F;满足需求量且已传递 的情况下最小需要多少饮料即可, 最后二分</p><p>复杂度 $n^2$</p><h3 id="B-全国高中-IO-联赛二试"><a href="#B-全国高中-IO-联赛二试" class="headerlink" title="B. 全国高中 IO 联赛二试"></a>B. 全国高中 IO 联赛二试</h3><blockquote><p>给定一棵树, 对于一个集合 $S$, 设其权值为拿出 $S$ 集合中的点并两两连边, 权值为两点在原树上的距离形成的完全图的最小生成树的边权和. 给定每个点在 $S$ 中的概率求 $S$ 的权值期望.</p><p>$n\le 1000$</p></blockquote><p>一开始没有懂为什么不是最小斯坦纳树问号了好久.</p><p>考虑期望的线性性, 枚举原树上两个点 $u, v$ 考虑 $(u, v)$ 成为新的最小生成树上边的概率, 显然要求 $u\in S, v\in S, \forall w\in Chain(u, v), w\notin S$, 但这样还不够, 考虑若一个 $S$ 中点 $w$ 在这条链上某个点的子树中, 那么除了连 $u\to v, w\to u&#x2F;v$, 还可以 $u\to w, v\to w$, 而选第一种的条件就是 $w$ 到这条链的距离大于 $w$ 到 $u$ 和 $v$ 的距离. 发现一个很大的问题是可能会数重最小生成树, 也就是同一个集合的两种最小生成树数两遍, 于是在原有边权上附加一维使得边权和大小相同的最小生成树被钦定了大小顺序即可.</p><p>于是只要对每个 $u, v$ 算 $u, v$ 之间的链及其子树中所有到 $u, v$ 的距离大于到 $u, v$ 链的距离的点不选的概率, 是这些点的不选的概率乘起来, 一次对一个 $u$ 算所有的 $v$ 即可 $n^2\log n$.</p><p>赛后题解是这样的, 感觉更智慧一点:</p><p><img src="/img/2023-12-23-19-17-03-image.png" alt="picture 6">  </p><h3 id="C-硬件包管理器"><a href="#C-硬件包管理器" class="headerlink" title="C. 硬件包管理器"></a>C. 硬件包管理器</h3><blockquote><p>你要造一套超级计算机. 为了使它的计算速度达到能够用暴力算法在瞬间内通过这场比赛的所有测试点, 你还需要在这台超级计算机上安装 $n$ 个硬件, 我们将这些硬件编号为 $1, 2, \ldots , n$. 第 $i$ 个硬件的预定安装时间是 $t_i$, 硬件之间有依赖关系. 安装硬件的时间可以忽略不计, 但是每个硬件安装的时间有一些大小限制. 一共有 $m$ 组限制, 第 $i$ 组限制可以用两个正整数 $l_i, r_i$ 表示 ($1\le l_i\le r_i\le n$), 具体意义是编号在 $[l_i, r_i)$ 的硬件的安装依赖于第 $r_i$ 个硬件的安装, 因此它们的安装时间不早于编号为 $r_i$ 的硬件的安装时间(安装时间可以相等).</p><p>所以你会发现, 完全按照预定的安装时间安装每个硬件, 这 $n$ 组限制不会全满足. 因此你要调整这些硬件的安装时间. 而你希望每个硬件的实际安装时间与预定安装时间的总偏离程度最小. 对于第 $i$ 个硬件, 如果它的实际安装时间比预定安装时间早, 那么每个单位时间都会使总偏离程度增加 $a_i$; 如果它的实际安装时间比预定安装时间晚, 那么每个单位时间都会使总偏离程度增加 $b_i$. 现在你的任务就是计算出总偏离程度的最小值.</p><p>$n, m\le 300000$</p></blockquote><p>重新调整这些区间, 若 $l_i&lt;l_j&lt;r_i&lt;r_j$, 那么显然 $[l_i, l_j]$ 的位置也是受 $r_j$ 约束的, 考虑把每个区间都先如此处理成极长的, 那么发现一个重要性质就是区间没有相交只有包含. 于是可以以树的形式考虑, 子节点要不早于父节点安装时间, 那就简单了, $f_{u, i}$ 表示 $u$ 的安装时间为 $i$ 的情况下 $u$ 子树的答案, 则 $f_{u, i}&#x3D;\sum_v \min_{j\ge i} f_{v, j}+cost(u, i)$, 其中 $cost$ 是加两个一次函数, 然后是满足下凸+维护差分的经典trick了.</p><h3 id="D-历史研究"><a href="#D-历史研究" class="headerlink" title="D. 历史研究"></a>D. 历史研究</h3><blockquote><p>给定平面上 $n$ 个点, 求用 $m$ 种颜色染色的方案数, 满足同色的点可以用一个边长为 $K$ 的平行坐标轴的正方形包含.<br>$n\le 4000, m\le 3$</p></blockquote><p>$m&#x3D;2$ 时, 考虑所有点的包围盒, 那么一定是两个正方形卡在两个包围盒的对角上, 分别计算方案数减去两种情况都有的方案数, 复杂度 $O(n)$</p><p>$m&#x3D;3$ 时先排除某一维极差 $\le K$ 的情况, 此时四个方向上边界的点有 $4$ 个, 至少有两个同色, 且不是对边的两个, 设是最左和最下的两点, 那么这个颜色的包围盒确定了, 去掉这种颜色后剩下的点的包围盒的右边和上边也确定了, 于是枚举左下两边用 $m&#x3D;2$ 的方法算.</p><h2 id="NOI2024省选模拟赛13"><a href="#NOI2024省选模拟赛13" class="headerlink" title="NOI2024省选模拟赛13"></a>NOI2024省选模拟赛13</h2><h3 id="A-过路费"><a href="#A-过路费" class="headerlink" title="A. 过路费"></a>A. 过路费</h3><blockquote><p>某国共有 $n$ 座城市, 有 $m$ 条高速公路连接这些城市, 每条高速公路只能单向通行.</p><p>第 $i$ 条高速公路的起点城市是 $u$, 终点城市是 $v$, 经过一次需要 $w_g$ 的费用.</p><p>节假日到了, 国家决定对高速公路通行费进行减免, 政策如下:</p><ul><li>如果一条路线经过的高速公路不超过 $k$ 条, 将按照原价收取费用.</li><li>如果一条路线经过的高速公路超过 $k$ 条, 将只收取其中费用最高的 $k$ 条高速公路的费用.</li></ul><p>求从城市 $s$ 到城市 $t$ 的最小花费.</p><p>$n, m\le 1000$</p></blockquote><p>这题以前见过啊</p><p>就是考虑枚举最短路上第 $k$ 大的边权值 $x$, 那么把所有边权 $w: &#x3D; \max (w-x, 0)$, 最后答案加上 $kx$, 则如果 $x$ 枚举大了减的就少了, 枚举小了最后就加多了, 所以只有当 $x$ 是正确的值的时候是对的.</p><p>[think] 有一种wqs二分的感觉.</p><h3 id="B-数列重排"><a href="#B-数列重排" class="headerlink" title="B. 数列重排"></a>B. 数列重排</h3><blockquote><p>定义一个数列区间的mex为区间中最小的没有出现过的自然数, 定义一个数列的价值为其中 $mex \geq k$ 的区间数量.</p><p>给定 $n$ 个小于 $m$ 的自然数和一个区间 $[l, r]$, 令 $f(k)$ 表示 $n$ 个数构成的数列所有重排列中数列价值的最大值, 对于每一个 $k \in {l, l+1, . . . , r}$, 求出 $f(k)$. 令 $a$ 表示数字 $i$ 出现的次数, 保证存在正整数 $X$, 使得 $V&lt;m$, $a_i \in {X, X+1}$.</p></blockquote><p>先假设 $a_i&#x3D;0$, 考虑对于某个固定的 $k$, <del>打一个大表发现</del>则最优状态一定是 $0\ldots k$ 的循环的基础上插入其余的数, 于是就成了一个插入数的最优化问题而非构造题. 把 $\le k$ 的数称为 $A$ 类数, 有 $n$ 个, 剩余的数为 $B$ 类数.</p><p>发现一个重要的性质是把 $A$ 按 $k$ 为大小分块成 $l$ 块后所有的 $B$ 都可以插入到块间的空隙而不插入到块之内, 因为考虑若在 $i$ 插入了一个 $B$, 则右边第一个 $B$ 插入到 $i+k+1$ 一定不优于 $i+k$, 则选定一个位置的 $B$ 之后其他的都可以和它在模 $k$ 的意义下相等, 又发现开头对齐更优, 因为反正 $1\ldots c(c&lt;k)$ 这一段不能和第一个 $B$ 构成合法区间.</p><p>于是分块后设第 $i$ 个缝隙插入有 $c_i$ 个 $B$, $A\to A$ 的贡献和没有 $B$ 的时候一样, 也就是选择长度 $\ge k$ 的区间的方案数, $B\to B$ 的贡献是 $\dfrac{1}{2}((\sum c_i)^2-\sum c_i^2)$, $A\to B$ 的部分则是</p><p>$$<br>(c_1+c_{l+1})(n-k+1)+\sum_{i&#x3D;2}^{l} c_i(n-2k+2)<br>$$</p><p>数据范围太大不像dp, 考虑贪心, 先加上 $A\to A$ 的贡献和 $(\sum c_i)^2$, 考虑在当前基础上新加入一个元素, 插入到第 $1$ 和 $l+1$ 个缝隙的贡献是 $n-k+\dfrac{1}{2}-c_i$, 插入到其他位置是 $n-2k+\dfrac{3}{2}-c_i$, 显然差分递减原函数凸性, 每次取最大的差分就是对的, 所以一定是先在 $1, l+1$ 轮流插入, 直到贡献相等, 也就是两边插入了 $k-1$ 个之后每个缝隙轮着插入, 贡献都是等差数列求和, 求单个 $f(k)$ 就是 $O(1)$ 了.</p><p>总复杂度 $O(m)$</p><h3 id="C-构造矩阵"><a href="#C-构造矩阵" class="headerlink" title="C. 构造矩阵"></a>C. 构造矩阵</h3><blockquote><p>给定 $n, k$, 构造一个只含有 $0, 1$ 的大小为 $T \times r$ 的矩阵 $A$, 满足:</p><ol><li>$A_{i, i} &#x3D; 1$</li><li>$A_{i, i+1} &#x3D; 1$</li><li>若 $i&gt;j$, 则 $A_{i, j} &#x3D; 0$</li><li>若 $A_{i, j} &#x3D; 1$ 且 $j-i &gt;1$, 则存在 $i&lt;t&lt;j$ 满足 $A_{i, t} &#x3D; A_{t, i} &#x3D; 1$.</li><li>若 $i\le j$, 则 $(A^k)_{i, j} &gt; 0$</li></ol><p>输出满足 $A_{i, j}&#x3D;1$ 且 $j-i&gt;1$ 的每个 $(i, j)$, 设这样的 $(i, j)$ 有 $m$ 个.</p><p>若输出不满足要求则不得分, 否则根据 $m$ 进行评分. (如图, 要求 $m\le f(k)n$)</p><p><img src="/img/2023-12-25-14-44-22-image.png" alt="picture 7">  </p></blockquote><p>先转换成, 给定一个序列, 你有 $[i, i+1)$ 的区间, 要求进行 $m$ 次合并的预处理使得任意区间可通过至多 $k$ 次合并得到.</p><p>对于 $k&#x3D;2$ 考虑猫树分治, $m&#x3D;n\log n$, 对 $k&#x3D;3$ 考虑sqrt tree, 将序列分治成 $\sqrt n$ 大小的块, 合并出每个块的区间和前后缀, 块内递归. $m(n)&#x3D;\sqrt nm(\sqrt n)+O(n)&#x3D;n\log \log n$, 对 $k&#x3D;4$ 考虑递归分治, 块内递归, 块间用 $k&#x3D;2$ 并处理前后缀.</p><p>于是对更大的 $k$ 就可以类比刚才的, 对序列分块块内递归, 块间递归到 $k-2$ 的子问题并预处理前后缀, 可以dp求块大小. 同时这个策略在 $k$ 大 $m$ 小的时候比较劣, 此时底层直接用线段树上层用上面的方法.</p><p>但还是不够优秀, 把块分类, 问题 $f(k, n), f_1(k, n), f_2(k, n)$ 表示查询时序列长 $n$ 可以合并 $k$ 次时的代价, 在此基础上要求查前<strong>或</strong>后缀只能用一个区间的代价, 在此基础上要求查前<strong>和</strong>后缀只用一个区间的代价, 则 $f(k, n)$ 可以分成两个边界块和中间的若干块, 两个边界块都是递归到 $f_1(k)$, 中间块要递归到 $f_2(k)$, 而若中间分了 $B$ 块又要把这 $B$ 块合并, 所以 $f(k, n)&#x3D;\min_i \min_j 2f_1(i)+\dfrac{n-2i}{j}f_2(j)+f(\dfrac{n-2i}{j})$, $f_1(k, n)&#x3D;n-1+f(k, n-1), f_2(k, n)&#x3D;2n-3+f(k, n-2)$, 要多开一个 $g$ 优化一下 $f$ 的转移. dp的时候记录状态根据状态构造即可.</p><p>边界要处理 $i&#x3D;1$ 时的 $f, f_1, f_2$, $j&#x3D;1$ 时用猫树分治, $j&#x3D;0$ 时处理出所有子区间, $i\le j$ 时的 $f$. 感觉很厉害的一点是它真的卡掉了dp中的小错, 那种答案只差 $1$ 的小错.</p><h2 id="NOI2024省选模拟赛14"><a href="#NOI2024省选模拟赛14" class="headerlink" title="NOI2024省选模拟赛14"></a>NOI2024省选模拟赛14</h2><h3 id="A-998244o5o"><a href="#A-998244o5o" class="headerlink" title="A. 998244o5o"></a>A. 998244o5o</h3><p>原题 CF788D 3000*蓝题</p><blockquote><p>二维平面上有共 $n+m$ 条未知的平行于坐标轴的直线.</p><p>你每次可以询问一个平面上点, 交互库将返回该点与离它最近的直线之间的距离.</p><p>你要在 $3 \times 10^5$ 次询问内确定这 $n$ 条直线.</p><p>题目保证直线 $x&#x3D;a$ 或者 $y&#x3D;a$ 中 $\vert a\vert \le 10^{8}$, 你询问的点坐标也要在 $[-10^8, 10^8]$ 中, 其中 $n, m \leq 10^4$.</p></blockquote><p>曼哈顿距离在两维是对称的, 发现当问 $(x_0, y_0)$ 时, 一条 $x&#x3D;x_0+k$ 和 $y&#x3D;y_0+k$ 的直线是等价的, 所以这其实是个一维问题&#x2F;xia, 可以都转化到与 $y&#x3D;x$ 的交点.</p><p>于是考虑一维怎么做, 要保证 $O(1)$ 次问出一条线, 感觉这里分治是应该枚举的策略, 或者是考虑若已经知道 $x&#x3D;l, x&#x3D;r$ 两条线存在, 则这个区间要想有线 $x&#x3D;mid$ 一定能问出来, 然后递归下去, 就可以线性得到一堆 $k$ 满足存在线使得 $x&#x3D;k$ 或 $y&#x3D;k$, 最后找一个集合之外的 $t$ 对每条线判断线的方向即可.</p><h3 id="B-告别"><a href="#B-告别" class="headerlink" title="B. 告别"></a>B. 告别</h3><blockquote><p>给定 $n$ 点树, 有一个路径集合 $S$, 定义一条边的权值为 $S$ 中不经过它的路径的权值集合的 $mex$. $q$ 次加入一条路径或查询经过一条边的权值的最小值.</p><p>$n, q\le 10^5$, 3s, 256Mb</p></blockquote><p>套路题吧, 看见mex考虑判定或者转化成不存在的最小值, 考虑判定就会发现最小值就是最小的 $z$ 满足权值为 $z$ 的路径的交和查询路径有交, 于是考虑如何判定交, 容易想到转化成链加链求和.</p><p>然后想了一个树套树空间 $n\log^2 n$ 时间 $n\log^3 n$ 不敢写, 想了一个分块空间 $n\sqrt n$ 时间 $n\sqrt n\log n$.</p><p>然而这就是正解.</p><p>然后可以线段树套可删堆直接维护覆盖一个点的最小颜色.</p><h3 id="C-被猫猫入侵的题面"><a href="#C-被猫猫入侵的题面" class="headerlink" title="C. 被猫猫入侵的题面"></a>C. 被猫猫入侵的题面</h3><p>原题是 Qoj4896 Alice、Bob 与 DFS</p><blockquote><p><img src="/img/2023-12-26-19-48-49-image.png" alt="picture 8">  </p><p>$n\le 2\times 10^5$</p></blockquote><p>多个公平游戏, 考虑算SG, 因为是DAG所以一个状态要用 $(u, {s_n}, i)$ 表示, 其中 $u$ 为当前点, $s$ 为起点到当前点的路径, $i$ 为走完了前 $i$ 条边. 设 $u$ 的第 $i$ 条边连到 $e_{u, i}$</p><p>考虑全都是白点的状态 $s$ 的转移, $(u, {s_n}, i)\to (e_{u, i}, {s_n}+e_{u, i}, 0), (u, {s_n}, i)\to (u, {s_n}, i+1), (u, {s_n}, i)\to (s_{n-1}, {s_{n-1}}, i’)$, 设可以转移到<strong>子树外</strong>的集合是 $S_s$, 此时SG值为 $f_{u, S_s}$.</p><p>那么就要向 $S$ 中加入孩子然后求 $mex$, 则倒序枚举孩子 $v$, 加入 $f_{v, S}$, 然后 $S: &#x3D; S\cup {f_{v, s}}$. 然后, <del>发现不了考虑 $f$ 的过程是对 $S$ 不断取mex猜测</del> $f_{u, S}&#x3D;\mathrm{mex}^{f_{u, {0}}} S$, 其中 $\mathrm{mex}^k$ 表示第 $k$ 小的不在集合中的数, 证明可以归纳.</p><p>有了黑点之后, 经过倒序枚举的第一个儿子后黑点的 $S$ 大小一定是 $1$, 信息量只有一个 $01$, 可以直接不断带入算出一个黑点的 $f_{u, {0&#x2F;1}}$, 但是对黑点的依赖会让刚才的白点计算方式不行, 同样发现不了 $f_{u, S}&#x3D;\mathrm{mex}^{f_{u, S\cap {0, 1}}}(S-{0, 1})$</p><p>最后有了以上发现不了的结论后, 就只用记录 $f_{u, S}, S\subset {0, 1}$, 然后用什么随便数据结构支持求 $\mathrm{mex}^k$ 就行了.</p><h2 id="凸性在最优化问题中的应用"><a href="#凸性在最优化问题中的应用" class="headerlink" title="凸性在最优化问题中的应用"></a>凸性在最优化问题中的应用</h2><h3 id="P6893-ICPC2014-WF-Buffed-Buffet"><a href="#P6893-ICPC2014-WF-Buffed-Buffet" class="headerlink" title="P6893 [ICPC2014 WF] Buffed Buffet"></a>P6893 [ICPC2014 WF] Buffed Buffet</h3><blockquote><p>自助餐厅里有 $n$ 种食物, 分为两大类, 为 “离散食物”和”连续食物”. 你可以通过吃食物来获得收益.</p><p>离散食物用 $(w, t_0, \Delta t)$ 描述. 对于这种食物, 你只能吃整数个, 每个重为 $w$. 吃的第一个收益为 $t_0$, 后面每吃一个收益减少 $\Delta t$. 具体的, 吃的第 $i$ 个这种食物 (从 $1$ 开始标号), 收益为 $t_0-(i-1)\Delta t$.</p><p>连续食物用 $(t_0, \Delta t)$ 描述. 对于这种食物, 你可以吃任意食物的重量. 如果你吃的重量为 $w$, 获得的收益是 $t_0w-\dfrac{1}{2}\Delta t w^2$.</p><p>你现在要吃重量和<strong>恰好</strong>为 $W$ 的食物. 最大化你的收益.</p><p>$n\le 250, W\le 10000$.</p><p>对于离散食物, 满足 $1\le w\le 10000$.</p><p>对于所有食物, 满足 $0\le t_0, t\le 10000$.</p></blockquote><p>考虑先对连续和离散分别求答案然后合并, 那么连续部分可以直接贪心, 每次选择一段直到两种食物收益(导数)相等, 相等之后两种食物选择的比例一定可以直接合并成一个.</p><p>对于离散部分对每个 $w$ 会拆到剩下 $\dfrac{W}{w}$ 个物品, 一共 $W\ln n$, 复杂度 $W^2\ln n$ 的3s也冲过去了.</p><p>我们知道多重背包可以 $nW$, 类似的进行优化, $f_{i, j}&#x3D;f_{i-1, j-kw_i}+kt_i-\dfrac{1}{2}\Delta t_ik(k-1)$, 类似多重背包按余数分类, $j’&#x3D;\dfrac{j}{w_i}$, 有<br>$f_{i, j}&#x3D;f_{i-1, k}+(j-k)t_i-\dfrac{1}{2}\Delta t_i(j-k)(j-k-1)$, 于是斜率优化, 复杂度 $nW$</p><h3 id="P3347-ZJOI2015-醉熏熏的幻想乡"><a href="#P3347-ZJOI2015-醉熏熏的幻想乡" class="headerlink" title="P3347 [ZJOI2015] 醉熏熏的幻想乡"></a>P3347 [ZJOI2015] 醉熏熏的幻想乡</h3><blockquote><p>考虑有源汇二分图上的流. 源到左侧第 $i$ 个点的流量上限为 $c_i$, 且流量为 $x$(实数)时会产生 $a_ix^2+b_ix$ 的费用; 右侧点 $i$ 到汇的流量上限为 $d_i$. 求最小费用最大流.</p><p>单侧点数 $100$, 值域 $3$, 需求精确解</p></blockquote><p>先求最大流.</p><p>然后考虑如果不考虑右侧点对左侧点的容量限制, 一定是贪心的选导数, 也就是存在一个 $k$ 使得每个左侧点的流量 $x$ 为 $2a_ix+b_i\le k$ 的 $x$ 最大值. 可以想象维护了一个当前导数最小元素的集合, 随着 $k$ 增加增加在集合不变的情况下 $x$ 是 $k$ 的一次函数, 可能会若干次加入元素 $(k\ge b)$, 删除元素(流量达到 $c_i$ 或受右边点限制), 形成一个分 $O(n)$ 段一次函数.</p><p>那么考虑怎么求流量对 $k$ 的函数, 发现一个性质是以 $k&#x3D;1, 2, 3$ 为断点的情况下每一段集合元素只会减少也就是有凸性. 因为对于一个确定的 $k$ 可以真的跑一遍网络流求出流量, 那么可以分治, 当前要确定函数在 $k\in [l, r]$ 的部分, 先计算 $l, r, mid$ 处的函数值, 如果三个点共线那么这就是一整段, 否则就递归下去.</p><h3 id="UOJ455雪灾与外卖-2018ICPC-Final正式赛-征服世界"><a href="#UOJ455雪灾与外卖-2018ICPC-Final正式赛-征服世界" class="headerlink" title="UOJ455雪灾与外卖, 2018ICPC-Final正式赛 征服世界"></a>UOJ455雪灾与外卖, 2018ICPC-Final正式赛 征服世界</h3><p>之前已经见过了模拟费用流的做法</p><p>然而这两个题都可以直接dp, 雪灾就设 $f_{i, j}$ 表示前 $i$ 个点最后一条边的容量为 $j$(正负表示方向), 征服世界的就是改成子树, 然后转移就是做闵和, 平移, 整体加绝对值, 就是维护差分题的模板了.</p><h3 id="Gym-102331-J-J-Jiry-Matchings"><a href="#Gym-102331-J-J-Jiry-Matchings" class="headerlink" title="Gym 102331 J J. Jiry Matchings"></a>Gym 102331 J J. Jiry Matchings</h3><blockquote><p>给定一棵 $n$ 个点的树, 边上带权. 对每个 $k$, 求恰有 $k$ 条边的最大权匹配.</p><p>$n \le 2 \times 10^5$</p></blockquote><p>直接dp, $f_{u, 0&#x2F;1, i}$ 表示 $u$ 的子树根不能匹配&#x2F;可以匹配的情况下选了 $i$ 条边, 则它关于 $i$ 是凸的, 因为我们知道二分图最大权匹配是网络流的. 于是合并是闵和.</p><p>但刚才那种维护差分的方式不好用了, 不止一个数组导致会有两个数组卷起来再取min之类的东西很那做到log以内合并, 考虑如果是链上的问题可以分治, 维护 $f_{0&#x2F;1, 0&#x2F;1}(i)$ 表示左右端点的情况, 对于 $[l, r]$ 的答案, 求出 $[l, mid], [mid+1, r]$ 的答案, 然后 $O(len)$ 的合并, 总合并复杂度就是 $n\log n$ 了.</p><p>于是对于树上也希望找到一种分治, 而且要求每个块和外界的点只有 $O(1)$ 个, 于是树剖, 先把轻儿子都合并到重链上再对重链用序列的方法, 对一个点的轻儿子合并时分治, 对重链序列分治, 复杂度就是 $n\log^2 n$ 了, 如果把树剖改成静态lct的方式就可以单log了.</p><h3 id="P6731-WC2020-选课"><a href="#P6731-WC2020-选课" class="headerlink" title="P6731 [WC2020] 选课"></a>P6731 [WC2020] 选课</h3><blockquote><p>经简化相当于求</p><p>$n$ 个物品, 有重量 $w_i \le 3$ 和代价 $c_i$. 对每个 $k$, 求恰好选重量为 $k$ 的物品最少花费的代价.</p><p>$n \le 5 \times 10^5$</p></blockquote><p>[trick] 结论, 对于重量最大为 $w$ 的背包模 $w!$ 同余的位置是凸的.</p><p>于是相当于维护 $3!$ 个凸包, 每次给它 $\min+$ 卷上一个线段.</p><h3 id="AGC045F"><a href="#AGC045F" class="headerlink" title="AGC045F"></a>AGC045F</h3><p>todo</p><h3 id="P5470-NOI2019-序列"><a href="#P5470-NOI2019-序列" class="headerlink" title="P5470 [NOI2019] 序列"></a>P5470 [NOI2019] 序列</h3><p>模拟费用流, 显然可以建图<br>$s\stackrel{1, a_i}{\longrightarrow} i$,<br>$i’ \stackrel{1, b_i}{\longrightarrow} t$,<br>$i\stackrel{1, 0}{\longrightarrow} i’$,<br>$i \stackrel{1, 0}{\longrightarrow} x$,<br>$x \stackrel{K-L, 0}{\longrightarrow} y$,<br>$y \stackrel{1, 0}{\longrightarrow} i’$.</p><p>然后找增广路, 显然会先走情况1 $s\to i\to x\to y\to j’\to t$, 情况2 $s\to i\to i’\to t$ 就是直接匹配, 此外走反悔边的可以是情况3 $s\to i\to x\to j\to j’\to t$, 相当于选择一个 $a_j$ 去匹配 $b_j$ 并把腾出来的空给 $i$, 与此对应的增广路是 $s\to i\to i’\to y\to j’\to t$. 此外还可以情况4 $s\to i\to i’\to y\to x\to j\to j’$, 腾出一个 $xy$ 流量并让 $a_i, a_j$ 直接匹配 $b_i, b_j$.</p><p>最后可能的是 $s\to i\to i’\to y\to j’\to j\to x\to k\to k’\to t$, 但这个其实是走2+4, 所以没有用.</p><p>于是开5个堆维护即可.</p><h3 id="CF1229F-Mateusz-and-Escape-Room"><a href="#CF1229F-Mateusz-and-Escape-Room" class="headerlink" title="CF1229F Mateusz and Escape Room"></a>CF1229F Mateusz and Escape Room</h3><p>contest records ZSTEST230831 C的原题</p><h3 id="Gym-102331-H-Honorable-Mention"><a href="#Gym-102331-H-Honorable-Mention" class="headerlink" title="Gym 102331 H. Honorable Mention"></a>Gym 102331 H. Honorable Mention</h3><blockquote><p>给定长度为 $n$ 的序列 $a$. $q$ 次查询 $l, r, k$, 求 $a_{l\ldots r}$ 中 $k$ 个不交非空子段和的最大值.</p><p>$n, q, a_i \le 3. 5 \times 10^4$</p></blockquote><p>很厉害的题啊</p><p>考虑这个子段和关于 $k$ 是凸的.</p><p>如果询问全局, 可以考虑分治, 维护 $f_{u, 0&#x2F;1&#x2F;2&#x2F;3}$ 区间 $u$ 和左右是否接通的情况下选出的子段和, 直接分治合并就是单log.</p><p>然后现在区间询问, 考虑拆成 $\log n$ 个区间要求它们闵和的单点, 注意到两个凸包上闵和的斜率为 $k$ 的位置的值就等于两个凸包各自斜率为 $k$ 位置的值的和, 所以只拿这些值去合并, 同时维护段数, 复杂度是二分之后在 $\log n$ 个区间上要lowerbound查斜率为 $k$ 的位置, $n\log^3 n$ 了.</p><p>可以离线后整体二分砍掉一个在段上二分的log.</p><h3 id="How-to-Create-a-Good-Game-Aizu-2230"><a href="#How-to-Create-a-Good-Game-Aizu-2230" class="headerlink" title="How to Create a Good Game Aizu - 2230"></a>How to Create a Good Game Aizu - 2230</h3><blockquote><p>给一个DAG, 要求修改边权使得最大化边权且 $1\to n$ 的最长路不变.</p><p>$n\le 100, m\le 1000$</p></blockquote><p>先求出最长路设为 $L$, 然后开始写线性规划, 则</p><p>$$<br>\max \sum_{i}f_i, \<br>s. t. \<br>d_{v_i}-d_{u_i}-f_i\ge e_i\<br>d_1-d_n\ge -L<br>$$</p><p>直接对偶原问题, 可以得到</p><p>$$<br>\min \sum_{i}x_ie_i-Ly\<br>s. t. \<br>x_i\ge 1\<br>\forall u\ne 1, \sum_{i\in in(u)}x_i-\sum_{i\in out(u)}x_i&#x3D; 0\<br>\sum_{i\in out(1)}x_i&#x3D;y\<br>\sum_{i\in in(n)}x_i&#x3D;y<br>$$</p><p>这就直接有源汇上下界最小费用可行流的形式了, $u\to v$ 连流量 $[1, inf]$ 费用 $e_i$ 的边, $s\to 1$ 连费用为 $-L$ 的即可.</p><h3 id="P6631-ZJOI2020-序列"><a href="#P6631-ZJOI2020-序列" class="headerlink" title="P6631 [ZJOI2020] 序列"></a>P6631 [ZJOI2020] 序列</h3><blockquote><p>有一个长度为 $n$ 的非负整数序列 $a_1, a_2, \cdots, a_n$. 每一步你可以从以下三种操作中选择一种执行:</p><ul><li><p>选择一个区间 $[l, r]$, 将下标在这个区间里的所有数都减 $1$.</p></li><li><p>选择一个区间 $[l, r]$, 将下标在这个区间里且下标为奇数的所有数都减 $1$.</p></li><li><p>选择一个区间 $[l, r]$, 将下标在这个区间里且下标为偶数的所有数都减 $1$.</p></li></ul><p>求最少需要多少步才能将序列中的所有数都变成 $0$.</p><p>对于 100% 的数据, $1 \leq n \leq 100000, 0 \leq ai \leq 10^9, 1 \leq T \leq 10$.</p></blockquote><p>写成线性规划, 给原来每个可能的操作一个系数 $x_i$, 要求 $\min x_i \ s. t. \ \sum_{i\in S_k}x_i\ge a_i, -\sum_{i\in S_k}\ge -a_i$. 其中 $S_k$ 表示操作 $k$ 影响的点.</p><p>对偶, 就是 $\max x_i a_i - y_i a_i$ 满足 $\sum_{i\in S_k} (x_i-y_i)\le 1$, 另 $z_i&#x3D;x_i-y_i$, 就成了给每个位置一个系数 $z_i$(可以为负), 最大化 $z_ia_i$, 要求每个操作对应的系数和不大于 $1$.</p><p>那么直接dp, 设 $f_{i, j, k, l}$ 表示前 $i$ 个点, 以 $i$ 为结尾的区间的和最大值分别为多少, $j, k, l\le 1$ 是显然的, 并且考虑后面影响的时候如果 $j, k, l&lt;0$ 则就相当于 $&#x3D;0$, 于是 $j, k, l\in [0, 1]$, 于是 $z_i\in [-1, 1]$, dp即可.</p><h3 id="XX-Open-Cup-Grand-Prix-of-Tokyo-Evacuation"><a href="#XX-Open-Cup-Grand-Prix-of-Tokyo-Evacuation" class="headerlink" title="XX Open Cup, Grand Prix of Tokyo Evacuation"></a>XX Open Cup, Grand Prix of Tokyo Evacuation</h3><blockquote><p>$[0, n+1]$ 的线段, 给定 $a_0\ldots a_{n+1}$ 表示这个位置洞的大小, 有 $S$ 个老鼠一开始在某个未知的位置 $x$ 有 $S$ 个人, $q$ 次询问对于给定的 $l, r$, 另所有老鼠进洞或走出区间的最小代价的最大值. 走一步代价为 $1$.</p><p>$n\le 2\times 10^5$</p></blockquote><p>考虑若对于区间 $[l, r]$, $i$ 离 $l$ 更进那么其实右边界就没用了, 所以可以设 $f_{l, r}, g_{l, r}$ 表示当前在 $l&#x2F;r$, 走出区间的另一边或进洞的最小代价. 下面只考虑 $f$ 表示当前在区间最左边.</p><p>发现 $f$ 可以预处理 $a$ 的前缀和之后 $O(1)$ 算</p><p>同时发现有 $f_{l, r-1}+f_{l+1, r}\le f_{l+1, r-1}+f_{l, r}$, 要求 $\min_{i&#x3D;l}^r f_{i, r}$, 于是建线段树把区间拆成 $\log n$ 个, 区间内右端点排序后就可以上分治做了.</p><h2 id="NOI2024省选模拟赛15"><a href="#NOI2024省选模拟赛15" class="headerlink" title="NOI2024省选模拟赛15"></a>NOI2024省选模拟赛15</h2><h3 id="A-吴冬拔铲雪"><a href="#A-吴冬拔铲雪" class="headerlink" title="A. 吴冬拔铲雪"></a>A. 吴冬拔铲雪</h3><blockquote><p>给定 $n$ 个点的树, 求有多少个区间 $[l, r]$ 满足编号在区间内的点的导出子图连通块数不大于 $m$.</p><p>$n\le 5\times 10^5, m\le 7$</p></blockquote><p>简单题, 连通块数是点数减边数, 扫描线线段树维护前 $m$ 小即可.</p><h3 id="B-吴冬拔寻宝"><a href="#B-吴冬拔寻宝" class="headerlink" title="B. 吴冬拔寻宝"></a>B. 吴冬拔寻宝</h3><blockquote><p>给定 $n$ 点树, 宝藏以均匀概率位于某个点上, 每次随机一个没问过的点问出它到宝藏距离, 求确定宝藏位置的期望次数.</p><p>$n\le 400$</p></blockquote><p>以宝藏为根, 注意到询问点集 $S$ 相当于询问虚树根到宝藏的距离, 则枚举虚树根 $u$ 算方案数即可, 要求是 $u$ 子树中到 $u$ 的距离和根相同的点所在子树必须有被选点, 且 $u$ 为点集虚树, 直接背包合并即可. 加上枚举根总复杂度 $n^3$</p><h3 id="C-吴冬拔跳广场舞"><a href="#C-吴冬拔跳广场舞" class="headerlink" title="C. 吴冬拔跳广场舞"></a>C. 吴冬拔跳广场舞</h3><blockquote><p>给定长 $m$ 的01串 $x$, 求有多少个长 $n$ 的01串 $S$ 满足不存在连续的长 $k$ 的子串的 $01$ 数量相等.<br>$n\le 114$</p></blockquote><h2 id="NOI2024省选模拟赛16"><a href="#NOI2024省选模拟赛16" class="headerlink" title="NOI2024省选模拟赛16"></a>NOI2024省选模拟赛16</h2><h3 id="A-数排列"><a href="#A-数排列" class="headerlink" title="A. 数排列"></a>A. 数排列</h3><p>见 2021省队集训-模拟 Day1T1</p><h3 id="B-梦魇"><a href="#B-梦魇" class="headerlink" title="B. 梦魇"></a>B. 梦魇</h3><blockquote><p>数 $n\times m\times k$ 的三维空间中从起点 $(a, b, c)$ 出发走 $d$ 步的方案数.</p><p>$n, m, k\le 10^5$</p></blockquote><p>注意到三维独立, 求一维的然后卷起来.</p><p>对于一维是众所周知的反射容斥, 类似之前Day11的D, 但是那个是对所有限制求和而这次是要对步数求和. 则对于 $n&lt; \sqrt d$ 可以直接dp, 对于 $n&gt;\sqrt d$ 用反射容斥可以表示成 $\dfrac{d}{n}&lt;\sqrt d$ 个组合数之和, 随着 $d$ 增加用组合数的递推式维护, 最后复杂度 $d\sqrt d$.</p><h3 id="C-Homura-V-S-Sayaka"><a href="#C-Homura-V-S-Sayaka" class="headerlink" title="C. Homura V. S. Sayaka"></a>C. Homura V. S. Sayaka</h3><blockquote><p>$n$ 点的树, $m$ 条非树边, A追B, 开始时分别位于 $(a, b)$, B先手, 每次可以走一条树边或一条非树边, A只能走树边, 问有多少不同的 $a, b$ 对使得A不可能追上B.</p><p>$n, m\le 10^5$</p></blockquote><p>考虑B赢一定是B走到一条跨过 $\ge 2$ 个点的非树边的一端, 则把跨过 $\ge 2$ 个点的非树边标记为B的必胜点, 对于只跨过一个点的边则对树的结构影响很小, 特判即可, 而B能走到某个点的前提是到B的距离小于A的距离, 统计这样性质的点对考虑点分治, 则对于当前分治中心, 设 $a, b$ 之间离 $a$ 最近的点 $c$ 使得删去 $c$ 后 $a$ 的连通块里有标记点, 分为 $c, a$ 在分治中心一侧和 $b, c$ 在一侧的情况讨论.</p><h2 id="NOI2024省选模拟赛17"><a href="#NOI2024省选模拟赛17" class="headerlink" title="NOI2024省选模拟赛17"></a>NOI2024省选模拟赛17</h2><p>原题见sdsj 2021</p><h3 id="C-Enigma"><a href="#C-Enigma" class="headerlink" title="C. Enigma"></a>C. Enigma</h3><p>hard</p><blockquote><p><img src="/img/2024-01-03-08-05-17-image.png" alt="picture 11">  </p></blockquote><h2 id="NOI2024省选模拟赛18"><a href="#NOI2024省选模拟赛18" class="headerlink" title="NOI2024省选模拟赛18"></a>NOI2024省选模拟赛18</h2><h3 id="A-掉落"><a href="#A-掉落" class="headerlink" title="A. 掉落"></a>A. 掉落</h3><blockquote><p><img src="/img/2024-01-02-15-18-02-image.png" alt="picture 9">  </p><p>$n\le 10^5, w\le 10^5, h\le 10^9$</p></blockquote><p>不用动脑子的方法是kdt, 相当于从上到下扫描板子, 要支持单点加, 矩形和, 矩形赋值为 $0$.</p><p>更好的方法是线段树套堆, 注意到总点数(带权)只有 $O(n+w)$ 个, 所以线段树维护横坐标, 开小根堆维护纵坐标, 每次找到第一个根内元素最小值小于 $u_i+s_i$ 的暴力删点复杂度即是单log.</p><p>KDT要卡常, 方法是如果当前矩形和为 $0$ 就跳过求和&#x2F;赋值为0.</p><h3 id="B-原神"><a href="#B-原神" class="headerlink" title="B. 原神"></a>B. 原神</h3><blockquote><p>$n$ 点树, 初始 $1$ 号点为根, AB博弈, 每个点上有棋子, 每次可以把棋子移动到所在节点的子树内任意一点, 不能操作为负.</p><p>$q$ 次操作每次给一条链加一个棋子, 给子树内的所有点都加一个棋子, 换根.</p><p>每次操作输出SG值.</p><p>$n, q\le 2\times 10^5$</p></blockquote><p>先注意到一个点的SG值是最长链长度. 此外因为SG值是异或所以相当于区间翻转点的状态.</p><p>此时一种做法是先以 $1$ 为根, 考虑以点 $x$ 为根的时候, 除了点 $1$ 到 $x$ 上的点以外都和以 $1$ 为根时相同, 而这条链上的点每个点的值都是以自己(子树包含 $x$ 的儿子)为根时的答案, 树剖, 则大多数点这个儿子都是重儿子.</p><p>另一种的做法是考虑直径的中点, 发现只有直径中点到当前根的路径答案是到除了最远点的子树的次远点, 其他点直接是到自己最远点的距离, 所以换根切换就是修改一条链上的权值.</p><h3 id="C-区间mex快速算法"><a href="#C-区间mex快速算法" class="headerlink" title="C. 区间mex快速算法"></a>C. 区间mex快速算法</h3><blockquote><p><img src="/img/2024-01-02-15-42-44-image.png" alt="picture 10">  </p><p>$n, q\le 3\times 10^5$</p></blockquote><p>显然 $(\prod a_i)\times \mathrm{mex} a_i&#x3D;0$.</p><p>在线做, 先用颜色段均摊解决掉若 $x\notin S, x\in S$, 然后线段树套可删堆维护集合中没出现的元素, 即某个 $S_i$ 的 $\mathrm{mex}$ 就是叶子到根上的最小值, 于是维护子树最小值即可求区间mex的min, 标记维护最小值加, 因此要维护最小值个数.</p><p>写的时候要保证所有删节点的区间都是被添加的, 更确切的说, 要保证若要删除某个区间 $[l, r]$ 必然曾经添加过 $[l, r]$, 而不能是 $[l, p], [p+1, r]$ 并起来.</p><h2 id="计数与数学"><a href="#计数与数学" class="headerlink" title="计数与数学"></a>计数与数学</h2><h3 id="CF1392I-Kevin-and-Grid"><a href="#CF1392I-Kevin-and-Grid" class="headerlink" title="CF1392I Kevin and Grid"></a>CF1392I Kevin and Grid</h3><blockquote><p>给定两个序列 $a_n, b_n$, 构造一张网格图, 每个点上 $(i, j)$ 写着 $a_i+bj$.<br>对于一个给定阈值 $x$, 将图分为 $a_i+b_j\leq x$ 和 $a_i+b_j\geq x$ 两组连通块. 定义一个能够连通到网格图边界的连通块的价值为 $1$, 否则为 $2$. 有 $q$ 次查询, 每次给定 $x$, 求两组连通块各自价值之和的差.<br>$n, q, a_i, b_ii, x \leq 10^5$.</p></blockquote><p>考虑对于平面图的一个连通块有 $V-E+F&#x3D;1$(不考虑外面的无限区域), 则连通块数 $C&#x3D;V-E+F$.</p><p>要求 $Ans&#x3D;A_1+B_1-A_2-B_2$, 其中 $A$ 为总连通块数, $B$ 为不和边界连通的块数, 又可以转化为 $Ans&#x3D;V_1-V_2-E_1+E_2+F_1-F_2+B_1-B_2$, 而<strong>观察不到对于每个 $F_1$ 的区域, 要么是四个相邻点围成的一个格子, 要么里面正好包含一个 $B_2$ 的格子</strong>.</p><p>于是就可以表示成 $Ans&#x3D;V_1-V_2-E_1+E_2+D_1-D_2$, 其中 $D$ 表示四个相邻点围成的格子的个数. 此时 $V, E, D$ 都很局部, 可以直接FFT优化计数, 如 $a_i+b_j\ge x$ 的横着的边可以由 $\min{a_i+a_{i+1}}+b_j\ge x$ 的数量算, $D$ 可以由 $\min(a_i, a_i+1)+\min(b_j, b_{j+1})\ge x$ 算. 复杂度 $n\log n+q$</p><h3 id="飞翔的胖鸟"><a href="#飞翔的胖鸟" class="headerlink" title="飞翔的胖鸟"></a>飞翔的胖鸟</h3><blockquote><p>给定 $a, b, h$, 求<br>$$<br>\min_{\theta\in [0, \frac{\pi}{2}]}b\theta+\dfrac{ah}{\sin \theta}<br>$$</p></blockquote><p>直接求导得 $\dfrac{b}{ah}&#x3D;\dfrac{\cos \theta}{\sin^2 \theta}$, 把 $\sin^2$ 换成 $1-\cos^2$ 即可.</p><p>坑: $b&#x3D;0$</p><h3 id="HAMILTON"><a href="#HAMILTON" class="headerlink" title="HAMILTON"></a>HAMILTON</h3><blockquote><p>给定 $L \times n$ 个节点的图, 分成 $L$ 层, 每层是 $n$ 个点的完全图, 相邻两层之间的 $n$ 对点对应连边. 求这张图的哈密顿回路数量.</p><p>$L, n \le 500$.</p></blockquote><p>直接dp, $f_{i, j}$ 表示前 $i$ 层最后一层向上留出 $i$ 段($2i$ 个端点), 每次转移要合并这些端点和新的一层的其他 $n-2i$ 个孤立点, 直接算把 $a$ 个段合并成 $b$ 个段只要算 $\dfrac{a! }{b! }\binom{a-1}{b-1}$(先给 $a$ 个版乱序再插板再除掉顺序), 但是这 $a$ 个段中有 $n-2i$ 个不能自己一段, 枚举钦点 $k$ 个孤立点不成段的方案即可, 总复杂度是 $n^2L$</p><h3 id="loj6696-复读机-加强版"><a href="#loj6696-复读机-加强版" class="headerlink" title="loj6696 复读机 加强版"></a>loj6696 复读机 加强版</h3><blockquote><p>群里有 $k$ 个不同的复读机. 为了庆祝平安夜的到来, 在接下来的 $n$ 秒内, 它们每秒钟都会选出一位优秀的复读机进行复读. 非常滑稽的是, 一个复读机只有总共复读了 $d$ 的倍数次才会感到快乐. 问有多少种不同的安排方式使得所有的复读机都感到快乐.</p><p>$n\le 10^9, k\le 5\times 10^5, d\in {1, 2, 3, 4, 6}$, 保证模数 $P$ 满足 $d\vert P-1$</p></blockquote><p>相当于求</p><p>$$<br><a href="%5Csum_%7Bi=0%7D%5Cdfrac%7Bx%5E%7Bid%7D%7D%7B(id">x^n</a>! })^k<br>$$</p><p>对这种 $id$, $d$ 又很小, 考虑单位根反演</p><p>$$<br>\sum_i [d\vert i]\dfrac{x^i}{i! }&#x3D;\sum_i \dfrac{x^i}{i! } \dfrac{1}{d}\sum_{j&#x3D;0}^{d-1}w_d^{ij}<br>&#x3D;\dfrac{1}{d}\sum_{j&#x3D;0}^{d-1} w_d^je^{w_dx}<br>$$</p><p>分类讨论, 当 $d&#x3D;1$ 时显然, $d&#x3D;2$ 时 $w&#x3D;-1$ 则求 $<a href="e%5E%7B-x%7D+e%5Ex">x^n</a>^k$, 则 $e^ix$ 的系数显然是 $\binom{k}{\frac{k+i}{2}}$.</p><p>对于 $d&#x3D;3, 4, 6$, 其共同点是 $\varphi(x)&#x3D;2$, 这里又有结论说</p><p>[trick] 对于单位根 $w_k^0\ldots w_k^{k-1}$, 可以被其中的 $\varphi(x)$ 个以整系数线性表示, 于是最终会变成 $\sum_{i&#x3D;0}^{d-1}e^{(c_i+d_iw)x}$ 的 $k$ 次方, 然后见到这种项数小的直接微分有限递推即可.</p><p>[trick] 求 $[x^n]F^k$, $n$ 很大 $k$ 不大 $F$ 项数很小的情况, 微分有限直接递推.</p><p>这个递推很好写, 因为没有的项都是 $0$ 没有奇怪的边界.</p><h3 id="loj3626-愚蠢的在线法官"><a href="#loj3626-愚蠢的在线法官" class="headerlink" title="loj3626 愚蠢的在线法官"></a>loj3626 愚蠢的在线法官</h3><blockquote><p>给系统一棵 $n$ 个点的有根树和每个点的点权 $v_i$, 且令根为节点 $1$, 同时传给系统一个长度为 $k$ 的数组 $A$, 构造阶为 $k$ 的方阵 $B$, 其中 $b_{i, j}&#x3D;v_{LCA(A_i, A_j)}$, 即:<br>$$<br>B&#x3D;\begin{bmatrix}<br>v_{LCA(A_1, A_1)} &amp; v_{LCA(A_2, A_1)} &amp; \cdots &amp; v_{LCA(A_k, A_1)} \<br>v_{LCA(A_1, A_2)} &amp; v_{LCA(A_2, A_2)} &amp; \cdots &amp; v_{LCA(A_k, A_2)} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>v_{LCA(A_1, A_k)} &amp; v_{LCA(A_2, A_k)} &amp; \cdots &amp; v_{LCA(A_k, A_k)}<br>\end{bmatrix}$$<br>其中 $LCA(x, y)$ 为节点 $x$ 和 $y$ 的最近公共祖先, 当你传入数组 $A$ 后, 将计算构造出来的这个方阵的行列式.</p><p>$n, k\le 5\times 10^5$</p></blockquote><p>显然 $A$ 是排列否则行列式为 $0$. 同时 $A$ 的顺序没有影响(交换一次行一次列答案不变), 假设它是dfs序, 因为是树的结构考虑能不能递归做.</p><p>那么因为一个子树是一个区间, 不同子树的lca全是根, 所以会把矩阵画出若干个沿对角线, 对角相接的小方阵, 每个代表一个子树, 剩下的地方全是 $v_1$.</p><p>[trick] 若 $M’<em>{i, j}&#x3D;M</em>{i, j}+x$, 则 $\det M’&#x3D;\det M+(\sum_{i, j} A_{i, j})x$, 其中 $A_{i, j}$ 为 $i, j$ 处的代数余子式.</p><p>于是可以dp了, 设 $f_u$ 表示 $u$ 所在子树部分所有数都减去 $u$ 的行列式, $g_u$ 表示 $u$ 所在子树部分的矩阵的代数余子式的和:</p><ul><li>那么如果 $u$ 没有出现在矩阵中, 矩阵的形态是沿着对角线若干个对角相连的小方阵即每个儿子子树对应区域, 其他位置全是 $w_u$, 给所有位置都减去 $w_u$ 求出 $f_v$, 则 $f_u&#x3D;\prod f_v+g_uw_u$, $g_u&#x3D;\sum_i g_i\prod_{j\ne i} f_j$, $f$ 的转移显然, $g$ 的转移是注意到子树外位置的代数余子式都是 $0$.</li><li>如果 $u$ 出现在矩阵中, 则第一行第一列和其他儿子子树部分之外的地方全是 $v_1$, 用下面每一行减去第一行, 则递归成了第一行是 $w_u$, 下面除了儿子子树对应区域全是 $0$ 的问题, 有 $f_u&#x3D;w_u\prod f_v, g_u&#x3D;\prod f_v$, 其中 $g_u$ 的转移是注意到, 对于一行的代数余子式之和, 其等于把这一行都换成 $1$ 之后的矩阵求行列式, 此时和第一行全为 $w_u$ 的线性相关行列式为 $0$, 所以最后只有第一行第一列的代数余子式剩下, 即 $\prod f_v$</li></ul><p>复杂度线性.</p><h3 id="loj3653-抽奖机"><a href="#loj3653-抽奖机" class="headerlink" title="loj3653 抽奖机"></a>loj3653 抽奖机</h3><blockquote><p>有 $n$ 个 $\bmod 3$ 的加法单元, 一开始这些单元为 $0$.<br>有 $m$ 种操作, 第 $i$ 种操作选择 $a$ 个单元 $+1$, $b$ 个单元 $+2$(选出的两部分不交). 你要进行 $k$ 轮操作, 每轮选择一种操作(每轮共有 $\binom{n}{a, b}$ 种可能).</p><p>问 $k$ 轮以后, 有 $i$ 个单元为 1, $j$ 个单元为 2 的方案数.</p><p>$n \leq 100, k \leq 10^{18}, \text{mod} &#x3D; 10^9+9$</p></blockquote><p>考虑相当于对一个集合多项式做3-FWT, 每个操作可以表示为三进制下的多项式 $F_i$, 若 $S$ 中包含 $a_i$ 个 $1$ 和 $b_i$ 个 $2$ 则 $x^S$ 的系数为 $1$, 而最后就是要求 $G&#x3D;\sum F_i$ 的 $\sum_{S, cnt_1&#x3D;i, cnt_2&#x3D;j} [x^S]G^k$</p><p>发现对于 $1, 2$ 个数相等的元素系数都是一样的, 考虑把它们压起来, 就要解决压起来的情况如何做FWT.</p><p>先回顾本来FWT-k是怎么做的:</p><p>[trick] FWT的变换都可以认为是找 $c’(S, T)$ 使得 $[x^S]F’&#x3D;\sum_T [x^T]F$, 而 $c’(S, T)$ 又是关于位独立的即 $c’(S, T)&#x3D;\prod_i c(S_i, T_i)$. 对于FWT-k, 就有 $c_{i, j}&#x3D;w_k^{ij}$, 逆运算则是 $c_{i, j}&#x3D;\dfrac{1}{k}w_k^{-ij}$.</p><p>那么现在, 用 $(a, b)$ 表示 $a$ 个 $1$, $b$ 个 $2$, $n-a-b$ 个 $0$ 的状态, 则 $c((a, b), (c, d))&#x3D;\sum_T \prod_i c(S_i, T_i)$ 其中 $S$ 为任意一个满足 $(a, b)$ 的状态而 $T$ 是遍历所有 $(c, d)$ 的状态.</p><p>那么 $A&#x3D;(a, b), B&#x3D;(c, d), c(A, B)$ 重要的就是 $a$ 个 $1$ 对应的 $B$ 中元素 $1, 2$ 的个数和 $b$ 个 $2$ 对应的个数, 这两部部分合并是二维背包, 可以写出BGF:</p><p>$$<br>\begin{gathered}<br>c((a, b), (c, d))&#x3D;[x^c y^d] (1+wx+w^2y)^a(1+w^2x+w^4)^y(1+x+y)^{n-a-b}\<br>let\ c(c(a, b), (c, d))&#x3D;[x^c y^d]F_{a, b}(x, y)\<br>\therefore<br>F_{a, b}&#x3D;F_{a-1, b}\dfrac{1+wx+w^2y}{1+x+y}<br>\end{gathered}<br>$$</p><p>于是能递推了, 推一下复杂度 $n^2$, 总复杂度 $n^4$</p><h2 id="NOI2024省选模拟赛19"><a href="#NOI2024省选模拟赛19" class="headerlink" title="NOI2024省选模拟赛19"></a>NOI2024省选模拟赛19</h2><h3 id="A-最小四贪那树"><a href="#A-最小四贪那树" class="headerlink" title="A. 最小四贪那树"></a>A. 最小四贪那树</h3><blockquote><p>给定 $n$ 点完全图, $q$ 次询问一个给定子集的最小斯坦纳树.</p><p>$n\le 21, q\le 10^5$</p></blockquote><p>先预处理 $g_{S, i}$ 为集合 $S$ 中点到点 $i$ 的最小距离, 再dp出 $f_S$ 为点集 $S$ 的最小生成树, 再跑FMT即可.</p><p>复杂度 $n2^n$, 然而不处理 $g$ 的 $n^22^n$ 也过了.</p><h3 id="B-数位"><a href="#B-数位" class="headerlink" title="B. 数位"></a>B. 数位</h3><blockquote><p>给定序列 $b_n$, 定义 $f(x)$ 为 $x$ 的十进制表示下所有位的值的权值和, 如 $f(2024)&#x3D;c_2+c_0+c_2+c_4$.</p><p>给定字符串 $a_n$ 包含<code>0-9</code>和<code>? </code>, 要求把<code>? </code>替换成数字, 设得到的数为 $a$, 最大化 $\sum_{i&#x3D;1}^n f(b_i+a)$.</p><p>$a$ 不能有前导 $0$.</p></blockquote><p>很经典的trick, 在lyh dp那篇里出现过, 就是加上相同的数 $x$, 第 $i$ 位会进位的数一定是最低 $i-1$ 位从大到小排序后的前缀.</p><p>于是设 $f_{i, j}$ 表示最低 $i$ 位, 进位的数有 $j$ 个即可转移, 复杂度 $10n^2$, 排序可以用<code>stable_sort</code></p><h3 id="C-树与"><a href="#C-树与" class="headerlink" title="C. 树与"></a>C. 树与</h3><blockquote><p>$q$ 次询问树链上选 $m$ 个点, 点权按位与的最大值.</p><p>$n\le 10^6, q\le 10^5, a_i\le 2^{64}$($a_i$ 是点权)</p></blockquote><p>contest records KFC NOIP 2022(20221125wjw模拟赛) C. sequence CF1665E有这个题选 $2$ 个数的情况的结论.</p><p>加强结论, 考虑选 $m$ 个数仍然可以用相同方式归纳, 若现在试图证明对于值域为 $2^k$ 下最多有 $(m-1)k$ 个, 那么若这一位有至少 $m$ 个 $1$, 这一位一定选 $1$, 选到的一定是前 $k-1$ 位的最大值拼上一个 $1$, 否则这一位最后的值是 $0$, 选的数可能这一位是 $1$ 则一定来自前 $k-1$ 位的最大值, 再加上新增的最多 $m-1$ 个这一位是 $1$ 的数.</p><p>于是有结论</p><p>[trick]: 在值域 $V$ 的集合 $S$ 中选 $m$ 个数最大化按位与或最小化按位或, $m$ 个数一定都是最大&#x2F;最小 $(m-1)\lg V$ 个数中的数.</p><p>于是先求链上前 $m\lg V$ 大, 直接线段树维护多log, 考虑用ST表支持求最大, 树剖成 $\log n$ 个区间把区间压到堆里, 每次弹出一个区间拿出它的最大值再分裂成两个放回去. 复杂度 $qm\log V\log(m\log V)$.</p><p>然后贪心部分就是从高到低删判断数量.</p><p>在贪心过程中求前若干大而不是先求后贪可以有效卡常.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南外省选集训</title>
      <link href="/2023/12/11/nflssxjx2/"/>
      <url>/2023/12/11/nflssxjx2/</url>
      
        <content type="html"><![CDATA[<p>文章太长, 拆出一个新的</p><h1 id="NOIP后南外省选集训"><a href="#NOIP后南外省选集训" class="headerlink" title="NOIP后南外省选集训"></a>NOIP后南外省选集训</h1><h2 id="NOI2024省选模拟赛20"><a href="#NOI2024省选模拟赛20" class="headerlink" title="NOI2024省选模拟赛20"></a>NOI2024省选模拟赛20</h2><h3 id="A-网络单纯形"><a href="#A-网络单纯形" class="headerlink" title="A. 网络单纯形"></a>A. 网络单纯形</h3><blockquote><p>给定连通无向图 $Graph(n, m)$, 边有边权 $w_i$, 点有颜色 $c_i$, $q$ 次修改一个点的颜色询问所有连通不同颜色点的边的边权最小值.<br>$n, q\le 2\times 10^5$</p></blockquote><p>考虑两个颜色的答案就是给定的两个集合间的最近的一条边, 那么这条边一定在最小生成树上.</p><p>用堆维护每个点的所有儿子的信息, 修改时更新父亲节点的数据结构即可.</p><h3 id="B-原神账号"><a href="#B-原神账号" class="headerlink" title="B. 原神账号"></a>B. 原神账号</h3><blockquote><p>给定 $a_n$, $m$ 次询问第 $i$ 次给定 $k_i$ 个区间和 $k_i$ 个区间 $[l_j, r_j]$ 问区间并的颜色数. 强制在线. 空间8Mb.</p><p>$n, \sum k, m\le 10^5$</p></blockquote><p>早上刚看了跳进兔子洞就开到这个题, 容易想到bitset, 问题变成如何在8Mb下提取区间bitset.</p><p>容易想到st表, 空间爆炸, 容易想到分块, 时间爆炸.</p><p>但是分块是可以调块长的! 设块长为 $B$, 每 $B$ 个分一块, 块间st表, 空间时间都是 $\dfrac{n^2}{Bw}\log \dfrac{n}{B}$, 取 $B&#x3D;\dfrac{n}{w}$ 得到 $n\log w$, 过了.</p><h3 id="C-肖芬途"><a href="#C-肖芬途" class="headerlink" title="C. 肖芬途"></a>C. 肖芬途</h3><blockquote><p>给定 $n$ 点树, $1$ 为根, 有点权 $a_i$, 设 $i$ 的父亲为 $fa_i$, 保证 $fa_i&lt;i, fa_i\le fa_{i+1}$.</p><p>$q$ 次询问给定区间求 $\sum_{x&#x3D;l}^r \sum_{y&#x3D;l}^r [l\le lca(x, y)\le r]a_xa_y$</p><p>强制在线 $n, q\le 2. 5\times 10^5$</p></blockquote><p>首先容易想到 $fa$ 的这两个性质比较重要, 发现它是描述了像zkw线段树一样从上到下按层标号的”bfs序”.</p><p>显然考虑扫描线, 扫 $r$ 的话, 对当前询问区间 $[l, r]$, 区间内的点的连通块的所有根也形成编号上一个区间, 而答案就是 $\sum_{rt} (\sum_{u\in subtree(rt), u\in [l, r]} a_u)^2$, 那么只要根号重构, 维护出子树点权和在编号维上的前缀和就可以查询整块答案, 此外散块的修改可以直接求 $k$ 级祖先看它是哪个子树里的计算贡献.</p><p>然后强制在线就把扫描线可持久化也就是记录每个 $r&#x3D;kB$ 时每个点的子树大小了.</p><h2 id="NOI2024省选模拟赛21"><a href="#NOI2024省选模拟赛21" class="headerlink" title="NOI2024省选模拟赛21"></a>NOI2024省选模拟赛21</h2><h3 id="A-盗梦空间"><a href="#A-盗梦空间" class="headerlink" title="A. 盗梦空间"></a>A. 盗梦空间</h3><blockquote><p>给定一棵树, $q$ 次给定点集 $S$, 询问树上每个点到 $S$ 中的点的最小距离的最大值.<br>$n, \sum \vert S\vert, q\le 10^5$</p></blockquote><p>一眼虚树, 代码量略大, 对于虚树每条边, 每个子树, 虚树根外的答案都是显然的, 用了树剖加st表查虚树的边的答案.</p><h3 id="B-偷藏女装"><a href="#B-偷藏女装" class="headerlink" title="B. 偷藏女装"></a>B. 偷藏女装</h3><blockquote><p>小W摆放物品时有个习惯, 不喜欢打乱原先物品的位置, 因此小家的衣柜只能从两财开, 可以从左边放衣服进去也可以从右边放衣服进去, 并且会把之前已经在衣柜里的衣服往中间挤. 比如衣柜里面已经有 $1, 2, 3$ 三件衣服了, 现在从左边放一件 $4$ 号衣服进去就变成了 $4, 1, 2, 3$, 在右边放一件 $5$ 号衣服就变成了 $4, 1, 2, 3, 5$. 现在AlseoR带着机房人民集资为小A买的 $n$ 件衣服潜入了小A的家, 将衣服按编号从小到大放进衣柜, 每次可以任意选择左侧或者右侧放入.</p><p>但是小W作为一个强迫症, 他希望可以存在一种方式从衣柜两侧不断取出衣服((取完为止), 每次可以任意选择将左似的衣服或者右侧的取出, 第 $K$ 件可以取出女装. 所以他想问问你方案的总数. 由于小A不知道衣柜里面的衣股是怎么摆放的, 所以他只关心取出的顺序字. 即对于两个方案不同, 当且仅当存在一个 $x$ 两个方案取出的第 $x$ 件衣服编号是不同的. 当然这个数可能很大, 所以小A决定从他最喜欢的三个数中选一个给你当模数.</p><p>$n, m\le 10^9$</p></blockquote><p>考虑最后取出序列满足的条件, 衣柜里是一个单谷的中间是 $1$, 则取出序列一定满足:</p><ul><li>前 $k-1$ 个元素可以被划分成两个递减序列.</li><li>$a_k&#x3D;1$</li><li>后 $n-k$ 个序列是一个递增序列每次取头&#x2F;尾得到.</li><li>前 $k-1$ 个元素划分出的序列中某个序列的最小值大于后 $n-k$ 个元素</li></ul><p>todo</p><h3 id="C-楼梯调度"><a href="#C-楼梯调度" class="headerlink" title="C. 楼梯调度"></a>C. 楼梯调度</h3><blockquote><p>对于一个序列 $a_1\ldots a_m$, 其权值为 $\sum_{i&#x3D;1}^m \max_{j&#x3D;1}^i a_i$, 现在给定 $a_n$ 求把它划分成两个序列 $b, c$ 后两个序列最小权值和.</p><p>$n\le 5\times 10^5$</p></blockquote><p>先上来dp, 容易想到设 $f_{i, j}$ 表示前 $i$ 个人, 让序列 $b$ 的前缀 $\max$ 是序列 $a$ 的前 $i$ 个数的最大值, 此时 $c$ 的前缀 $\max$ 是 $j$ 的情况下的最小代价. 转移考虑新加的数 $a_i$, 可以放到 $b$ 序列(设 $s_i&#x3D;\max_{j&#x3D;1}^i a_i$)$f_{i, j}&#x3D;f_{i-1, j}+s_i$, 可以放到 $c$ 序列 $f_{i, j}&#x3D;f_{i-1, j}+j, \ if\ j&gt;a_i$, $f_{i, j}&#x3D;\min_{k&lt;j} f_{i-1, k}+a_i\ if\ j&#x3D;a_i$.</p><p>发现转移只需要维护一个序列支持区间加, 区间加下标, 区间最小值, 单点修改, ktt秒了.</p><p>然后这个题里因为每次后缀加下标不影响势能, 前缀加单点修改只影响边界的log个节点, 所以可以分析到 $\log^2$ 而不是 $\log^3n$</p><h2 id="NOI2024省选模拟赛22"><a href="#NOI2024省选模拟赛22" class="headerlink" title="NOI2024省选模拟赛22"></a>NOI2024省选模拟赛22</h2><h3 id="A-染色问题"><a href="#A-染色问题" class="headerlink" title="A. 染色问题"></a>A. 染色问题</h3><blockquote><p>给定一个 $n$ 个点 $m$ 条边的联通无向图, 给图上每个点染上 $k$ 种颜色中的一种, 且要求每一条边的两个端点不同色(不需要使用全部 $k$ 种颜色). 求方案数.</p><p>$n\le 10^5, m\le n+5$</p></blockquote><p>广义串并联图说我们直接缩一度点和二度点, 即若一个点度数为 $1$ 可以删掉然后给答案乘 $k-1$, 如果度数为 $2$ 则设一条边 $(a, b)$ 表示这条边两边点颜色相同时方案数为 $a$, 不同时为 $b$, 则若原来该点连的两条边分别是 $(a, b), (c, d)$, 新的边应为 $(ac+(k-1)bd), (ac+bd+(k-2)bd)$, 缩到最后直接枚举颜色的集合划分 $B(10)$ 即可.</p><h3 id="B-IOer"><a href="#B-IOer" class="headerlink" title="B. IOer"></a>B. IOer</h3><blockquote><p>小Z是一个IOer, 很快就要参加IO省选了, 他可以用来刷题的时间还剩下 $n$ 天. 由于IO题非常简单, 你可以认为小Z能在一天内刷完任意数量的IO题, 且每题只会考察一个知识点.</p><p>IO题的数量非常多, 你可以认为考察每个知识点的IO题都是足够多的. 在开始刷题前, 小Z只会 $v$ 个知识点.</p><p>在这 $m$ 天中, 小Z会每天学习新的知识点. 在第 $i$ 天开始刷题前, 小Z会学习 $u$ 个新知识点. 即在第 $i$ 天刷题时, 小Z已经掌握了 $v+ui$ 个不同的知识点. 只有一道题所考察的知识点已被掌握时, 小Z才能刷这道题.</p><p>虽然IO题非常简单, 但是小Z还是不能做到同时刷多道IO题, 因此小Z在同一天刷的题, 时间上存在先后顺序.</p><p>小Z想在省选前刷恰好 $o$ 道题. 小Z不关心题目的具体内容, 只关心题目所考察的知识点. 他想知道, 共有多少种不同的刷题方案. 两种刷题方案是不同的, 当且仅当存在 $1&lt;i&lt;n$, 按时间顺序, 小Z刷第 $i$ 道题的时间在两个方案中不在同一天, 或小Z刷的第 $i$ 道题所考察的知识点不同. 但是小Z不会OI, 所以他无法求出不同的刷题方案数. 于是他找到了你, 一个能随手AK模拟赛的OIer, 希望你帮他解决这个问题.</p><p>由于答案可能很大, 你只需要回答答案模 $998244353$ 的值.</p><p>$n\le 10^{18}, m\le 2\times 10^5, u, v\le 10^9$</p></blockquote><p>显然可以列答案的生成函数: $ans&#x3D;[z^n]\prod \dfrac{1}{1-(ui+v)x}$.</p><p>发现 $n$, $m$ 都很大, 直接线性递推只能做到 $m\log m\log n$ 肯定不行, 此时考虑分式分解, 也就是像我们一开始求Fib数列时, 把它的生成函数拆成 $\dfrac{1}{1-cx}$ 的形式以得到通项的方法, 显然对于多项式 $\dfrac{p}{\prod_i q_i}$, 拆成 $\sum_i \dfrac{d_i}{q_i}$ 后 $d_i$ 的系数小于 $q_i$, 得到方程 $\sum_i\dfrac{Md_i}{q_i}&#x3D;p$, 其中 $M&#x3D;\prod_i q_i$,</p><p>考虑因为 $d_i$ 的次数小于 $q_i$, 所以 $d_i&#x3D;d_i\bmod q_i$, 两边都模掉 $q_i$ 后, 左边只有第 $i$ 项不为 $0$, 于是得到 $\dfrac{M}{q_i}d_i\equiv p\pmod {q_i}$, 于是只要求 $p\bmod q_i$ 和 $(\dfrac{q_i}{M})\bmod q_i$, 对于本问题 $p\bmod q_i&#x3D;1\bmod q_i&#x3D;1, \dfrac{q_i}{M}\bmod q_i&#x3D;\dfrac{q_i}{M}[\dfrac{1}{ui+v}]&#x3D;\dfrac{1}{\prod_{j\ne i}(1-\dfrac{uj+v}{ui+v})}&#x3D;\dfrac{u^{1-m}(ui+v)^{m-1}}{\prod_{j\ne i}(i-j)}$(这里用方括号表示函数求值), 化成阶乘做完了.</p><p>最后复杂度 $n\log n$(快速幂).</p><p>组合意义:</p><p><img src="/img/2024-01-13-14-37-34-image.png" alt="picture 13">  </p><h3 id="C-力脑"><a href="#C-力脑" class="headerlink" title="C. 力脑"></a>C. 力脑</h3><blockquote><p>有一长度为 $n$ 的仅由<code>0</code>和<code>1</code>构成的字符串 $s$, 某些位置的字符已经给定, 其他位置的字符等概率取<code>0</code>或<code>1</code>, 求 $s$ 的后缀自动机的结点数量的期望, 答案对 $998244353$ 取模.</p><p>$n\le 36$</p></blockquote><p>考虑SAM的节点数和parent tree的节点数是一样的而后者结构显然更好考虑, 那么对于字符集为 $2$ 的 $s$ 后缀树每个点最多有两个儿子, 设 $0&#x2F;1&#x2F;2$ 个儿子的数量分别为 $a, b, c$, 则分别求 $a, b, c$ 的期望即可. 发现叶子个数 $a&#x3D;c+1$, 于是只要求 $a, b$ 了.</p><p>考虑SAM的parent tree什么时候只有 $0&#x2F;1$ 个儿子, $0$ 个儿子一定是一个前缀且全串只出现一次, $1$ 个儿子一定是一个前缀最前面加一个<code>0/1</code>恰好有一种在字符串中出现过.</p><p>先考虑 $a$ 怎么算, 一个暴力是对每个前缀单独计算 $p_i$ 表示 $i$ 前缀只出现一次的概率, 则它不能是另一个前缀的后缀, 考虑容斥它是集合 $S$ 中的后缀的前缀其他任意, 则可以得到若干相等关系, 把它建图计算方案数, 复杂度是 $n^22^{n-i}$($S$ 中只有更长的前缀).</p><p>那如果找到一个 $2^i$ 的东西就赢了, 于是可以直接枚举这个前缀到底是什么, 然后dp每个位置的容斥系数之和, 设 $f_j$ 表示 $j$ 是 $S$ 中最大的元素的情况下所有位置的容斥系数乘只考虑前 $j$ 个位置的方案数的和, 则对于 $f_j$, 首先如果 $f_j$ 的最后 $i$ 个位置无法和当前枚举的匹配显然是 $0$, 否则枚举当前前缀上一次出现的位置 $k$, 若 $j-k&lt; i$ 则有重叠, 要求 $j-k$ 是一个border, 如果 $j-k\ge i$ 则中间没有覆盖的没确定的位置可以任选. 这个的复杂度就是 $n^22^i$</p><p>于是求 $a$ 的总复杂度是 $n^22^{\frac{n}{2}}$, 再考虑求 $b$, 直接算前缀加一个<code>0</code>出现至少一次不好算, 考虑一个点有一个儿子等价于不是叶子且它没有另一个儿子. 而没有加<code>1</code>得到的儿子就是在这个前缀前面加一个<code>1</code>不出现在字符串中, 发现正好是字符串前面添一个<code>1</code>然后跑刚才的做法得到的(实际上刚才求得不是恰好出现一次而是没在其他位置出现), 于是恰好只加<code>0</code>的儿子的概率实际上是 $p_{1, i}-p_i$, 其中 $p_{0&#x2F;1, i}$ 表示在字符串前面添加一个字符<code>0/1</code>之后跑出的答案.</p><p>最终答案是 $a+b+c&#x3D;2a+b-1&#x3D;(\sum_i 2p_i+p_{0, i}-p_i+p_{1, i}-p_i)-1&#x3D;(\sum_0 p_{1, i}+p_{1, i})-1$.</p><h2 id="字符串专题"><a href="#字符串专题" class="headerlink" title="字符串专题"></a>字符串专题</h2><h3 id="失配树"><a href="#失配树" class="headerlink" title="失配树"></a>失配树</h3><blockquote><p>给定字符串 $s_n$, $m$ 次询问 $s_{1\ldots p}, s_{1\ldots q}$ 的最长公共border长度.</p><p>$p, q, s\le 10^6, m\le 10^5$</p></blockquote><p>失配树说的是每个点向自己的最长border连边, 则这个题是求lca.</p><h3 id="P4156-WC2016-论战捆竹竿"><a href="#P4156-WC2016-论战捆竹竿" class="headerlink" title="P4156 [WC2016] 论战捆竹竿"></a>P4156 [WC2016] 论战捆竹竿</h3><blockquote><p>给定长 $n$ 的字符串 $S$, 有一个空串, 求每次可以将 $S$ 去掉一个border的部分拼上去求最后长度在 $[n, w]$ 内有多少长度可以拼出来.</p><p>$n\le 5\times 10^5, w\le 10^18$</p></blockquote><p>考虑就是用 $S$ 所有周期长度线性组合, 先求出所有周期 $a_1\ldots a_k$. 然后接下来问题是同余最短路的形式.</p><p>直接做同余最短路的转圈是 $n^2$, 考虑优化, 有结论一个串的border构成 $\log n$ 个值域不交的等差数列, 那么转圈的时候一次转移一个公差为 $d$ 长 $n$ 的等差数列, 单调队列转移即可.</p><h3 id="P4548-CTSC2006-歌唱王国"><a href="#P4548-CTSC2006-歌唱王国" class="headerlink" title="P4548 [CTSC2006] 歌唱王国"></a>P4548 [CTSC2006] 歌唱王国</h3><blockquote><p>求字符集为 $m$ 的情况下, $T$ 初始为空, 每次随机一个字符串追加到 $T$, 期望多少次使得 $S$ 为 $T$ 的子串.</p><p>$\vert S\vert \le 10^7, m\le 10^9$</p></blockquote><p>列PGF, 设 $F$ 是还不包含 $S$ 的PGF, $G$ 是包含 $S$ 的PGF.</p><p>给 $G$ 的情况添加整个串 $S$ 一定得到包含 $S$ 的串, 但可能加了一半就得到了, 发现此时加了一个 $S$ 的border, 于是就是<br>$$<br>m^{-\vert S\vert}x^{\vert S\vert}F&#x3D;\sum_{i\in border(S)}Gx^{\vert S\vert -i}m^{-\vert S\vert +i}<br>$$</p><p>最后要求的期望步数是 $\sum f_i&#x3D;F(1)$, 于是 $F(1)&#x3D;\sum_{i\in border(S)} m^iG(1)$, 而 $G(1)$ 是最终能得到的概率之和也就是 $1$, 于是 $F(1)&#x3D;\sum_{i\in border(S)} m^i$ 了.</p><h3 id="hdu6791-Tokitsukaze-CSL-and-Palindrome-Game"><a href="#hdu6791-Tokitsukaze-CSL-and-Palindrome-Game" class="headerlink" title="hdu6791 Tokitsukaze, CSL and Palindrome Game"></a>hdu6791 Tokitsukaze, CSL and Palindrome Game</h3><blockquote><p>在歌唱王国的基础上, 给定字符串 $S$, 每次给定两个区间询问用上一题的方法哪个区间的答案大. 保证两个区间都是回文子串.</p><p>$n, q\le 10^5$</p></blockquote><p>用PAM处理可以得到每个回文子串的border的若干个等差数列, 而因为等差数列值域无交, $\sum_{i\in border(T)} m^i$ 的式子中没有进位, 于是只要比较border序列字典序即可.</p><h3 id="ROI-2016-DAY2二指禅"><a href="#ROI-2016-DAY2二指禅" class="headerlink" title="ROI 2016 DAY2二指禅"></a>ROI 2016 DAY2二指禅</h3><p>原题! 本篇训练赛8 C. 数据结构</p><h3 id="CF1483F-EXAM"><a href="#CF1483F-EXAM" class="headerlink" title="CF1483F EXAM"></a>CF1483F EXAM</h3><blockquote><p>给定互不相同的字符串 $s_1, s_2, \cdots, s_n$, 求有多少对 $(i, j)$ 满足:</p><ul><li>$i \neq j$</li><li>$s_j$ 是 $s_i$ 的子串.</li><li>不存在 $k$, $(k \neq i, k \neq j)$ 满足 $s_j$ 是 $s_k$ 的子串且 $s_k$ 是 $s_i$ 的子串.</li></ul><p>保证 $n, \sum \lvert s_i \rvert \leq 10^6$.</p></blockquote><p>考虑对于长的串考虑其对短串的贡献, 则对 $s_i$ 枚举 $s_j$ 的右端点位置, 显然每个右端点只有最长的是有用的, 对每个右端点 $r$ 处理出 $l_r$ 表示最小的 $l$ 满足 $[l, r]$ 是某个 $s_j$, 那显然被包含的区间不能贡献, 而对于不被包含的仍然可能会错, 发现一个子串不能贡献当且仅当它在这个字符串中的每一次出现中有任意一次没有被统计成 $l_x$ 或者被其他区间包含, 也就是一个子串 $s_j$ 被贡献当且仅当其在 $s_i$ 的实际出现次数等于只统计不交区间 $[l_r, r]$ 的情况下它的出现次数.</p><p>统计不交区间那个次数显然扫一遍就有了, 于是要支持查 $s_j$ 在 $s_i$ 的出现次数, 可以<del>上一个SAM把所有串拼在一起统计子树endpos</del>用AC自动机. 也是子树endpos个数.</p><h3 id="CF1393E2-TWILIGHT-AND-ANCIENT-SCROLL-HARDER-VERSION"><a href="#CF1393E2-TWILIGHT-AND-ANCIENT-SCROLL-HARDER-VERSION" class="headerlink" title="CF1393E2 TWILIGHT AND ANCIENT SCROLL (HARDER VERSION)"></a>CF1393E2 TWILIGHT AND ANCIENT SCROLL (HARDER VERSION)</h3><blockquote><p>给定 $n$ 个串 ${s_n}$, 在每个串中删除之多 $1$ 个字符使得 $s_n$ 构成字典序递增的序列, 求方案数.</p><p>$\sum \vert s_i\vert \le 3\times 10^6$</p></blockquote><p>显然要知道上一个串选了什么, 设 $f_{i, j}$ 表示第 $i$ 个串删了第 $j$ 个字符情况下的方案数.</p><p>那么考虑如果当前字符串 $s_i$ 要删第 $j$ 个, 设 $s_{i-1}$ 删第 $k$ 个, 可以先求删了之后得到的 $s_i’$ 和 $s_{i-1}$ 的lcp设为 $p$.</p><ul><li>对于 $k&gt;p$ 的部分, 显然对 $s_{i-1}’$ 的前面位置没有影响, 只要 $s_{i, p+1}&gt;s_{i-1, p+1}$ 即可转移.</li><li>对于 $k\le p$ 的部分, 比较 $s_{i-1}’$ 和 $s’_{i}$.<ul><li>若 $s’<em>{i-1, 1: p}&#x3D;s’</em>{i, 1: p}$ 则 $s’<em>{i-1, 1: p}&#x3D;s</em>{i-1, 1: p}$, 说明 $s_{i-1}$ 在位置 $[k, p]$ 全部相等, 此时在其中的删除会得到同一个字符串 $t$, 比较它和 $s’_i$ 即可转移这个区间.</li><li>否则 $s_{i-1}’$ 和 $s_i’$ 的lcp就是 $s_{i-1}’$ 和 $s_{i-1}$ 的lcp, 也是 $s_{i-1}$ 在位置 $k$ 后面第一个不等于 $s_{i-1, k}$ 的字符的位置减 $1$, 设该位置为 $p’$ 则要求 $s_{i-1, p’}&gt;s_{i-1, k}$ 即可转移, 那么这些位置与 $j$ 无关, 可以直接前缀和处理出来.</li></ul></li></ul><p>最后就只有求lcp的复杂度加线性dp.</p><h3 id="CF1276F-Asterisk-Substrings"><a href="#CF1276F-Asterisk-Substrings" class="headerlink" title="CF1276F Asterisk Substrings"></a>CF1276F Asterisk Substrings</h3><blockquote><p>给定一个字符集为小写字母的长度为 $n$ 的字符串 $s$, 设 $t_i$ 表示将 $s$ 中的第 $i$ 个字符替换为特殊字符 $\text{<em>}$ 时得到的字符串, 比如当 $s&#x3D;\text{abc}$ 时, $t_1&#x3D;\text{<em>bc}$, $t_2 &#x3D; \text{a</em>c}$, $t_3 &#x3D; \text{ab</em>}$.</p><p>求字符串集合 ${s, t_1, t_2, t_3, . . . , t_n}$ 中本质不同的子串个数(需要计算空串).</p><p>注意 $\text{*}$ 仅表示一个字符, 不表示其他含义(如通配符).</p><p>$n\le 10^5$</p></blockquote><p>不包含 $\text{<em>}$ 的数量显然, 只考虑包含 $\text{</em>}$ 的子串, 则这样的子串是一个子串的所有后缀拼上 $\text{<em>}$ 拼上一个子串的所有前缀, 用 $(a, b)$ 表示, 其中 $a, b$ 分别表示 $\text{</em>}$ 前后的部分. 而字符串 $t_i$ 包含这个子串就是把字符串 $t_i$ 表示成 $(x, y)$, 要求 $a$ 是 $x$ 的后缀, $b$ 是 $y$ 的前缀.</p><p>于是对 $s$ 建立正反两个SAM及后缀树, 则 $a$ 是 $x$ 的后缀可以表示成 $a$ 是 $x$ 在树上的祖先, 另一边同理. 问题转化为给定两棵树, 有 $n$ 对 $(x_i, y_i)$, 求有多少个 $a, b$ 满足 $a$ 是存在 $i$ 使得 $x_i$ 的祖先, $b$ 是 $y_i$ 的祖先.</p><p>最后这个数数, 考虑枚举 $a$, 求它的子树中的 $x$ 对应的 $y$ 在另一棵树上的祖先的并集, 可以枚举一个 $a$ 给所有子树里的 $x$ 对应的 $y$ 到根路径加 $1$, 然后用重剖换根+全局平衡二叉树可以2log吧.</p><p>然而因为点集到根的路径的并长度是可以直接用线段树在合并过程中维护的:</p><p>[trick] 点集到根的路径的并的长度是所有点的深度减去相邻点lca的深度.</p><h3 id="ICPC-2021-沈阳-M-STRING-PROBLEM"><a href="#ICPC-2021-沈阳-M-STRING-PROBLEM" class="headerlink" title="ICPC 2021 沈阳 M STRING PROBLEM"></a>ICPC 2021 沈阳 M STRING PROBLEM</h3><blockquote><p>给定串 $S$ 求每个前缀字典序最大的子串.</p><p>$\vert S\vert \le 10^6$</p></blockquote><p>建SAM, 插入过程中维护转移每次走最大的那条链.</p><p>另一种方法是, 注意到答案一定当前前缀的一个后缀, 于是新增一个字符新的答案是当前答案的border加新字符.</p><h3 id="P5420-CTSC2016-香山的树"><a href="#P5420-CTSC2016-香山的树" class="headerlink" title="P5420 [CTSC2016] 香山的树"></a>P5420 [CTSC2016] 香山的树</h3><blockquote><p>定义一个串是好的当且仅当它是自己唯一最小的循环同构.</p><p>对所有长度 $\le n$ 由小写字母构成的串 $S$ 查询一个串在好的串中的rank或者kth.</p><p>$n\le 50, k\le 10^{18}$</p></blockquote><p>求kth也是求rank. 考虑如果是让计数所有lyndon word就是没有整周期的串除以 $n$, 因为其所有循环互不相同恰有一个是最小的.</p><p>那考虑现在要计数大于字符串 $t$ 的 $s$ 的个数, 仍然假装 $s$ 无循环节, 考虑枚举两个字符串的LCP是 $p$, 那么就要求 $s$ 的循环同构都比 $t$ 大, 也就是 $s$ 任意长度为 $\vert p\vert$ 的子串都不比 $p$ 的字典序小, 且不能出现 $t$ 比 $\vert p\vert$ 更长的前缀. 注意若串中出现了 $k$ 次子串 $p$, 则它会被算 $k$ 次, 于是贡献 $\dfrac{1}{k}$</p><p>于是可以dp了, 设 $f_{i, j, k}$ 表示以 $p$ 为前缀, 长度为 $i$, 当前kmp自动机上节点为 $j$, 且到当前位置 $s$ 中有 $k$ 个子串 $p$ 的方案数, 直接dp转移 $O(1)$ 复杂度 $n^3\vert \sigma\vert$ 再加上一开始枚举每一位二分就是 $n^4\vert \sigma\vert\log {\vert \sigma\vert}$</p><h2 id="NOI2024省选模拟赛23"><a href="#NOI2024省选模拟赛23" class="headerlink" title="NOI2024省选模拟赛23"></a>NOI2024省选模拟赛23</h2><h3 id="A-星际逃亡"><a href="#A-星际逃亡" class="headerlink" title="A. 星际逃亡"></a>A. 星际逃亡</h3><blockquote><p>有 $n$ 个三维空间中的星球, 第 $i$ 个一开始位于 $(x_i, y_i, z_i)$, 以每秒 $(vx_i, vy_i, vz_i)$ 的速度移动(连续而非离散), 你从 $0$ 号点出发前往 $1$ 号点, 每次可以从一颗星球跳到另一颗或等待, 过程中不能在一颗星球连续停留 $s$ 秒, 求最大跳跃距离最小值.</p><p>$n\le 1000$</p></blockquote><p>显然二分答案, 问题变成给你一张图每个边有一个出现时间, 不能连续停留 $s$, 问是否连通. 而对于某时刻有边的连通块, 你总可以不断在一条边左右横条刷时间相当于没有 $s$ 的限制.</p><p>那么直接扫当前时间, 维护当前所有点的度数, 维护 $v_i$ 表示点 $i$ 是否可达, 每次可能会加入一条边时bfs更新 $v$, 删除一条边时如果一边变成孤立点就记录时间, 如果某个点变成孤立点超过 $s$ 更新 $v_i$.</p><p>发现 $v_i$ 的总变化次数是 $O(n)$ 的(一开始全<code>false</code>, $n$ 次删边可能把<code>true</code>变成<code>false</code>). 于是总复杂度是 $(n+m)\log n$ 的.</p><h3 id="B-博弈问题"><a href="#B-博弈问题" class="headerlink" title="B. 博弈问题"></a>B. 博弈问题</h3><blockquote><p>给定有根树, 点有权值 $w_i$, 定义一颗子树的权值是A先选一个点 $x$, B再选一个与 $x$ 不同的点 $y$, 得到的值 $v&#x3D;w_x\mathrm{xor}w_y$, 且A希望最大化B希望最小化, 最终得到的 $v$, 求所有子树的 $v$.</p><p>$n\le 10^5$</p></blockquote><p>看到两个数异或直接上字典树, 设 $f_u$ 表示字典树上以 $u$ 为根的子树作为整棵树并从中选两个数最终的权值, 则若当前点有一边没儿子就直接 $f_u&#x3D;f_v$($v$ 是 $u$ 的某个儿子), 否则如果有一边子树内只有一个数 $x$, 则一定选择那一个数, 再从另一边子树中选和他异或起来最小的数记为 $y&#x3D;calc(x, v)$, $calc$ 是单log的, 所以一次更新当前点的操作是单log的, 用线段树的形式支持插入一个数&#x2F;合并总复杂度就是2log的.</p><h3 id="C-兔子猜拳"><a href="#C-兔子猜拳" class="headerlink" title="C. 兔子猜拳"></a>C. 兔子猜拳</h3><blockquote><p>有 $n$ 个 $n$ 维向量 $x_1\ldots x_n$, 初始 $x_i$ 只有第 $i$ 位为 $1$ 其他位置为 $0$, 每次任选两个向量 $u, v$(有序), 另 $u&#x3D;2u-v$ 并删除 $v$, 进行 $n-1$ 次, 求最后得到的向量可能有多少种.</p><p>$n\le 500$</p></blockquote><p>是AGC022F Checkers加个 $0$.</p><p>就是进行 $n$ 次合并每次保留一个, 考虑把合并模型建成树, 若 $u, v$ 合并保留 $u$ 则 $v$ 向 $u$ 连边最终形成根向树, 把子树按照合并的先后顺序从左到右排序, 意义是先子树内合并, 再把得到的每个儿子从左到右依次和父亲合并每次都是删除儿子对应的向量. 而考虑第 $i$ 位最终的值, 则每次第 $i$ 维有值的点 $u$ 与另一个点 $v$ 合并时, 若保留 $u$ 则这一维乘 $-1$, 保留 $v$ 则乘 $2$, 而发现在这棵树上, 保留 $v$ 的次数就是点的深度. 而保留 $u$ 的次数则是每一层左边的儿子的个数之和加上自己的儿子个数之和, 若设点 $y$ 的 $-1$ 的次数为 $c_y$, 则 $c_y&#x3D;(c_{fa_y}-s_{fa_y})+(l_y+s_y)$, 其中 $s_u$ 表示 $u$ 的儿子个数, $l_u$ 表示自己左边点的个数(以后都只在模 $2$ 意义下讨论 $c, s, l$).</p><p>考虑怎么进行dp, 两种情况最后相同要求所有点对应深度相同且符号相同. 层数到底是多少无关紧要, 设 $f_i$ 表示 $i$ 点最后一层有 $j$ 个点, 每次枚举 $x, y$ 表示新的一层中最后 $c_y$ 为 $0&#x2F;1$ 的点的个数, 那么方案数就是选出这一层的点并分配奇偶.</p><p>但是这不对: 加入下一层的时候会导致这一层的一些点 $u$ 的 $s_u$ 变成 $1$ 使得 $c_u$ 变化, 并且本层儿子个数为奇数的点(简称奇点&#x2F;偶点)的个数和下一层的 $x, y$ 相关. 若本层只有偶点必然要求 $x&#x3D;y$(下一层点 $fa$ 相同的点的 $s_u$ 都是 $0$, $s_{fa_u}-l_u$ 为 $01$ 交替, $c_{fa_u}$ 相同, 所以最后 $01$ 个数相同的), 而若奇点中有两个点 $a, b$ 满足 $c_a\ne c_b$, 则交换 $a, b$ 会获得等价的, 奇点数减 $2$ 的状态所以可以要求奇数点的 $c$ 全都相同(等于 $x, y$ 中个数大的那一个对应颜色).</p><p>于是设有 $k$ 个点下一层子树大小为奇数, 状态为 $f_{i, j, k, 0&#x2F;1}$, 其中最后一个 $01$ 是这 $k$ 个点的 $c$ 值. 于是下一层的 $x+y&#x3D;j, \vert x-y\vert&#x3D;k, [x&gt;y]&#x3D;0&#x2F;1$, (下面以 $x&gt;y$ 为例), 枚举 $k’$, 转移系数就是组合数选出最后实际上为 $0&#x2F;1$ 的 $x-k, y+k$ 个点: $\binom{n-i}{x\mp k’, y\pm k’}$.</p><p>这样做复杂度是单 $n^4$($n^3$ 状态加枚举 $k’$), 发现 $j$ 是没必要的状态(就是 $x+y$, 且不需做区分), 另外让 $k$ 带符号表示 $x-y$ 去掉01一维.</p><p>喵的不会, 这是官方的 $n^3$</p><p><img src="/img/2024-01-12-21-23-09-image.png" alt="picture 12"></p><p>不是很懂两种做法本质区别导致一种可以优化一种不会.</p><h2 id="NOI2024省选模拟赛24"><a href="#NOI2024省选模拟赛24" class="headerlink" title="NOI2024省选模拟赛24"></a>NOI2024省选模拟赛24</h2><h3 id="A-划分串"><a href="#A-划分串" class="headerlink" title="A. 划分串"></a>A. 划分串</h3><blockquote><p>给定整数 $M, K$, 对于一个01串 $S$, 如果存在一个切分, 使得 $S(1, i)$ 与 $S(i+1, n)$ 的最大公共前缀长度大于等于 $K$, 那么称是 $S$ 的精准切分. 如果 $S$ 至少有 $M$ 个精准切分, 那么称 $S$ 是一个切分串. 给定 $N$, 问有多少长度为 $N$ 的切分串.</p><p>$n\le 1000$</p></blockquote><p>简单题, 显然就是前 $k$ 位出现超过 $m$ 次, 枚举前 $k$ 位设为 $t$, 设 $f_{i, j, l}$ 表示前 $i$ 位, $t$ 出现了 $j$ 次, 匹配了 $t$ 的前 $l$ 位, 暴力转移复杂度为 $nmk2^k$. 运算量有 $10^9$</p><p>看起来不太能过, 我的改进是让 $j$ 只枚举到 $\dfrac{i}{x}$, 其中 $x$ 为 $t$ 的最短循环节长度, 运算量大概 $10^7$</p><p>然而还有更厉害的, 打表发现输出范围内, 对同一个 $k$, 可以把 $2^k$ 分成不超过 $10$ 种等价类, 每种的答案相同.</p><h3 id="B-降落伞环"><a href="#B-降落伞环" class="headerlink" title="B. 降落伞环"></a>B. 降落伞环</h3><blockquote><p>有一张图初始全是散点, $q$ 次询问, 每次加一条边, 获得问对当前的图, 有多少点满足删除这个点后剩下的所有连通块都是链(不包括环).</p><p>$n\le 10^6, q\le 10^6$</p></blockquote><p>考虑链有两个条件: 不是环, 度数小于 $3$. 而如果有节点度数大于等于 $3$, 那么可能的答案不超过 $4$(它自己和它相连的最多 $3$ 个点, 如果它相连的点更多则那些点都不能成为答案).</p><p>于是把问题分成所有点度数小于 $2$ 和有点度数大于 $2$ 两部分, 第一部分再分成没环和有环两部分, 没环时输出 $n$, 有一个环时输出 $1$, 有两个环时因为度数小于 $2$ 所以环不交答案为 $0$. 第二部分只要对 $O(1)$ 个固定点check, 于是一开始直接不加有关他们的所有边, 判断剩下的点有没有环和三度的即可.</p><p>用vector建图被卡爆了, 这种每个点度数很小但总边数挺大的用vector会很慢.</p><h3 id="C-螺旋"><a href="#C-螺旋" class="headerlink" title="C. 螺旋"></a>C. 螺旋</h3><blockquote><p>给定 $a_n$, $q$ 次询问对于给定的区间 $[l, r]$, 最长的满足 $a_{l’}&#x3D;a_{r’}, \forall i\in [l’, r’] a_i\le a_{l’}$ 的子区间 $[l’, r’]$ 长度.</p><p>$n, q\le 5\times 10^5$</p></blockquote><p>赛时先想了一个 $n\sqrt n$, 考虑根号分治, 对于次数大于根号的可以 $O(n)$ 直接扫一遍出答案, 对次数小于根号的颜色 $c$ 考虑枚举有序对 $(x, y)$ 满足 $a_x&#x3D;a_y&#x3D;c$, 这样的有序对有 $n\sqrt n$ 个, 每个可以看成一个2side矩形赋值为max, 而查询单点查, 只要支持 $O(1)$ 前缀取max和 $O(\sqrt n)$ 单点查, 发现是简单的(对前缀 $p$ 取max改为把值插入到位置 $p$)</p><p>然后赛时又想了一个poly log, 考虑因为有 $l’, r’$ 区间不会相交, 所以可以类似建树的处理, 对于区间 $[l, r]$ 要求 $a_l&#x3D;a_r&#x3D;x$ 为该区间的最大值(非严格, 该区间可能有其他最大值, 一个包含 $cnt$ 个 $x$ 的区间对应的点相当于上面做法 $cnt^2$ 个可能的答案), $x$ 把它分成若干子区间, 点 $(l, r, x)$ 向每个子区间连边, 容易发现一共有 $O(n)$ 个 $(l, r, x)$ 的对, 那么我们查找一个询问 $L, R$ 的时候, 一定是找到最浅的点 $(l, r, x)$, 使得 $L, R$ 包含至少两个在 $[l, r]$ 中的 $x$(不一定是 $a_l$ 和 $a_r$), 则该询问的答案可能有这个点贡献, 设 $[l, r]$ 中被 $[L, R]$ 包含的最左最右的 $x$ 分别为 $p_1, p_2$, 则答案还有可能出现在 $[L, p_1], [p_2, R]$, 发现对于 $[L, p_1]$ 中的区间 $(l’, r’, x’)$, 其一定贡献一个后缀($[k, r’]$), 同理对于 $[p_2, R]$ 的一定贡献一个前缀, 于是这样的只有 $O(n)$ 个可能贡献的位置了. 于是解法就有了: 对每个 $[L, R]$ 找到对应最浅 $(l, r, x)$ 是简单的, 后面计算 $O(n)$ 个可能区间的贡献也是简单的, 总复杂度 $(n+q)\log n$.</p><p>更厉害的出现了: <img src="/img/2024-01-13-17-21-15-image.png" alt="picture 14">, 很巧妙的把全局和部分的联系在了一起.</p><p>更厉害的出现了: std $n\sqrt {n\log n}$ 跑 $5\times 10^5$</p><h2 id="NOI2024省选模拟赛25"><a href="#NOI2024省选模拟赛25" class="headerlink" title="NOI2024省选模拟赛25"></a>NOI2024省选模拟赛25</h2><h3 id="A-Lost-Kingdom"><a href="#A-Lost-Kingdom" class="headerlink" title="A. Lost Kingdom"></a>A. Lost Kingdom</h3><blockquote><p>给定 $n$ 点 $m$ 条边连通无向图, 可以选任意多个连通块, 对连通块的点集和边集分别求交最大化连通块个数.</p><p>$n\le 10^5$</p></blockquote><p>在他给了样例解释之后变得毫无难度: “选 $4$ 个边集: $U-$ 环上一条边”</p><p>于是注意到用 $U-{e}$ 这个边集 $E$ 可以在最后交的图中删去 $e$ 这条边, 条件是 $E$ 连通也就是 $e$ 不是割边. 而对于割边如果连通块不包含它必然要把它的一边扔了, 一定不优, 所以答案就是保留所有割边的连通块数.</p><h3 id="B-Lighthouse"><a href="#B-Lighthouse" class="headerlink" title="B. Lighthouse"></a>B. Lighthouse</h3><p>原题Gym103446C</p><blockquote><p>有 $n\times m$ 的矩阵, 每个位置可能为 $0$, $1$, 一次于 $(i, j)$ 的操作可以覆盖同行同列且与 $(i, j)$ 之间没有 $1$ 的所有 $0$, 现在又有一些位置是 $2$ 可以任意变成 $1$ 或 $0$, 求所有情况下要让所有 $0$ 覆盖至少一次的最小操作次数.</p><p>$n\times m\le 190$</p></blockquote><p>这个题一开始数据范围给 $n, m\le 190$ 让人很不会.</p><p>容易想到 $n\times m\le 190\Rightarrow \max(n, m)\le 13$, 设 $n&gt;m$.</p><p>于是直接轮廓线dp逐行做, 设状态要记录轮廓线上每个点 已经被覆盖且能提供向下面的覆盖, 被覆盖, 未被覆盖即需要向上的覆盖 $3$ 种情况, 同时一个点还可能被同行横向覆盖, 也要记录进去, 设 $f_{i, j, S, 0&#x2F;1&#x2F;2}$ 表示dp到第 $i, j$ 这个格子, $S$ 为轮廓线上格子覆盖的 $3^m$ 种情况, $0&#x2F;1&#x2F;2$ 表示这一行前面的格子 已经有提供横向覆盖的&#x2F;已经有要求横向覆盖的&#x2F;没有要求没有提供 的情况.</p><p>状态数和复杂度是 $3nm3^m$, 写出来开O2跑12s.</p><p>考虑优化, 极端情况当然是 $n&#x3D;14, m&#x3D;13$, 所有位置全是 $2$ 之类的($2$ 的格子要做两种转移), 考虑直接写个不优的东西乱跑一个解当最优性剪枝.</p><h3 id="C-Dark-Blue"><a href="#C-Dark-Blue" class="headerlink" title="C. Dark Blue"></a>C. Dark Blue</h3><p>原题Gym102803E</p><blockquote><p>给定一个字符串的后缀数组sa和height数组 $h$ 的一部分(用 $-1$ 代表未知), 求字典序最小的满足条件的小写字母构成的字符串 $s$.</p><p>$n\le 10^6$</p></blockquote><p>设 $suf_i&#x3D;s_{i\ldots n}$</p><p>感觉绕到后缀树上反而远了, 直接在字符串上, 对于 $i$, 有 $suf_{sa_i}&lt;suf_{sa_{i+1}}$, 对于 $h$ 给定的情况, 就是 $\forall i, \forall j\in[0, h_i), s_{sa_{i-1}+j}&#x3D;s_{sa_i+j}, s_{sa_{i-1}+h_i}&lt;s_{sa_i+h_i}$, 那么可以用并查集把相等的元素合并起来, 小于关系只有 $O(n)$ 可以随便做了.</p><p>对于有 $h_i&#x3D;-1$ 的情况, 考虑要满足 $suf_{sa_{i-1}}&lt;suf_{sa_i}$, $suf_{sa_{i-1}+1}$ 和 $suf_{sa_i+1}$, 如果前者小则 $s_{sa_{i-1}}\le s_{sa_i}$, 否则 $s_{sa_{i-1}}&lt;s_{sa_i}$.</p><p>并查集合并可以用 ds里P3295 [SCOI2016]萌萌哒的做法做到 $n\log n\alpha(n)$, 然后小于和小于等于统一成小于变成差分, 得到一张图, 字典序最小对应最长路, 然后scc必须是 $0$ 权边全相等, 求完scc然后乱做了.</p><blockquote><p><img src="/img/2024-01-15-15-27-31-image.png" alt="picture 15">  </p></blockquote><h2 id="NOI2024省选模拟赛26"><a href="#NOI2024省选模拟赛26" class="headerlink" title="NOI2024省选模拟赛26"></a>NOI2024省选模拟赛26</h2><h2 id="计数专题-程思元"><a href="#计数专题-程思元" class="headerlink" title="计数专题-程思元"></a>计数专题-程思元</h2><h3 id="Gym102538H-Horrible-Cycles"><a href="#Gym102538H-Horrible-Cycles" class="headerlink" title="Gym102538H. Horrible Cycles"></a>Gym102538H. Horrible Cycles</h3><blockquote><p>二分图, 每个左侧点和右边一个前缀 $1\ldots a_i$ 连边, 求简单环数量.</p><p>$n\le 5000$</p></blockquote><p>把 $a$ 从小到大排序, 每次加入一个左侧点和若干个右侧点, 显然只考虑一部分点一个环表现为若干条链, 设考虑左边前 $i$ 个点, 组成 $j$ 条链的环数为 $f_{i, j}$, 则每次可以新增一个链&#x2F;合并两个链&#x2F;什么也不做, 最后合并到只剩一个链的方案数为 $f_{n, 1}$, 要去除单点&#x2F;单边&#x2F;交换一条链的两个端点的贡献.</p><h3 id="AT-hitachi2020-f-Preserve-Diameter"><a href="#AT-hitachi2020-f-Preserve-Diameter" class="headerlink" title="AT_hitachi2020_f Preserve Diameter"></a>AT_hitachi2020_f Preserve Diameter</h3><blockquote><p>给定 $n$ 点树 $G$, 要求再添加若干条边形成简单图 $H$, 满足 $H, G$ 直径相同且再添加任意一条边 $H$ 直径变小. 求 $H$ 方案数</p><p>$n\le 2\times 10^5$</p></blockquote><p>$H$ 最后只有一个直径, 不然可以把其他直径两端连起来.</p><p>只有一个直径后, 以一个端点 $s$ 当做根建bfs树, 显然要求同层点和相邻层点边全连, 其他不连, 也就是每个点的深度唯一确定这张图. 而可行的深度序列 $dep$ 要求 $dep_s&#x3D;0, \exist t, dep_t&#x3D;d, \forall u\ne t, dep_u&lt;d, \forall (u, v)\in G, \vert dep_u-dep_v\vert\le 1$, 没了.</p><p>那么按照树上子树结构dp, 因为 $G$ 的直径可能很多考虑按照 $G$ 直径中点 $x$ 为根, 要求, $dep_y-dep_x&#x3D;\pm\dfrac{d}{2}$ 的恰好各一个, 设 $f_{u, 0&#x2F;1&#x2F;2, 0&#x2F;1&#x2F;2}$ 表示 $u$ 的子树, $dep_y-dep_x$ 的值分别为 $0&#x2F;1&#x2F;\ge 2$ 个的方案数即可. 复杂度线性.</p><h3 id="CF1450H2-Multithreading"><a href="#CF1450H2-Multithreading" class="headerlink" title="CF1450H2 Multithreading"></a>CF1450H2 Multithreading</h3><blockquote></blockquote><p>考虑相邻同色点直接连不劣, 连完之后是 $\text{wb}$ 重复 $k$ 次的序列交替形式, 此时异色边相交数为 $\dfrac{k}{2}$, 问题变为求 $k$,<strong>发现 $k$ 是偶数下标与奇数下标上 $\text{w}$ 的个数之差</strong>(一次匹配删一奇一偶).</p><p>设奇数, 偶数上分别有 $a$, $b$ 个 $\text{w}$, $x$, $y$ 个 $\text{? }$, 设 $x&lt;y$, 枚举 $k$ 得到答案为<br>$$<br>\begin{gathered}<br>ans &#x3D;\sum_i \sum_j \vert a-b+i-j\vert\binom{x}{i}\binom{y}{j}\<br>    let a-b&#x3D;c, i-j&#x3D;d\<br>   &#x3D;\sum_d \vert c+d\vert\sum_i \binom{x}{i}\binom{y}{i+d}\<br>   \because \sum_{i&#x3D;0}^{\infty}\binom{x}{i}\binom{y}{i+d}&#x3D;\sum_{i&#x3D;0}^{\infty}\binom{x}{x-i}\binom{y}{i+d}&#x3D;\binom{x+y}{x+d}\<br>   \therefore<br>   ans &#x3D;\sum_d \vert c+d\vert\binom{x+y}{x+d}<br>\end{gathered}<br>$$</p><p>显然拆开绝对值, 现在要计算</p><p>$$<br>\begin{gathered}<br>  \sum_{d&#x3D;l, d\bmod 2&#x3D;t}^r(c+d)\binom{x+y}{x+d}\<br>  &#x3D;(c-x)\sum_d\binom{x+y}{x+d}+\sum_d (x+d)\binom{x+y}{x+d}\<br>  &#x3D;(c-x)\sum_d \binom{x+y}{x+d}+(x+y)\sum_d \binom{x+y-1}{x+d-1}\<br>  \because \sum_{d&#x3D;t\bmod 2, d\bmod 2&#x3D;t}^r\binom{n}{d}&#x3D;\sum_{d&#x3D;t\bmod 2, d\bmod 2&#x3D;t}^r \binom{n-1}{d-1}+\binom{n-1}{d}&#x3D;\sum_d^r \binom{n-1}{d}<br>\end{gathered}<br>$$</p><p>于是都变成了求组合数行前缀和, 可以快速维护.</p><h3 id="在此之前让我们学习析合树"><a href="#在此之前让我们学习析合树" class="headerlink" title="在此之前让我们学习析合树"></a>在此之前让我们学习析合树</h3><p>对一个排列, 定义一个连续段为区间满足重排后值也是连续区间, 非平凡连续段是除了单个元素和整个序列, 而一个本原段定义为一个连续段, 且不存在另一个连续段和它相交(可以包含), 发现任意连续段都可以分解成本原段的并.</p><p>本原段有包含关系可以建树, 建的时候区分子树且保留原序列顺序, 此时定义合点为儿子本原段的值域是升序&#x2F;降序, 析点为其他点</p><p>上结论:</p><ul><li>合点的区间中任意选一段都是连续段, 析点区间任意选非平凡的一段一定不是连续段.</li><li>析点儿子数量至少为 $4$.</li><li>合点儿子中合点必须和父亲反向(若父亲儿子序列递增则该儿子的儿子序列递减), 合点儿子数量至少为 $2$.</li><li>符合以上内容的都是合法的析合树.</li></ul><p>试看看</p><h3 id="CF1089I-Interval-Free-Permutations-或-LOJ3397「2020-2021-集训队作业」春天-在积雪下结一成形-抽枝发芽"><a href="#CF1089I-Interval-Free-Permutations-或-LOJ3397「2020-2021-集训队作业」春天-在积雪下结一成形-抽枝发芽" class="headerlink" title="CF1089I Interval-Free Permutations 或 LOJ3397「2020-2021 集训队作业」春天, 在积雪下结一成形, 抽枝发芽"></a>CF1089I Interval-Free Permutations 或 LOJ3397「2020-2021 集训队作业」春天, 在积雪下结一成形, 抽枝发芽</h3><blockquote><p>求长 $n$ 没有非平凡连续段的排列数.<br>CF题 $n\le 400$, loj3397 $n\le 100000$</p></blockquote><p>上析合树, 答案为析点为根且高度为 $2$ 的数量, 设其OGF为 $F$, 设根为合点且儿子递增的排列数的OGF为 $G$, 排列的OGF为 $H+1$($H$ 无常数), 则根为析点的析合树GF为 $H-(2G-x)$(对于长 $1$ 的序列正反相同减去). 同时根为析点的排列数量为 $F(H)-x$ 了.</p><p>于是有方程<br>$$<br>\begin{gathered}<br>  G&#x3D;\dfrac{(H-G)^2}{1-(H-G)}\<br>  F(H)&#x3D;H-(2G-x)<br>\end{gathered}<br>$$</p><p>于是有设 $H(R)&#x3D;x$, 第一个式子变形成 $G(x)&#x3D;\dfrac{H^2}{1+H}$ 则代入得 $G(R)&#x3D;\dfrac{x^2}{1+x}$, 第二个式子得到 $F&#x3D;x-2G(R)-R&#x3D;x-2\dfrac{x^2}{1+x}-R$, 现在只要求 $R$. 这个和 count 中P4566 [CTSC2018] 青蕈领主完全一样.</p><h3 id="P7278-纯洁憧憬"><a href="#P7278-纯洁憧憬" class="headerlink" title="P7278 纯洁憧憬"></a>P7278 纯洁憧憬</h3><blockquote><p>求长 $n$ 且至少存在一个长度大于 $k$ 的非平凡连续段的排列.</p><p>$k\le n\le 400$</p></blockquote><p>先容斥成求没有大于 $k$ 的.</p><p>析合树, 对析点要求所有儿子大不超过 $k$, 对合点要求第一个, 最后一个儿子分别大于等于 $n-k$ 且小于等于 $k$</p><p>设满足限制的析点, 合点个数为 $F$, $G$, 满足不存在非平凡连续段的方案数为 $H$, 全排列为 $P$, $A&#x3D;\dfrac{1}{1-F-G}$, 则 $F&#x3D;H(P^{\le k}), g_n&#x3D;\sum_{i\ge n-k}\sum_{j\ge n-k} (f_i+g_i)(f_j+g_j)(a_{n-i-j})$, 是不是这么跑暴力就 $n^3$ 了啊.</p><p>然后std是再dp一步, 对于合点有限制的儿子都是边上, 所以可以设 $p_n$ 为长 $n$ 任何前缀不是非平凡连续段的排列个数, 则 $p_n&#x3D;n! -\sum_{i&#x3D;1}^{n-1} p_i (n-i)!$(容斥类的转移), 则 $g_n&#x3D;\sum_i \sum_j p_ip_j(n-i-j)!$ 对于析点也是求出 $H$ 暴力复合.</p><h2 id="NOI2024省选模拟赛27"><a href="#NOI2024省选模拟赛27" class="headerlink" title="NOI2024省选模拟赛27"></a>NOI2024省选模拟赛27</h2><h3 id="A-不休陀螺"><a href="#A-不休陀螺" class="headerlink" title="A. 不休陀螺"></a>A. 不休陀螺</h3><blockquote><p>有 $n$ 张牌组成一个序列, 每张牌用一个二元组 $(a_i, b_i)$ 表示, 意味着打出这张牌需要消耗 $a_i$ 点费用, 打出后可以获得 $b_i$ 点费用. 接下来你可以选择一个区间 $l, r$ 将这个区间中的卡取出来作为你的卡组.</p><p>开始时你的卡组会按照随机顺序排列并且你有 $E$ 点费用, 然后你会依次从前往后打出这个排列中的卡. 当你打完这个排列中的卡后你的卡组又会重新随机排列然后你再依次打出, 直到你无法再打出下一张牌(当前费用小于下一张牌需要消耗的费用)时停止. 如果一个卡组无论在什么情况下都能够无限打下去, 我们则称这卡组可以”陀螺无限”. 现在求有多少个区间组成的卡组能够”陀螺无限”.</p><p>$n\le 10^6$</p></blockquote><p>简单题, 对于区间 $[l, r]$, 合法的条件是区间和大于 $0$ 且 $E+sum_{&lt;0}\ge \max_{a_i&gt; b_i} a_i \sum_{a_i&gt;b_i}$, $E+sum_{&lt;0}&gt; a_i-(b_i-a_i)$, 其中 $sum_{&lt;0}$ 为所有 $b_i-a_i&lt;0$ 的和, 于是对每个右端点找到满足后两个条件的最小左端点, 然后前缀和二维数点.</p><h3 id="B-染色"><a href="#B-染色" class="headerlink" title="B. 染色"></a>B. 染色</h3><blockquote><p>在 $2^n\times 2^n$ 的 $01$ 矩阵上, 每次可以选定位置让上下左右相邻位置及其本身共 $5$ 个位置取反, 认为第一列和最后一列相邻, 第一行和最后一行相邻.</p><p>构造从全 $0$ 矩阵弄出指定状态方案.</p><p>$n\le 11$</p></blockquote><p>只会暴力高消, 设前两行的推别的, 可以发现方程数和位置数相等, 所以应该都有解. 又考虑到弄出 $1$ 就行了, 然而不会弄 $1$ 于是寄了.</p><p>考虑要弄一个 $1$, 一个可行的构造是对于一个当前全 $0$ 局面, 假设要构造 $(0, 0)$ 位置是 $1$, 操作 $(0, 0)$ 会出现上下左右多余的 $4$ 个 $1$, 分别操作这 $4$ 个位置会变成多余 $(0, 2), (2, 0), (0, -2), (-2, 0)$ 四个 $1$, 记集合 $S_i&#x3D;{(0, 2^i), (2^i, 0), (0, -2^i), (-2^i, 0)}$, 发现用得到 $S_i$ 的操作去操作 $S$ 中的每个点会得到 $S_{i+1}$, 而当 $i&#x3D;n$ 的时候 $S$ 重合没了, 于是就弄出一个 $1$.</p><p>逐层模拟以上过程即可.</p><p>更厉害的做法, 题目等价于给定 $F(x, y)$, 计算 $F(x, y)(1+x+x^{-1}+y+y^{-1})^{-1}\bmod (x^{2^n}-1) \bmod (y^{2^n}-1) \bmod 2$(设操作为 $A(x, y)$, 其中 $[x^iy^j]A\in [0, 1]$ 表示是否操作 $i, j$, 则卷上 $1+x+x^{-1}+y+y^{-1}$ 再模一下是结果, 所以要求逆. )</p><p>然后有对质数 $p$ 有 $f^p(x)\equiv f(x^p)\pmod p$, 这个是考虑对于多项式系数 $\binom{p}{a_1\ldots a_k}&#x3D;\dfrac{p! }{a_1! \ldots a_k! }, (p&#x3D;\sum a_i)$ 要想没有 $p$ 因子只能是 $a_i&#x3D;p$.</p><p>有 $(1+x+x^{-1}+y+y^{-1})^{2^n}&#x3D;1$, 于是要求 $F(x, y)(1+x+x^{-1}+y+y^{-1})^{2n-1}$.</p><h3 id="C-计算"><a href="#C-计算" class="headerlink" title="C. 计算"></a>C. 计算</h3><blockquote><p>设 $F(x, a, b)&#x3D;\gcd(x^a-1, x^b-1)+1, x&gt;0$, 特殊规定 $F(x, 0, b)&#x3D;F(x, a, 0)&#x3D;0$, 给定 $m, a, b, c, d$, 设 $L&#x3D;F(m, a, b)+1, R&#x3D;F(m, c, d)$ 求 $[L, R]$ 有多少子集是 $m$ 的倍数.</p><p>$m\le 10^7, a, b, c, d\le 3000, L, R\le 10^{18}$</p></blockquote><p>首先把 $L, R$ 求了, 设 $a&lt;b$, 考虑要算 $\gcd(x^a-1, x^b-1)&#x3D;(x-1)\gcd(\sum_{i&#x3D;0}^a x^i, \sum_{i&#x3D;0}^b x^i)$, $\gcd(\sum_{i&#x3D;0}^a x^i, \sum_{i&#x3D;0}^b x^i)&#x3D;\gcd(\sum_{i&#x3D;0}^a x^i, \sum_{i&#x3D;a+1}^b x^i)&#x3D;\gcd(\sum_{i&#x3D;0}^a x^i, x^{a+1}\sum_{i&#x3D;0}^{b-a-1} x^i)&#x3D;\gcd(\sum_{i&#x3D;0}^a x^i, \sum_{i&#x3D;0}^{b-a-1} x^i)$, 于是可以用类似 $gcd$ 的递归简单算这个. 特殊的记住有 $F(x, a, b)&#x3D;x^k$ 的性质.</p><p>那么接下来算子集和, 设 $F&#x3D;\prod_{i&#x3D;L}^R (1+x^i)&#x3D;\prod_{i&#x3D;0}^{m-1}(1+x)^{iC}$(所有东西出现次数相同, 由刚才 $R-L+1&#x3D;x^{k_1}-x^{k_2}$ 得到), 容易想到单位根反演, 于是答案写成</p><p>$$<br>\begin{gathered}<br> ans&#x3D;\sum_{i}[m\vert i][x^i]F(x)&#x3D;\dfrac{1}{m}\sum_i\sum_{j&#x3D;0}^{m-1}w_m^{ij}[x^i]F(x)&#x3D;\dfrac{1}{m}\sum_{j&#x3D;0}^{m-1}F(w_m^j)\</p><p> F(w_m^j)&#x3D;\prod_i (1+w_m^{ij})^{C}\<br> \because w_m^{ij\bmod m}&#x3D;w_m^{ij}<br> \therefore\ let\ d&#x3D;\gcd(m, j)\<br> F(w_m^j)&#x3D;\prod_{i&#x3D;0}^{m&#x2F;d}(1+w_{m&#x2F;d}^j)^{dC}\<br> \because \prod_{i&#x3D;0}^m (x-w_m^i)&#x3D;x^m-1\<br> \therefore<br> F(w_m^j)&#x3D;((-1)^{m&#x2F;d}\prod_{i&#x3D;0}^{m&#x2F;d}(-1-w_{m&#x2F;d}^j))^{dC}&#x3D;2^{dC}[2\vert \dfrac{m}{d}]\<br> \let\ f_d&#x3D;2^{dC}[2\vert \dfrac{m}{d}]<br> \therefore ans&#x3D;\dfrac{1}{m}\sum_{i&#x3D;1}^{m}f_{\gcd(i, m)}&#x3D;\dfrac{1}{m}\sum_{d \vert m}f_d\sum_{i}^{m&#x2F;d}[i\perp \dfrac{m}{d}]&#x3D;\dfrac{1}{m}\sum_{d\vert m}f_d\varphi(\dfrac{m}{d})<br>\end{gathered}<br>$$</p><p>赛时被这个 $\prod_{i&#x3D;0}^m (1+w_{m}^{ij})^C$ 整不会了&#x2F;kk</p><h3 id="D-鸡"><a href="#D-鸡" class="headerlink" title="D. 鸡"></a>D. 鸡</h3><blockquote><p>对于一个非负整数序列 $a$, 定义它对应的独立集序列 $f(a)$: 假设将 $a_i$ 改为 $0$, 此时选出若干个两两不相邻的数使得它们的和最大, 则 $f(a)_i$. 表示和的最大值. 现在给定 $n, m$, 求有多少个长度为 $n$ 的非负整数序列 $b$ 满足存在至少一个长度为 $n$, 值域为 $[0, m]$ 的非负整数序列 $a$ 使得 $f(a)&#x3D;b$. 答案对给定的质数 $MOD$ 取模.</p><p>$n, m\le 300$</p></blockquote><p>设 $B$ 为 $b$ 的全局最大值, 也就是 $a$ 的全局最大独立集, 设 $c_i&#x3D;B-b_i$, 则容易发现相邻两个 $c_i$ 至少有一个为 $0$, 把 $c_i$ 分为 $0$ 和 $&gt;0$ 两类, $c_i&gt;0$ 是全局独立集的元素而 $c_i&#x3D;0$ 的可能是. 当 $c$ 确定了 $b$ 的相对大小就确定了, 于是考虑对于每个 $c$, 另其权值为 $B$ 的取值范围大小, 则累加所有 $c$ 的权值即为答案.</p><p>容易发现对于一个 $c$, $B$ 的最小值就是 $\sum c_i$, 而最大值分开考虑.</p><p>对于 $c_i&#x3D;0$ 的极长连续段, 这一段在 $b$ 中的值相等, 发现如果左端点左边存在 $c_i\ne 0$, 那么左端点一定不会进入独立集, 否则会对外面造成影响同时中间不变, 右端点同理, 于是可以删掉左右端点, 设中间剩下长度为 $x$, 可填入 $\lfloor\dfrac{x}{2}\rfloor$ 个数奇数则留空一个, 数大小任取贡献即 $\lfloor\dfrac{x}{2}\rfloor m$</p><p>对于 $c_i&gt;0$ 的每个数单独考虑, 一定是独立集中元素, 且不小于 $c_i$, 上界看起来是 $m$, 但存在情况不是: 对于序列 $c&#x3D;p0x0x0x0x0q$ 其中 $p, q&gt;x$ 或 $p0, 0q$ 不存在顶到序列边界, 设从第一个 $x$ 到最后一个 $x$ 的区间长 $l$, 因为删去第一个 $x$ 的最优解一定包含 $p$(根据 $p&gt;x$)同理有删去最后一个 $x$ 一定包含 $q$, 于是删去它后区间外方案不变, $p, q$ 之间显然最大是 $(l-1)m+x$($l-1$ 个位置填 $m$ 剩下一个填 $x$), 就行了.</p><p>于是可以拆贡献, 一个 $c$ 序列的贡献是所有极长 $0$ 段加上所有 $c_i\ne 0$ 减去 $p0x0x0q$ 的贡献, 分别计算, 设 $f_i$ 表示一个长 $i$ 的段, 每个位置属于 $[0, m]$ 没有选到两个连续的 $0$(即 $c$ 序列方案数), $g$ 表示 $f\times f$, 就能算了.</p><h2 id="NOI2024省选模拟赛28"><a href="#NOI2024省选模拟赛28" class="headerlink" title="NOI2024省选模拟赛28"></a>NOI2024省选模拟赛28</h2><h3 id="A-树的重心"><a href="#A-树的重心" class="headerlink" title="A. 树的重心"></a>A. 树的重心</h3><blockquote><p>给定一棵树求有多少个连通块的重心与这棵树相同.</p><p>$n\le 5000$</p></blockquote><p>显然容易 $n^2$ 求出以 $u$ 子树与 $u$ 连通的部分大小为 $x$ 的方案数, 设为 $f_{u, x}$, 则如果有两个重心吸纳然要求两个一条边的两个子树大小相同, 直接做复杂度就是对的. 对于只有一个重心的要求没有一棵子树大于一半, 先不管限制卷起来再容斥掉大于一半的即可, 复杂度也是 $n^2$.</p><h3 id="B-匹配"><a href="#B-匹配" class="headerlink" title="B. 匹配"></a>B. 匹配</h3><blockquote><p>给定一个 $2n$ 个点 $m$ 条边的二分图, 左部点编号为 $1\sim n$ 右部点编号为 $n+1\sim 2n$. 给定每条边为黑色或白色, 你需要找到一个完美匹配, 使得匹配里的黑色边数恰好为偶数.</p><p>$\sum n\le 500$</p></blockquote><p>容易想到先随便找一个匹配调整, 则接下来要找一个有奇数条黑边的环, 容易想到把每个点拆两个最短路, 或者随机一个点为根找所有返祖边形成的环也能过.</p><h3 id="C-deadline"><a href="#C-deadline" class="headerlink" title="C. deadline"></a>C. deadline</h3><blockquote><p>给定二分图, 左边有 $n$ 个点, 右边有 $m$ 个点, 有 $k$ 条边, 右边点有黑&#x2F;白色, 左边点颜色任选, 求只保留同色边的情况下最大匹配的最小值.</p><p>$n, m\le 2000, k\le 5000$</p></blockquote><p>考虑网络流, 考虑最小割, 容易想到左边每个点拆两个 $u, u’$, 连边 $s \stackrel{inf}{\rightarrow} u, u’\stackrel{inf}{\rightarrow} t, u\stackrel{inf^2}{\rightarrow} u’$ 来使得每个点恰好选一边, 对每个右边的点, 若为白色连 $s\stackrel{inf^2}{\rightarrow} v$, 若为黑色连 $v\stackrel{inf^2}{t}$, 对一条边 $x\to y$, 若 $y$ 为白色连 $x\to y$ 否则连 $y\to x’$ 边权为 $1$, 跑最大流即可.</p><p>最小割的好处是, 先割了一部分后剩下的仍然是一个最小割问题使得我们可以把二分图匹配问题嵌入进去.</p><h3 id="D-新本格魔法少女"><a href="#D-新本格魔法少女" class="headerlink" title="D. 新本格魔法少女"></a>D. 新本格魔法少女</h3><p>todo</p><h2 id="NOI2024省选模拟赛29"><a href="#NOI2024省选模拟赛29" class="headerlink" title="NOI2024省选模拟赛29"></a>NOI2024省选模拟赛29</h2><h3 id="A-Easy"><a href="#A-Easy" class="headerlink" title="A. Easy"></a>A. Easy</h3><blockquote><p>给定一个 $n$ 个点, $m$ 条边的无向联通图第 $0$ 天未尾你在结点 $1$, 并且战斗力为 $l_1$ 除了结点 $1$ 之外的 $n-1$ 个节点都有BOSS, 第 $I$ 节点BOSS的战斗力可以表示为 $l_i$. 每天你可以挑战最多一个BOSS, 到其所在结点打败他, 前提是当前结点到BOSS结点的一条路径上没有其他BOSS存活.</p><p>当你的战斗力大于该BOSS时, BOSS会被消灭, 否则不能挑战该BOSS. 当击败一名BOSS, 奖励的经验值会使你的战斗力提高 $A$. 而每天的一开始, BOSS的战斗力会提高 $B$.</p><p>你必须打败结点n的BOSS来获得游戏的胜利. 问是否存在这样的方案, 如果存在, 最少需要多少天?</p><p>$n, m, A, B, l_i\le 21\times 10^5$</p></blockquote><p>容易想到当 $A-B&lt;0$ 时就是直接写dij(第一次到达一定最优), 当 $A-B&gt;0$ 时任何一个曾经能到的节点将来都能到所以维护当前能到的所有节点, 不断拓展, 当能到节点数不大于当前天数就说明无解, 当当前能到的节点包含 $n$ 时胜利.</p><h3 id="B-幂"><a href="#B-幂" class="headerlink" title="B. 幂"></a>B. 幂</h3><blockquote><p>对所有 $x\in [1, A], y\in [1, B]$ 求有多少种不同的 $x^y$</p></blockquote><p>容易想到把 $[1, A]$ 中 $a$ 相同的 $a^b$ 拿出来一起处理, 则 $b&gt;1$ 的就只有根号了, 考虑计算答案比 $AB$ 少多少(算重了多少).</p><p>则钦定每个数 $a^c$ 被最小的 $b\vert c$ 的 $a^b$ 表示, 于是 $a^x$ 会表示的数就是 $c(x)&#x3D;\sum_{S\subset {1\ldots x-1}} c(S)(-1)^{\vert S\vert}$, 其中 $c(S)$ 表示能同时被 $S$ 中所有数表示的数的个数, 容易发现其为 $\dfrac{m\cdot g_S}{\mathrm{lca(S)}}$, 其中 $g_S$ 表示 $S$ 中最小元素, 直接做复杂度是 $2^29$ 过不了, 但是注意到如果新加入元素已经被 $lca(S)$ 表示则加&#x2F;不加的所有方案构成双射贡献为 $0$, 就过了.</p><h3 id="C-哈夫曼回路"><a href="#C-哈夫曼回路" class="headerlink" title="C. 哈夫曼回路"></a>C. 哈夫曼回路</h3><blockquote><p><img src="/img/2024-01-26-19-57-25-image.png" alt="图 0">  </p><p><img src="/img/2024-01-26-19-57-45-image.png" alt="图 1">  </p><p>$n, q\le 10^5, w_i, h_i\le 10^6$</p></blockquote><p>考虑任意两个匹配都不在边上相交否则直接交换即可, 于是容易发现匹配只会在同一个矩形中, 于是直接线段树结构分治做即可.</p><h3 id="D-模拟赛"><a href="#D-模拟赛" class="headerlink" title="D. 模拟赛"></a>D. 模拟赛</h3><blockquote><p>$A\times B$ 网格上有 $n$ 个点, 求矩形对数使得每个点至少被一个矩形覆盖</p><p>$n, A, B\le 10^5$</p></blockquote><p>这种题和上一次碰到的历史研究类似, 都先考虑所有点横竖方向最大的点带来的性质. 现在设所有点的上, 下, 左, 右界分别为 $U, D, L, R$ 构成矩形 $R_0$. 考虑现在确定第一个矩形 $R_1$ 为 $u, d, l, r$, 分类考虑第二个矩形的范围. 下面包含均指严格包含(非边界覆盖)</p><p>分类之后扫描线即可. 附上官方题解, 但其实不用线段树, 直接二分就能做的.</p><p><a href="/res/5193rty.pdf">sol</a></p><h2 id="NOI2024省选模拟赛30"><a href="#NOI2024省选模拟赛30" class="headerlink" title="NOI2024省选模拟赛30"></a>NOI2024省选模拟赛30</h2><h3 id="A-Y"><a href="#A-Y" class="headerlink" title="A. Y"></a>A. Y</h3><blockquote><p>你有一个随机生成器, 每次会均匀随机地生成一个 $[0, m]$ 之间的整数. 你用这个随机生成器生成了 $2n$ 个整数, 你想知道你生成的前 $n$ 个整数的和比后 $n$ 个整数的和大的概率是多少. 你只需求出这个概率对质数 $P$ 取模后的结果即可.<br>$T, n, m\le 1000$</p></blockquote><p>前两天是不是刚做了一个谁比谁大相当于赢得和输的双射, 只要求平局数量的题.</p><p>[trick] 输赢双射后求平局数量</p><p>于是直接GF, 把后 $n$ 个数每个数求相反数相当于提取 $0$ 项</p><p>$$<br>\begin{gathered}<br>  [x^0]\left(\dfrac{1-x^{m+1}}{1-x}\right)^n\left(\dfrac{1-x^{-m-1}}{1-x^{-1}}\right)^n\<br>  &#x3D;[x^m]\left(\dfrac{(x^{m+1}-1)^2}{(x-1)^2}\right)^n<br>  &#x3D;[x^m]\left(\dfrac{x^{m+1}-1}{x-1}\right)^{2n}<br>\end{gathered}<br>$$</p><p>而分子和分母逆的展开式都是简单的, 于是直接线性卷就做完了.</p><h3 id="B-hashit"><a href="#B-hashit" class="headerlink" title="B. hashit"></a>B. hashit</h3><blockquote><p>初始为空的字符串 $S$, $q$ 次操作, 每次末尾增删字符, 每次操作后询问本质不同子串数.<br>$q\le 10^5$</p></blockquote><p>容易想到离线后操作树, 想到字典树, 建广义SAM, 一个操作的答案对应操作树上到根的链构成的字符串的本质不同子串, 对应字典树上到根链的本质不同子串, 对应sam上若干个节点到根的链的答案之和, 也就是要求到根的链并的权值和, 于是直接做就行了.</p><h3 id="C-点点的圈圈"><a href="#C-点点的圈圈" class="headerlink" title="C. 点点的圈圈"></a>C. 点点的圈圈</h3><blockquote><p>给定 $n$ 个圆的圆心 $(x_i, y_i)$ 和半径 $r_i$, 保证没有相交和相切, 第 $i$ 个圆价值为 $w_i$ 要求选出最多的互不相交的圆.</p><p>$n\le 10^5$</p></blockquote><p>首先容易发现如果建出树就是简单题, 乱dp即可.</p><p>于是只要给每个点找父亲, 这种题没有相交就是在说上下关系不变让你扫描线, 但是圆不好扫, 分成上半圆和下半圆去做即可, 注意扫描线可能不能容易的找到父亲, 此时找到一个兄弟也能知道父亲.</p><h3 id="D-图上的游戏"><a href="#D-图上的游戏" class="headerlink" title="D. 图上的游戏"></a>D. 图上的游戏</h3><blockquote><p>交互题, $n$ 点 $m$ 边图, 每次可以给定点集问是否连通, 要求问出图. $n, m\le 600$, 次数 $3\times 10^4$</p></blockquote><p>考虑对于一条链已知点集和边集怎么做, 维护加入前若干点后这些点的顺序和两点之间的边集, 每次先二分出新点应该插入在哪两个点之间再逐个判断边应该加在哪边, 后面这不期望1log所以要先打乱.</p><p>考虑先求图的一棵生成树, 从 $1$ 到 $n$ 加点, 维护若干条链加点的时候可以而分出这个点在哪条链或者不在任何已有的链上, 不在任何已有的链上时可以对边集二分出这条链的边. 经过这一步之后可以得到每个链的边集和点集, 在dfs序上二分可以得到每个链的父亲节点, 然后用链的方法处理.</p><p>对于图剩下的边考虑从叶子到根处理, 在dfs序上二分出每个边的另一端是谁, 然后剥掉叶子重复, 就做完了.</p><h2 id="NOI2024省选模拟赛31"><a href="#NOI2024省选模拟赛31" class="headerlink" title="NOI2024省选模拟赛31"></a>NOI2024省选模拟赛31</h2><h3 id="A-X"><a href="#A-X" class="headerlink" title="A. X"></a>A. X</h3><blockquote><p>JOI准高速列车的背景</p><p><img src="/img/2024-02-12-18-15-40-image.png" alt="图 1">  </p><p>$k\le 2500, x\le 2500, S_{i+1}-S_i&#x3D;10000$</p></blockquote><p>显然每段是独立的, 对于单独一段, 考虑dp怎么划分子问题, 发现一个两端点都修建站台的区间是子问题, 此外要知道两个端点各还能走多远, 于是设 $f_{i, a, b}$ 表示长 $i$ 的区间左边还能走 $a$ 步右边还能走 $b$ 步的方案数就做完了.</p><h3 id="B-装饰"><a href="#B-装饰" class="headerlink" title="B. 装饰"></a>B. 装饰</h3><blockquote><p>有 $2\times m$ 的矩阵, 要求用 $3$ 种颜色涂色, 满足第 $i$ 种颜色的数量恰好为 $c_i$, 相邻格子颜色不同, 任意 $2\times 2$ 区域包含所有种类的颜色. 求方案数.<br>$m\le 10^6$</p></blockquote><p>考虑把上下两个作为一个整体考虑, 若当前位置填 $(1, 2)$ 下一个只能填 $(2, 3)$ 或 $(3, 1)$, 而 $(2, 3)$ 下一个只能填 $(3, 1)$ 或 $(1, 2)$, $(3, 1)$ 下面只能填 $(1, 2)$ 和 $(2, 3)$, 即上下两个看起来有 $6$ 种可能, 但一种填色方案只出现 $3$ 种, 问题变成了给定 $c_1, c_2, c_3$, 要求没有两个颜色相邻的方案数.</p><p>后面这个问题直接插板组合数即可, 枚举第二个颜色插到第一个颜色中时还有相邻两个都是第一个颜色的位置.</p><h3 id="C-和谐宇宙"><a href="#C-和谐宇宙" class="headerlink" title="C. 和谐宇宙"></a>C. 和谐宇宙</h3><blockquote><p><img src="/img/2024-02-12-15-46-41-image.png" alt="图 0">  </p><p>$n\le 6\times 10^5, tp\le 2$</p></blockquote><p>对树的这种连通块计数. $E$ 的权值可以变成逆元做, 相当于问所有方案的连通块的边权积之和. $tp&#x3D;1$ 是直接dp, 对于 $tp&#x3D;2$ 考虑两个连通块要么有祖孙关系要么没有, 有的部分在每个节点 $u$, 统计 $u$ 子树内连通块和包含 $fa_u$ 的连通块之间的贡献. 没有祖先关系的在每个 $u$ 统计不同子树之间的贡献. 换根要维护孩子前后缀背包(背包以满足选至少三个分支)</p><p>为什么不能直接待删背包? 因为这里只会维护 $g_{u, 1&#x2F;2&#x2F;3}$ 表示选 $1, 2, \ge 3$ 个分支的情况, 而删除权值为 $w$ 的物品时 $g_{u, 3}$ 要除掉 $\dfrac{1}{w+1}$, 题目只保证 $w$ 有逆元而不保证 $w+1$ 有就寄了. 只能前后缀背包合并.</p><h3 id="D-黑鸭的序列"><a href="#D-黑鸭的序列" class="headerlink" title="D. 黑鸭的序列"></a>D. 黑鸭的序列</h3><p>对 $\forall i\in [1, V]$ 建树 $G$ 使得 $fa_i&#x3D;\lfloor \sqrt i\rfloor$, 设树高为 $H$, 设数 $i$ 高为 $dep_i$. 则显然我们要求区间内的数的 $lca$ 的深度 $d$, 答案即为 $(r-l+1)d-\sum_i dep_{a_i}$. 而要求lca可以考虑求dfs序最小&#x2F;最大的lca, 但是dfs序不会求, 考虑这棵树的bfs序就是数的大小顺序, 而同一层的点dfs序的大小关系和bfs序相同, 于是把每层最小最大的数拿出来暴力lca即可.</p><p>于是显然要维护区间内深度和, 区间内每个深度中点的最大&#x2F;最小值. 区间赋值直接打标记, 区间加考虑如果没有数的深度变化就打标记, 否则递归到左右儿子再合并信息.</p><p>定义势能 $\Phi&#x3D;H-\sum_{u\in T} c_u$, 其中 $u$ 为线段树节点, $c_u$ 为每个 $u$ 节点中存在的值 $v$ 的 $H-h_v$ 之和, 显然考虑区间赋值和初始情况总势能是 $(n+q)\log n$ 的. 每次区间加的时候如果当前节点存在某个位置深度增加则暴力递归到两边后合并, 于是单次复杂度是 $\Delta \Phi\log n\log \log V$. 可以把 $\log \log V$ 去掉, 改为只上传发生变化的层的信息, 由于势能变化一只能变两层所以就是 $\Delta \Phi \log n$ 了.</p><p>然后一种常数优化是把递归改为标记下传时做而不是修改时做</p><h2 id="NOI2024省选模拟赛32"><a href="#NOI2024省选模拟赛32" class="headerlink" title="NOI2024省选模拟赛32"></a>NOI2024省选模拟赛32</h2><h3 id="A-Giao-徽的烤鸭"><a href="#A-Giao-徽的烤鸭" class="headerlink" title="A. Giao 徽的烤鸭"></a>A. Giao 徽的烤鸭</h3><blockquote><p>给定一棵树, 选点 $i$ 要付出代价 $w_i$, 若一个点距离 $p$ 以内的点都被选了收益 $v_p$, 最大化收益减代价.</p><p>$n\le 2000$</p></blockquote><p>距离的限制是简单满足的, 只要直接dp, $f_{i, j}$ 表示点 $i$ 距离 $j$ 以内的点都被选了, 转移的时候到父亲到儿子限制至少为 $i-1$ 即可. 复杂度 $n^2$</p><h3 id="B-apers"><a href="#B-apers" class="headerlink" title="B. apers"></a>B. apers</h3><blockquote><p>给定有向图 $G$, 可以化 $c_u$ 代价选中点 $u$, 要求每条 $s\to t$ 路径上必须经过至少 $k$ 个选中的点.<br>$n\le 200, m\le 500, k\le 5$</p></blockquote><p>$k&#x3D;1$ 显然是最小割, 而且数据范围也很网络流, 考虑最小割拓展, 想到拆分层图.</p><p>于是建 $k$ 层 $G$, $G$ 中每个点拆成 $u\stackrel{c_i}{\longrightarrow} u’$,</p><h3 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C. 字符串"></a>C. 字符串</h3><blockquote><p>给定字符串 $a_n, b_m$, 求有多少有序对 $(i, j)$ 满足 $a_{1\ldots i}+a_{j\ldots n}$ 是 $b$ 的子串</p><p>$n, m\le 5\times 10^5$</p></blockquote><p>相当于对 $b$ 每个本质不同子串数划分方式. 则设 $p_i$ 表示 $a_{i\ldots n}$ 与 $a$ 的lcp, $q_i$ 表示 $a_{1\ldots i}$ 与 $a$ 的最长公共后缀, 显然区间 $[l, r]$ 的划分数是 $\max(\min(l+p_l, r)-\max(r-q_r, l), 0)$.</p><p>sam的等价类要求每次对 $r$ 固定, $l$ 位于一个区间的子串统计答案, 可以差分成对 $r$ 固定 $l$ 位于一个前缀, 扫描线, 然后看起来三个maxmin很难做但一拆发现三种情况都很好做, 只剩下 $(l+p_l)-(r-q_r)$ 的情况, 要求 $l+p_l\in [r-q_r, r], r-q_r\ge l, l\le L$, 发现最也只有两维数点. 复杂度单log.</p><h2 id="NOI2024省选模拟赛33"><a href="#NOI2024省选模拟赛33" class="headerlink" title="NOI2024省选模拟赛33"></a>NOI2024省选模拟赛33</h2><h3 id="A-塔"><a href="#A-塔" class="headerlink" title="A. 塔"></a>A. 塔</h3><blockquote><p>有长 $l$ 的数轴, 要求选编号为 $1\ldots n$ 的 $n$ 个点, 对第 $i$ 个点要求距离其 $&lt;i$ 的位置没有选点. 模 $m$<br>$n\le 100, m, l\le 10^9$</p></blockquote><p>$l$ 很大, 考虑如果确定了点的排列 $p$, 则 $i, i+1$ 两个点的距离要不小于 $b_i&#x3D;\max p_i, p_{i+1}$, 设 $s&#x3D;\sum b_i$, 那么对于确定的排列 $p$ 安排点的位置的方案数就是 $\binom{l-s+n-1}{n}$.</p><p>于是考虑计数 $s$ 为某固定值的排列数量, 排列计数且贡献只和相邻元素有关容易想到扫值域dp, 设 $f_{i, s, j, k}$ 表示当前插入最大的 $i$ 个数, 这些数的贡献为 $s$(每个数插入时贡献), 有 $j$ 个连续段, 且有 $k$ 个端点被占用, 转移即可, 复杂度 $n^4$.</p><p>然后要求若干组合数, 因为 $n$ 很小可以矩阵快速幂, 复杂度 $n^3\log n$</p><h3 id="B-运输"><a href="#B-运输" class="headerlink" title="B. 运输"></a>B. 运输</h3><blockquote><p>$n$ 点树, $q$ 询问子树和, 链和, 或给定 $x, y, a$, 对每个 $u\in subtree(x)$ 加上 $dis(u, y)\cdot a$</p><p>$n, q\le 2\times 10^5$ </p></blockquote><p>容易想到按照 $y$ 是否在 $x$ 子树分类, 而 $y$ 在子树外的情况很简单, 相当于子树加 $dep\cdot v$ 和子树加.</p><p>对 $y$ 在子树内的情况, 子树询问ban掉了点分树, 考虑硬拆 $dep_u+dep_y-2dep_{lca(u, y)}$, 要给 $y$ 到 $x$ 这条链第一个点加 $-2dep\cdot a$, 后面链上每个点的子树加 $2a$, 加的标记都记录在这条链上, 则一个点的值是自己记录的值加上祖先链的和, 剩下都很简单了.</p><h3 id="C-麻将"><a href="#C-麻将" class="headerlink" title="C. 麻将"></a>C. 麻将</h3><blockquote><p><img src="/img/2024-02-10-15-00-48-image.png" alt="图 4"><br><img src="/img/2024-02-10-15-00-59-image.png" alt="图 5">  </p></blockquote><p>考虑dp of dp, 对于判定问题, 显然对麻将扫值域, 设 $f_{i, 0&#x2F;1&#x2F;2, 0&#x2F;1&#x2F;2, 0&#x2F;1&#x2F;2}$, 表示考虑前 $i$ 大的数, 当前有没有将, $i-1$ 的值的个数和 $i-2, i-1$ 都有的值的个数.</p><p>对于数数问题, 看起来是设 $f_{i, j, S}$ 表示扫了前 $i$ 大的值选了 $j$ 个数当前内层dp状态为 $S$ 的方案数, $S$ 很大过不了, 但是发现有用的 $S$ 个数很少($100$ 个), 于是复杂度变成 $MKS$.</p><h2 id="NOI2024省选模拟赛34"><a href="#NOI2024省选模拟赛34" class="headerlink" title="NOI2024省选模拟赛34"></a>NOI2024省选模拟赛34</h2><h3 id="A-duyi-的切题树"><a href="#A-duyi-的切题树" class="headerlink" title="A. duyi 的切题树"></a>A. duyi 的切题树</h3><blockquote><p>交互题, 有一棵高为 $n$ 的完全二叉树, 节点编号未知, 求根的编号, 每次可以问每个点的所有邻居的编号. 你可以问 $q$ 次.<br>$n\le 12, q\le 50$</p></blockquote><p>容易想到对于一个点直接可以问出一条到叶子的链, 可以先随便一个点问出三条链得到其深度.</p><p>然后假设现在在点 $u$, 深度为 $h$, 假设已知另外两条链长度为 $h, l$(一定有一条是深度), 那么可以直接跳到第二条链的第 $(l-h)&#x2F;2$ 个点, 不断重复. 然后其实这两条只要随便问出一条, 如果长 $h$ 就跳 $u$ 不是这条链的那个邻居, 否则跳 $(l-h)&#x2F;2$. 这样询问次数是 $\sum_{i&#x3D;1}^12 i&#x3D;78$.</p><p>容易发现最后 $k$ 步直接爆搜要用 $2^k-1$ 次, 于是平衡出最优是 $1+2\ldots +8+2^4-1&#x3D;51$</p><p>最后爆搜 $2^k-2$ 个点还没搜出来, 直接排除, 于是就 $50$ 次.</p><p>是CF750F New Year and Finding Roots加强版</p><h3 id="B-红蓝大作战"><a href="#B-红蓝大作战" class="headerlink" title="B. 红蓝大作战"></a>B. 红蓝大作战</h3><blockquote><p>给定 $(2n)\times m$ 的01矩阵, 其中 $0, 1$ 各 $nm$ 个, 给 $0, 1$ 各自两两连边构成向量($(a, b)$ 连向 $(c, d)$ 得到向量 $(c-a, d-b)$), 要求把边定向后所有向量和为 $0$. 构造方案.</p><p>$nm\le 3000$</p></blockquote><p>$nm$ 为奇数很简单, 直接就是欧拉回路定向, 因为向量绕一圈和为 $0$.</p><p>对 $nm$ 为偶数, 要发现一个结论, 保证颜色不同的两个对角点 $a, b$ 各自连向同色点可以让这些边向量和为 $0$. 证明考虑对称的两个点, 如果颜色不同显然是 $0$, 如果颜色相同则是由 $a\to b$ 或 $b\to a$ 的向量. 因为 $0, 1$ 个数相等, 两个方向的一样多所以最后是 $0$. 最后还是欧拉回路.</p><p>欧拉回路直接跑好像会爆, 但完全无向图构造若干个环实在是很简单. (模几)</p><h3 id="C-发讲义"><a href="#C-发讲义" class="headerlink" title="C. 发讲义"></a>C. 发讲义</h3><blockquote><p>给定一棵 $n$ 点树, 两个人从根开始走, 不能走向父亲, 一个人可以在任意节点处传送到另一个人的位置, 要求所有点都必须走到, 求最短时间</p><p>$n\le 5\times 10^6$</p></blockquote><p>上来第一个想法是一定是两个人一起往下走, 走到第一个有分叉的地方之后先清理其它分叉, 再留下最深的一个分叉, 然后两人再同时往下走, 把一个人传过来, 这是错的, 一个hack: 根引出两条链, 链靠近根处挂几个叶子, 此时应该让一个人先去叶子, 再传送回根, 然后两个人同时走两条链. 错误原因是可能先修剪掉浅处一些分叉使得最后剩下的两个分叉延伸更长.</p><p>因为两个人是不区分的, 考虑一定可以看成两个人中的一个人没有传送过而另一个人不断传送到它, 于是这个人走了一条到叶子的主链, 会在若干关键点处停留, 此时另一个人去清理到下一个关键点之间链外的叶子, 当只剩一个最深的叶子时两人一起向下走.</p><p>于是可以dp, $f_u$ 表示 $u$ 作为主链上的关键点时从根到 $u$ 的部分耗费的时间, 转移枚举祖先 $v$ 作为上一个关键点, 设 $u$ 深度, 子树叶子个数, 子树叶子深度和, 子树内且主链外最深的叶子深度分别为 $d_u, c_u, s_u, m_u$, 则转移为 $f_u&#x3D;f_v+(s_v-s_u)-d_v(c_v-c_u)+\max(0, (d_u-d_v)-\max_k m_k)$, 可以上复杂数据结构斜率优化.</p><p>一个分叉不作为关键点一定是祖先上有一个延伸很长的叶子, 至少要比自己长, 于是点 $u$ 一定会从 $m_v\ge d_u$ 的地方转移过来. 同时发现 $m_v$ 更长且当前点更靠下的一定更优(单调), 而且长过 $u$ 的对 $u$ 来说都一样, 最后每个点只会从最近的 $m_v\ge d_u$ 转移过来即可.</p><p>于是直接可撤销化单调栈 $n\log n$ 即可. 考虑普通单调栈, <code>push</code>一个点 $m_u$ 时会 <code>pop</code> 掉 $O(Height)$ 个点, 于是先进短儿子再进长儿子, 复杂度是线性的.</p><p>原是[UR #7]水题走四方</p><h2 id="NOI2024省选模拟赛35"><a href="#NOI2024省选模拟赛35" class="headerlink" title="NOI2024省选模拟赛35"></a>NOI2024省选模拟赛35</h2><h3 id="A-God的怒火"><a href="#A-God的怒火" class="headerlink" title="A. God的怒火"></a>A. God的怒火</h3><blockquote><p>$n\times m$ 矩阵, 有 $k$ 个点有障碍, 你在 $(s, t)$, 求你走到能走到每个位置的最小代价之和. 你每次可以走到同行同列上不是障碍的一个位置(可以跨过障碍).</p><p>$n, m\le 10^5, k\le 10^6$</p></blockquote><p>一开始往数数上想歪了, 其实是简单最短路题, 注意到格子 $(i, j)$ 的到达时间是到达第 $i$ 行或第 $j$ 列的时间取min再加一, 于是只对行bfs即可. 对行bfs可以对所有行, 所有列开并查集使得每个行列只被遍历 $1$ 次, 复杂度就对了. 之后求 $\sum_i \sum_j \min(a_i, b_j)$ 可以双指针, 也线性.</p><h3 id="B-弱化的杨表"><a href="#B-弱化的杨表" class="headerlink" title="B. 弱化的杨表"></a>B. 弱化的杨表</h3><blockquote><p>有 $2n$ 个数填到 $2\times n$ 的表格 $a$ 中, 要求 $a_{1, i}&lt;a_{1, i+1}$, $a_{1, i}&lt;a_{2, i}$, $i$ 填到第 $j$ 行会产生 $c_{i, j}$, 问最小代价.</p><p>$n\le 3\times 10^5$</p></blockquote><p>容易发现表的两行都递增, 如果按照数从小到大考虑相当于要求每个放到第二行的数 $i$ 之前的数至少有 $\lfloor \dfrac{i}{2}\rfloor$ 个放到第二行. (实际上相当于括号匹配)除此之外也没啥限制.</p><p>直接dp, 发现转移是 $min+$ 卷积长 $2$ 的序列和把开头删掉($\dfrac{i}{2}$ 前的不需保留), slope trick.</p><h3 id="C-达拉然的废墟"><a href="#C-达拉然的废墟" class="headerlink" title="C. 达拉然的废墟"></a>C. 达拉然的废墟</h3><blockquote><p>长 $2n$ 的随机好排列分成随机 $k$ 个长为偶数的段, 求权值期望. 好排列指所有偶数位置递增的排列, 排列的权值为每段的权值积, 一段的权值为段内逆序对数.</p><p>$n\le 500$</p></blockquote><p>积和形式的东西拆贡献, 可以考虑相当于每个段选一个数对贡献的乘积, 即每段选一个数对恰好全为逆序对的方案数.</p><p>如果选的都是奇数位置, 由双射贡献是 $\dfrac{1}{2}$, 两个偶数是 $0$, 奇数在前偶数在后相当于限制奇数大于偶数, 否则是限制奇数小于偶数. 限制可以看成树形拓扑序(根大)的限制, 则偶数位置串成一条链, 要求对于某偶数位置的奇数挂成叶子, 要求小于的用挂成叶子的容斥, 根据经典结论数满足树形限制的只要知道子树大小. 对于一个前缀部分的限制就是整棵树的一个子树.</p><p>设 $f_{i, j, k}$ 表示前 $2i$ 个数, 分 $j$ 层, 子树大小为 $i+k$ 的方案数, 每次转移一段, 枚举当前段长度为 $i-2l$ 和选的第一个数的位置 $p$, 状态中不把子树大小倒数乘进去, 状态里存真实值除 $\dfrac{1}{(i+k)! }$:</p><p>$$<br>\begin{gathered}<br>f_{i, j, k}&#x3D;\sum_{l&#x3D;0}^i \sum_{p&#x3D;1}^{i-l} \dfrac{1}{2}(p-1)f_{l, j-1, k}\<br>+\sum_{l&#x3D;0}^i \sum_{p&#x3D;1}^{i-l} (i-l-p)(l+p+k-1)f_{l, j-1, k-1}\<br>+\sum_{l&#x3D;0}^i \sum_{p&#x3D;1}^{i-l} pf_{l, j-1, k}-<br> \sum_{l&#x3D;0}^i \sum_{p&#x3D;1}^{i-l} p(l+p+k-1)f_{l, j-1, k-1}<br>\end{gathered}<br>$$</p><p>第一行是奇数, 第二行是奇数在后, 第三行是奇数在前的容斥.</p><p>为啥是乘 $(l+p+k-1)$? 因为全都除 $(i+k)!$, 本来 $f_{l, j-1, k-1}$ 到 $f_{i, j, k}$ 会乘上 $\dfrac{(i+k)! }{(l+k-1)! }$, 而实际上多挂了一个叶子之后, 应该去掉一个 $l+k+p-1$, 后面的都是对的.</p><p>直接做复杂度是 $n^5$ 或 $n^4$, 然后前缀和优化记录 $k\in [0, 3]$ 的 $\sum_{i&#x3D;0}^v f_{i, j, k}i^k$ 即可 $n^3$</p><p>卡常题没素质.</p><h2 id="NOI2024省选模拟赛36"><a href="#NOI2024省选模拟赛36" class="headerlink" title="NOI2024省选模拟赛36"></a>NOI2024省选模拟赛36</h2><h3 id="A-赌徒"><a href="#A-赌徒" class="headerlink" title="A. 赌徒"></a>A. 赌徒</h3><blockquote><p>萌新小H和他的 $n$ 个好朋友玩游戏!<br>他们将要玩的游戏是抛硬币, 小H 和他的对手分别抛出硬币, 如果小H 抛出的数值大于等于对方的, 则小H赢, 否则对手赢.<br>第个好朋友有一个两面分别为 $a_i$ 和 $b_i$ 的硬, 他和小H赌 $x_i$ 个硬币, 即如果小H 赢则他获得 $x_i$ 个硬币, 否则失去 $x_i$ 个硬币.<br>小H 还没有硬币, 它可以去邪恶工匠大D 定制一枚硬币. 若小H 得到的硬币两面分别是 $a, b$, 则 $a, b$ 都需要是正整数, 并且他需要支付 $ab$ 个硬币<br>他想知道, 如果他选择一枚合适的硬币, 他期望最多能挣到多少硬币<br>注意小H很富有, 他初始有足够多的硬币, 不需要考虑硬币不足以支付的情况</p><p>$n\le 5\times 10^5$</p></blockquote><p>见到乘积想凸性相关, 考虑第 $i$ 个人的贡献是 $(2[a\ge a_i]+2[b\ge b_i]-2)x_i$, 于是贡献是 $s_a+s_b+ab$, $s_i$ 为 $\sum_{j&lt;i} 2[a\ge a_i] -1$, 然后上个李超树维护即可(凸包就行, 但李超好写啊).</p><h3 id="B-毒假强"><a href="#B-毒假强" class="headerlink" title="B. 毒假强"></a>B. 毒假强</h3><blockquote><p>求第 $n$ 个好数, 好数 $x$ 满足条件当且仅当 $x(10^k-1)$ 在 $10$ 进制下不包含 $9$.</p><p>$n\le 10^18, k\le 18$</p></blockquote><p>考虑显然答案是 $n$ 级别的, 可以先算 $x(10^k-1)$ 再除, 而一个数可以被 $10^k-1$ 整除当且仅当从低到高 $k$ 个分一段, 每段的和加起来是 $10^k-1$ 的倍数(证明考虑多项式模 $x^k-1$ 代入 $x&#x3D;10$, 就是 $k$ 个分段加起来).</p><p>于是枚举这 $k$ 段的和 $s&#x3D;c(10^k-1)$, $c$ 是 $O(\dfrac{\log n}{k})$ 的, 然后数位dp从低到高背包即可.</p><p>复杂度是 $O(poly(\log n, k)$</p><h3 id="C-零和"><a href="#C-零和" class="headerlink" title="C. 零和"></a>C. 零和</h3><blockquote><p>给定 $K$, 构造长 $n$ 的序列 $a_n$ 满足恰好有 $K$ 个子集和为 $0$. 要求 $n\le 30, \vert a_i\vert \le 10^{16}$</p><p>$K\le 10^6$</p></blockquote><p>随机化题, 考虑构造正数序列 $b_i$ 和负数序列 $c_i$ 满足 $\forall i, 2c_i\ge \sum_j b_j$, 也就是合法的子集一定是一个 $b$ 配上若干 $c$.</p><p>然后发现 $a$ 硬随长 $22$, 值域 $5$ 的序列就过了&#x2F;kx</p><h2 id="数据结构-ducati"><a href="#数据结构-ducati" class="headerlink" title="数据结构-ducati"></a>数据结构-ducati</h2><h3 id="CF464E"><a href="#CF464E" class="headerlink" title="CF464E"></a>CF464E</h3><p>数据结构维护dij, 需要想办法维护到每个点的距离, 距离可以用线段树维护巨大的01序列, 那么每次距离更新就是在某个点的序列某个位置加 $1$ 并进位得到另一个点的序列, 主席树维护即可. 比较大小就两个版本上同时线段树二分维护子树哈希值做.</p><h3 id="P8860-动态图连通性"><a href="#P8860-动态图连通性" class="headerlink" title="P8860 动态图连通性"></a>P8860 动态图连通性</h3><p>容易发现每个边的第一个询问时有用的, 考虑最后剩下的路径, 应该是被删除时间最小值最大, 在此基础上次小值最大, 即一条字典序最大的路径.</p><p>那么对照上一个题dij上主席树, 每个版本表示一个 $dis_u$ 就做完了.</p><p>但是rqy给出更强的做法, 这个题有性质边权互不相同(删除时间), 容易让每条边的边权是 $C^x$, $C$ 为常数, 考虑dij要比较 $d_1+C^{w_1}, d_2+C^{w_2}$, 设 $d_1&lt;d_2$, 一定有 $d_1+C^{w_1}&gt;d_2$($2$ 先被更新), 这说明比 $w_1$ 高的位上 $d_1$ 和 $d_2$ 相同, 那么若 $w_2&gt;w_1$ 一定 $d_2+w_2$ 更大, 否则 $d_1+w_1$ 更大, 就比较出来了, 任意时刻只要比较边权即可.</p><h3 id="Qoj5421-ICPC2022-Asia-Nanjing-H-Factories-Once-More"><a href="#Qoj5421-ICPC2022-Asia-Nanjing-H-Factories-Once-More" class="headerlink" title="Qoj5421 ICPC2022 Asia Nanjing H Factories Once More"></a>Qoj5421 ICPC2022 Asia Nanjing H Factories Once More</h3><blockquote><p>树上选 $k$ 个点最大化两两之间距离和.</p><p>$n, k\le 2\times 10^5$</p></blockquote><p>dp, $f_{u, i}$ 为子树 $u$ 内选 $i$ 个点, 只考虑子树内和 $u$ 的父边的贡献的最大值, 则转移是先给所有儿子做max+闵和, 再加函数 $i(k-i)$, 都是上凸的, 做完了.</p><h3 id="P6845-CEOI2019-Dynamic-Diameter"><a href="#P6845-CEOI2019-Dynamic-Diameter" class="headerlink" title="P6845 [CEOI2019] Dynamic Diameter"></a>P6845 [CEOI2019] Dynamic Diameter</h3><p>toptree 感觉赢麻了, 只要建静态toptree, 合并直径要维护到界点的最远距离和簇直径, rake tree, compress tree分别做即可. 复杂度单log.</p><p>然后不toptree的话可以线段树维护点集, 但要改边, 考虑维护dfs序上区间的点集, 这样改一条边只有跨过它子树区间的受影响, 也就是与一个区间有交的 $\log n$ 个, 总复杂度 $n\log^2 n$.</p><p>还可以维护欧拉序单log! 维护直径关于欧拉序的式子. 就是拆成 $d&#x3D;\max_{a\le c\le b} d_a+d_b-2d_c$, 然后线段树维护.</p><h3 id="CF1458F"><a href="#CF1458F" class="headerlink" title="CF1458F"></a>CF1458F</h3><p>考虑众所周知合并点集直径是直接四个点两两跑.</p><p>但实际上可以更强的合并, 可以把直径看成以直径中点为圆心, 长度一半为半径的圆去合并(找到最小的包含原来两个圆的圆), 若合并 $(c_1, r_1)$ 和 $(c_2, r_2)$, 包含的显然, 否则新半径是 $\dfrac{1}{2}(dis(c_1, c_2)+r_1+r_2)$, 新圆心是这个的中点.</p><p>于是考虑分治做, 则对跨过 $mid$ 的区间, 对于一个固定的左端点, 发现随 $r$ 单调增右边圆是不断变大的, 一定是先被包含, 再没包含, 再包含左边的, (树上圆理论在直径合并和圆合并建立映射, 而圆合并显然是有这个单调的)各是一个区间, 在扫 $l$ 的时候端点单调移动可以双指针.</p><p>于是只要对没包含关系的要求 $\sum_{i\in l, r} dis(c_x, c_i)$, 可以建点分树支持加点删点和询问, 在双指针同时维护.</p><h3 id="P7125-Ynoi2008-rsmemq"><a href="#P7125-Ynoi2008-rsmemq" class="headerlink" title="P7125 Ynoi2008 rsmemq"></a>P7125 Ynoi2008 rsmemq</h3><p>在sdjx1里</p><h3 id="P8264-Ynoi-Easy-Round-2020-TEST-100"><a href="#P8264-Ynoi-Easy-Round-2020-TEST-100" class="headerlink" title="P8264 [Ynoi Easy Round 2020] TEST_100"></a>P8264 [Ynoi Easy Round 2020] TEST_100</h3><p>注意到值域也是 $O(n)$ 的, 对于全局询问, 考虑维护 $f_i$ 表示输入 $i$ 最后是几, 在前面复合一个绝对值 $\vert x-v\vert$ 相当于把 $f_i$ 的 $[0, v]$ 和 $[1, V-v]$($V$ 是值域)拼接和翻转, 是可持久化平衡树的内容, 于是套个线段树支持区间. 然后线段树叉变多和底层暴力可以卡常. 复杂度 $(n+m)\log n\log V$</p><h3 id="米哈游的游戏"><a href="#米哈游的游戏" class="headerlink" title="米哈游的游戏"></a>米哈游的游戏</h3><blockquote><p>给定 $a_n$ 和常数 $m$, 定义 $f_i(x)$ &#x3D; $\sum_{j\in [i, i+m-1]} [a_j&lt;x]$, $q$ 次询问区间 $f$ 最小值.</p><p>$n, q\le 2\times 10^5$, 要求空间线性. (30Mb)</p></blockquote><p>无储存处. jpg, 不过有人肥节点卡过去了.</p><p>考虑如果可以离线就直接按照 $a$ 排序从小到大扫描不断区间加区间min秒完了. 空间大可持久化就做完了.</p><p>肯定考虑时间分块替代可持久化, 每根号分一块. 虽然分块, 但我们甚至不能每 $\sqrt n$ 次存下整个序列的值. 但是我们可以 $O(1)$ 知道某个时刻整个序列的差分, 即 $f_i-f_{i-1}&#x3D;[a_{i-m}&lt;x]-[a_i&lt;x]$, 则可以线性还原序列.</p><p>接下来考虑支持区间加区间min, 要能 $O(1)-O(\sqrt n)$, 整块加直接打差分标记, 维护每块最小值. 查询简单. 散块加不会做, 但是注意修改是确定的, 可以先预处理出每个修改操作对各自散块的影响, 就做完了.</p><p><a href="https://www.luogu.com.cn/paste/5r7px35t">code</a></p><h3 id="有理有据题"><a href="#有理有据题" class="headerlink" title="有理有据题"></a>有理有据题</h3><blockquote><p>$n$ 个炸弹每个可以炸一个2side矩形, $m$ 个建筑, 第 $i$ 个建筑是纵坐标为 $i$ 的一条线段, 有 $q$ 次询问每次加一条线段(纵坐标递增), 询问对于一个炸弹能炸的最长的纵坐标上连续段的长度(能炸指完全包含), 不超过 $20$ 次的询问所有炸弹答案的异或和.</p><p>$n, q\le 5\times 10^4$, 5s</p></blockquote><p>考虑每次加入一个建筑之后对所有炸弹贡献, 那么每个位置只维护能炸的最长后缀长度 $c$, 则真实值就是这个的历史最大值, 而能炸一个建筑的限制是一个矩形, 于是KDT矩形赋 $0$, 矩形加 $1$, 查询单点历史最大值. 对全部都要问的只要dfs整棵kdt即可.</p><h3 id="Mix"><a href="#Mix" class="headerlink" title="Mix"></a>Mix</h3><blockquote><p>给定序列, $q$ 次询问给定 $[l, r]$ 问所有子区间的mix之和, 一个区间的mix定义为次小的没有出现的数.</p><p>$n\le 2\times 10^5, q\le 2\times 10^6$</p></blockquote><p>先如果只有mex, 扫描线, 考虑每个值的最后一次出现位置 $p_i$, 则 $p_i$ 的前缀min将序列划分成若干个mex相同的区间, 每次会把一个位置改大, 使得若干元素成为前缀min, 一个元素只能成为前缀min $O(1)$ 次所以均摊是对的.</p><p>加上mix会在mex相同的区间再拆出若干个, 发现是 $p_i$ 的前缀次小值的区间, 把一个数改大会暴露一些数成为最小一些数成为次小, 而每个数这么变的次数还是 $O(1)$ 的.</p><p>子区间就是区间历史和的问题.</p><h3 id="P5284-十二省联考-2019-字符串问题"><a href="#P5284-十二省联考-2019-字符串问题" class="headerlink" title="P5284 [十二省联考 2019] 字符串问题"></a>P5284 [十二省联考 2019] 字符串问题</h3><p>如果把A类串, B类串当成点建图, 最后答案就是判个环或者DAG上最长路, 简单的.</p><p>于是只要想优化建图, 一个暴力是建出所有串的字典树, 用字典树优化, 注意到后缀树是对所有后缀的字典树进行压缩(连续只有一条出边的链压缩成单点), 于是后缀树是天然符合条件的, 做完了吗?</p><p>发现不对, 压缩后可能会有长度不同的 $A, B$ 全都在同一个点上, 它们的关系是乱的, 可以把在同一个点上的字符串串成一条链, 就做完了啊.</p><p>然后要根据区间再在SAM上定位节点, 倍增跳即可, 总复杂度 $n\log n$</p><h2 id="NOI2024省选模拟赛36-1"><a href="#NOI2024省选模拟赛36-1" class="headerlink" title="NOI2024省选模拟赛36"></a>NOI2024省选模拟赛36</h2><h3 id="A-A-Dance-of-Fire-and-Ice"><a href="#A-A-Dance-of-Fire-and-Ice" class="headerlink" title="A. A Dance of Fire and Ice"></a>A. A Dance of Fire and Ice</h3><blockquote><p>你有一个数 $val&#x3D;1$, 有 $n$ 个操作 $(t, a), t\in {0, 1}$, $t&#x3D;0$ 表示赋值为 $a$, $t&#x3D;1$ 表示乘 $v$. 你可以按任意顺序执行操作的任意子集, 求可能得到的 $val$ 种数.</p><p>$2\times 10^5, x_i&lt;p$</p></blockquote><p>乘法, 容易想到原根, 现在变成了循环可行背包问题.</p><p>然后赛时以为背包是不能平凡的做的去考虑模 $x^n-1$ 的多项式了. . .</p><p>但实际上循环可行性背包是好做的, 一个位只会变成 $1$ 一次, 考虑怎么快速搞这个事, 每次二分下一个 $f_i\ne f_{i+x}$ 的位置, 则BIT维护哈希做完了.</p><h3 id="B-最短路"><a href="#B-最短路" class="headerlink" title="B. 最短路"></a>B. 最短路</h3><blockquote><p>对于 $10^5\times 10^5$ 的网格图把每个点替换成一个菱形(如图), $T$ 次求图上 $(0, 0)$ 上第 $c$ 个点到 $(a, b)$ 上第 $d$ 个点最短路和最短路数量, ($a, b$ 为 $a$ 行 $b$ 列)</p><p> <img src="/img/2024-02-19-23-50-00-image.png" alt="graph"></p></blockquote><p>垃圾分类讨论.</p><p>对于两者都是 $0$ 的情况是容易的, 可以先翻转一下默认 $a&lt;b$, 最短路就是斜着走再横着走, 方案数就是横着走的步数可以从上面&#x2F;下面任意再乘上选横着走的步的组合数.</p><p>然后其他的也都直接讨论, 表示成 $O(1)$ 个 $(a, b, 0, 0)$ 的答案的和, $a&#x3D;b$ 和 $a\ne b$ 需要分类.</p><h3 id="C-字符串-1"><a href="#C-字符串-1" class="headerlink" title="C. 字符串"></a>C. 字符串</h3><blockquote><p><img src="/img/2024-02-19-23-55-00-image.png.png" alt="alt text"></p><p>$k\le 5$</p></blockquote><p>考虑给定 $p$ 如何判定, 不妨右移一下使得每个位置 $i$ 和 $[i, i+2k]$ 相关, 只要扫一下记录 $s$ 表示当前这 $k$ 位的数值和 $c$ 表示已经扫过的位置中 $1$ 的数量变化, 若下一个为 $x$, 则 $s’&#x3D;(2s+x)\operatorname{and} (2^{2k+1}-1), c’&#x3D;c+x-p_{s’}$. 而满足条件要求最后 $c&#x3D;0$, 也就是从 $(0, 0)$ 出发, 当 $s&#x3D;0$ 时 $c&#x3D;0$</p><p>于是建图, $s\stackrel{c’-c}{\longrightarrow} s’$, 则满足答案的条件为所有包含 $0$ 的环权值都是 $0$, 因为图强连通相当于要求所有环都是 $0$, 应该可以从这里看到Johnson标号和差分约束的味道, 即有一组 $d_i$ 使得 $u\to v$ 的边权为 $d_v-d_u$, 于是真的跑差分约束可以判定一个.</p><p>现在要求答案要判断 $p$ 有若干位确定若干位不确定的情况的答案, 则相当于有若干边可以任选 ${0, 1}$, 有若干边可以任选 ${-1, 0}$ 且选择独立. 于是差分约束.</p><p>然后现在的复杂度是 $2^{3(2k+1)}$(外面逐位确定, 里面 $nm$ 跑spfa), 但实际上注意到可以在 $O(k)$ 步走到图上任意一个点, 则 $mk$ 个点入队后每个点最短路都不超过 $k$, 再这之后每次更新一个点都会让 $dis$ 至少减少 $1$, 于是更新 $O(mk)$ 个点一定能找到一个 $d_u&lt;0$ 判断无解, 复杂度变成 $2^{2(2k+1)}$</p><h2 id="NOI2024省选模拟赛38"><a href="#NOI2024省选模拟赛38" class="headerlink" title="NOI2024省选模拟赛38"></a>NOI2024省选模拟赛38</h2><h3 id="A-nnntxdy"><a href="#A-nnntxdy" class="headerlink" title="A. nnntxdy"></a>A. nnntxdy</h3><blockquote><p>$n$ 个变量, 初始第 $i$ 个为 $a_i$, $m$ 次随机一个大于 $0$ 的变量减 $1$, 问最后期望有几个为 $0$. 模 $998244353$</p><p>$n\le 15, m\le 200$</p></blockquote><p>想到 通用评测号 和 猎人杀. 则相当于每次随机一个变量, 跳过小于等于 $0$ 的. 但是这个题特殊的是要计算有效步数, 于是 $x, z$ 分别记录有效步数和总步数. 过程需要有一个终点(停时)不然概率不对, 于是拆期望, 对每个 $k$ 计算成为 $0$ 的概率之和, 则答案为</p><p>$$<br>\begin{gathered}<br>  ans&#x3D;\sum_k [x^m] \dfrac{x}{1-x} L_z \left(<br>    \dfrac{x^{a_i-1}z^{a_i-1}}{n^{a_i-1}(a_i-1)! }<br>    \prod_{i\ne k} \left(<br>        \sum_{i&lt;a_k} \dfrac{x^iz^i}{n^ii! }+<br>        \sum_{i\ge a_k} \dfrac{x^{a_i}z^i}{n^ii! }<br>    \right)<br>  \right)\Bigg \vert <em>{z&#x3D;1}\<br>  &#x3D;\sum_k [x^m] \dfrac{x}{1-x} L_z \left(<br>    \dfrac{x^{a_i-1}z^{a_i-1}}{n^{a_i-1}(a_i-1)! }<br>    \prod</em>{i\ne k} \left(<br>        \sum_{i&lt;a_k} \dfrac{z^i(x^i-x^{a_i})}{n^ii! }+<br>        x^{a_i}e^{\frac{z}{n}}<br>    \right)<br>  \right)\Bigg \vert _{z&#x3D;1}\<br>\end{gathered}<br>$$</p><p>其中 $L_z$ 表示关于 $z$ 的拉普拉斯算子.</p><p>其中 $e^{\frac{z}{n}}$ 是收敛到关于 $e$ 的无限求和, 但 $L_z(z^ae^{\frac{n}{b}})$ 是简单的:</p><p>$$<br>L_z(z^a e^{\frac{n}{b}})\<br>&#x3D;z^a\sum_{i&#x3D;0} \dfrac{(i+a)! z^ib^i}{i! }\<br>&#x3D;z^aa! \sum_{i&#x3D;0} \binom{i+a}{i}z^ib^i\<br>&#x3D;\dfrac{z^aa! }{(1-\dfrac{z}{n})^{a+1}}<br>$$</p><p>于是复杂度是 $n^2m^3$.</p><p>赛时没拆贡献, 引入了新的元 $y$ 记录选到 $x^n$ 后的部分复杂度就多 $n$ 了.</p><p>可以作为今年叶开论文的补充例题(</p><p>来个dp做法, 感觉很不会贡献延迟计算的dp, 于是把它转成了一个不延迟的:</p><p>不是裸EGF题的原因是概率和当前为正的个数有关, 于是考虑对于一个 $m$ 步操作的 $\vert S\vert$ 的序列 $s_m$, 最后的概率. 设第 $i$ 步操作了变量 $b_i$, 发现 $s_m$ 确定的情况下填出的每种 $b$ 的概率是相等的, 如果再确定每个变量变成 $0$ 的时间, $t_i$, 则第 $t_i$ 步之前必须有 $a_i$ 个对 $j, b_j&#x3D;i$, 于是总方案数是 $\prod_i s_i \prod \binom{t_i}{a_i}G(n-s_m, \sum_{i\in S} a_i)$, 后面的 $G$ 是对当前还活着的元素可以在里面任意分配. 于是dp确定 $s$ 和 $t$ 的过程中算答案, 最后乘一个 $G$, 设 $f_{i, S}$ 表示前减了 $i$ 次, $S$ 种的变量已经变成 $0$, 复杂度 $n^2m$</p><h3 id="B-集合"><a href="#B-集合" class="headerlink" title="B. 集合"></a>B. 集合</h3><blockquote><p>给定 $a_n, b_n, c_n$, 求 $a$ 权值最大的线性基, 权值定义为 $(\sum b_i)(\sum c_i)$.</p><p>$n\le 1000$</p></blockquote><p>看到乘积想凸包, 最优解一定在凸包上可以用权值为 $b_i+kc_i$ 的线切到.</p><p>对于只有一个权值的, 注意到线性基和Kru本质都是拟阵问题, 会得到加入顺序下时间最早的一组解, 所以排序就行了.</p><p>于是可以用类似ZJOI那个醉熏熏的幻想乡的分治方法求得凸包, 即现在要求 $[l, r]$ 的凸包, 把 $l, r$ 连起来得到一条线用这条线去切, 切到的点一定在凸包上, 然后左右递归下去. 复杂度是 $n^2\log n$</p><p>或者考虑扫描 $k$, 则过程中 $b_i+kc_i$ 的相对大小改变 $O(n^2)$ 次, 考虑交换相邻两项时快速得到答案, 若两项本来都在或都不在线性基中答案不变, 否则说明这两项和前面的元素可以线性相关, 那么用一个替换另一个直接删除再添加即可.</p><p>因为线性基和mst都是拟阵独立集问题, 所以这个题和最小乘积生成树惊人的相似.</p><h3 id="C-PolarSea-与遗忘的森林"><a href="#C-PolarSea-与遗忘的森林" class="headerlink" title="C. PolarSea 与遗忘的森林"></a>C. PolarSea 与遗忘的森林</h3><blockquote><p>有一个未知的基环树森林, 给定每个点的 $(h_i, l_i)$ 表示点 $i$ 到环的距离和环长, 若 $h_i$ 或 $l_i$ 等于 $-1$ 表示不知道. 构造方案或判断无解.</p><p>$n\le 500$</p></blockquote><p>考虑如果已知所有 $h_i, l_i$, 则所有 $(0, x)$ 是在环上的, 要求每个 $(0, x)$ 的个数是 $x$ 的倍数. 同时要求所有 $(y, x), y\ne 0$ 存在 $(y-1, x)$. 如果满足构造很显然.</p><p>现在有一些 $-1$, 分成 $(-1, -1), (-1, x), (y, -1), (y, x)$ 四种, $(-1, -1)$ 处理是简单的, 要填数满足上面两个要求, 对于倍数要求只要统计对每个 $x$, $(0, x)$ 的个数 $c_x$, 只要要求数量恰好为($\lceil\dfrac{c_x}{x}\rceil$). 对于第二个要求, 只要考虑 $y$ 最大的 $(y, -1)$ 填到谁, 多余的 $(z, -1)$ 都可以挂和它一起.</p><p>于是限制都可以写成需要 $c$ 个 $(x, y)$, 于是网络流跑匹配, 网络流. 做完了.</p><p>注意这里连边的时候 $(0, x)$ 的限制是恰好, 不能有多的没匹配, 所以应该强制匹配 $(0, x)$. 数组要开够.</p><h2 id="数学相关-Alex-Wei"><a href="#数学相关-Alex-Wei" class="headerlink" title="数学相关-Alex_Wei"></a>数学相关-Alex_Wei</h2><h3 id="在线-O-1-逆元"><a href="#在线-O-1-逆元" class="headerlink" title="在线 $O(1)$ 逆元"></a>在线 $O(1)$ 逆元</h3><p>TODO</p><h3 id="P7325-斐波那契"><a href="#P7325-斐波那契" class="headerlink" title="P7325 斐波那契"></a>P7325 斐波那契</h3><p>两个重要结论: $f_i$ 在模 $m$ 意义下纯循环, 循环节长度 $O(m)$. $f_i, f_{i+1}$ 互质.</p><p>考虑题目中的数列第 $n$ 项可以表示为 $af_i+bf_{i-1}&#x3D;0$, 于是如果 $m$ 是质数, 只要变成 $-\dfrac{b}{a}&#x3D;\dfrac{f_i}{f_{i-1}}$ 然后 $O(m)$ 预处理 $\dfrac{f_i}{f_{i-1}}$ 对应的 $i$.</p><p>那么现在 $m$ 不为质数, 显然可以先除掉 $d&#x3D;\gcd(m, a, b)$ 变成, $a’f_i+b’f_{i-1}&#x3D;0\pmod {m’}$, 考虑现在仍然可能有 $\gcd(a’, m’)&#x3D;e\ne 1$, $a’f_i+b’f_{i-1}&#x3D;0\pmod {m’}$, 则 $f_{i-1}$ 也要是 $e$ 的倍数, 此时可以得到 $f_i&#x3D;-b’\dfrac{f_{i-1}}{e}(\dfrac{a}{e})^{-1}$, 此时若 $f_{i-1}&#x2F;e$ 和 $m$ 有公因数, 因为 $f_i\bot f_{i-1}$ 则方程不成立, 于是一定可以有 $f_i(\dfrac{f_{i-1}}{e})^{-1}&#x3D;\dfrac{-b}{e}(\dfrac{a}{e})^{-1}$. 同时 $e$ 若要满足 $\dfrac{f_{i-1}}{e}\bot m, e\vert f_{i-1}$, 也就是 $e&#x3D;\gcd(f_{i-1}, m)$.</p><p>于是只要枚举 $d$ 预处理, 复杂度是 $\sum_{d\vert m} d&#x3D;O(m\log \log m)$.</p><h3 id="P3543-POI2012-WYR-Leveling-Ground"><a href="#P3543-POI2012-WYR-Leveling-Ground" class="headerlink" title="P3543 [POI2012] WYR-Leveling Ground"></a>P3543 [POI2012] WYR-Leveling Ground</h3><blockquote><p>给定 $n$ 个数和 $a, b$. 每次可以选择一段区间 $+a, -a, +b$ 或 $-b$, 问最少操作几次能把它们都变成 $0$. 如果无解请输出 $-1$.</p><p>$n\le 10^5, a, b\le 10^9$</p></blockquote><p>考虑差分数组 $c_n$, 对于第 $i$ 个位置求出 $c_i&#x3D;ax+by$ 的一组特解 $x_0, y_0$, 则 $x&#x3D;x_0+t\dfrac{b}{\gcd(a, b)}, y&#x3D;y_0-t\dfrac{a}{\gcd(a, b)}$, 那么最后要满足在 $\sum x&#x3D;\sum y&#x3D;0$ 的情况最小化 $\sum \vert x\vert+\sum \vert y\vert$.</p><p>若 $\sum x&#x3D;0$, $\sum y&#x3D;\sum y_0-(x-x_0)\dfrac{a}{b}&#x3D;0+\dfrac{1}{b} \sum by_0+ax_0&#x3D;\dfrac{1}{b}\sum c_i&#x3D;0$, 于是只要满足 $\sum x&#x3D;0$, 考虑贪心调整, 每个位置贡献是绝对值里面一个一次函数, 全是下凸, 所以直接贪心就是对的. 此外可以证明最多调 $n$ 次, 因为没有限制的时候 $\vert x\vert+\vert y\vert$ 最小一定是 $x$ 为最大负整数解或者最小正整数解, 于是 $x&lt;b$, 于是最多调 $O(n)$ 次.</p><p>这个题不从差分视角看也很好(qyc题解), 考虑原数组, 假设已知第 $i$ 个位置 $ax_i+by_i$, 那么只看 $a$ 的操作就是每次可以区间加减 $1$, 全变成 $0$ 的经典问题, 答案是差分数组绝对值之和的一半. 于是问题等价于有 $n$ 条斜率相同的直线, 在上面选 $n$ 个点, 最小化从 $(0, 0)$ 出发按顺序把每个点遍历一遍的曼哈顿距离最小值. 那么考虑先忽略最后一个点回到 $(0, 0)$ 的代价算一个答案, 就直接贪心即可, 然后再进行调整, 每次可以把一个后缀整体沿着线移动, 只影响当前位置和最后一个位置, 这部分贪心和上面是一样的, 因为每个点和上一个点尽可能接近, 也是最多 $n$ 次调整.</p><p>后一个做法上来强制满足了所有限制.</p><h3 id="CF516E-Drazil-and-His-Happy-Friends"><a href="#CF516E-Drazil-and-His-Happy-Friends" class="headerlink" title="CF516E Drazil and His Happy Friends"></a>CF516E Drazil and His Happy Friends</h3><p>考虑首先可以分成独立的 $d&#x3D;\gcd(n, m)$ 类, 最后合并是简单的. 对于每一类变成长 $n’, m’, n’\bot m’$ 的两个环.</p><p>单独考虑B环每个人快乐的时间, 发现一个性质: 若A环上 $i$ 快乐了, 则 $i+m’$ 一定在 $m’$ 时间后快乐, 且这个是充要的, 于是一个暴力是建图跑最短路, 但点数是 $10^9$ 的.</p><p>发现边把 $A$ 环上的点按新的顺序串成一个环, 于是只要考虑 $O(b+g)$ 个初始快乐的点第一次被B环快乐的点, 中间点的最短路是容易快速处理的, 就做完了.</p><h3 id="P4621-COCI2012-2013-6-BAKTERIJE"><a href="#P4621-COCI2012-2013-6-BAKTERIJE" class="headerlink" title="P4621 [COCI2012-2013#6] BAKTERIJE"></a>P4621 [COCI2012-2013#6] BAKTERIJE</h3><p>对于单独一个细菌, 状态 $(n, m, d)$ 表示, $d\le 4$ 表示方向, 显然最多 $4nm$ 个循环, 于是这个点到每个陷阱状态(不同方向一共四个)的时间要么是 $t_0$(入环前), 要么是 $t_0+tx, x\in N*$(入环后), 枚举每个点最终状态用exgcd合并即可.</p><h3 id="P3747-六省联考-2017-相逢是问候"><a href="#P3747-六省联考-2017-相逢是问候" class="headerlink" title="P3747 [六省联考 2017] 相逢是问候"></a>P3747 [六省联考 2017] 相逢是问候</h3><p>如果做过炸脖龙I应该很显然, 一个指数塔只要考虑前 $\log V$ 层, 于是只要做到一个位置只更新 $\log V$ 次就赢了, 维护线段树节点内被更新次数的最小值即可, 总复杂度 $n\log n\log V$.</p><h3 id="P6730-WC2020-猜数游戏"><a href="#P6730-WC2020-猜数游戏" class="headerlink" title="P6730 [WC2020] 猜数游戏"></a>P6730 [WC2020] 猜数游戏</h3><p>拆贡献! 一个数被选当且仅当所有能生成它的数都没被选. 看到这种题肯定考虑原根. 但没有保证 $a_i\bot p$, 即有些数可能没原根. 分开考虑有原根和没原根的数, 容易发现两者能生成的集合是不交的.</p><p>对于没原根的数 $u$(即 $p^k$), 只有 $\log p$ 个, 直接暴力check每个数就是 $n\log p$. 否则 $v$ 能生成 $u$ 当且仅当 $\mathrm{ord}(v) \vert \mathrm{ord}(u)$, 暴力求原根即可(预处理 $\varphi(p)$ 的因数)</p><h3 id="loj6056-最大团"><a href="#loj6056-最大团" class="headerlink" title="loj6056 最大团"></a>loj6056 最大团</h3><p>枚举团大小 $d$ 分配标号可得答案为</p><p>$$<br>\sum_{d\vert n} \dfrac{n! }{(d! )^{n&#x2F;d}(n&#x2F;d)! }<br>$$</p><p>考虑exlucas的求阶乘, $n! \mod p&#x3D;p^k\dfrac{n}{p}! (n! )_p$, 而后面的 $(n! )_p$ 这次不能预处理,</p><h3 id="P5233-JSOI2012-爱之项链"><a href="#P5233-JSOI2012-爱之项链" class="headerlink" title="P5233 [JSOI2012] 爱之项链"></a>P5233 [JSOI2012] 爱之项链</h3><p>先数戒指, 是经典ploya, 现在要数一个序列, 每个位置可以是 $1\ldots k$ 任意相邻两个位置不同的方案数, 并且认为 $1$ 和 $n$ 相邻. 设 $f_n$ 为答案, 则 $f_n&#x3D;k(k-1)^{n-1}-f_{n-1}$(先忽略 $1$ 和 $n$ 不能相邻, 相邻则把它俩缩成, 一个去数方案数为 $f_{n-1}$), 不断展开 $f_1&#x3D;1$</p><p>$$<br>\begin{gathered}<br>  f_n&#x3D;1+\sum_{i&#x3D;2}^n k(k-1)^{i-1}(-1)^{n-i}\<br>  &#x3D;1+(-1)^{n+1}k\sum_{i&#x3D;2}^n (1-k)^i<br>\end{gathered}<br>$$</p><p>等比数列求和, 做完了.</p><h3 id="CmdOI2019-简单的数论题"><a href="#CmdOI2019-简单的数论题" class="headerlink" title="[CmdOI2019] 简单的数论题"></a>[CmdOI2019] 简单的数论题</h3><p>$$<br>\begin{gathered}<br>\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m \varphi(\dfrac{lcm(i, j)}{\gcd(i, j)})\<br>&#x3D;\sum_{i&#x3D;1}^n \sum_{j&#x3D;1}^m \varphi(\dfrac{i}{\gcd(i, j)})\varphi(\dfrac{j}{\gcd(i, j)})\<br>&#x3D;\sum_d\sum_{i&#x3D;1}^{n&#x2F;d}\varphi(i)\sum_{j&#x3D;1}^{m&#x2F;d} \varphi(j) \sum_{k\vert i, k\vert j} \mu(k)\<br>&#x3D;\sum_d \sum_k \mu(k) \sum_{i&#x3D;1}^{n&#x2F;kd}\sum_{j&#x3D;1}^{m&#x2F;kd} \varphi(ik)\varphi(jk)\<br>&#x3D;\sum_T \sum_{k\vert T}\mu(k)\sum_{i&#x3D;1}^{n&#x2F;T}\sum_{j&#x3D;1}^{m&#x2F;T} \varphi(ik)\varphi(jk)<br>\end{gathered}<br>$$</p><p>预处理 $f_{a, k}&#x3D;\sum_{i&#x3D;1}^n \varphi(ik)$(固定 $k$, 只有 $n&#x2F;k$ 个可能得 $a$, 一共只有 $n\ln n$ 个可以预处理)</p><p>对 $T$ 根号分治, 当 $T$ 小于根号时暴力枚举 $k$ 复杂度是 $\sqrt n\log n$, 当 $T$ 大于根号时 $n&#x2F;T$ 不会很大, 考虑预处理 $g(a, b, T)&#x3D;\sum_{k\vert T} \mu(k)f(a, k)f(b, k)$, 注意 $a$ 有根号种, $(b, T)$ 有 $n$ 种, 一共 $n\sqrt n$ 种, 时间复杂度 $n\sqrt n\log n$. 做完了!</p><h3 id="P5518-MtOI2019-幽灵乐团-x2F-莫比乌斯反演基础练习题"><a href="#P5518-MtOI2019-幽灵乐团-x2F-莫比乌斯反演基础练习题" class="headerlink" title="P5518 [MtOI2019] 幽灵乐团 &#x2F; 莫比乌斯反演基础练习题"></a>P5518 [MtOI2019] 幽灵乐团 &#x2F; 莫比乌斯反演基础练习题</h3><p>感觉三合一很没素质. 只留第三问不好吗.</p><p>而且解题过程中还有个陷阱, 很容易推到 $Tn\log \log n$ 然后不会, 需要大力卡常才能过, 但实际上一开始路就走错了. 也就是第三问再算式子 $\prod \prod \prod \gcd(i, j)^{\gcd(i, j, k)}$ 的时候如果先枚举 $g&#x3D;\gcd(i, j)$ 再算 $\sum_k \gcd(g, k)$ 的复杂度. 而应该直接枚举 $\gcd(i, j, k)$.</p><p>式子懒得抄了.</p><h3 id="CF1796F-Strange-Triples"><a href="#CF1796F-Strange-Triples" class="headerlink" title="CF1796F Strange Triples"></a>CF1796F Strange Triples</h3><p>设 $l(x)&#x3D;\log_{10}(x)+1$, 枚举 $x&#x3D;l(n), y&#x3D;l(b)$ 可以拆开, $n$ 很大不能枚举, 进行分参, 要求 $n&#x3D;\dfrac{ab(10^x-1)}{a10^y-b}$, 要求满足 $n$ 的范围限制和整除.</p><p>考虑要去除 $a$ 对整除性的影响, 设分母上 $\gcd(a10^y-b, a)&#x3D;k$, 左边辗转相减一下得到 $k&#x3D;\gcd(a, b)$, 那么设 $kd&#x3D;a10^y-b$, $d$ 要是 $b(10^x-1)$ 的因数, 如果枚举 $x, y, b, d$, 总枚举量是 $\sum_b \sum_y d(b(10^x-1))$, $d$ 是因数个数函数, 算出来是 $185B\ln B$ 刚好.</p><p>现在确定了 $d$, 由 $kd&#x3D;a10^y-b$ 得 $\dfrac{b}{k}&#x3D;\dfrac{a10^y}{k}-d$, 注意 $\dfrac{b}{k}&lt;10^{y}$, 于是得到最多只有一个合法的 $k$, 直接解方程求出这个 $k$, 又可以得到 $a$, 于是就能check了.</p><h3 id="SP422-TRANSP2-Transposing-is-Even-More-Fun"><a href="#SP422-TRANSP2-Transposing-is-Even-More-Fun" class="headerlink" title="SP422 TRANSP2 - Transposing is Even More Fun"></a>SP422 TRANSP2 - Transposing is Even More Fun</h3><p>这个题好厉害.</p><p>首先分析转置, $(i, j)\to (j, i)$, $2^bi+j\to 2^bj+i$, 设一开始为 $x$, 发现是把 $x$ 从低到高的第 $b$ 位分开, 前后交换, 相当于把下标在二进制数下循环左移 $a$ 位.</p><p>这下找到方向了, 也就是若 $i$ 的目标位置是 $p_i$, 现在已经知道 $p_i$ 构成了若干个环, 答案是所有环的大小减 $1$, 那么只要求环数. 转化成, 长 $a+b$ 的序列每个位置填 $0&#x2F;1$, 求转 $a$ 下的操作下的本质不同环数.</p><p>考虑这样一个环可以分成长 $l&#x3D;\dfrac{(a+b)}{\gcd(a, b)}$ 个小环的 $g&#x3D;\gcd(a, b)$ 个环, 于是转 $i$ 格的不动点方案是 $2^{\gcd(l, i)\gcd(a, b)}$. 上一个burnside再上一个莫反就做完了.</p><h2 id="NOI2024省选模拟赛44"><a href="#NOI2024省选模拟赛44" class="headerlink" title="NOI2024省选模拟赛44"></a>NOI2024省选模拟赛44</h2><h3 id="A-小-Z-与函数"><a href="#A-小-Z-与函数" class="headerlink" title="A. 小 Z 与函数"></a>A. 小 Z 与函数</h3><blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> vs=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[j])</span><br><span class="line"><span class="built_in">swap</span>(a[i],a[j]),res++,vs=<span class="number">1</span>;</span><br><span class="line">res+=vs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>显然最后变成递减序列. 注意到对互不相同<code>res++</code>的总和是逆序对数, 因为交换时一定交换两个前缀max, 恰好让逆序对数减 $1$. 对有相同的情况它是每个数前面比它小的数的颜色数之和(每次会换到同颜色的第一个).</p><p>对于<code>vs</code>, 进行到第 $i$ 位, 前面一定是 $1\ldots i-1$ 大, 第 $i$ 位是原序列前缀min(发现前缀min一定没被交换出前 $i$ 个), 只要判断序列第 $i$ 大和前缀min的大小.</p><p>对于所有前缀, 问题变成有多少个位置 $i$ 满足 $m_i&gt;k_i$, $k_i$ 为第 $i$ 大. 不断在最后插入一个数, 每次会对 $k$ 移位, 注意 $m$ 单减, $k$ 单增, 做完了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>THUPC2024 邮寄</title>
      <link href="/2023/12/07/thupc/"/>
      <url>/2023/12/07/thupc/</url>
      
        <content type="html"><![CDATA[<h1 id="THUPC2024-邮寄"><a href="#THUPC2024-邮寄" class="headerlink" title="THUPC2024 邮寄"></a>THUPC2024 邮寄</h1><p>和Mikefeng和Harry23182组队, 来看看往年题.</p><h2 id="THUPC2023-Pre"><a href="#THUPC2023-Pre" class="headerlink" title="THUPC2023 Pre"></a>THUPC2023 Pre</h2><h3 id="P9140-THUPC-2023-初赛-背包"><a href="#P9140-THUPC-2023-初赛-背包" class="headerlink" title="P9140 [THUPC 2023 初赛] 背包"></a>P9140 [THUPC 2023 初赛] 背包</h3><p>因为 $V$ 远大于 $v_i$ 和 $n$, 所以考虑贪心, 选出其中性价比最高的元素 $i$, 则就是要在模 $m&#x3D;v_i$ 的意义下求恰好为 $V$ 的最大价值, 这个几乎是同余最短路, 因为此时总代价是 $\dfrac{V-v}{m}c_i + res$, 其中 $res$ 为选出的元素的 $c$ 之和, 所以实际上是最大化 $res-\dfrac{v}{m}c_i$, 于是同余最短路时先 $i\to j+v_i$ 连 $c_i-\dfrac{v_i+j}{m}c_i$ 的代价即可.</p><p>然后同余最短路实际上不用写最短路, 它是个模 $m$ 的完全背包问题, 加入物品时这个物品的转移形成 $gcd(m, v_i)$ 个环, 只要对每个环转移两圈即可保证转移完全. 复杂度 $nm$</p><h3 id="P9143-THUPC-2023-初赛-众数"><a href="#P9143-THUPC-2023-初赛-众数" class="headerlink" title="P9143 [THUPC 2023 初赛] 众数"></a>P9143 [THUPC 2023 初赛] 众数</h3><p>从大到小排即可.</p><h3 id="P9134-THUPC-2023-初赛-拧螺丝"><a href="#P9134-THUPC-2023-初赛-拧螺丝" class="headerlink" title="P9134 [THUPC 2023 初赛] 拧螺丝"></a>P9134 [THUPC 2023 初赛] 拧螺丝</h3><p>老板肯定每次拿走最大的, 小E肯定尽量平均的加, 于是反向考虑, 最后拿走时是 $n$ 个, 那么上一次一定是 $n-k, n-k$, 往后推下去, 则老板每次会让最大值数量增加 $1$, 然后小E让最大的若干个减少 $1$, 暴力就是朴素的模拟这个直到最大值变成 $0$. 于是同一时刻只有最大值和最大值减 $1$ 两个数.</p><p>那么考虑把最大值次大值不变的一段压到一起处理, 又因为高精所以复杂度 $n^2$, 然后再特判掉 $n&#x3D;2$ 时答案是 $2^{n-2}$.</p><h3 id="P9133-THUPC-2023-初赛-大富翁"><a href="#P9133-THUPC-2023-初赛-大富翁" class="headerlink" title="P9133 [THUPC 2023 初赛] 大富翁"></a>P9133 [THUPC 2023 初赛] 大富翁</h3><p>支配的代价实际上是有祖先关系的点对代价 $1$, 那么就是最后局面 $\text{敌方点祖先中我方个数}-\text{我方点祖先中敌方个数}$, 于是对于每个我方点 $u$, 答案是 $\text{深度}-\text{我方祖先个数}+\text{敌方子孙个数}$, 转化贡献, 变成每个点给所有子树中的我方点贡献 $-1$, 就成了 $dep_u-siz_u$, 于是按照 $dep_u-siz_u+w_u$ 排序贪心选即可.</p><h3 id="P9142-THUPC-2023-初赛-欺诈游戏"><a href="#P9142-THUPC-2023-初赛-欺诈游戏" class="headerlink" title="P9142 [THUPC 2023 初赛] 欺诈游戏"></a>P9142 [THUPC 2023 初赛] 欺诈游戏</h3><p>纳什博弈的结论好像就是最优策略下所有情况期望收益相等.</p><p>但是不排除可能双方各自放弃一些决策的情况, 不过发现看起来放弃任意一个位置都是不优的.</p><p>如果猜到结论, 选取任意情况期望都相等, 就可以直接列式子解出策略了, 当然不能高斯消元, 注意到式子形如 $x\sum_{i&lt;x} p_i+\sum+{i&gt;x} p_i dfrac{i}{2}$, 此时 $x+1$ 减 $x$ 的式子是 $\sum_{i&lt;x} p_i+p_x+p_{x+1}\dfrac{x+1}{2}&#x3D;0$, 此时可以递推的把所有 $p$ 用 $p_1$ 表示, 最后用 $\sum_i p_i&#x3D;1$ 就能解出来.</p><h3 id="P9137-THUPC-2023-初赛-速战速决"><a href="#P9137-THUPC-2023-初赛-速战速决" class="headerlink" title="P9137 [THUPC 2023 初赛] 速战速决"></a>P9137 [THUPC 2023 初赛] 速战速决</h3><p>分类讨论, 如果你手里有两张相同的则你可以保证对面一张也收不回去(保持牌底的另一张在你手中), 否则对面至少收回去一次, 并且可以让它最多收回去一次, 发现只要第一次放 $n$, 后面跟着小 $J$ 放即可.</p><h3 id="P9138-THUPC-2023-初赛-公平合作"><a href="#P9138-THUPC-2023-初赛-公平合作" class="headerlink" title="P9138 [THUPC 2023 初赛] 公平合作"></a>P9138 [THUPC 2023 初赛] 公平合作</h3><p>后手策略一定是一直装直到大于先手装的的或者爆了. 那么可以设 $f_i$ 表示要求至少装到 $i$ 的情况下不爆的概率(先手选 $i$ 时后手胜的概率), 那么先求 $g_i$ 表示装到 $i$ 的概率 $g_i&#x3D;\sum_k g_{i-a_k}\dfrac{1}{n}$, $f_i&#x3D;1-(\sum_{k&lt;i} g_k\sum_{k+a_l&gt;n} \dfrac{1}{n})$, 最后先手再列一个递推式 $h_i&#x3D;\min f_i, (\sum_k \dfrac{1}{n}h_{i+a_k})$. 于是获得了一个 $nL$ 的做法.</p><p>然后不会了, 然后发现这三个都是常系数线性递推, 可以做到 $n\log n\log L$</p><h3 id="P9144-THUPC-2023-初赛-最后的活动"><a href="#P9144-THUPC-2023-初赛-最后的活动" class="headerlink" title="P9144 [THUPC 2023 初赛] 最后的活动"></a>P9144 [THUPC 2023 初赛] 最后的活动</h3><p>注意到只有 $6$ 层, 于是可以直接设 $f_i$ 表示打到当前还剩 $i$ 到 $m$ 的情况下的概率, 枚举每一层的策略然后每次转移一整局, 如果这一局收益为 $x$ 那么转移到 $f_{i-x}$, 但是转移可能成环, 即 $x&#x3D;0$, 于是考虑直接二分, 因为 $f_i$ 一定会乘上一个系数所以答案一定比你赋的初值更接近真实值, 就做完了.</p><h3 id="P9135-THUPC-2023-初赛-快速-LCM-变换"><a href="#P9135-THUPC-2023-初赛-快速-LCM-变换" class="headerlink" title="P9135 [THUPC 2023 初赛] 快速 LCM 变换"></a>P9135 [THUPC 2023 初赛] 快速 LCM 变换</h3><p>只操作一次, 就是删掉两个数再插入一个数. 但是lcm的和对每个质因数没有好的独立性, 所以只能一起做.</p><p>现在只考虑一个因数 $d$, 删除了数 $p, q$, $d$ 的最大值会变成 $\max (smx, p+q)$, 那么如果 $p+q$ 有贡献一定意味着 $p, q$ 都是 $mx$, 此时一定不会让 $d$ 的最终指数减少, 也就是说它们的贡献可以独立着看, 要么是 $p$ 或 $q$ 带来的减少要么是 $p+q$ 带来的增加, 或者说可以写出函数使得 $f(x)$ 为删掉 $x$ 的贡献, $g(x)$ 为增加 $x$ 的贡献, 则答案为 $\mathrm{lcm}({a_i})f(x)f(y)g(x+y)$</p><p>于是这个就好做了啊, 卷卷即可.</p><h3 id="P9139-THUPC-2023-初赛-喵了个喵-II"><a href="#P9139-THUPC-2023-初赛-喵了个喵-II" class="headerlink" title="P9139 [THUPC 2023 初赛] 喵了个喵 II"></a>P9139 [THUPC 2023 初赛] 喵了个喵 II</h3><p>先考虑如果 $2$ 次怎么做, 则若有两种数的出现位置发生包含 $a, b, b, a$, 则一定无解, 因为一定是一个 $a, b$ 一个 $b, a$. 否则一定有解(一个子序列都放第一次出现的).</p><p>然后 $4$ 次, 考虑能不能把这 $4$ 个位置 $a, b, c, d$ 先分成两个颜色, 则只有 $(a, c), (b, d)$ 和 $(a, b), (c, d)$ 是可能的划分, 那么可以写出2sat关系.</p><p>但是直接2sat关系爆炸了, 注意到实际上每个2sat关系限制是矩形: $(a, c), (b, d)$ 连向有区间被 $(a, c)$ 或 $(b, d)$ 包含的区间选择另一种方式, 而包含是矩形, 于是主席树建图优化2sat即可.</p><h3 id="P9136-THUPC-2023-初赛-种苹果"><a href="#P9136-THUPC-2023-初赛-种苹果" class="headerlink" title="P9136 [THUPC 2023 初赛] 种苹果"></a>P9136 [THUPC 2023 初赛] 种苹果</h3><p>就是加叶子, 边上加点, 区间加, 区间rank, 因为这个东西序列上都不能低于根号所以树上你肯定也得根号复杂度.</p><p>于是树分块, 此时区间加区间rank就维护有序数组和加法标记上去二分, 加叶子和边上加点, 发现可以直接上去调整, 树的形态只维护父亲就行, 然后保证复杂度需要根号重构, 最后平衡复杂度是 $n\sqrt{n\log n}$</p><h2 id="THUPC2022-Pre"><a href="#THUPC2022-Pre" class="headerlink" title="THUPC2022 Pre"></a>THUPC2022 Pre</h2><h3 id="P8213-THUPC2022-初赛-挑战"><a href="#P8213-THUPC2022-初赛-挑战" class="headerlink" title="P8213 [THUPC2022 初赛] 挑战"></a>P8213 [THUPC2022 初赛] 挑战</h3><p>直接倒着dp就行吧</p><h3 id="P8207-THUPC2022-初赛-最小公倍树"><a href="#P8207-THUPC2022-初赛-最小公倍树" class="headerlink" title="P8207 [THUPC2022 初赛] 最小公倍树"></a>P8207 [THUPC2022 初赛] 最小公倍树</h3><p>考虑要么是Kru要么是Brovka, 同时这个lcm大概让你考虑gcd.</p><p>考虑枚举gcd值 $d$, 对于 $dk, d(k+1)\ldots d(k+p)$, 暴力会连 $p^2$ 条边, 但后面的都只要和 $dk$ 连就好了, 于是总连边数是调和级数过了.</p><h3 id="P8208-THUPC2022-初赛-骰子旅行"><a href="#P8208-THUPC2022-初赛-骰子旅行" class="headerlink" title="P8208 [THUPC2022 初赛] 骰子旅行"></a>P8208 [THUPC2022 初赛] 骰子旅行</h3><p>根据期望线性考虑能不能单独求每个点的期望经过次数, 那么暴力dp是计算 $f_{u, i, t}$ 表示现在在 $u$, 走了 $i$ 次, $t$ 的期望经过次数, 复杂度是 $(\sum m)nT$, 同理可以出 $g_{u, i, t}$ 表示现在在 $u$, 走了 $i$ 次曾经过 $t$ 的概率.</p><h3 id="P8211-THUPC2022-初赛-搬砖"><a href="#P8211-THUPC2022-初赛-搬砖" class="headerlink" title="P8211 [THUPC2022 初赛] 搬砖"></a>P8211 [THUPC2022 初赛] 搬砖</h3><p>注意到如果所有 $b\ge 1$ 则最多只会进行 $\sqrt n$ 次, 按照 $d$ 是否 $&gt;\sqrt n$ 讨论即可证明.</p><p>于是肯定考虑一次处理一段 $d$ 不变的, 而这个只要找到下一个不为 $0$ 的 $b$, 直接二分就是单log, 并查集可以整成线性.</p><p>但是不对, 因为可能在这过程中因为没有搬完一摞而结束, 所以考虑对每个 $d&lt;\sqrt n$, 按 $d$ 分块, 根据一开始的偏移维护 $d$ 个长 $\dfrac{n}{d}$ 的数组, 每次插入一个数遍历每个 $d$, 会修改两个偏移区间的同一个位置的值, 于是就是 $\sqrt n$ 次单点修改和查询, 总复杂度 $n\sqrt n\alpha(n)$</p><p>关键大概是 $\sqrt n$ 次以及对小于 $\sqrt n$ 的每个长度和偏移分块是 $n\sqrt n$ 的</p><h3 id="P8212-THUPC2022-初赛-喵喵花園"><a href="#P8212-THUPC2022-初赛-喵喵花園" class="headerlink" title="P8212 [THUPC2022 初赛] 喵喵花園"></a>P8212 [THUPC2022 初赛] 喵喵花園</h3><p>确定一个起始位置就都确定了, 那么考虑随着起始位置变化本来每个点位置都在直线上移动, 直到有一个点移动到下一条边, 于是整个函数是 $n$ 段的. 就成了已知每个点坐标为 $p_i+v_it$ 求面积, 而面积是相邻两项叉积的和, 是二次函数, 那么每次暴力算下一个段的起始点并暴力求二次函数看起来是简单的啊.</p><p>但是是不是, 当你修改一个位置的时候你只是单点改 $p$ 和 $v$, 于是二次函数修改可以 $O(1)$, 而每次要找下一个起始点也可以维护, 是单点改大, 求最小值, 看起来可以单log整体.</p><h3 id="P8215-THUPC2022-初赛-分组作业"><a href="#P8215-THUPC2022-初赛-分组作业" class="headerlink" title="P8215 [THUPC2022 初赛] 分组作业"></a>P8215 [THUPC2022 初赛] 分组作业</h3><p>看到这么离谱的东西应该想流, 先给每个人建一个点</p><p>然后首先最基本的是愿意, 可以用一边的边建成割&#x2F;不割表示是否愿意, 也可以用两边的与源汇连边表示愿意, 看起来后者信息更多, 这里认为割源点的边表示愿意.</p><p>然后对于合作, 只要两者各建一条边连 inf 到一个新点, 新点向汇点连代价, 这样只有这条汇边被保留表示合作. 同时再用一条边连到源点, 也是二选一表示合作和不合作即可.</p><p>然后对于 $e$ 的代价显然只要两个人之间连有向边.</p><p>然后喜欢就是刚才的合作建出来的点向另一边表示愿意的点连边即可.</p><p>然后你要保证你做的是不能一个人&#x2F;组把连到源点汇点都割了, 因为这么连人和组都至少割一个, 所以给这些边每个加 $inf$ 最后减掉即可.</p><h2 id="THUPC-乱做"><a href="#THUPC-乱做" class="headerlink" title="THUPC 乱做"></a>THUPC 乱做</h2><h3 id="P7609-THUPC2021-游戏"><a href="#P7609-THUPC2021-游戏" class="headerlink" title="P7609 [THUPC2021] 游戏"></a>P7609 [THUPC2021] 游戏</h3><p>让人想起移动金币那个题, 考虑逐位做, 设 $f_{i, S, j, 0&#x2F;1}$ 表示考虑完低 $i$ 位, 当前 $S$ 中的数顶上界, 他们的和进位为 $j$, 总和是否小于等于 $n$ 的方案数.</p><p>然后直接做复杂度带 $4^m$ 爆炸, 这里按位从低往高不如从高往低, 因为那样只要考虑 $S$ 中的数, 其他数都不可能变的顶上界, 复杂度会变成 $3^n$,<strong>因为数位dp从高往低性质其实是比从低往高好在大小限制变化单调</strong></p><h3 id="P7604-THUPC2021-形式语言与自动机"><a href="#P7604-THUPC2021-形式语言与自动机" class="headerlink" title="P7604 [THUPC2021] 形式语言与自动机"></a>P7604 [THUPC2021] 形式语言与自动机</h3><p>考虑分成三段后它们的把括号看成 $\pm 1$ 序列后的和以及前缀 $min$ 的值 $s_1, s_2, s_3, m_1, m_2, m_3$, 则换完之后显然要满足 $m_1\ge 0, s_1+m_3\ge 0, s_1+s_3+m_2\ge 0$.</p><p>我们大概率扫描 $r$ 也就是枚举 $3$, 那么看起来第二个条件转化成 $m_2-s_2\ge 0$, 也就是后缀 $min&#x3D;sm_2\ge 0$, 这样转化的好处是满足第二个条件的变成了一个区间, 显然 $m_1\ge 0$ 也是一个区间, 剩下的是 $m_3+s_1\ge 0$, 其中 $m_3$ 确定, 就是求 $s_1$ 的和大于某个值了. 总结一下发现这就是下标一维和一维的二维数点, 做完了.</p><h3 id="P7605-THUPC2021-小-E-爱消除"><a href="#P7605-THUPC2021-小-E-爱消除" class="headerlink" title="P7605 [THUPC2021] 小 E 爱消除"></a>P7605 [THUPC2021] 小 E 爱消除</h3><p>容易想到区间dp, 那么设 $f_{l, r}$ 为答案后要转移, 以左边为例, 要么 $l$ 最后也没被消掉可以直接从 $f_{l+1, r}$ 转移, 否则假设找到与 $l$ 颜色相同的另一个位置 $i$, 则一定是拿出 $l$, 消空 $i$ 左边或右边(可能用到没被消空的一边), 比如消没左边, 那么枚举用了右边的 $k$ 个, 就转移到 $f_{i+1, r-k}$, 于是需要知道把 $j, k$ 端不可被删除的区间 $[i, j], [k, l]$ 完全消空的最小杯子大小 $g_{i, j, k, l}$, 而 $g$ 可以用一样的方式转移, 最后复杂度 $n^6$, 然后靠玄学常数过题.</p><h3 id="P7606-THUPC2021-混乱邪恶"><a href="#P7606-THUPC2021-混乱邪恶" class="headerlink" title="P7606 [THUPC2021] 混乱邪恶"></a>P7606 [THUPC2021] 混乱邪恶</h3><p>好棒的题</p><p>就是, 本来你肯定直接dp设 $f_{i, l, g, x, y}$ 表示考虑完前 $i$ 个idea, 然后 $l, g$ 的值和自己的坐标 $x, y$(六边形可以转化成走 $x, y$ 和沿着 $y&#x3D;x$ 走), 然后获得复杂度 $n^3p^2$ 再靠bitset压上 $\dfrac{n^3p^2}{w}$</p><p>见识新dp优化方案了. 一个众所周知的结论是二维平面随机游走期望距离 $\sqrt n$, 所以可以把输入的idea随机打乱然后把 $x, y$ 只开到 $\sqrt n$, 使得转移过程中不会出现很大的 $x, y$, 复杂度就成了 $\dfrac{n^2p^2}{w}$</p><p>[trick] 随机游走结论更改添加物品顺序以优化dp状态</p><h3 id="P7136-THUPC2021-初赛-方格游戏"><a href="#P7136-THUPC2021-初赛-方格游戏" class="headerlink" title="P7136 [THUPC2021 初赛] 方格游戏"></a>P7136 [THUPC2021 初赛] 方格游戏</h3><p>注意到最关键的部分: 对任意 $i, j$, $D_i+1&lt;U_j$ 或 $D_j+1&lt;U_i$ 以及横向的, 这个说明不可能用障碍物围迷宫之类的, 甚至任意两点只会被一个障碍物影响, 因为横竖独立可以光看一边, 以纵向绕远为例, 因为某个障碍物绕远的条件是起点终点都属于障碍覆盖的纵坐标区间, 则会绕一下.</p><p>而绕远距离是简单一次函数, 求完和二次函数乱算即可.</p><h3 id="P7607-THUPC2021-初赛-赌徒问题"><a href="#P7607-THUPC2021-初赛-赌徒问题" class="headerlink" title="P7607 [THUPC2021 初赛] 赌徒问题"></a>P7607 [THUPC2021 初赛] 赌徒问题</h3><p>看起来枚举 $s$, 然后拿出所有因数暴力背包的复杂度是 $m^2d(mk)$, 其中 $d(mk)$ 大约是 $6000\sim 10000$ 之间, 过不了.</p><p>考虑背包的时候 $k$ 的约数先都加进去, 每次只插入不是 $k$ 的约数而是 $sk$ 的约数的部分, 复杂度就下来了.</p><h2 id="于是开打THUPC2024-pre"><a href="#于是开打THUPC2024-pre" class="headerlink" title="于是开打THUPC2024 pre"></a>于是开打THUPC2024 pre</h2><p>7题, 但自己只过了一个, 被队友带飞了.</p><h3 id="M-你说得对-但是AIGC"><a href="#M-你说得对-但是AIGC" class="headerlink" title="M. 你说得对, 但是AIGC"></a>M. 你说得对, 但是AIGC</h3><p>如果是<code>You are right, but</code>开头就是AI.</p><h3 id="H-二进制"><a href="#H-二进制" class="headerlink" title="H. 二进制"></a>H. 二进制</h3><blockquote><p>今天也是喜欢二进制串的一天, 小 F 开始玩二进制串的游戏.</p><p>小 F 给出了一个这里有一个长为 $n$ 的二进制串 $s$, 下标从 $1$ 到 $n$, 且 $\forall i\in[1, n], s_i\in {0, 1}$, 他想要删除若干二进制子串.</p><p>具体的, 小 F 做出了 $n$ 次尝试.</p><p>在第 $i\in[1, n]$ 次尝试中, 他会先写出正整数 $i$ 的二进制串表示 $t$(无前导零, 左侧为高位, 例如 $10$ 可以写为 $1010$).</p><p>随后找到这个二进制表示 $t$ 在 $s$ 中从左到右<strong>第一次</strong>出现的位置, 并删除这个串.</p><p>注意, 删除后左右部分的串会拼接在一起<strong>形成一个新的串</strong>, 请注意新串下标的改变.</p><p>若当前 $t$ 不在 $s$ 中存在, 则小 F 对串 $s$ 不作出改变.</p><p>你需要回答每一次尝试中, $t$ 在 $s$ 中第一次出现的位置的左端点以及 $t$ 在 $s$ 中出现了多少次.</p><p>定义两次出现不同当且仅当出现的位置的左端点不同.</p><p>请注意输入输出效率.</p><p>$n\le 10^6$</p></blockquote><p>Harry秒了</p><p>显然这个尝试的串长度是 $\log_{10}(n)$ 的, 非常短, 那么直接字符串哈希(都不用哈希, 直接拿这个串表示的二进制数就行), Harry写的是可删堆去维护hash值的出现位置并求位置最小值(因为删掉原序列一个数两边拼起来会减少一些hash形成一些新的hash, 要暴力更新, 所以要支持删除), 上链表维护删除一个数并把两边拼起来的操作, 用BIT维护被删了的元素的位置.</p><p>复杂度是2log, 但有一个log底数是10.</p><h3 id="C-前缀和"><a href="#C-前缀和" class="headerlink" title="C. 前缀和"></a>C. 前缀和</h3><blockquote><p>小兰很喜欢随机数.</p><p>TA 首先选定了一个实数 $0 &lt; p &lt; 1$, 然后生成了 $n$ 个随机数 $x_1, \dots, x_n$, 每个数是独立按照如下方式生成的:</p><ul><li>$x_i$ 有 $p$ 的概率是 $1$, 有 $(1-p)p$ 的概率是 $2$, 有 $(1-p)^2p$ 的概率是 $3$, 以此类推.</li></ul><p>生成完这些随机数之后, 小艾对这个数列求了前缀和, 得到了数列 $y_1, \dots, y_n$.</p><p>给定 $1\leq l\leq r\leq n$, 小兰想知道, 期望有多少 $y_i$ 落在 $[l, r]$ 内?</p><p>$n, l, r\le 10^9$</p></blockquote><p>赛时代数推导天地灭式子的角标推错了, 还是靠Mikefeng, 喵的重推一遍.</p><p>$x_i$ 为 $n$ 的概率显然是</p><p>$$<br>[z^k]\dfrac{pz}{1-(1-p)z}<br>$$</p><p>于是 $y_k$ 为 $n$ 的概率是</p><p>$$<br>\begin{gathered}<br>[z^n]\dfrac{p^kz^k}{(1-(1-p)z)^k}\<br>&#x3D;[z^n]p^kz^k\sum_j \binom{-k}{j}(-1)^j(1-p)^jz^j\<br>&#x3D;[z^n]p^kz^k\sum_{j&#x3D;0}^{n-k} \binom{k+j-1}{j}(1-p)^jz^j<br>\end{gathered}<br>$$</p><p>原来要求 $[l, r]$ 中的可以改成求 $[1, r]$ 中的差分, 其中少于 $r$ 的期望个数为</p><p>$$<br>\begin{gathered}<br>\sum_{i&#x3D;1}^n \sum_{j&#x3D;0}^{r-i} p^i(1-p)^j\binom{k+j-1}{j}\<br>&#x3D;\sum_{i&#x3D;0}^{r-1}\sum_{j&#x3D;0}^{r-1}p^{i-j+1}(1-p)^j\binom{i}{j}\<br>&#x3D;\sum_{i&#x3D;0}^{r-1}p(1-p+p)^{i}\<br>&#x3D;rp<br>\end{gathered}<br>$$<br>所以答案就是 $(r-l+1)p$</p><h3 id="K-三步棋"><a href="#K-三步棋" class="headerlink" title="K. 三步棋"></a>K. 三步棋</h3><blockquote><p>K 家里有一条不成文的规矩. 如果家里只有 K 和 H 两个人, 那么两个人会通过一种叫作”三步棋”的游戏来决定谁做饭. 三步棋的规则与五子棋有一些相似之处. 众所周知, 五子棋是一种先连出五枚己方棋子者获胜的游戏. 与五子棋相同的是, 三步棋中双方也轮流在网格状的棋盘上摆放棋子, 并根据是否连成指定的图案决定胜负. 与五子棋不同的是:</p><ol><li>三步棋不区分双方的棋子, 即可以认为双方执同色棋子进行游戏;</li><li>在判定时, 指定的图案不能旋转;</li><li>如果连成指定的图案时, 棋盘上的棋子数量恰好为 $3$ 的倍数, 则连成指定的图案的一方获胜, 否则判定该方负(即对方获胜).</li></ol><p>在 K 家, 为了节约时间, 通常使用 $5\times 5$ 的初始为空的棋盘进行三步棋. 同时, 每次也只会随机选择一个由不超过 $4$ 枚棋子组成的四连通图案. 显然三步棋不存在平局, 所以 K 和 H 约定由输的一方负责做饭. K 想知道, 如果自己和 H 都足够聪明, 那么以选中的图案进行的三步棋游戏是否为<strong>先手必胜</strong>; 因为如果她更容易赢, 她就要偷偷地给自己的妹妹放水.</p></blockquote><p>首先容易看出这是个爆搜题.</p><p>然后HarryTLE了, 爆搜冲不过, 需要打表. . .</p><p>打完就过了, 这里可以用对称性少打几个.</p><h3 id="J-套娃"><a href="#J-套娃" class="headerlink" title="J. 套娃"></a>J. 套娃</h3><blockquote><p>我们定义一个集合的 $\mathrm{mex}$ 是最小的不在 $S$ 中的非负整数.</p><p>给定一个序列 $a_1, \dots, a_n$, 对于每个 $1\leq k\leq n$, 我们按照如下方式定义 $b_k$:</p><ul><li>对于 $a$ 的所有长为 $k$ 的子区间, 求出这个子区间构成的数集的 $\mathrm{mex}$.</li><li>对于求出的所有 $\mathrm{mex}$, 求出这个数集自己的 $\mathrm{mex}$, 记为 $b_k$.</li></ul><p>请你求出序列 $b$.</p><p>$n\le 10^5$</p></blockquote><p>Mikefeng秒了.</p><p>包含某个出现了 $cnt$ 次的值的区间在平面上是 $O(cnt)$ 个矩形, 不包含的是一个下阶梯, 那么相当于平面上若干个矩形取min后得到的就是mex, 那么转换维度, 从小大大枚举值, 维护mex小于当前值的区域(一个下阶梯), 每次插入一个矩形就是给阶梯新添加一块, 且新加的区域的mex恰好是当前枚举的值, 而且新加的一块在 $x+y$ 上一定是一个区间, 也就是新加的区域的区间长度是一个区间, 而当前值插入的所有矩形求出的区间的并就是那些包含至少一个区间以当前值作为mex的所有长度.</p><p>求出长度区间扫一遍就做完了.</p><h3 id="E-转化"><a href="#E-转化" class="headerlink" title="E. 转化"></a>E. 转化</h3><blockquote><p>小 E 有 $n$ 种颜色的球, 其中第 $i$ 种有 $a_i$ 个. 有两类工具, 第一类可以把一个指定颜色的球变成一个<strong>任意</strong>颜色的球; 第二类可以把一个指定颜色的球变成两个<strong>这种</strong>颜色的球. 一个变化之后的球也可以通过工具产生新的变化. 关于第 $i$ 种颜色的第一类工具有 $b_i$ 个, 第二类工具有 $c_i$ 个.</p><p>小 E 想知道, 如果每一<strong>个</strong>工具最多只能使用一次, 那么对于每种颜色 $i$, 第 $i$ 种颜色的球最后最多能有多少个. 以及, 小 E 最后最多能有多少个球.</p><p>$n\le 5\times 10^5, a_i, b_i, c_i\le 10^9$</p></blockquote><p>C过之后去开E了, 很好想, 但是一直在写愚蠢错误, 并且没有大样例不知道错哪的贪心题.</p><p>先考虑第一问求到第 $k$ 种颜色的最多有多少, 那么把其他球分成三类, $b_i&#x3D;0$ 的部分不用考虑, $b_i\ne 0, a_i\ne 0$ 的可以直接 $a_i’: &#x3D; a_i+c_i$, 并可以提供 $d_i\min (b_i, a_i’)$ 的贡献(这里把贡献定义成可以根据需要转换成任意颜色的球数), 然后 $b_i\ne 0, a_i&#x3D;0$ 的球, 需要先消耗一个球, 然后用二类工具, 则它们的贡献是 $\min (b_i-1, c_i)$, $-1$ 是把转入的球转出去的代价. 这样答案就是所有点的贡献, 再加上 $a_k$, 此时求出来的结果如果不为 $0$ 就再加 $c_k$.</p><p>对于第二问, $a_i\ne 0, b_i\ne 0$ 的球不变, $a_i&#x3D;0, b_i\ne 0$ 变成了如果转入一个球会贡献 $\min(b_i-1, c_i)$, 会给总数增加 $(c_i)$, 此时你会剩下若干贡献可以转换成其他球, 这些应该送到 $b_i&#x3D;0 0, a_i&#x3D;0$ 中 $c_i$ 前若干大的球, 然后对于 $b_i&#x3D;0, a_i\ne 0$ 的球直接把 $a_i+c_i$ 到总数.</p><p>调了一年, wa了4发&#x2F;&#x2F;&#x2F;fn</p><h3 id="D-多折较差验证"><a href="#D-多折较差验证" class="headerlink" title="D. 多折较差验证"></a>D. 多折较差验证</h3><blockquote><p>对于所有折痕互相平行的说明书, 可以按照说明书上文字的阅读顺序从上到下给每条折痕分别编号 $1, 2, \cdots, N$, 这 $N$ 条折痕将说明书分成了 $(N+1)$ 条纸带. 每条折痕可能为两种形态之一: 一种是垂直纸面向内凸出, 对应将纸的上下两半向前对折; 一种是垂直纸面向外凸出, 对应将上下两半向后对折. 根据折痕截面的形状, 分别使用小写字母 <code>v</code> 表示向内凸出的折痕, <code>^</code> (ASCII 码为 $94$)表示向外凸出的折痕. 假设所有纸带的宽度都是一样的, 并且折纸的过程中说明书不发生形变, 那么沿着一条折痕对折后两侧的纸能够重合, 当且仅当两侧的折痕是相反的; 即, 如果沿着第 $k$ 条折痕折叠, 那么对于所有满足 $1\le k-m&lt;k+m\le N$ 的正整数 $m$, 第 $(k-m)$ 条折痕和第 $(k+m)$ 条折痕的形态是相反的. 例如, 对于折痕依次为 <code>v^v^^^^v</code> 的说明书, 可以沿其第 $7$ 条折痕进行折叠. 根据定义可知, 一张说明书总能沿着第一条或最后一条折痕进行折叠. 折叠之后的说明书可以用被折叠的折痕两侧中, 剩余折痕数量较多一侧的折痕表示, 如 <code>v^v^^^^v</code> 沿着第 $7$ 条折痕折叠后得到 <code>v^v^^^</code>. 如果被折叠的折痕两侧折痕数量相等, 那么用哪一侧的折痕表示折叠后的纸都可以, 因为折痕在三维空间中是旋转对称的. 特别地, 对只剩下一条折痕的说明书, 即 <code>v</code> 或 <code>^</code> 进行折叠后, 所有 $(N+1)$ 条纸带都重叠在一起, 此时称这张说明书被折叠整齐.</p><p>虽然按顺序依次折叠每一条折痕, 总能将说明书折叠整齐, 但 Kanan 觉得这样并不美观. 一种美观的折法应该尽量少折, 并且每次折的时候折痕两侧应该尽可能的对称. 定义一种折法的不对称程度为每次折叠时, 被折叠的折痕两侧的折痕数量之差的总和. 给出一张说明书的折痕, Kanan 想知道最少需要折多少次才能将这张说明书折叠整齐, 以及所有折叠次数最少的折法中, 不对称程度的最小值.</p><p>$n\le 5000$</p></blockquote><p>长得像区间dp, 真的是区间dp, 直接区间dp显然是 $n^3$ 的.</p><p>然后你看到这个就会猜有效转移不多, 因为条件看着很苛刻, 所以考虑求出所有有效转移只转移这些, 然后过了.</p><p>题解表示能卡到 $n^2\log n$, 但也没证出来.</p><h3 id="B-一棵树"><a href="#B-一棵树" class="headerlink" title="B. 一棵树"></a>B. 一棵树</h3><blockquote><p>这里有一棵树, 具体的, 这是一张有 $n$ 个节点和 $n-1$ 条边组成的无向联通图.</p><p>每个节点初始颜色为白色, 你需要恰好将其中 $k$ 个节点染成黑色, 定义一条边的权值是, 断开这条边之后, 两个连通块的黑色节点个数之差, 定义一棵树的权值为所有边的权值求和, 你需要最小化整棵树的权值.</p><p>$n\le 5\times 10^5$, 1s</p></blockquote><p>赛时最后1. 5h会了这个题, 结果没调出来寄了.</p><p>以 $1$ 为根, 首先显然可以把贡献转化成 $\sum_{u\ne 1} \vert k-2cnt_u\vert$, 其中 $cnt$ 为 $u$ 内黑点个数.</p><p>于是dp, $f_{u, i}$ 表示 $u$ 子树内染了 $i$ 个黑点, 转移的话是先把所有子树做 $\min, +$ 卷积然后再加上绝对值函数 $\vert k-2i\vert$, 这东西是很典的凸性题.</p><p>实现的话因为这个绝对值加的位置固定所以直接开两个大根堆, 堆里塞 $pair(k, l)$ 表示一个斜率为 $k$, 长度为 $l$ 的斜率连续段, 这样区间加直接打标记, 然后用启发式合并. 复杂度 $n\log^2 n$, 赛时先T一发, 卡常完了还CE了然后比赛结束.</p><p>靠这里启发式合并直接换可并堆就单log啊.</p><p>[think] 碰到这种凸性题之后要想到底要维护什么, 维护原数组, 差分数组(用数据结构维护每个位置即对应差分)&#x2F;差分连续段(搭配堆&#x2F;数据结构)&#x2F;差分变化 $1$ 的位置. 要做闵和而且不是和 $O(1)$ 段函数做闵和的时候基本上只有差分连续段是能用的对应直接数据结构合并. 此外一般需要你维护&#x2F;能快速求某个特定位置的dp值来求答案.</p><p>比赛结束之后发现写的会WA, 输麻了, 码力过低.</p><h3 id="G-采矿"><a href="#G-采矿" class="headerlink" title="G. 采矿"></a>G. 采矿</h3><blockquote><p>矿坑是二叉树形结构, 有 $n$ 个节点. $1$ 号点为地面, 对于所有的 $2\le i\le n$, $i$ 号节点与更浅层的 $f_i$ 号节点通过通道相连, 其中 $f_i&lt;i$, 且相同的 $f_i$ 最多出现两次. 矿坑的不同节点的产量和开采难度均不相同. 对于 $i$ 号节点 $(2\le i\le n)$, 如果派一个机器人开采, 一单位时间内能有 $r_i$ 的产出; 如果派一个人类开采, 一单位时间内能有 $p_i$ 的产出. 地面没有产出. 你有一个机器人, 初始位于 $s$ 号节点. 你的矿坑里初始没有人类工人.</p><p>你现在有 $q$ 条计划需要按顺序执行. 每个计划分为准备、执行、调整、开采四个阶段.</p><p>在准备阶段, 人类可以在满足移动规则的前提下任意移动, 但不能进入或离开矿坑(矿坑内的工人到达 $1$ 号节点不算离开矿坑), 移动的顺序和次数均没有限制. 机器人不能移动.</p><p>在执行阶段, 不同计划需要做的事情可能不同, 共分为 $4$ 种:</p><ol><li>机器人只能沿通道向<strong>更浅</strong>的方向移动, 且至少需要经过一条通道. 人类不能移动.</li><li>机器人只能沿通道向<strong>更深</strong>的方向移动, 且至少需要经过一条通道. 人类不能移动.</li><li>使一名人类从 $1$ 号节点进入矿坑(这意味着该阶段开始时 $1$ 号节点上必须没有工人). 除此之外所有工人都不能移动.</li><li>使一名人类从 $1$ 号节点移出矿坑(这意味着该阶段开始时 $1$ 号节点上必须有一名人类). 除此之外所有工人都不能移动.</li></ol><p>在调整阶段, 限制与准备阶段相同. 在开采阶段, 所有的工人会采一单位时间的矿.</p><p>问按顺序执行完所有计划之后, 你所有计划的产出之和最多可以达到多少.</p><p>$n\le 300, q\le 600$</p><p>PS: 移动时不能穿过有工人的点</p></blockquote><p>那么这不直接dp设 $f_{i, u, j, k, 0&#x2F;1}$ 表示经过了前 $i$ 步, 现在机器人在 $u$, $u$ 的两棵子树分别有 $j, k$ 个人, 机器人是否移动过, 用树上背包一样的分析状态数是 $qn^2$, 转移用前缀和可以 $O(1)$</p><p>这题该过的, 只是最后榜上也只过了8个队根本不敢做.</p><h3 id="I-分治乘法"><a href="#I-分治乘法" class="headerlink" title="I. 分治乘法"></a>I. 分治乘法</h3><blockquote><p>小艾想要挑战分治乘法. TA 将策略抽象成了如下问题:</p><p>现在给定一个目标集合 $T$, 该集合是 ${1, \dots, n}$ 的一个子集($1\leq n\leq 5\times 10^5$). 你需要通过一系列操作构造一些集合最后得到 $T$, 具体来说有以下三种操作:</p><ul><li>创造一个大小为一的集合 $\vert S\vert &#x3D;1$.</li><li>将已经被构造出的两个不交集合 $A, B$ 并起来, 得到 $A\cup B$.</li><li>将已经被构造出的一个集合 $A$ 进行平移, 也即 $A+x &#x3D; { a+x : a\in A }$.</li></ul><p>一个已经被构造出的集合可以在之后被使用多次. 同时你需要保证操作过程中出现的所有集合都是 ${1, \dots, n}$ 的子集.</p><p>你的代价是构造出的所有集合的大小之和, 你不需要最小化代价, 只需要让代价控制不超过 $5\times 10^6$ 即可. 你用的操作数量也不应超过 $10^6$.</p></blockquote><p>朴素做法是直接用 $1$ 操作先把所有数拿出来然后合并, 复杂度显然是 $n\log n$, 比限制差不多正好大一倍.</p><p>考虑怎么使用操作 $3$, 按照 $L$ 分块, 则一块有 $2^L$ 种可能, 然后设 $S_i$ 表示 $i$ 这种可能出现的所有下标的集合, 则 $S_i$ 大小是 $\dfrac{n}{L}$, 构造出一个 $S_i$ 的代价就是 $\dfrac{n}{L}\log n$, 然后平移覆盖, 代价是 $n$</p><p>创建完之后要合并现在得到的 $L2^L$ 个集合, 直接分治复杂度是 $n\log (L2^L)&#x3D;n\log L+nL$, 于是取 $L&#x3D;\sqrt {\log n}$, 总复杂度 $n\sqrt {\log n}$</p><p>很厉害啊赛时只想着把连续的 $L$ 个分块, 处理出 $L2^L$ 种, 然后平移的代价是 $n$, 合并的代价是 $n\log \dfrac{n}{L}$ 没变. . .</p><p>[think]<br>题解: 先合并出 $L2^L$ 个总大小为 $\dfrac{n}{L}$ 的集合, 第二步合并 $L2^L$ 个集合.<br>我: 先合并出 $L2^L$ 个总大小为 $L2^L$ 的集合, 第二步合并 $\dfrac{n}{L}$ 个集合.<br>两步的合并是具有对称性的, 关键是把两步的复杂度平衡.</p><h3 id="A-排序大师"><a href="#A-排序大师" class="headerlink" title="A. 排序大师"></a>A. 排序大师</h3><blockquote><p>由于你是排序大师, 你经常被路过的游客刁难, 要求用一些奇怪的操作给序列排序.</p><p>由于你是远近闻名的排序大师, 邻国的排序萌新小 I 慕名前来拜访, 留下了一个长度为 $n\le 2000$ 的排列 $a_1, a_2 \cdots, a_n$, 并要求你用以下操作将排列升序排序:</p><ul><li>定义 $a_{i \sim j} &#x3D; {a_i, a_{i+1}, \cdots, a_j}$. 选定 $1 \le i \le j &lt; k \le l \le n$, 交换 $a_{i \sim j}$ 和 $a_{k \sim l}$, 即交换过后序列变为 $a_{1 \sim i-1}, a_{k \sim l}, a_{j+1 \sim k-1}, a_{i \sim j}, a_{l+1 \sim n}$.</li></ul><p>由于你是因精益求精而远近闻名的排序大师, 你需要给出一个排序方案<strong>最小化</strong>操作次数.</p></blockquote><p>根本不会.</p><p>考虑分析下界, 因为这个是区间操作所以建图 $p_i+1\to p_{i+1}$, 前面带上 $0$, 这样构造是为了让最后是环 $n$ 个自环, 这样最后是 $n$ 个自环, 分析环数, 则发现一次操作是相当于进行两次子操作: 交换两个点的出边, 那么每次这个子操作可以增加&#x2F;减少一个环, 于是每次操作可以改变环数 $2$, 下界有了, 开始构造.</p><p>找到最小的 $a_x$ 使得存在 $a_y&gt;a_x, y&lt;x$, 拿出最大的 $y$, 则 $a_x-1$ 一定在 $a_y$ 左边, $a_y+1$ 一定在 $a_x$ 后面, 就可以交换 $x-1, y$ 和 $x, y+1$</p><h3 id="L-勇闯末日塔"><a href="#L-勇闯末日塔" class="headerlink" title="L 勇闯末日塔"></a>L 勇闯末日塔</h3><blockquote><p>在一个球面上有 $N$ 个点 $M$ 条弧, 保证弧无重边自环, 所有弧构成连通无向图, 且弧各不相交. 每条弧对应容量 $w_i$(需要根据弧长计算). 给出源 $s$ 和汇 $t$, 求删去恰好 $L$ 个点后从 $s$ 到 $t$ 最大流的最小值.</p><p>$3 \le N \le 1000, 1 \le L \le \min{8, N −2}$</p></blockquote><p>弧各不相交, 则图是平面图, $M\le 3N-6$</p><p>然后最大流等于最小割等于对偶图最短路等于在球上找一个最小环让 $S, T$ 分别在两边.</p><p>为了在两边, 先bfs出一条 $S\to T$ 的路径, 然后要求找到的最小环经过 $S\to T$ 奇数次, 然后从一个点开始spfa dp, 状态要记录当前点和删了几个点, 而对于一个点转移次数是 $M$ 相关的, 总复杂度 $N^2L$</p><p>std8. 4k的怪物.</p><h3 id="F"><a href="#F" class="headerlink" title="F."></a>F.</h3><p>大模拟</p><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>开局想了个假B浪费时间, 然后C式子推寄了浪费时间, E调了1. 5h+wa了好几发.</p><p>本来应该至少再过一个B的, 时间充足的话还有G只要仔细看了题就很有希望.</p><p>主要问题是自己码力太弱, 写完了调不对, 写代码犯智障错误.</p><p>% Mikefeng&amp;Harry27182 %, 最后70名还是很好的.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2023游记</title>
      <link href="/2023/11/18/noip2023/"/>
      <url>/2023/11/18/noip2023/</url>
      
        <content type="html"><![CDATA[<h1 id="NOIP2023游记"><a href="#NOIP2023游记" class="headerlink" title="NOIP2023游记"></a>NOIP2023游记</h1><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>试机看到do_while_true<del>and yyh</del>, MLE, LgxTpre, modinte</p><p>win7, 但有安了C++插件的vscode</p><p>但是1e8 rand 跑1. 5s的机子, 想起报数lcez机子线性过不去的故事.</p><p>打了ntt和sam</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="Before-Contest"><a href="#Before-Contest" class="headerlink" title="Before Contest"></a>Before Contest</h3><p>看样例, 哟, 有字母? , 剩下三个看不出来是啥, tribool啥词不认识</p><h3 id="During-Contest"><a href="#During-Contest" class="headerlink" title="During Contest"></a>During Contest</h3><p>吸取经验, 上来先喝咖啡.</p><p>先看T1, 这直接对字符串排序, 比最小次小就能过吧</p><p>看T2, 看起来模拟每个位置最后是一开始的什么, 然后并查集扩展域处理相等不等限制就行了</p><p>看T3, 没懂, 看起来让求若 $a_i&gt;b_i$ 连边, 选出不相交的若干条每个点度数至少是 $1$, 一会再说.</p><p>看T4, $n\le 10^9$ 大概是离散化坐标, 像个dp.</p><p>开始写T1, 直接sort吧卡常了再搞桶, 0. 5s大样例, 相信lcez的机子, 开T2.</p><p>写T2, 开始脑子不对劲, ($a$ 数组是维护每个变量最后的值是哪个变量的初值)赋值 $a_x&#x3D;y$, 没初始化, 多测不清空, 9: 30过大样例.</p><p>开始想C, 发现尽量短的前缀匹配它不是最优, 想了个奇怪 $n^2$, 用vector维护 $a$ 一个前缀的所有能匹配 $b$ 的位置, 但 $3\times 10^7$ 应该是线性吧感觉正解应该不是优化二维dp, 大概30min后发现不会, 开始想D.</p><p>诶这个D, 直接dp不就做完了吗, 怎么还不如CSPT4了, 遂又想10minC, 还是不会, 开始冲D.</p><p>Wa on test2, 不会DP假了吧, 又写了 $n^2$ 暴力对了, 于是写 $n^2$ 替代线段树还是不对, 最后是 $f_0$ 没放到线段树里. 大概11: 00调出来, 大样例 $4$ 跑 $2. 4s$, 把离散化排序后二分的部分替换成排序后指针扫变成 $2. 2s$, 选择相信lcez的机子.</p><p>开始想T3, 又想了1h.</p><p>怎么只有1h了, 写T3暴力, 写了个T3特殊性质的假做法(贪心用最短的 $f$ 前缀匹配 $g$)发现过不去样例, 删了, 发现 $n^2$ 暴力跑 $4\times 10^4$ 样例才一点几秒, 选择相信lcez的机子. 大概还剩30min.</p><p>四个代码都拖进noi linux下测一遍, 发现diff的结果有些啥也不输出有些输出一个大于号, 不太懂, 肉眼比对过了.</p><h3 id="After-Contest"><a href="#After-Contest" class="headerlink" title="After Contest"></a>After Contest</h3><p>去dwt考场堵他, 说是335+了&#x2F;bx, 出来第一句先骂区分度怎么这么低&#x2F;fn, 碰见nrd, lgxPre, 大家一对发现谁也没过T3, 看起来人均335+了</p><p>然后碰见whc, 大神切了T3, 大概是每个点向左向右找最近匹配, 判断不能交叉, 没有很懂, 证明是他构造出来了一定可以的方案&#x2F;kt</p><p>T1怎么还 $n&#x3D;1$ 啊急了, 小丑竟是我自己.</p><p>云斗估分90+100+40+100&#x3D;330吧, T1挂10分真是太唐了, 看CCF的了.</p><p><del>出来有看到了yyh, 但dwt怎么不冲上去</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023.11 NOIP前复习</title>
      <link href="/2023/11/04/reviewfornoip2023/"/>
      <url>/2023/11/04/reviewfornoip2023/</url>
      
        <content type="html"><![CDATA[<h2 id="又做了几个杂题"><a href="#又做了几个杂题" class="headerlink" title="又做了几个杂题"></a>又做了几个杂题</h2><h3 id="CF1305F-Kuroni-and-the-Punishment"><a href="#CF1305F-Kuroni-and-the-Punishment" class="headerlink" title="CF1305F Kuroni and the Punishment"></a>CF1305F Kuroni and the Punishment</h3><blockquote><p>给定 $n$ 个数. 每次可以选择将一个数 $+1$ 或 $-1$ . 求至少多少次操作使得整个序列都是正数且全部元素的 $\gcd&gt;1$ .<br>$n\leq 2\times10^5, 1\le a_i\leq 10^{12}$ .</p></blockquote><p>答案不超过 $n$(全调成偶数).</p><p>值域很大, 直接做要求一些 $\sum a_i\bmod g$ 状物, 是困难的, 考虑因为答案不超过 $n$, 那么至少有一半的数被操作至多一次, 于是随一个数, 再随一种操作, 它被这么操作的概率有 $\dfrac{1}{6}$, 随错了的是 $\dfrac{5}{6}$, 那么只要随比如 $50$ 组就行, 然后对着这些可能的操作分解质因数, 只对它们的约数作为gcd去求答案即可.</p><p>哦, 一直以为cf的possibilities都是概率期望题, 结果是随机化</p><h3 id="CF605E-Intergalaxy-Trips"><a href="#CF605E-Intergalaxy-Trips" class="headerlink" title="CF605E Intergalaxy Trips"></a>CF605E Intergalaxy Trips</h3><blockquote><ul><li>$n$ 个点的有向完全图.</li><li>$i \to j$ 的边每天出现的概率均为 $p_{i, j}$, 若 $i &#x3D; j$, 有 $p_{i, j} &#x3D; 1$.</li><li>每天可以选择一条存在的出边走过去或停留在原地不动.</li><li>求最优策略下从 $1$ 到 $n$ 的期望天数.</li><li>$n \le 10^3$.</li></ul></blockquote><p>首先不考虑转移成环的问题, 你能列出一个式子:</p><p>$$<br>f_u&#x3D;\min_q \sum_i f_{q_i}(p_{q_i}) \prod_{j&lt;i} {1-p_{q_j}}<br>$$</p><p>然后考虑, $q$ 一定是比你当前更优的点(否则你选择停留而不是走), 于是当前值最小的点就已经确定了, 可以用它更新其它点, 于是复杂度就是 $n^2\log n$ 了.</p><p>重点是搞出一个转移顺序.</p><h3 id="CF1093F-Vasya-and-Array"><a href="#CF1093F-Vasya-and-Array" class="headerlink" title="CF1093F Vasya and Array"></a>CF1093F Vasya and Array</h3><blockquote><p>给出一段长度为 $n$ 的整数序列, 一个正整数 $k$ , 一个正整数 $len$ , 序列中的所有数均在 $1$ ~ $k$ 之间, 或者等于 $-1$.</p><p>如果没有长度大于等于 $len$ 的连续相同数字则该数段是好的.</p><p>可以将 $-1$ 改为所有 $1$ ~ $k$ 之间的整数, 将该数列变为好的, 求出方案数, 对 $998244353$ 取模</p><p>$len, n\le 10^6, k\le 100$</p></blockquote><p>看起来这是个 $nk$ 的复杂度, 那么想设 $f_{i, j}$ 表示 $i$ 的值为 $j$, 发现直接转移这个限制不好做, 联想起HNOI卡农那个题, 枚举一个 $l$, 用总的方案减去最后恰好长 $l$ 的相等段的方案, 那么总的方案直接从 $f_{i-1}$ 转移过来, 而长 $l$ 的第一反应应该是 $\sum_{k\ne j} f_{i-l, k}$, 要求 $k\ne j$ 是因为不然他们在 $i-1$ 处就已经爆了.</p><h3 id="CF1556F-Sports-Betting"><a href="#CF1556F-Sports-Betting" class="headerlink" title="CF1556F Sports Betting"></a>CF1556F Sports Betting</h3><blockquote><p>有 $n\ (n\le14)$ 个人, 两两之间会打比赛. 每人有一个实力值 $a_i$, 在 $i$ 与 $j$ 的比赛中, $i$ 有 $\frac {a_i}{a_i+a_j}$ 的概率获胜, 其他情况则是 $j$ 获胜. $i$ 在与 $j$ 的比赛中获胜则称 $i$ 打败了 $j$. 若 $i$ 打败了 $j$, $j$ 打败了 $k$, 则认为 $i$ 也打败了 $k$. 若 $i$ 打败了除了他自己以外的所有人, 则称 $i$ 是一个 Winner(是否打败了自己不要求), 注意 Winner  可能有多个. 现在你需要求出 Winner 的期望数量, 对 $1e9+7$ 取模.</p><p>$n\le 14$</p></blockquote><p>容易想到累加每个点成为 Winner 的概率.</p><p>那一个点成为Winner相当于给边定向, 要求有一棵以它为根的根向树, 大概会想设 $f_{S, i}$ 表示以 $i$ 为根, $S$ 中的点都有到 $i$ 的路径的概率, 但是一次转移一个点不能处理当前被加进去的点先连到没被加进去的点再连到 $S$ 中点的情况, 所以你要一次转移一层, 设原来层为 $S$, 然后要转移到 $T\supset S$, 那么就要算 $T-S$ 中的点连向 $S$ 中的点的概率, 存在不好表示, 可以考虑转移 $T-S$ 中点都没连到 $S$ 中的概率, 这个就是其中每个点都没连过去的概率乘起来做完了.</p><p>另一个想法是, 这是竞赛图, 那么缩点成一条链, 个数就是链上第一个SCC的大小, 对这个dp.</p><h3 id="CF1254D-Tree-Queries"><a href="#CF1254D-Tree-Queries" class="headerlink" title="CF1254D Tree Queries"></a>CF1254D Tree Queries</h3><blockquote><p>给定一棵 $N$ 个节点的树, 有 $Q$ 次操作</p><p>$1\space v\space d$ 给定一个点 $v$ 和一个权值 $d$, 等概率地选择一个点 $r$, 对每一个点 $u$, 若 $v$ 在 $u$ 到 $r$ 的路径上, 则 $u$ 的权值加上 $d$ (权值一开始为 $0$)<br>$2\space v$  查询 $v$ 的权值期望, 对 $998244353$ 取模<br>$1\leqslant N, Q \leqslant 150000$</p></blockquote><p>容易想到, 对每个点分开看贡献, 则一次对 $v$ 的修改对 $u$ 的贡献是 $n-siz_v$ 或 $n-siz_w$, 其中 $w$ 为子树包含 $u$ 的 $v$ 的儿子.</p><p>于是你现在做这个修改是 $O(son\log n)$ 的, 考虑把修改上移一位记录在父亲上, 这样一个点的答案就是 $\sum siz_v w_{fa_v}$, 这种儿子关于父亲的显然只有一条链能维护, 树剖就赢了单log.</p><p>我认为点分也可以.</p><h3 id="CF1737E-Ela-Goes-Hiking"><a href="#CF1737E-Ela-Goes-Hiking" class="headerlink" title="CF1737E Ela Goes Hiking"></a>CF1737E Ela Goes Hiking</h3><blockquote><p>$n$ 只蚂蚁站成一排, 第 $1$ 只蚂蚁左边和第 $n$ 只蚂蚁右边各有一个挡板, 相邻两只蚂蚁的距离、第 $1$ 只蚂蚁与左边挡板的距离和第 $n$ 只蚂蚁与右侧挡板的距离相等. 初始时每只蚂蚁重量相等, 每只蚂蚁有 $\frac{1}{2}$ 概率向左运动, $\frac{1}{2}$ 概率向右运动, 每只蚂蚁速度相同. 中途蚂蚁不可主动改变方向, 如果碰到挡板则向相反方向运动, 若两只蚂蚁相遇, 重量大的蚂蚁会把重量小的蚂蚁吃掉, 重量变为两者之和, 如果重量相同, 向左运动的蚂蚁会吃掉向右运动的蚂蚁. 求对于所有 $i\le1\le n$, 第 $i$ 只蚂蚁成为最终的存活者的概率对 $10^9+7$ 取模.</p><p>$n\le 10^6$</p></blockquote><p>注意速度一样和一开始重量一样. 于是过程是每只向左运动的都会干掉前面连续的向右运动的, 现在还剩下若干向左的, 然后每次前两个决斗剩下一个. 现在要求一个位置 $i$ 成为最后的概率, 要求它要能干掉前面的也就是 $\lfloor \dfrac{i}{2}\rfloor$ 到 $i$ 应该被分成一段, 前面的方案是 $2^{\lfloor i\rfloor}$, 然后它的重量会变成 $i$, 则它干掉后面的概率 $g_i$ 可以枚举它干掉的第一个人 $g_j, j\in [i+1, 2i-1]$, 就能dp了.</p><h3 id="CF1835C-Twin-Clusters"><a href="#CF1835C-Twin-Clusters" class="headerlink" title="CF1835C Twin Clusters"></a>CF1835C Twin Clusters</h3><blockquote><p>给定 $2^{k+1}$ 个 $[0, 4^k)$ 内的整数, 请求出任意两个不交非空区间使得其异或和相等, 若无解则输出 <code>-1</code>.</p><p>$k\le 17$</p></blockquote><p>首先鸽子原理是不是 $2^{k+1}(2^{k+1}-1)&#x2F;2$ 比 $4^k$ 大将近一倍, 一定有解.</p><p>不要鸽子原理了随机你还学过生日悖论, 随一个区间期望 $2^k$ 次相同.</p><p>更好的是再砍一半看鸽巢, 你考虑前 $k$ 位有 $2^{k+1}+1$ 种, 那么至少有 $2^k+1$ 个前 $k$ 位相等的对, 又因为后 $k$ 位只有 $2^k$ 种于是又必然出现两个一样的, 于是就做完了.</p><h3 id="CF513G123-Inversions-problem"><a href="#CF513G123-Inversions-problem" class="headerlink" title="CF513G123 Inversions problem"></a>CF513G123 Inversions problem</h3><blockquote><p>有长度 $n$ 的 $n$ 阶排列 $p_i$, $k$ 次操作, 每次等概率反转一个区间, 求最后逆序对的期望. 误差 $&lt;10^{-9}$ 即可.</p><p>$\textrm{task} 1: n \le6 , k\le4$.</p><p>$\textrm{task} 2: n \le30 , k\le200$.</p><p>$\textrm{task} 3: n \le100 , k\le10^9$.</p></blockquote><p>考虑套路, 把它转化成对两个数一个数在另一个数前的概率, 然后你设 $f_{i, j, k}$ 表示操作 $i$ 次, $j, k$ 两个数交换了的概率是多少, 这个直接枚举翻转区间再搭一个前缀和就是 $kn^2$, 然后比较离谱的是, 显然操作的越多就越接近随一个序列, 所以在答案变化量在精度以下时直接停, 大概1000轮就行了.</p><h3 id="CF1218A-BubbleReactor"><a href="#CF1218A-BubbleReactor" class="headerlink" title="CF1218A BubbleReactor"></a>CF1218A BubbleReactor</h3><blockquote><p>基环树, 你可以先选中一个点, 以后每次选中一个与已经选中的点相连的点, 选一个点的贡献是与它连通的未选点个数.</p><p>$n\le 15000$</p></blockquote><p>假设根已经确定, 则树上每个点的贡献是确定的, 只要考虑环的部分, 问题变成给一个环, 每个元素有权值, 选择起点会获得起点的权值, 以后每次从左或从右选一个删掉贡献是还在的权值的和, 容易做到 $n^2$, 然后你没想到的是这题std $n^2$ 过 $15000$</p><h3 id="P4733-BalticOI-2015-Tug-of-War"><a href="#P4733-BalticOI-2015-Tug-of-War" class="headerlink" title="P4733 [BalticOI 2015] Tug of War"></a>P4733 [BalticOI 2015] Tug of War</h3><blockquote><p>由于一共 $2n$ 名选手报名参赛, 所以一个队有 $n$ 名队员. 一根绳上左右两边各有 $n$ 个点. Byteland 的拔河精英们都很挑剔, 每个参赛选手在左右两边都有一个他们想要站的位置. 此外, 你知道每一个参赛选手的力量值 $s_i$.</p><p>组织者现在问你如下的问题: 给定一个整数 $k$, 能否分出两个队, 这两个队各有 $n$ 名选手, 并且他们站在他们想站的位置(当然不能有两名或以上选手站在同一位置), 双方力量和之差不超过 $k$?</p><p>$n\le 3\times 10^4, s_i\le 20$</p></blockquote><p>考虑把两边的位置看成点, 选手看成边, 则就是要给边定向让每个点只有一个入度, 那条件显然是是基环树森林, 然后每个基环树森林只有两种选法要拿它们跑背包, 因为和为 $n$ 大小只有根号种, 多重背包就过了, 或者bitset也能直接冲.</p><p>基环树判定可以拓扑排序后判环.</p><h3 id="CF335E"><a href="#CF335E" class="headerlink" title="CF335E"></a>CF335E</h3><p>纯数学&#x2F;fn题</p><h3 id="CF1874D"><a href="#CF1874D" class="headerlink" title="CF1874D"></a>CF1874D</h3><blockquote><p>$n$ 个点随机游走, 你一开始在 $0$, 你在 $i$ 有 $\dfrac{a_i}{a_i+a_{i+1}}$ 的概率走到 $i-1$, 其他情况走到 $i+1$, 请你分配 $a_i$ 使得总和不超过 $m$ 情况下期望时间最小.</p><p>$n, m\le 3000$</p></blockquote><p>首先常规列式子 $f_i&#x3D;\dfrac{a_i}{a_i+a_{i+1}}f_{i-1}+\dfrac{a_{i+1}}{a_i+a_{i+1}}f_{i+1}, f_n&#x3D;0$, 展开它的系数, 列出是 $f_0&#x3D;f_1+1, f_1&#x3D;f_2+\dfrac{a_1}{a_2}$, 不断展开, 最后就是 $f_0&#x3D;\sum_{j&lt;i} \dfrac{a_j}{a_i}$</p><p>这个可以dp, 直接做就是 $n^3$, 另外注意到若 $j&lt;i, a_j&gt;a_i$, 那交换 $a_j, a_i$ 只会改变 $\dfrac{a_j}{a_i}$ 项其他项不变, 于是易得 $a$ 单增, 于是可以做到 $n^2\log n$ </p><h3 id="某PYYZ题"><a href="#某PYYZ题" class="headerlink" title="某PYYZ题"></a>某PYYZ题</h3><blockquote><p><img src="/img/2023-11-14-19-43-40-image.png" alt="picture 0">  </p></blockquote><p>求得分是简单的, 然后从头开始遍历, 每次看位置 $i$ 最大是多少, 二分这个位置的值, 就要判定后面的区间, 只要开值域线段树维护匹配, 注意到左子树到右子树又是都能匹配的, 于是直接维护 $a, b$ 中未匹配的数量和匹配数即可, 每次单点修改判断.</p><h3 id="DWT某模拟赛题1"><a href="#DWT某模拟赛题1" class="headerlink" title="DWT某模拟赛题1"></a>DWT某模拟赛题1</h3><p>是<a href="https://codeforces.com/gym/104114">https: &#x2F;&#x2F;codeforces. com&#x2F;gym&#x2F;104114</a>的I</p><blockquote><p>有序列 $a_n$, 每次把 $a_i, a_{i+1}$ 设为设为 $\max (a_i, a_{i+1})-1$, 求最少次数变成 $0$</p><p>$n\le 10^5, a_i\le 10^9$</p></blockquote><p>从大到小贪心做, 考虑让所有数都由 $x$ 变化为 $x-1$ 的次数, 则这些数构成若干连续段, 每个连续段需要用 $\lceil \dfrac{x}{2} \rceil$ 次操作, 就做完了.</p><h3 id="DWT某模拟赛题2"><a href="#DWT某模拟赛题2" class="headerlink" title="DWT某模拟赛题2"></a>DWT某模拟赛题2</h3><p>同场的K</p><blockquote><p>给定无向带权图, 保证对任意 $u\to v, \vert u-v\vert \le 10$, $q$ 次询问两点最短路<br>$n\le 10^5, q\le 5\times 10^4$</p></blockquote><p>分治, 对于 $l, r$ 选出 $mid$ 左右各 $10$ 个点, 然后用它们跑区间中的点的单源最短路并更新询问两个点都在区间中的(不要求跨过 $mid$), 再把没跨过的递归下去即可.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造!</title>
      <link href="/2023/11/03/constructive/"/>
      <url>/2023/11/03/constructive/</url>
      
        <content type="html"><![CDATA[<h3 id="CF1375E-Inversion-SwapSort"><a href="#CF1375E-Inversion-SwapSort" class="headerlink" title="CF1375E Inversion SwapSort"></a>CF1375E Inversion SwapSort</h3><blockquote><p>给定一个长度为 $n$ 的序列 $a$, 求 $a$ 中的所有逆序对 $(i_1, j_1), (i_2, j_2), \cdots, (i_m, j_m)$ 的一个排列 $p$,<br>使得依次交换 $(a_{i_{p_1}}, a_{j_{p_1}}), (a_{i_{p_2}}, a_{j_{p_2}}), \cdots, (a_{i_{p_m}}, a_{j_{p_m}})$ 后序列单调不降.<br>$1 \le n \le 10^3$, $1 \le a_i \le 10^9$.</p></blockquote><p>感觉还可以. 不过大概是因为前两天那道ssfz友好联测的D.</p><p>因为这个你需对是跟一开始的值位置相关而不是跟某时刻的值相关, 从位置角度, 考虑先用所有和 $n$ 构成逆序对的东西把 $n$ 换到最后一位, 这个是简单的, 从小到大换和 $a_n$ 构成逆序对的即可, 发现这样的好处是前面的顺序不变. 于是可以递归下去.</p><h3 id="CF741C-Arpa’s-overnight-party-and-Mehrdad’s-silent-entering"><a href="#CF741C-Arpa’s-overnight-party-and-Mehrdad’s-silent-entering" class="headerlink" title="CF741C Arpa’s overnight party and Mehrdad’s silent entering"></a>CF741C Arpa’s overnight party and Mehrdad’s silent entering</h3><blockquote><p>有 $2n$ 个人围成一圈坐在桌子边上, 每个人占据一个位子, 对应这 $2n$ 个人是 $n$ 对情侣, 要求情侣不能吃同一种食物, 并且桌子上相邻的三个人的食物必须有两个人是不同的, 只有两种食物($1$ 或者是 $2$), 问一种可行分配方式.</p><p>$n\le 10^5$</p></blockquote><p>三个人的食物中两个人不同感觉很难办啊</p><p>帮他加强限制, $2i$ 与 $2i-1$ 不是一组. 合理性在于<strong>两个匹配合成出来的图一定是二分图</strong></p><p>感觉真的很不会构造</p><h3 id="CF547D-Mike-and-Fish"><a href="#CF547D-Mike-and-Fish" class="headerlink" title="CF547D Mike and Fish"></a>CF547D Mike and Fish</h3><blockquote><ul><li>给定 $n$ 个整点.</li><li>你要给每个点染成红色或蓝色.</li><li>要求同一水平线或垂直线上两种颜色的数量最多相差 $1$.</li><li>$n, x_i, y_i \le 2 \times 10^5$.</li></ul></blockquote><p>按照行向列连边方式建图, 然后就是给边定向让入度出度之差不大于 $1$, 这时你想到欧拉回路.</p><p>但直接跑的话不一定有欧拉回路, 考虑建一个新点向所有奇数度数点连边即可.</p><p>欧拉路定度数感觉挺典的, 但是唉.</p><h3 id="CF449C-Jzzhu-and-Apples"><a href="#CF449C-Jzzhu-and-Apples" class="headerlink" title="CF449C Jzzhu and Apples"></a>CF449C Jzzhu and Apples</h3><blockquote><p>给出正整数 $n$, 你要从 $1-n$ 之间的正整数中选出尽可能多组, 每组两个数, 使得每一组的最大公约数大于 $1$; 输出能分成最多组的个数, 并按任意顺序输出每组的两个数.</p><p>$n\le 10^5$</p></blockquote><p>首先肯定要尽量让所有数都被用上, 而当一个质数的倍数有奇数个时, 留下 $2p$ 是比留下 $kp$ 优的, 所以策略就是从大到小遍历质数, 如果没被匹配的有奇数个扔掉两倍的那个.</p><h3 id="CF1368E-Ski-Accidents"><a href="#CF1368E-Ski-Accidents" class="headerlink" title="CF1368E Ski Accidents"></a>CF1368E Ski Accidents</h3><blockquote><p>有一个由 $n$ 个点 $m$ 条边组成的有向无环图, 每个点出度至多为2. 您需要标记一些点(<strong>不超过</strong> $\frac{4}{7}n$ 个). 标记一个点 $u$ 将会<strong>删除所有与</strong> $u$ <strong>连接的边</strong>.<br>您需要找到一种标记点的方案, 使得删边后的图中每一条路径至多有一条边.</p><ul><li>$1 \leq n \leq 2 \times 10^5$, 并且所有数据中 $n$ 的和不超过 $2 \times 10^5$.</li></ul></blockquote><p>这谁想的到啊</p><p>于是吧所有入度为 $0$ 的点放到集合 $A$, 至少有一条来自 $A$ 的入边的点放到 $B$, 剩下的至少有一条 $B$ 的入边杀了. 显然没有长 $2$ 的了.</p><p>这为啥是对的呢? $A$ 出边至多有 $2A$ 条, $B$ 的出边至多有 $2B$ 条, 于是 $C\le 4B\le 2A$.</p><h3 id="CF527E-Data-Center-Drama"><a href="#CF527E-Data-Center-Drama" class="headerlink" title="CF527E Data Center Drama"></a>CF527E Data Center Drama</h3><blockquote><ul><li>给定一张 $n$ 个点 $m$ 条边的连通无向图.</li><li>你需要加尽可能少的边, 然后给所有边定向, 使得每一个点的出入度都是偶数.</li><li>边可以是自环, 也可以有重边.</li><li>$n \le 10^5$, $m \le 2 \times 10^5$.</li></ul></blockquote><p>有了刚才的CF547D你是不是很容易想到欧拉回路然后定向了.</p><p>于是给每两个奇度点连一条边. 欧拉回路交替定向.</p><p>但仍然不一定合法, 如果你最后欧拉回路是奇数条会有一条边没法定向, 你就连一个自环变成偶数.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 构造 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南外集训</title>
      <link href="/2023/10/24/nfls/"/>
      <url>/2023/10/24/nfls/</url>
      
        <content type="html"><![CDATA[<h2 id="NOIP模拟赛44"><a href="#NOIP模拟赛44" class="headerlink" title="NOIP模拟赛44"></a>NOIP模拟赛44</h2><h3 id="A-K-近查询"><a href="#A-K-近查询" class="headerlink" title="A. K 近查询"></a>A. K 近查询</h3><blockquote><p>给定序列 $a_n$, 对每个 $k\le lim$ 求 $j$ 使得 $j$ 是 $j &lt; i, a_j\ge a_i$ 中第 $k$ 大的.</p><p>$n\le 10^7, lim&#x3D;1$ 或 $n\le 3\times 10^6, lim&#x3D;5$</p></blockquote><p>简单题, 对 $10^7$ 的部分直接单调栈, 对 $lim&#x3D;5$ 的部分建出链表, 然后从小到大删元素并统计答案.</p><h3 id="B-树上流水"><a href="#B-树上流水" class="headerlink" title="B. 树上流水"></a>B. 树上流水</h3><blockquote><p>给一棵 $n$ 个点的外向树, 根有无限水, 边有容量限制, 每秒可以把水延边推动, 求最少几秒使得叶子处总水量至少为 $K$.<br>$K\le 10^9$, $n\le 1000$</p></blockquote><p>容易想到dp, 设 $f_{u, i}$ 表示点 $u$ 发出 $fw_u&#x3D;w_{fa_u\to u}$ 的流量在 $i$ 秒后最多有多少到叶子, 转移大概是 $f_{u, i}&#x3D;\min (\sum f_{v, i}, fw_u)$, 然后求出 $1$ 的就可以算答案了.</p><p>然而赛时一开始没看到 $n\le 1000$(它写 $\sum n\le 5\times 10^4$), 所以可以写线段树合并加速转移. 或者动态dp每次删最底下的东西, 或者可并堆, 都能做到单log.</p><p>当然也容易想到贪心, 因为你一定优先流深度低的叶子.</p><h3 id="C-逆序对"><a href="#C-逆序对" class="headerlink" title="C. 逆序对"></a>C. 逆序对</h3><blockquote><p>给定一长为 $2^n$ 的序列 $p_1, p_2, . . . , p_{2^n}$, $m$ 次操作, 每次操作给出三个整数 $q_i$, $l_i$, $r_i$, 然后对序列作如下变换:</p><ul><li>将序列分为 $2^{q_i}$ 个大小为 $2^{n-q_i}$ 的块.    </li><li>选择第 $l_i$ 到第 $r_i$ 个块.</li></ul><p>每次操作后, 输出整个序列的逆序对数.</p></blockquote><p>直接线段树维护就行了. 建线段树后, 每个点记录 $w_x$ 为左儿子对右儿子的逆序对数, 发现翻转这个节点(交换左右子树, 子树内不变)只影响本节点的 $w$ 且可以预处理, 而题目所要求的翻转一个区间就是翻转区间对应节点的所有子树. 于是要打懒标记, 记录 $s_x$ 表示 $x$ 子树中集合 $s$ 中的层都要翻转, $c_{x, i}$ 表示 $x$ 子树中深度为 $i$ 的那层节点翻转后的 $w$ 减去翻转前的 $w$ 就做完了就能合并标记和处理变化了. 复杂度2log.</p><h3 id="D-净土裁断"><a href="#D-净土裁断" class="headerlink" title="D. 净土裁断"></a>D. 净土裁断</h3><blockquote><p>在一棵 $n$ 点树上随机游走, 在点 $u$ 有 $p_u$ 概率停留 $1s$, 有 $1-p_u$ 概率等概率走到相邻一点, 走到 $1$ 停止, 求每个点走到 $1$ 的步数的 $k$ 次方的期望.</p><p>$n\le 10^5, k\le 10^3$</p></blockquote><p>先考虑 $k&#x3D;1$ 怎么做, 那么</p><p>$$<br>f_u&#x3D;p_u(f_u+1)+(1-p_u)\sum_{u\to v}(f_v+1)<br>$$</p><p>然后这个有后效性, 学到一个树上高消: 依赖关系成树之后叶子的式子可以写成 $f_u&#x3D;a_uf_{fa}+b_u$, 然后把这个式子带入父亲的式子就消掉自己, 于是父亲最后也表示成关于爷爷的一次函数, 以此类推, 最后推到根, 再用根的值算出整棵树的dp值.</p><p>遇到 $k$ 次方常见套路是EGF和斯特林数.</p><p>斯特林数, 则 $x^k&#x3D;\sum_{i&#x3D;0} \binom{n}{i}{k\brace i}i!$, 于是要算 $\sum \binom{l}{i}$, 于是</p><p>$$<br>f_{u, k}&#x3D;p_u(f_{u, k}+f_{u, k-1})+(1-p_u)\sum_{u\to v}(f_{v, k}+f_{v, k-1})<br>$$</p><p>于是仍然套刚才的树上高消, 复杂度 $nk+k^2$</p><p>假设我们一开始选择EGF, 则设 $F_u(x)$ 表示 $\sum_{l\in S} p_le^{xl}$, 其中 $S$ 是所有方案下到根步数的多重集, 那么列出 $F_u(x)&#x3D;p_ue^xF_u(x)+\sum_{u\to v}(1-p_u)e^xF_v(x), F(1)&#x3D;1$ 并仍然套用刚才树上高消的转移, 这个转移不动因为卷 $e^x$ 复杂度是 $k\log k$ 的, 考虑换元 $t&#x3D;e^x$ 则 $F_u(t)&#x3D;p_utF_u(t)+\sum_{u\to v}(1-p_u)tF_v(t)$, 此时卷上单个 $t$ 复杂度就 $O(k)$ 了.</p><h2 id="USACO-2018-铂金"><a href="#USACO-2018-铂金" class="headerlink" title="USACO 2018 铂金"></a>USACO 2018 铂金</h2><blockquote><p>A. Balance Beam</p></blockquote><p>想到dp $dp_i&#x3D;\max (f_i, \dfrac{1}{2}(dp_{i-1}+dp_{i+1}))$, 但这个转移不了.</p><p>考虑一些点 $dp_i&#x3D;f_i$, 那么这些点就把序列分成若干段, 每一段内的点的dp值就由两边的断点决定. 而发现走到左右断点中的哪一个的概率是能求的: 和距离成正比.</p><p>然后最厉害的地方在于, 考虑把它们以 $i$ 为横坐标, $f$ 为纵坐标画到平面上, 则中间的点就是断点连线在这个横坐标的值. 现在把 $i, v_i$ 画到平面上, 选择若干个点使得对应横坐标最大, 发现这是凸包. 于是最后只要求个凸包就做完了.</p><p>[think] 想出一个最优策略</p><p>[trick] 在 $[1, l]$ 的线段上, 每步随机走到 $-1+1$ 的位置, 点 $x$ 从 $0$ 出来的概率是 $\dfrac{x}{l+1}$</p><blockquote><p>B. Sort It Out</p></blockquote><p>集合外的点相对顺序不变, 于是集合外的点必然是升序的, 在此基础上发现集合内的每个点都会到正确的位置上. 那么剩下的是一个LIS, 发现若两个LIS的字典序关系和它们的补的大小关系相反(考虑其第一个不相同的元素前都相同, 第一个不相同的元素 $B$ 大则补中 $B$ 缺一个大的 $A$ 缺一个小的). 于是求第 $k$ 大LIS, 设 $f_i, g_i$ 表示以 $i$ 结尾的 $LIS$ 长度和个数, $g$ 的转移一定是 $f_j&#x3D;f_i-1$ 的一个后缀转移过来, 如果对每种 $f$ 的值开一棵线段树, 那么就是区间查, 最后求第 $k$ 大也就是在线段树上面二分. 复杂度单log. 好吧实际上求 $g$ 可以直接维护最大值对应元素之和, 二分也可以直接二分, 但这样是先确定尾不断往头走, 所以应该翻过来找下降序列.</p><p>[think] 寻找不变性, 排除一定不合法的情况分析充分性. 这里先要求集合外升序, 而集合外不升序的情况下集合内的点最终目标没有好的性质.</p><blockquote><p>C. The Cow Gathering</p></blockquote><p>容易想到建成根向有根树, 把限制边连上就是问每个点开始有没有环.</p><p>发现对于限制 $u\to v$, 所有以 $v$ 为根的 $u$ 的子树都不能当根了. 于是ban掉 $O(1)$ 个dfs区间.</p><p>[think] 考虑每个限制的贡献</p><blockquote><p>D. Lifeguards</p></blockquote><p>看到 $k&#x3D;100$ 直接dp, 显然有包含关系可以全杀了, 然后按 $r$ 排序, $f_{i, j}$ 表示前 $i$ 个区间删 $j$ 个的最大值转移不了, 不知道转移过来时那里有没有删, 那么钦点 $i$ 必选, 考虑前面一段没有选, 然后从 $f_{k, j-1}$ 转移来, 此时若 $r_k&gt;l_i$ 则贡献就是 $f_{i, j}&#x3D;f_{k, j-(i-k+1)}+(r_i-r_k)$, 否则是 $f_{i, j}&#x3D;f_{k, j-{i-k+1}}+(r_i-l_i+1)$, 对 $k$ 的限制就是前后缀, 发现其实是要知道 $f_{k, k+(j-i-1)}$, 对每个差维护单调队列即可 $O(1)$ 转移.</p><p>[think] 钦点状态加强性质帮助转移, 困难是不知道最后一个被删的是谁那可以钦点成自己</p><blockquote><p>E. Cow at Large</p></blockquote><p>Bessie通过一个点的条件是这个点最近的叶子到它的距离小于根到这个点的距离, 所有不能通过的点中父亲能通过的就是你会用来堵死bessie的点(农民会走到这些位置).</p><p>考虑怎么不依赖父亲, 考虑此时先拿出所有Bessie不能通过的点, 容斥出答案, 我们值希望让每个子树的和为 $1$ 即可, 于是叶子贡献 $1$, 每个点贡献负的度数减 $1$ 即可.</p><p>于是统计答案, 要对每个点 $u$ 求所有 $dis_{u, v}&gt;p_v$ 的 $v$ 的权值和, 点分治就可以了.</p><p>[think] 容斥点权使得子树和为 $1$ 相当于最上层点个数</p><blockquote><p>F. Sprinklers</p></blockquote><p>显然水和废料覆盖的分别是一个阶梯状, 要数两个阶梯状的交里放下几个矩形. 考虑直接扫描线, 因为值域 $O(n)$, 维护纵向的扫描线上每个 $y$ 坐标在扫描线有多长一段合法的, 每次移动区间加, 发现答案贡献要再维护下标和值的乘积就做完了.</p><blockquote><p>G. Out of Sorts</p></blockquote><p>考虑每个位置什么时候出现分隔点, 因为每次冒泡都让右边比 $i$ 小的元素向左移动一格, 于是可以求出冒泡次数. 于是每个位置的贡献就是两边分隔出现时间中的较大值. 于是就结束了.</p><p>不会做就拆贡献!</p><blockquote><p>H. Train Tracking</p></blockquote><p>咕咕</p><blockquote><p>I. Disruption</p></blockquote><p>这不是模板题吗! 直接并查集就能做到 $n\alpha (n)$</p><h2 id="NOIP2023模拟赛45"><a href="#NOIP2023模拟赛45" class="headerlink" title="NOIP2023模拟赛45"></a>NOIP2023模拟赛45</h2><h3 id="A-树上删边"><a href="#A-树上删边" class="headerlink" title="A. 树上删边"></a>A. 树上删边</h3><blockquote><p>有一棵 $n$ 个结点的树, 每个结点有一个权值, 删除一条边的费用为该边连接子树中结点权值最大值之和. 问以任意顺序删除树中所有边的最小花费.</p><p>$n\le 10^5$</p></blockquote><p>容易发现, 应该按照边的两个端点中大的一个排序然后依次删除. 然后为了维护这个可以倒过来加边并查集.</p><h3 id="B-欧几里得"><a href="#B-欧几里得" class="headerlink" title="B. 欧几里得"></a>B. 欧几里得</h3><blockquote><p>定于<br>$$<br>    R(a, b)&#x3D;<br>    \begin{cases}<br>    R(b, a)\ if\ a&lt;b\<br>    R(\lfloor\dfrac{a}{b}\rfloor, b)\ if\ 1&lt;b\le a\<br>    a\ if\ b&#x3D;1\end{cases}<br>$$<br>给定 $g, h$, 求任意一组 $a, b\le 10^{18}, R(a, b)&#x3D;\gcd(a, b)$</p></blockquote><p>考虑 $\gcd$ 的限制是精确的, 而 $R$ 每次是给一个范围, 于是想到从 $R(1, h)$ 往回倒退 $a, b$ 的范围, 往前一组肯定是 $R(h, x), x\in [h^2, 2h^2)$, 于是发现你可以不断对 $[h^2, 2h^2)$ 乘一个 $h$ 扩大它的范围, 然后让我们的答案分别是 $ag, bg(a&gt;b)$, 那么经过一次递归之后变成 $R(\dfrac{a}{b}, bg)$, 于是只要能找到 $bg\in [h^k, 2h^k)$, 则能算出 $ag&#x3D;hb+i(i\in (0, b))$ 使得 $gcd(ag, bg)&#x3D;g$, 容易发现 $gcd(ag, bg)&#x3D;gcd(i, bg)$, 于是直接让 $i&#x3D;(b-1)g$ 即可. 赛时没细想最后一步直接写了个 $0, b$ 范围内随也过了.</p><h3 id="C-没有上司的涨薪舞会"><a href="#C-没有上司的涨薪舞会" class="headerlink" title="C. 没有上司的涨薪舞会"></a>C. 没有上司的涨薪舞会</h3><blockquote><p>一个公司有 $n$ 名员工, $1$ 没有直接上司, 其余员工都有一个直接上司. 这样的直接上司关系构成以 $1$ 为根的有根树. 已知这颗树. 一个员工的直接下属, 指以他为直接上司的所有员&gt; 工. 一个员工的下属, 指他子树内除他以外的所有员工.</p><p>这些员工都十分渴望涨薪, 所以有些人会要求涨薪. 记 $s_i$ 为第 $i$ 个员工是否要求涨薪, “是”为 $1$, “否”为 $0$. 不知道序列 $s$.</p><p>现在所有员工都被邀请去了一个舞会. 但是并不是所有人都十分想去, 而且他们是否参加会以自己的直接下属参加情况为参考. 每个人 $u$ 都会等待自己所有下属都决定完, 然后:</p><p>若不存在直接下属决定参加舞会, 则以 $p_u$ 的概率参加舞会;</p><p>否则, 一定不参加舞会.</p><p>已知序列 $p$.</p><p>这个公司里, 每位员工都有权力和义务给自己的下属涨薪&#x2F;降薪. 在这个舞会上, 每位参加舞会的员工 $u$ 会对每个要求涨薪并且参加舞会的下属都涨薪 $a_u$. 这个值可以是负的, 因为有些人心情很差, 专门给要求涨薪的人降薪. 已知序列 $a$.</p><p>求使公司所有员工涨薪量之和期望最大的序列 $s$. 不用输出序列 $s$, 只用输出期望的大小. 保证答案在 $10^{11}$ 以内.</p></blockquote><p>期望的线性性说可以对每个点分别求祖先到它的期望. 此时你可以智慧的直接设 $f_{u, 0&#x2F;1}$ 表示 $u$ 一定来或不来时祖先造成的贡献去dp, 或者直接看成每次修改 $a_u$, 上一个矩阵优化的静态动态dp, 只要维护到根的矩阵连乘积.</p><h3 id="D-最大子段和"><a href="#D-最大子段和" class="headerlink" title="D. 最大子段和"></a>D. 最大子段和</h3><blockquote><p>给定 ${a_n}$, 每次可以选择 $p$ 让 $a_p: &#x3D;a_p-1$, 定义 $g(i)$ 表示操作 $i$ 次后最大子段和的最小值, $q$ 次求 $\sum_{i&#x3D;l}^r g(i) \pmod {10^9+7}$</p><p>$l, r\le 10^{15}, n, q\le 5\times 10^5$</p></blockquote><p>看到这个询问可以直接猜答案是 $O(n)$ 段一次函数的区间和. 但问题是一个子段和可能随着减小突然裂开成两个.</p><p>考虑二分答案转为求让答案减少到 $V$ 需要操作多少次, , 线性规划形式为</p><p>$$<br>\min_c \sum_i x_i\<br>s. t. \forall l, r\ \sum_{i&#x3D;l}^r a_i-x_i\le V\<br>x_i\ge 0<br>$$<br>标准型<br>$$<br>\min 1\cdot x\<br>Ax\ge c\<br>x\ge 0<br>$$<br>$A$ 是 $\dfrac{n(n-1)}{2}\times n$ 的矩阵, 每行对应一个区间, 这一行中属于这个区间的位置是 $1$ 其他是 $0$, $x$ 是长 $\dfrac{n(n-1)}{2}$ 的数组每个位置为 $sum-V$. 对偶之后变成</p><p>$$<br>\max c\cdot y\<br>A^Ty\ge 1\<br>y\ge 0<br>$$</p><p>那这个的意思是, 每个区间有一个 $01$ 权值, 最大化区间的权乘 $sum-V$, $y$ 中不能有两个相交的区间权值都不为 $0$. 于是转化成了 $\max t_k-kV$, 其中 $t_k$ 表示选 $k$ 个不相交的区间的和最大是多少.</p><p>此时能求出 $t$, 考虑 $k$ 个区间一定是若干个最大子段和, 用线段树维护最大子段和, 有个经典技巧是每次取走一个子段然后把它取负作为如果交上的反悔, 求出 $t$ 之后因为函数取 $\max$ 可以求一个下凸壳, 那么 $g(x)$ 表示最大子段和为 $x$ 最少需要操作几次就是这个下凸壳函数了, 而 $f$ 是 $g$ 的反函数, 对 $f$ 预处理前缀和, 区间求和即可.</p><h2 id="NOIP2023模拟赛46"><a href="#NOIP2023模拟赛46" class="headerlink" title="NOIP2023模拟赛46"></a>NOIP2023模拟赛46</h2><h3 id="A-完美主义"><a href="#A-完美主义" class="headerlink" title="A. 完美主义"></a>A. 完美主义</h3><blockquote><p>你在电脑上发现了一个长度为 $a$ 的字符串, 根据你的完美主义你需要将其长度变成 $b$.<br>你可以执行任意顺序, 任意多次的以下 $5$ 种操作:</p><ol><li>A. . . Z , 即花费一个按键的代价在字符串尾部添加一个字符, 此时所有选中会被撤销, 这与你的生活经验<br>或许有所不同, 因为平时使用时若全选了则会将字符串整个删除后添加该字符.</li><li>Ctrl + A , 即花费两个按键的代价全选所有字符.</li><li>Ctrl + C , 即花费两个按键的代价复制当前选择的字符到剪贴板, 即剪贴板中的内容是当前字符串.</li><li>Ctrl + V , 即花费两个按键的代价粘贴当前剪贴板中的内容.</li><li>Backspace , 即若全选了当前的所有字符, 则删除所有字符, 否则删除最后一个字符.<br>现在你想知道长度从 $a$ 变到 $b$ 至少需要按几次按键.</li></ol></blockquote><p>直接建图记录剪贴板长度是 $n^2$ 的.</p><p>考虑把按下剪贴板之后的一系列操作(剪贴加若干次粘贴)一起维护, 枚举这次复制之后粘贴了几次, 那么复杂度就成了 $n\ln n$</p><h3 id="B-挑战哈密顿"><a href="#B-挑战哈密顿" class="headerlink" title="B. 挑战哈密顿"></a>B. 挑战哈密顿</h3><blockquote><p>给定一张 $n$ 点完全图, 顶点编号 $1\ldots n$, 每条边是红色或蓝色, 你要以每个点为起点, 找一条尽量短的路径满足以 $u$ 为起点经过每个点至少一次, 且边的颜色最多变化一次.</p><p>$n\le 2000$</p></blockquote><p>猜测一定有恰好为 $n$ 的解.</p><p>考虑增量构造哈密顿路, 如果目前所有颜色都相同直接放到链的最后, 于是现在已经有一条链 $1\ldots x\ldots u$, 其中 $1\ldots x$ 的边颜色为 $c_1$, $x\ldots y$ 为 $c_2$, $c_1\ne c_2$, 考虑分类讨论新的点 $i$ 和原来 $p\to x\to q$ 三个点的关系.</p><p>若 $i\to q$ 为 $c_2$, 那么你可以把 $i$ 插入到 $x, q$ 之间, 不管 $x\to i$ 为什么都满足条件, 然后移动 $x$(分界点). 同理有 $i\to p$ 为 $c_1$, 于是现在只剩下 $i\to p$ 为 $c_2$, $i\to q$ 为 $c_1$, 发现若 $i\to x$ 为 $c_1$ 可以 $p\to x\to i\to q$, 为 $c_2$ 可以 $p\to i\to x\to q$, 然后移动端点.</p><p>然后有一个容易WA的点在于如果当前 $x$ 为链首或链尾, 说明整条链都是一个颜色, 要处理一下, 不然可能会把新的点插入到起点前面.</p><h3 id="C-装备"><a href="#C-装备" class="headerlink" title="C. 装备"></a>C. 装备</h3><blockquote><p><img src="/img/2023-10-27-19-03-50-image.png" alt="picture 0">  </p><p>$n\le 10^5$, $a_i$ 互不相同</p></blockquote><p>首先这个 $c_i\le n$ 说明你从后往前贪心满足是对的. 然后考虑如果要翻转 $i$ 不行, 那一定是 $b_i&#x3D;a_j$, 那么若有这种情况就连一条边 $i\to j$, 则形成一个基环树森林, 但有环的连通块都动不了, 所以只要考虑森林. 同时, $i$ 翻过去之后会让所有 $b_k&#x3D;b_i$ 不能翻.</p><p>于是你就建图找环, 然后对每个点维护 $s_i$ 表示翻转它需要再翻转几个点, 维护 $fixed_i$ 表示 $i$ 是否已经确定, 维护 $flip_i$ 表示 $i$ 是否被翻转, 模拟上面的东西即可. 维护 $s$ 要查点到根的和, 可以BIT维护dfs序.</p><p>然而这题有线性做法, 注意到一棵树只有一个装备没被使用, 而你翻转就是把没有使用的空位移动, 而 $k$ 就是移动步数.</p><h3 id="D-灵活性"><a href="#D-灵活性" class="headerlink" title="D. 灵活性"></a>D. 灵活性</h3><blockquote><p><img src="/img/2023-10-27-19-09-48-image.png" alt="picture 1">  </p><p><img src="/img/2023-10-27-19-10-09-image.png" alt="picture 2">  </p></blockquote><p>好难啊</p><p>我要把这个7k代码放在这&#x2F;oh</p><p>考虑你要求一个一开始的答案, 一个当前答案. 那么路径应该放到 $lca$ 上dp(完整包含路径的点): 设 $f_u$ 为子树内的答案, 那么考虑转移就说枚举 $u$ 上一条路径, 然后 $f_u&#x3D;\sum_{fa_i\in Path_{u, v}} <a href="f_i">i\notin Path_{u, v}</a>+w$, 考虑维护 $s_u$ 表示 $\sum_{v\in son_u} f_v$, 那么就只要求链的 $\sum s_u-f_u+f_{lca}$ 了. 最后 $f_1$ 就是答案.</p><p>而询问的答案由两部分构成, 显然建虚树, 然后一部分是虚树上所有点的 $s_u-f_u$, 另一部分是虚树根子树外的答案, 于是考虑如何处理每个点子树外的答案 $g_u$, 发现经过点 $u$ 的路径 $x\to l\to y$ 可以被用来更新 $v$, 当且仅当不经过 $v$ 的子树, 此时 $g_v&#x3D;\max g_{l}+\sum_{i\in path_{x, y}} s_i-f_i + f_l$, 则可以把这个值插入到 $x$ 和 $y$ 上, 更新一个点的儿子时就只要用子树最大值更新了.</p><p>复杂度 $n\log n$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">500</span>, H = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    ll w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Line&gt; ls[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[N];</span><br><span class="line">ll s[N], f[N], g[N], sr[N];</span><br><span class="line"><span class="type">int</span> dep[N], top[N], dfn[N], dcnt, arr[N], siz[N],fa[N],son[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    fa[u] = f;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">pre</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">if</span>(siz[v]&gt;siz[son[u]])son[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs0</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> tp)</span></span>&#123;</span><br><span class="line">    dfn[u] = ++dcnt;</span><br><span class="line">    arr[dfn[u]] = u;</span><br><span class="line">    top[u]=tp;</span><br><span class="line">    <span class="keyword">if</span>(son[u])<span class="built_in">dfs0</span>(son[u],tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==fa[u]||v==son[u])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs0</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[a]!=top[b])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[a]]&lt;dep[top[b]])<span class="built_in">swap</span>(a,b);</span><br><span class="line">        a=fa[top[a]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[a]&lt;dep[b]?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(v==u)<span class="keyword">return</span> v;</span><br><span class="line">    <span class="type">int</span> lv=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(top[v]!=top[u])</span><br><span class="line">        lv=top[v],v=fa[top[v]];</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(fa[lv]==u)res=lv;</span><br><span class="line">    <span class="keyword">else</span> res=son[u];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BIT</span> &#123;</span><br><span class="line">    ll t[N];</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, ll v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; x &lt;= n + <span class="number">1</span>; x += x &amp; -x)</span><br><span class="line">            t[x] += v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; x; x -= x &amp; -x)</span><br><span class="line">            res += t[x];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">radd</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, ll v)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(l, v);</span><br><span class="line">        <span class="built_in">add</span>(r + <span class="number">1</span>, -v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; bit;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Cmp</span>, ll DE&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span> &#123;</span><br><span class="line">    Cmp cmp;</span><br><span class="line">    ll val[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line">    <span class="function">ll <span class="title">chk</span><span class="params">(ll a, ll b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(a, b) ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        val[x] = <span class="built_in">chk</span>(val[x &lt;&lt; <span class="number">1</span>], val[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r)</span><br><span class="line">            <span class="keyword">return</span> val[x];</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        ll ans = DE;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">            ans = <span class="built_in">chk</span>(ans, <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr));</span><br><span class="line">        <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">            ans = <span class="built_in">chk</span>(ans, <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, ll v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            val[x] = <span class="built_in">chk</span>(v, val[x]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (p &lt;= mid)</span><br><span class="line">            <span class="built_in">insert</span>(x &lt;&lt; <span class="number">1</span>, l, mid, p, v);</span><br><span class="line">        <span class="keyword">if</span> (p &gt; mid)</span><br><span class="line">            <span class="built_in">insert</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, p, v);</span><br><span class="line">        <span class="built_in">pushup</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Seg&lt;greater&lt;ll&gt;, <span class="number">0</span>&gt; seg;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v);</span><br><span class="line">        s[u] += f[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Line l : ls[u]) &#123;</span><br><span class="line">        ll v = bit.<span class="built_in">ask</span>(dfn[l.u]) + bit.<span class="built_in">ask</span>(dfn[l.v]) - bit.<span class="built_in">ask</span>(dfn[u]) - bit.<span class="built_in">ask</span>(dfn[fa[u]]);</span><br><span class="line">        f[u] = <span class="built_in">max</span>(f[u], v + s[u] + l.w);</span><br><span class="line">    &#125;</span><br><span class="line">    bit.<span class="built_in">radd</span>(dfn[u], dfn[u] + siz[u] - <span class="number">1</span>, s[u] - f[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    sr[u] = sr[fa[u]] + s[u] - f[u];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u])</span><br><span class="line">        <span class="keyword">if</span> (v != fa[u])</span><br><span class="line">            <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs3</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == fa[u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        g[v] = <span class="built_in">max</span>(g[v], seg.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[u], dfn[v] - <span class="number">1</span>) - f[v]);</span><br><span class="line">        <span class="keyword">if</span> (dfn[v] + siz[v] != dfn[u] + siz[u])</span><br><span class="line">            g[v] = <span class="built_in">max</span>(g[v], seg.<span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[v] + siz[v], dfn[u] + siz[u] - <span class="number">1</span>) - f[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;pair&lt;ll, pii&gt; &gt; cannot;</span><br><span class="line">    <span class="keyword">for</span> (Line l : ls[u]) &#123;</span><br><span class="line">        ll v = sr[l.u] + sr[l.v] - sr[u] - sr[fa[u]] + f[u] + g[u] + l.w;</span><br><span class="line">        seg.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[l.u], v);</span><br><span class="line">        seg.<span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">1</span>, n, dfn[l.v], v);</span><br><span class="line">        <span class="type">int</span> a = <span class="built_in">jump</span>(l.u, u), b = <span class="built_in">jump</span>(l.v, u);</span><br><span class="line">        cannot.<span class="built_in">push_back</span>(&#123;v, &#123;a, b&#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(cannot.<span class="built_in">begin</span>(), cannot.<span class="built_in">end</span>(), greater&lt;pair&lt;ll, pii&gt; &gt;());</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u])</span><br><span class="line">        <span class="keyword">if</span> (v != fa[u])</span><br><span class="line">            l.<span class="built_in">push_back</span>(v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : cannot) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = l.<span class="built_in">begin</span>(), nt = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it = nt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nt != l.<span class="built_in">end</span>())</span><br><span class="line">                nt++;</span><br><span class="line">            <span class="type">int</span> v = *it;</span><br><span class="line">            <span class="keyword">if</span> (v != p.second.first &amp;&amp; v != p.second.second) &#123;</span><br><span class="line">                g[v] = <span class="built_in">max</span>(g[v], p.first - f[v]);</span><br><span class="line">                l.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u])</span><br><span class="line">        <span class="keyword">if</span> (v != fa[u])</span><br><span class="line">            <span class="built_in">dfs3</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> keys[N], kcnt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;u&lt;&lt;&quot; &quot;&lt;&lt;v&lt;&lt;&quot; &quot;&lt;&lt;(sr[v] - sr[u] - (s[v] - f[v]))&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> (sr[v] - sr[u] - (s[v] - f[v]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> stk[N];</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(keys + <span class="number">1</span>, keys + <span class="number">1</span> + kcnt, cmp);</span><br><span class="line">    kcnt = <span class="built_in">unique</span>(keys + <span class="number">1</span>, keys + <span class="number">1</span> + kcnt) - keys - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> anc = <span class="built_in">lca</span>(keys[<span class="number">1</span>], keys[kcnt]);</span><br><span class="line">    stk[++top]=anc;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ed (stk.size() - 1)</span></span><br><span class="line">    ll tmp = s[anc] + g[anc];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= kcnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (keys[i] == anc)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> u = keys[i], v = stk[top], l = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        <span class="keyword">if</span> (l != v) &#123;</span><br><span class="line">            <span class="keyword">while</span> (top &gt; <span class="number">1</span> &amp;&amp; dfn[stk[top - <span class="number">1</span>]] &gt; dfn[l]) &#123;</span><br><span class="line">                tmp += <span class="built_in">calc</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk[top - <span class="number">1</span>] != l) &#123;</span><br><span class="line">                tmp += <span class="built_in">calc</span>(l, stk[top]);</span><br><span class="line">                tmp += s[l] - f[l];</span><br><span class="line">                stk[top]=l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp += <span class="built_in">calc</span>(stk[top - <span class="number">1</span>], stk[top]);</span><br><span class="line">                top--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        stk[++top]=u;</span><br><span class="line">        tmp += s[u] - f[u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (top &gt; <span class="number">1</span>)</span><br><span class="line">        tmp += <span class="built_in">calc</span>(stk[top - <span class="number">1</span>], stk[top]), top--;</span><br><span class="line">    ll ans = f[<span class="number">1</span>] - tmp + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;flexibility.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;flexibility.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">int</span> m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pre</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs0</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        ls[<span class="built_in">lca</span>(u, v)].<span class="built_in">push_back</span>(&#123;u, v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ls[i].<span class="built_in">push_back</span>(&#123;i, i, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs3</span>(<span class="number">1</span>);</span><br><span class="line">    ll lans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for(int i=1;i&lt;=n;i++)cout&lt;&lt;g[i]&lt;&lt;&quot; &quot;;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) &#123;</span><br><span class="line">        cin &gt;&gt; kcnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= kcnt; j++)</span><br><span class="line">            cin &gt;&gt; keys[j];</span><br><span class="line">        keys[<span class="number">1</span>] = (keys[<span class="number">1</span>] + lans - <span class="number">1</span>) % n + <span class="number">1</span>;</span><br><span class="line">        lans = <span class="built_in">query</span>();</span><br><span class="line">        cout &lt;&lt; lans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="USACO2020-铂金"><a href="#USACO2020-铂金" class="headerlink" title="USACO2020 铂金"></a>USACO2020 铂金</h2><p>剩下的大黑题要不鸽了吧!</p><h3 id="A-Non-Decreasing-Subsequences"><a href="#A-Non-Decreasing-Subsequences" class="headerlink" title="A. Non-Decreasing Subsequences"></a>A. Non-Decreasing Subsequences</h3><p>值域很小?</p><p>可以写成dp, 预处理前缀矩阵和矩阵逆的乘积, $(n+q)k^3$.</p><p>考虑矩阵长什么样: $f_{i, a_i}&#x3D;\sum f_{i-1, k}, k&lt;a_i$, 哦所以矩阵的样子是对角线全是 $1$ 加上第 $k$ 列有一些 $1$, 那其实乘上这个矩阵是 $n^2$ 的, 因为你只需要对每个 $1$ 贡献就行了.</p><p>然后求答案的时候向量乘矩阵也是 $n^2$ 的.</p><h3 id="B-Falling-Portals"><a href="#B-Falling-Portals" class="headerlink" title="B. Falling Portals"></a>B. Falling Portals</h3><p>画出每个地方关于时间的纵坐标图像, 容易想到对着出发点分类, 考虑如果出发点比目的地高, 那你就要尽量快的下降, 也就是每次走到比自己下的快的直线就下的策略. 于是你走的一定是一个凸壳. 同时, 每条直线转移到的下一跳直线是唯一的, 考虑 $l$ 如果在 $0$ 时进入转移到 $p$, 那么如果它可以从 $q\to l$ 时不走 $p$ 而走 $q$ 只能因为 $p$ 与 $l$ 的交点在 $q$ 与 $l$ 交点之前, 但此时根据斜率关系, 发现 $p$ 与 $q$ 交点一定在 $p$ 与 $l$ 之前, 于是每条直线的转移时唯一的, 预处理后倍增的跳即可.</p><h3 id="C-Delegation"><a href="#C-Delegation" class="headerlink" title="C. Delegation"></a>C. Delegation</h3><p>难蚌, 读成了每个点在一个路径里. (不看样例的吗! )</p><p>直接multiset去把里面的都匹配起来传一个剩下的上去. 那应该把哪一个放上去是需要考虑的, 考虑如果自己这层全都匹配了放上去的是 $1$ 是最不好的, 所以如果可以就不要全部匹配, 如果当前点有偶数个儿子(可能全部匹配), 那么因为全部自己匹配是最劣的所以如果可以先把最大的能放走的的单独放走. 如果是奇数那么不可能全部匹配直接做就行了.</p><h3 id="D-Help-Yourself"><a href="#D-Help-Yourself" class="headerlink" title="D. Help Yourself"></a>D. Help Yourself</h3><p>设 $f_i$ 表示最后所有线段的并的右端点是 $i$ 的答案, 此时的困难是, 如果用区间 $[l, r]$ 转移, 对于 $i\ge l$ 我们不会做: 新的区间可能会覆盖两个原区间, 使得 $f_i$ 中两个连通块合并成一个. 此时考虑钦点一个转移顺序避免这种情况, 如果出现合并, 一定与其中至少一个区间有交, 那么考虑按 $l$ 从小到大转移, 此时可以做了, 对于区间 $[l, r]$, 所有 $f_i, i&lt;l$ 都要连通块数加 $1$ 贡献过来, $i\in [l, r]$ 直接贡献过来, $f_i, i&gt;r$ 无影响(方案数乘 $2$). 那么线段树维护即可, 次幂用斯特林数转组合数.</p><h3 id="E-Sprinklers-2-Return-of-the-Alfalfa"><a href="#E-Sprinklers-2-Return-of-the-Alfalfa" class="headerlink" title="E. Sprinklers 2: Return of the Alfalfa"></a>E. Sprinklers 2: Return of the Alfalfa</h3><p>容易发现这些中间只有一条分割线, 分割线转角处要放洒水器, 好像接下来直接dp, 设 $f_{i, j, 0&#x2F;1}$ 表示在 $i, j$ 处放一个洒水器, 分割线最后一次方向, 每次可以由往上或往左一条线求和转移过来.</p><h3 id="F-Exercise"><a href="#F-Exercise" class="headerlink" title="F. Exercise"></a>F. Exercise</h3><p>好厉害的容斥数数.</p><p>首先它肯定是让你求所有环的 $lcm$ 的积. 那你肯定要转成求指数, 又因为直接求指数不好求, 考虑算有多少种方案 $lcm$ 是 $p^k$ 的幂, $p$ 为质数.</p><p>考虑怎么在已有若干个环长 $n$ 的排列数上在添加一个长 $i$ 的环, 那么这 $i$ 个数自己有 $(i-1)!$ 种, 再拼进去有 $\binom{n}{i}$ 种.</p><p>考虑先枚举一个 $p^k&#x3D;D$, 那么是算有多少种方案包含一个大小为 $D$ 的倍数的环, 但包含太难算了考虑变成不包含的排列数 $f_n$, 但只用不包含的环大小去背包是 $n^2$ 的, 考虑再次容斥计算仅有 $D$ 的倍数构成的排列数 $g_n$, 因为这样的 $g$ 只有 $\dfrac{n}{D}$ 个, 然后容斥出 $f_n&#x3D;n! -\sum_i \binom{n}{i}f_ig_{n-i}$(总数减去包含的), 同时发现 $f$ 也只有 $\dfrac{n}{D}$ 个, 因为你要算 $f_n$ 的时候只用到 $f_i, i&#x3D;n-kD$, 再往下递归也始终是这个形式, 于是复杂度成了 $\dfrac{n^2}{d^2}$, 而 $\sum \dfrac{1}{d^2}$ 是收敛的!</p><p>最后按照之前写的拼接方式计算 $g$, 枚举包含第一个点的环长 $i$, 则方案数是 $g_n&#x3D;g_{n-i}\binom{n-1}{i-1}(i-1)!$.</p><h3 id="G-Circus"><a href="#G-Circus" class="headerlink" title="G. Circus"></a>G. Circus</h3><h3 id="H-Sleeping-Cows"><a href="#H-Sleeping-Cows" class="headerlink" title="H. Sleeping Cows"></a>H. Sleeping Cows</h3><p>上来先对 $a, b$ 排序, 这个题 $a$ 和 $b$ 匹配是对称的, 考虑从 $b$ 这一维做, 则能匹配 $b_i$ 的 $a$ 是一个前缀 $p_i$, 那么当前这个 $b$ 可以匹配一个 $a$, 也可以留空, 留空要求前面没有必须留空的 $a$, 于是可以设 $f_{i, j, 0&#x2F;1}$ 表示前 $i$ 个 $b$, $1\ldots p_i$ 中有 $j$ 个 $a$ 还没匹配但该匹配, 是否有被钦定不匹配的 $a$, 每次转移枚举这 $[p_i-p_{i-1}]$ 中的牛有多少加入匹配即可. 注意这里 $\sum p_i-p_{i-1}&#x3D;n$ 所以复杂度其实是 $n^2$ 而不是 $n^3$</p><p>更好的做法可能是把 $a$ 和 $b$ 一起排序, 一次只转移一个.</p><h3 id="I-Spaceship"><a href="#I-Spaceship" class="headerlink" title="I. Spaceship"></a>I. Spaceship</h3><p>见鬼数数</p><h3 id="J-Cowmistry"><a href="#J-Cowmistry" class="headerlink" title="J. Cowmistry"></a>J. Cowmistry</h3><h2 id="NOIP2023模拟赛47"><a href="#NOIP2023模拟赛47" class="headerlink" title="NOIP2023模拟赛47"></a>NOIP2023模拟赛47</h2><h3 id="A-药品试验"><a href="#A-药品试验" class="headerlink" title="A. 药品试验"></a>A. 药品试验</h3><blockquote><p>你在数轴上, 有 $a$ 的概率往左走一步, $b$ 的概率停在当前位置, $c$ 的位置往右走一步, 你一开始在 $n$, 走到 $0$ 或 $2n$ 停止, 求走到 $2n$ 的概率.<br>$n\le 10^7$</p></blockquote><p>直接写主元高消会因为求逆元爆炸掉.</p><p>考虑中间的部分可以矩阵快速转移, 那么直接用矩阵算出 $f_{2n}$ 关于 $f_0, f_1$ 的概率那个矩阵然后解出 $f_1$, 再直接递推 $n$ 即可.</p><h3 id="B-小猫钓鱼"><a href="#B-小猫钓鱼" class="headerlink" title="B. 小猫钓鱼"></a>B. 小猫钓鱼</h3><p>模拟</p><h3 id="C-模拟旅行"><a href="#C-模拟旅行" class="headerlink" title="C. 模拟旅行"></a>C. 模拟旅行</h3><blockquote><p>给定一张 $n$ 个点的图, 询问集合 $s$ 中的点两两距离的最小值.<br>$n\le 3\times 10^5, m\le 10^6$</p></blockquote><p>首先容易想到多源dij求每个点正着&#x2F;反着到最近的两个 $S$ 中点的距离然后做完了.</p><p>一个很好写的方法是, 考虑如果是 $S$ 中到 $T$ 中的你直接跑一遍最短路就行了, 那每次随机划分重复 $\log$ 次即可.</p><p>找到原题: P5304</p><h3 id="D-迷雾华光"><a href="#D-迷雾华光" class="headerlink" title="D. 迷雾华光"></a>D. 迷雾华光</h3><blockquote><p>求树链上众数</p><p>$n\le 8\times 10^4, q\le 10^5$</p></blockquote><p>树分块模板. 分完了就是蒲公英那个题的做法.</p><p>王氏联邦分块比随机撒点跑的快得多.</p><h2 id="NOIP2023模拟赛48"><a href="#NOIP2023模拟赛48" class="headerlink" title="NOIP2023模拟赛48"></a>NOIP2023模拟赛48</h2><h3 id="A-Chefina-与区间"><a href="#A-Chefina-与区间" class="headerlink" title="A. Chefina 与区间"></a>A. Chefina 与区间</h3><p>简单题</p><h3 id="B-小-G-的布料"><a href="#B-小-G-的布料" class="headerlink" title="B. 小 G 的布料"></a>B. 小 G 的布料</h3><blockquote><p>给定 $01$ 矩阵, 求面积 $\ge k$ 的全 $0$ 矩形个数.</p><p>$n, m\le 2000$</p></blockquote><p>预处理每个点往下连续 $0$ 的个数 $f_{i, j}$, 枚举每一行, 对 $f_i$ 建笛卡尔树, 在上面数数, 就只要算包含在一个矩形中的面积大于 $k$ 的个数了, 这个列出式子预处理即可.</p><h3 id="C-Easy-Data-Structure"><a href="#C-Easy-Data-Structure" class="headerlink" title="C. Easy Data Structure"></a>C. Easy Data Structure</h3><p>模板ddp</p><h3 id="D-LCM-Game"><a href="#D-LCM-Game" class="headerlink" title="D. LCM Game"></a>D. LCM Game</h3><blockquote><p>随机生成 $[1, n]$ 的数 $k$ 次, 求所有方案下生成的数的 $lcm$ 的和&#x2F;积.</p><p>$n\le 500, k\le 100$</p></blockquote><p>积是好做的, 直接对每个素数的幂分别算即可.</p><p>有一个经典技巧(寿司晚宴)说的是大于 $\sqrt n$ 的质数每个数只能有一个, 在最终的答案要么出现要么不出现, 而小于 $sqrt n$ 的数在这题里只有 $8$ 个, $lcm$ 有大约 $6\times 10^4$ 种. 于是考虑对每个数分解成 $lp\times bp$, 其中 $bp&#x3D;p\ge sqrt n$ 或 $bp&#x3D;1$. 则考虑对 $lp$ 的 $lcm$ 算 $bp$ 部分的lcm的乘积. 但限制 $lp$ 的 $lcm&#x3D;x$ 恰好为一个数困难, 限制 $lcm\vert x$ 的答案 $g_x$ 只要选的每个数的小质数部分都是 $x$ 的因数, 于是先算后面这种再一遍狄利克雷差分就能得到答案.</p><p>枚举 $x$ 计算 $g$, 先预处理能选的数($lp\vert x$)中 $bp&#x3D;p_i$ 的数的个数 $cnt_i$, 那么现在要求在 $[1, n]$ 中选 $k$ 个数的所有方案权值和, 一个方案的权值是它选的数中包含的 $bp$ 的乘积. 限制出现过是困难的(只能一次转移相同 $bp$ 的所有数, 复杂度 $nm$), 考虑容斥, 原来一个 $bp$ 的贡献可以看成 $([have]p+[nothave]1)&#x3D;(p+[nothave]\cdot (1-p))$, 于是把方案算成钦定 $bp$ 可以出现则乘 $bp$, 不能出现则乘 $1-bp$, 算出有 $i$ 个被钦定可以出现的方案数 $f_i$, 则答案为 $\sum f_i i^k$.</p><p>另一种容斥的理解是, 考虑原来要求的是 $\prod (p(e^{x\cdot cnt}-1)+1)$, 它可以变成 $\prod (pe^{x\cdot cnt}+(1-p))$, 这个就能算了, 对每个最后的 $e^{kx}$ 算前面的系数, 而 $n! [z^n]e^{kx}&#x3D;k^n$, 后面算每个 $e$ 前面系数的部分就是那个dp.</p><p>复杂度是 $l n^2$ 其中 $l$ 为 $lp$ 部分 $lcm$ 个数, 发现过不了, 但发现如果只看 $bp\ne 1$ 的数的 $lcm$ 就只剩不到 $1000$ 种, 于是把dp分成 $bp\ne 1$ 和 $bp&#x3D;1$ 两部分, 前面的记忆化就能过了.</p><h2 id="一些构造题"><a href="#一些构造题" class="headerlink" title="一些构造题"></a>一些构造题</h2><h3 id="A-人生的经验"><a href="#A-人生的经验" class="headerlink" title="A. 人生的经验"></a>A. 人生的经验</h3><blockquote><p><img src="/img/2023-11-01-07-52-20-image.png" alt="picture 3">  </p></blockquote><p>猜测答案是 $c^l+l-1$, 考虑如果把字符串建成点, 相邻两个字符串转移建成边, 那要求哈密顿路不会, 于是考虑把字符串表示成边, 那么可以建 $l-1$ 长度的字符串为点, 这样就是要求欧拉路径了, 而且此时可以发现一定有解.</p><h3 id="B-矩阵"><a href="#B-矩阵" class="headerlink" title="B. 矩阵"></a>B. 矩阵</h3><blockquote><p>有一个 $n\times n$ 的 $01$ 矩阵, 每次选择一个 $i\in [1, n]$, 然后记录 $c_j&#x3D;a_{i, j}$, 然后赋值 $a_{j, i}&#x3D;c_j$, 要求最后全 $1$. 最小化操作次数或判断无解.</p><p>$n\le 1000$</p></blockquote><p>如果有 $1$ 一定有解, 容易想到一定是先把一行全 $1$ 然后再把每列操作, 而全 $1$ 一行的代价首先是这行 $0$ 个数, 但是如果这行对应的列没有 $1$ 就在加上 $1$.</p><h3 id="C-Divide"><a href="#C-Divide" class="headerlink" title="C. Divide"></a>C. Divide</h3><blockquote><p>$n$ 个元素分成两组, 每个元素有属性 $a_i$, 最大化不在一组的元素 $i, j$ 满足 $a_i+a_j&gt;m$ 的对数, 求方案数</p><p>$n\le 2000, m\le 2\times 10^6$</p></blockquote><p>这谁想得到啊!</p><p>考虑直接dp不行因为你大概需要前面知道在不在一组的点中有多少能匹配. 于是你把 $a$ 重排, 使得要么前面每个元素都不可能和它构成贡献, 要么都能和它构成贡献, 于是dp只要记录前面有多少个点在A组. 但这个序列为什么一定存在呢? 考虑把原序列排序, 若 $a_1+a_n\ge m$ 则 $a_n$ 可以和中间所有元素构成贡献, 可以把 $a_n$ 拿出来放到序列最后, 若 $a_1+a_n&lt;m$ 则 $a_1$ 不能和中间任何元素构成贡献, 可以把 $a_1$ 拿出来放最后, 递归下去就构造出来了.</p><p>[trick] 可以排序序列使得对常数 $m$ 和任意 $i$, 有 $a_i+a_j&gt;m, \forall j&lt;i$ 或 $a_i+a_j&lt;m, \forall j&lt;i$ upd:乘法也可以  </p><p>有更厉害的做法!</p><p><img src="/img/2023-11-01-20-39-06-image.png" alt="picture 6">  </p><h3 id="D-Hby的旅游之都"><a href="#D-Hby的旅游之都" class="headerlink" title="D. Hby的旅游之都"></a>D. Hby的旅游之都</h3><blockquote><p>给定 $DAG(n, m)$, 给边三染色使得不存在一条路径可以连续经过 $42$ 条相同颜色的边.</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>考虑把点分成 $42$ 组, 组之间全染色成 $0$. 再把每组分成 $42$ 组递归下去, 发现 $42^3$ 成功的大于了 $n$. 这个要想对要求你走出一个组之后没有可能回到组中, 于是你可以按拓扑序上的区间分组.</p><h3 id="E"><a href="#E" class="headerlink" title="E."></a>E.</h3><blockquote><p><img src="/img/2023-11-01-19-22-54-image.png" alt="picture 4">  </p></blockquote><p>首先根据它给的结论, 猜测答案为 $n-1$.</p><p>考虑把边分为 $n-1$ 组, 则每组有 $\dfrac{n}{2}$ 条边, 每组内连续编号则一定是对的. 于是只要找完全图的 $n-1$ 组不交的匹配.</p><p>可以构造成这幅图的 $n-1$ 次旋转</p><blockquote><p><img src="/img/2023-11-01-19-28-05-image.png" alt="picture 5"></p></blockquote><h3 id="F"><a href="#F" class="headerlink" title="F."></a>F.</h3><blockquote><p>定义一个 $n\times n$ 的矩阵称为 $n$ 阶皇后矩阵, 当且仅当矩阵中的元素都取自集合 $S&#x3D;1, 2\ldots 2n-1$, 且对于每个 $i&#x3D;1, 2\ldots n$, 它的第 $i$ 行和第 $i$ 列中所有元素合起来恰好是 $S$ 中的所有元素. 请你对于给定的 $n$ 给出一个边长为 $n$ 的皇后矩阵. 当然如果你不想回答这个问题, 或确实无法构造, 你也可以退而求其次, 回答是否存在 $m$ 阶皇后矩<br>$n\le 1500$</p></blockquote><h2 id="NOIP2023模拟赛49"><a href="#NOIP2023模拟赛49" class="headerlink" title="NOIP2023模拟赛49"></a>NOIP2023模拟赛49</h2><h3 id="B-括号串"><a href="#B-括号串" class="headerlink" title="B. 括号串"></a>B. 括号串</h3><blockquote><p>构造 $n\times n$ 的空矩阵, 值域 $1\ldots n$ 使得行, 列, 主对角线中元素互不相同.</p><p>$n\le 300$</p></blockquote><p>奇数时直接 $a_{i, j}&#x3D;(i+j)\pmod n$</p><p>偶数先构造出奇数的再在上面补充.</p><p>我才不会告诉你我直接瞪着100的大样例找规律.</p><h3 id="B-括号串-1"><a href="#B-括号串-1" class="headerlink" title="B. 括号串"></a>B. 括号串</h3><blockquote><p>一开始, 一个仅包含一对括号的串即 $()$, 接下来有 $3$ 个操作, 操作分为三类:</p><ul><li>操作 $1$ , 在字符串的末尾加上一对括号, 即由 $S$ 变为 $S()$;</li><li>操作 $2$ , 在字符串的最外面套上一对括号, 即由 $S$ 变为 $(S)$;</li><li>操作 $3$ , 是撤销之前的某个操作, 清除它造成的一切影响.</li></ul><p>每次操作后, 你需要输出当前字符串能够括号匹配的非空子串数量.</p></blockquote><p>考虑把括号之间的嵌套关系建树, 顶层建一个超级根, 那么操作 $1$ 是给当前根挂一个儿子, 操作 $2$ 是给当前根挂一个父亲并成为新的根. 若只有操作 $1, 2$, 则某一时刻的答案就是每个点的 $\sum \dfrac{s_u(s_u+1)}{2}$, 其中 $s_u$ 为 $u$ 的儿子个数. 那现在有了操作 $3$, 把最终的整棵树建出来, 让被撤销的&#x2F;还没加入的点为白点, 其余点为黑点, 则显然一个点的 $s_u$ 应该指的是 $u$ 子树中到 $u$ 的路径上没有其他黑点的黑点数量, 而答案是所有黑点的贡献之和. 那么用dfs+BIT维护 $s_u$ 支持链加单点查, 再上一个数据结构支持查一个点往上最近的黑点即可. 查这个在普通树上不用lct类科技应该只能2log? 但是这个树上直接树剖就是单log.</p><p>然而不树剖直接二分+bit也过了.</p><h3 id="C-博弈"><a href="#C-博弈" class="headerlink" title="C. 博弈"></a>C. 博弈</h3><p>是Topcoder SRM700 AnyNumber</p><blockquote><p>有一个棋盘, 第 $i$ 行有 $l_i$ 个格子, 给定字符串序列 $s_n$, 你会按顺序依次把字符串放到一个随机的空格子中, 当有一行被填满时结束, 定义一个操作序列的权值为操作后这一行满格子上的字符串顺次拼接后形成的数字, 求权值期望.</p><p>$n, m, \sum s_i\le 300, \sum l_i\le n+m$</p></blockquote><p>一开始疑惑为什么要按照顺序, 因为看起来先放这个再放那个最后局面概率是一样的. 但发现有终止局面就不一样了. 于是考虑枚举结束的时间.</p><p>这个权值看起来很奇怪, 先看它怎么处理, 假设我们会处理一行的权值, 那么接下来就只要乘上 $cnt_{i, j}$ 表示没有第 $i$ 行的情况下放 $j$ 个字符串, 没有填满任何一行的方案数, 就可以合并答案了.</p><p>再枚举最后满的一行, 现在要算权值, 这个权值直接看很见鬼, 考虑把每个数字的贡献拆开算, 设字符串 $s_i$ 的实际值为 $v_i$, 长度为 $q_i$. 我们可以把其贡献表示成 $v_i\sum 10^{x}$, 那么看看能不能dp这个 $x$ 出来, 设加入 $i$ 个字符串, 其中有 $j$ 个放在当前这一行的情况下, 把这 $j$ 个拿出拼成一个序列, $\sum_T 10^{s_{T, k}}$, 其中 $s_{T, k}$ 表示方案 $T$ 下最后 $k$ 个数的 $q_i$ 之和为 $f_{i, j, k}$(换句话说, 如果新加一个字符串插入在从右往左数第 $k$ 个字符串的右边, 它应该乘上多少). 转移就是新来的字符串的位置, 其中 $(1)$ 表示这个字符被放到其它行, $(2)$ 是放在后 $k$ 个之前, $(3)$ 是放在后 $k$ 个中</p><p>$$<br>\begin{align}<br>    f_{i, j, k}&#x3D;&amp;f_{i-1, j, k}\tag{1}\<br>             +&amp;(j-k)f_{i-1, j-1, k}\tag{2}\<br>             +&amp;k\cdot f_{i-1, j-1, k-1}\cdot 10^{q_i}\tag{3}<br>\end{align}<br>$$</p><p>此时已经可以写答案了吧, 就是你枚举一个数, 枚举它的位置, 但这样复杂度应该是 $n^4$ 的. 考虑再dp, 设 $g_{i, j}$ 表示前 $i$ 个字符串, 有 $j$ 个在当前行, 发现此时加入一个数不好转移, 因为当你向这 $j$ 个数中间插入一个数时, 会让一个前缀乘上 $10^{q_i}$, 于是考虑把前缀也设进去: $g_{i, j, k}$ 表示前 $i$ 个字符串, 有 $j$ 个在当前行, 把它们拼成一个序列, 在所有方案下, 前 $k$ 个元素的贡献和是多少(比如前 $k$ 个元素种有一个元素在一种方案下为 $x$, 它后面总长为 $y$, 那么它会产生 $x10^y$ 贡献), 此时就可以列转移了.</p><p>$$<br>\begin{align}<br>    g_{i, j, k}&amp;&#x3D;g_{i-1, j, k}\tag{1}\<br>             &amp;+kg_{i-1, j-1, k-1}\tag{2}\<br>             &amp;+\sum_{l&lt;k} k{i-1, j-1, l}(10^{q_i}-1)\tag{3}\<br>             &amp;+\sum_{l\in [j-k, j)} f_{i-1, j-1, l}v_i\tag{4}<br>\end{align}<br>$$</p><p>$(1)$ 表示不选, $(2)$ 是去掉这个元素的贡献, $(3)$ 是选上这个元素后, 有一些元素的贡献因为插入了它变大, $(4)$ 是这个元素自身在每个位置的贡献之和.</p><p>$f, g$ 用滚动数组优化都是 $n^3$, 前面那个枚举处理 $cnt$ 也是 $n^3$, 合并答案 $n^2$, 总复杂度 $n^3$, 注意合并答案时要强制当前元素在这一行被选(只要在贡献 $g_i$ 时差分掉 $g_{i-1}$ 的即可).</p><h3 id="D-平面树"><a href="#D-平面树" class="headerlink" title="D. 平面树"></a>D. 平面树</h3><blockquote><p><img src="/img/2023-11-02-20-43-59-image.png" alt="picture 7">  </p><p>$n\le 3\times 10^5, q\le 6\times 10^6$</p></blockquote><p>考虑先预处理, 把一条边的代价重置为从这条边左边到这条边右边的最小代价, 这个可以两遍dfs实现, 跨过一条边的方式包括跨过子树的所有儿子, 跨过它, 跨过所有兄弟和父亲三种.</p><p>然后设状态为 $f_{u, 0&#x2F;1, 0&#x2F;1}$ 表示从这条边的左右侧转移到父边的左右侧要加的代价, 这个转移可以写成矩阵, 然后查询时你就从两个点先转移到lca, 然后合并答案即可.</p><p>复杂度是单log吧.</p><h2 id="NOIP2023模拟赛50"><a href="#NOIP2023模拟赛50" class="headerlink" title="NOIP2023模拟赛50"></a>NOIP2023模拟赛50</h2><h3 id="A-点分治"><a href="#A-点分治" class="headerlink" title="A. 点分治"></a>A. 点分治</h3><blockquote><p><img src="/img/2023-11-04-14-56-14-image.png" alt="picture 8"><br><img src="/img/2023-11-04-14-56-26-image.png" alt="picture 9">  </p></blockquote><p>容易发现从小到大排列后, $v_i$ 就是祖先分别是 $solve$ 几级别的树.</p><p>那么设 $f(u, d)$ 表示级别 $u$ 的树中深度为 $x$ 的点有多少, 发现它就是组合数. 那就简单了, 显然答案就是这个点为根的答案加上祖先们到它的距离, 而 $u$ 的祖先的答案 $g(u, d)&#x3D;g(fa, d-1)+f(fa, d-1)-f(fa, d-2)$.</p><p>没特判 $f(u, d), d&lt;0$ 的情况挂成5分.</p><h3 id="B-塔"><a href="#B-塔" class="headerlink" title="B. 塔"></a>B. 塔</h3><p>这个是CF354D</p><p>怎么是黑的啊</p><p>感觉dp基本功不行啊, 上来先想到你看设计成 $S+2$ 而不是 $aS+b$ 肯定有点意义吧, 于是如果你要用第二种法术, 必然要保证 $S+2\le 3k$, 于是你可能用第二种法术的高度是根号级的. 然后就不会了?</p><p>好吧可以直接dp的啊, 但你应该从左往右dp而不是见鬼的按行做或按点做, 因为把三角形摆正后, 这个修改是直角三角形, 然后就直接 $n\sqrt n$ 了.</p><h3 id="C-军队"><a href="#C-军队" class="headerlink" title="C. 军队"></a>C. 军队</h3><blockquote><p><img src="/img/2023-11-04-15-14-27-image.png" alt="picture 10"><br>$n, m, c\le 3\times 10^5, k\le 10$</p></blockquote><p>什么缝合破题.</p><p>第一部分显然直接线段树维护前 $k$ 小个数. 算出每一行的.</p><p>第二行显然按照每行中雌雄个数中较小的排序, 前缀和.</p><h3 id="D-最优化"><a href="#D-最优化" class="headerlink" title="D. 最优化"></a>D. 最优化</h3><blockquote><p><img src="/img/2023-11-04-15-16-45-image.png" alt="picture 11">  </p><p>$n\le 300, q\le 10^5$</p></blockquote><p>感觉这个是现有算法后有题类.</p><p>考虑你要求一个图的链覆盖, 先考虑dag最小链覆盖怎么做, 就拆点跑网络流, 也就是 $s\to u, u+n\to v$, 若 $u\to v$ 则连 $u\to v+n$, 去跑匹配. 这个是不允许路径有交的, 如果允许有则先传递闭包(对任意 $u\Longrightarrow v$(可到达)则连边 $u\to v+n$).</p><p>然后这个为什么不能做一般图链覆盖呢? 因为一般图下会成环, 但这个题允许成环, 且这个 $+C$ 的共线可以看成(点数减边数), 于是发现这简直是为这个算法量身定做的, 于是你直接暴力求出流量为 $i&#x3D;1\ldots n$ 的答案 $f_i$ 然后对每个 $c$ 计算 $\min (n-i)c+f_i$ 即可.</p><h2 id="CCPC-Online-2023"><a href="#CCPC-Online-2023" class="headerlink" title="CCPC Online 2023"></a>CCPC Online 2023</h2><p>大多数题都不难啊&#x2F;fn</p><p>其中比较有趣的:</p><h3 id="C-Clique-Challange"><a href="#C-Clique-Challange" class="headerlink" title="C. Clique Challange"></a>C. Clique Challange</h3><blockquote><p>$Graph(n, m)$ 求团个数, $n, m\le 1000$</p></blockquote><p>NPC, 但是复杂度是 $\sqrt m1. 414^{\sqrt {2m}}$</p><p><img src="/img/2023-11-04-16-17-09-image.png" alt="picture 12">  </p><h3 id="J-Find-the-Gap"><a href="#J-Find-the-Gap" class="headerlink" title="J. Find the Gap"></a>J. Find the Gap</h3><blockquote><p>给 $50$ 个点, 求最近的两个平面把它们夹住</p></blockquote><p>以为一定是与某三个点平行的, 但不对</p><p>考虑正四面体, 其最优情况是两条对角线.</p><p>于是正解是异面直线的情况和三个点确定的情况.</p><p>特判所有点在一条直线上(叉乘总为 $0$)</p><h3 id="H-Hurricane"><a href="#H-Hurricane" class="headerlink" title="H. Hurricane"></a>H. Hurricane</h3><blockquote><p>给定稀疏图, 求补图上长度分别为 $1$ 到 $n-1$ 的简单路径数<br>$n, m\le 2\times 10^5$</p></blockquote><p>考虑如果两个点度数之和小于 $n$, 那么答案不超过 $2$ 啊.</p><p>于是把点分成度数超不超过 $n&#x2F;2$ 的两类, 第一类的直接答案填 $2$, 第二类对每个点bfs. bfs的话可以维护两个集合, 一个和当前点相连一个不相连就行了.</p><h3 id="I-Monster-Generator"><a href="#I-Monster-Generator" class="headerlink" title="I. Monster Generator"></a>I. Monster Generator</h3><blockquote><p>你要打 $m$ 天怪, 有 $n$ 个怪, 每天独立(你都要把它们打一遍), 第 $k$ 天打第 $i$ 个怪会失去 $a+bk$ 点体力, 打完了会获得 $c+dk$ 点体力, 你的体力不能小于 $0$. 问你每天开始时的最小体力.</p><p>$n\le 100, m\le 10^{18}$</p></blockquote><p>长得一脸贪心, 考虑一天的怎么做, 把怪分成两类, 一类是打完体力上升, 一类是打完下降, 那么你显然上升的从小往大打, 下降的从小往大打即可.</p><p>那么当 $m$ 很大的时候, 你就直接处理情况变化的时间即可.</p><h3 id="L-Partially-Free-Meal"><a href="#L-Partially-Free-Meal" class="headerlink" title="L. Partially Free Meal"></a>L. Partially Free Meal</h3><blockquote><p>给定 $n$ 对 $(a_i, b_i)$, 对每个 $k$ 最小化 $\sum_{i\in S} a_i+\max_{i\in S} b_i\ s. t. \ \vert S\vert &#x3D; k$.</p><p>$n\le 2\times 10^5, a, b\le 10^9$</p></blockquote><p>按 $b$ 排序, 对于一个固定的 $k$ 显然答案是某个位置前的前 $k-1$ 小, 可以主席树.</p><p>当要对每个 $k$ 做时, 发现决策单调性, 更大的 $b$ 只在更大的 $k$ 时有用, 于是上个分治即可.</p><h3 id="K-Sequence-Shift"><a href="#K-Sequence-Shift" class="headerlink" title="K. Sequence Shift"></a>K. Sequence Shift</h3><blockquote><p>给定 $a_1\ldots a_n, b_1\ldots b_n$, 每次操作为把 $b$ 循环左移并设置 $b_n$, 询问 $\max a_i+b_i$.</p><p>$n, q\le 10^6$, 数据随机</p></blockquote><p>好强悍的东西.</p><p>说的是, 离线, 然后你选择一个 $k$, 记录 $a_k+b_k&#x3D;lim$, 然后每次移动后先枚举 $a_i+b_n\ge lim$ 的数算贡献更新对应的 $ans$, 那么吸纳然如果一个询问更新到了答案就是对的, 否则你暴力计算. 那 $k$ 选大了更新的复杂度爆炸, 选小了暴力的复杂度爆炸, 于是它开始平衡复杂度: 先算期望对数 $E&#x3D;\dfrac{k^2(n+m^2)}{2nm}$, 然后算暴力的复杂度 $(m-n+1)n(1-\dfrac{E}{nm})^n$, 然后加起来求导, 最后接出来 $k&#x3D;\dfrac{m}{n+m}\sqrt {2n\log \dfrac{nq}{m}}$</p><h2 id="NOIP2023模拟赛51"><a href="#NOIP2023模拟赛51" class="headerlink" title="NOIP2023模拟赛51"></a>NOIP2023模拟赛51</h2><h3 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h3><p>是AGC027E</p><blockquote><p>给定一个只含小写字母 $\mathtt{a}, \mathtt{b}$ 的字符串 $s$, 每次你可以执行以下两种操作:</p><ol><li>选取 $s$ 中连续的两个字符 $\mathtt{aa}$, 把它们删去, 替换成一个字符 $\mathtt{b}$.</li><li>选取 $s$ 中连续的两个字符 $\mathtt{bb}$, 把它们删去, 替换成一个字符 $\mathtt{a}$.</li></ol><p>请你求出执行若干次操作后, 能够得到的本质不同的字符串有多少个, 答案对 $({10}^9 + 7)$ 取模.</p><ul><li>$1 \le \vert s\vert \le {10}^5$.</li></ul></blockquote><p>考虑赋权看操作不改变什么, $v(a)&#x3D;1, v(b)&#x3D;2$, 则不改变模 $3$ 的值, 且若 $s$ 不是 $ab$ 交替的串, 则任意一段可以合并成等于它的和模 $3$ 的一个字符. 于是直接dp就行了.</p><h3 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h3><blockquote><p>给定简单图 $Graph(n, m)$, 保证 $1$ 不为割点且每个点到 $1$ 有连边, 对每个 $k$ 求 $1$ 的度数为 $k$ 时的答案.</p><p>$n\le 3\times 10^5$</p></blockquote><p>最容易想到的是按照每条边对答案的贡献(权值减换掉的那条的权值)排序后替换, 但问题是替换前面的会影响后面的, 暴力更新复杂度也是错的.</p><p>另一种方法是在 $n-1$ 个点 MST 上dp, 设 $f_{u, i}$ 表示 $u$ 内选 $i$ 个点和 $1$ 连通的答案, 这个 $v$ 转移到 $u$ 只要枚举是否连 $1\to u, 1\to v, u\to v$. 直接做复杂度是树上背包 $n^2$, 但经典结论是它是凸的, 于是闵和合并+分治+树上启发式合并.</p><p>最简单的方法是考虑kruskal重构树, 两个点之间的最大值是它们的lca, 那么某一次你会删掉 $u\to v$, 然后剩下的情况你不会删掉跨过 $u, v$ 的连通块的边, 也就是kruskal重构树的子树内的子问题, 于是就不用考虑删边影响未删的边的贡献了.</p><h3 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h3><blockquote><p>一棵 $n$ 点树, 每个点上有一个BST, 每次给一条路径上插入一个值 $k$ 或询问单个节点中查询 $k$ 时 $k$ 到BST中根的点的权值和.</p><p>$n, q\le 2\times 10^5, k$ 互不相同</p></blockquote><p>碰到这种数据结构你第一反应应该是枚举扫描线方向和把BST结构搞清楚, 这种问题肯定是扫序列维维护时间的.</p><p>于是你发现把权值排序后, BST中一个点的父亲是前驱&#x2F;后继中晚插入的那个, 另外会发现两边对 $x$ 的贡献是独立的, 就是左边的答案就是不断跳比当前节点早插入的节点中的前驱, 右边同理.</p><p>对于序列上, 问题变成插入删除点 $(k, time_k)$ 和求答案, 答案是跟前缀后缀min相关的, 所以上一个值域上的楼房重建线段树. 假设要求往右跳的贡献, 设 $calc(l, r, k)$ 表示区间 $l, r$ 中 $time&lt;k$ 的 $time$ 前缀min的 $k$ 之和, 则若 $d&#x3D;\min_{i\le mid} time_i, d&gt;k$ 那直接跳到右边了, 否则就是 $calc(l, mid, k)+calc(mid+1, r, d)$, 维护 $calc(mid+1, r, d)$ 即可.</p><p>现在求树上, 线段树合并就行了.</p><h3 id="D"><a href="#D" class="headerlink" title="D."></a>D.</h3><p>就是 UOJ Round#6 懒癌</p><p>好难todo</p><h2 id="NOIP2023模拟赛52"><a href="#NOIP2023模拟赛52" class="headerlink" title="NOIP2023模拟赛52"></a>NOIP2023模拟赛52</h2><h3 id="A-区间"><a href="#A-区间" class="headerlink" title="A. 区间"></a>A. 区间</h3><blockquote><p>给定 $n$ 个区间 $[l_i, r_i]$, 要求选出尽可能多的区间对使得任意每对中两个区间不交, 区间只能被选一次.</p><p>$n\le 4\times 10^5$</p></blockquote><p>就是让你求一个图的匹配, 方法是如果一个点</p><h3 id="B-排序"><a href="#B-排序" class="headerlink" title="B. 排序"></a>B. 排序</h3><blockquote><p>给定排列 $p_n$, 每次可以把 $a_l, a_{l+1}, \ldots a_r$ 重排成 $a_{l+1}, a_{l+3}\ldots a_l, a_{l+2}\ldots$, 构造在 $2n$ 次内使排列升序.</p><p>$n\le 3000$</p></blockquote><p>首先你会冒泡, 然后你会看怎么能快速移动一个节点的位置, 原问题上不好考虑, 考虑操作反过来做后问题是等价的(对排列置换), 那么反过来后你可以把 $\dfrac{n}{2}$ 左边的元素 $x$ 最大移动到 $2x$, 否则你可以移动到最后, 然后移动一个数需要 $\log {n}-\log i+1$ 次, 而这个期望是常数. 所以你先随机操作打乱排列然后去做即可.</p><p>[trick] $\log n-\log i+1$ 期望 $O(1)$</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><blockquote><p>给定字符串 $S$. 对于一个字符串, 你可以选择一个起点然后每次走到相邻的点, 不能走出字符串, 你必须走出一个回文且不能回到起点. 一个字符串合法当且仅当可以走任意次使路径把字符串覆盖, 区间询问子串是否合法.</p><p>$n, q\le 10^6$</p></blockquote><p>首先看什么样的字符串是合法的, 发现包含长度为 $3$ 的回文合法(走 $a_1ba_2xx\ldots a_2ba_2$ 可以覆盖掉一边, 再来一次可以覆盖掉另一边), 而如果不包含发现奇回文不能令你回头, 那么如果只有偶回文你只能一直走, 也就是另一种合法是字符串被回文覆盖.</p><p>那么第一种显然好判断, 考虑怎么判第二种, 对于一个点 $i$, 处理出它左右最近的覆盖到它的回文中心, 那么一个点被覆盖是限制(左端点小于某个值或右端点大于某个值), 那么不能覆盖的就是一个2side矩形, 发现于是每个点给区间的限制是一个 $4side$ 矩形不能选, 就是矩形加单点查了.</p><h3 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h3><blockquote><p>求有多少个 $a_n$ 满足 $\forall i\in[1, m], \mathrm{lcm}(a_{x_i}, a_{y_i})&#x3D;b_i$.</p><p>$n\le 38$</p></blockquote><p>首先观察到对每个质因子独立.</p><p>现在对于单个质因子就是给你一张图, 然后要求每条边连的两个点中的最大值等于某值, 那么显然如果一个点连了好几个边不是最小值的都可以直接确定另一个点是几, 然后形成若干连通块, 每个连通块边权相等设为 $v$, 那么没取到 $v$ 的点必须构成独立集, 一个独立集 $S$ 的权值为 $(v-1)^{\vert S\vert}$, 那么预处理每个点的相邻点集合, 折半 $2^{\frac{n}{2}}$ 搜一边, 合并就是 FWT 的或卷积.</p><h2 id="div1-杂题"><a href="#div1-杂题" class="headerlink" title="div1-杂题"></a>div1-杂题</h2><h3 id="SNOI2019-纸牌"><a href="#SNOI2019-纸牌" class="headerlink" title="[SNOI2019] 纸牌"></a>[SNOI2019] 纸牌</h3><blockquote><p>有一副纸牌. 牌一共有 $n$ 种, 分别标有 $1, 2, . . . , n$ , 每种有 $C$ 张. 故这副牌总共有 $nC$ 张.</p><p>三张连号的牌 $(i, i+1, i+2)$ 或三张相同的牌 $(i, i, i)$ 可以组成一<strong>叠</strong>. 如果一组牌可以分成若干(包括零)<strong>叠</strong>, 就称其为一组<strong>王牌</strong>.</p><p>你从牌堆中摸了一些初始牌. 现在你想挑出一些牌组成一组王牌, 请问有多少种可能组成的王牌呢? 答案对 $998244353$ 取模.</p><p>两组牌相同当且仅当它们含有的每一种牌数量都相同.</p><p>对于所有数据, $1\leq n\leq 10^{18}, 0\leq a_i\leq C\leq 1000, 0\leq X\leq 1000$ . 注意 $a_i$ 和 $C$ 可能为 $0$ .</p></blockquote><p>直接想dp, 假设覆盖你要怎么做? 你发现以 $i$ 为右端点的操作你需要知道 $i-1$ 和 $i-2$ 都多少, 然后丢给下一位, 于是就dp $f_{i, j, k}$ 表示前 $i$ 种牌, $i, i-1$ 分别有多少, 矩阵加速一下即可.</p><p>upd: 感觉这么设状态不如设 $f_{i, j, k}$ 表示 $j, k$ 分别被操作了多少, 因为这个只用关于第 $i$ 位考虑, 而之前那种和前两位也有关.</p><h3 id="SNOI2019-字符串"><a href="#SNOI2019-字符串" class="headerlink" title="[SNOI2019] 字符串"></a>[SNOI2019] 字符串</h3><blockquote><p>给定字符串 $s_n$, 求删掉第 $i$ 位的字符串 $s_i$ 按字典序排序后的序列.</p><p>$n\le 10^6$</p></blockquote><p>直接sort, 那你只要想怎么比较两个字符串, 则删掉 $i$ 的和删掉 $j$ 的你就要比较 $s_{i+1\ldots j}$ 和 $s_{i, j-1}$ 的字典序, 你冲动的写了一发SA, 然后发现因为你只要比较相邻两后缀, 直接预处理 $a_i$ 表示 $s_i, s_{i+1}$ 的大小关系, 就是找到第一个不是等于的.</p><h3 id="SNOI2019-数论"><a href="#SNOI2019-数论" class="headerlink" title="[SNOI2019] 数论"></a>[SNOI2019] 数论</h3><blockquote><p>给出正整数 $P, Q, T$, 大小为 $n$ 的整数集 $A$ 和大小为 $m$ 的整数集 $B$, 请你求出:</p><p>$$\sum_{i&#x3D;0}^{T-1}[(i \in A (mod P) \wedge (i \in B (mod Q)]$$</p><p>换言之, 就是问有多少个小于 $T$ 的非负整数 $x$ 满足: $x$ 除以 $P$ 的余数属于 $A$ 且 $x$ 除以 $Q$ 的余数属于 $B$.</p><p>对于所有数据, $1 \leq n, m \leq 10^6 , 1 \leq P, Q \leq 10^6 , 1 \leq T \leq 10^{18}$.</p></blockquote><p>考虑直接硬上, 枚举 $A$ 中的元素 $a$, 则表示 $x&#x3D;kP+a$, 那么要 $kP+a&#x3D;b \bmod Q$, $kP&#x3D;(b-a)$ 这个怎么解, 考虑如果有两个解那么 $(k_1-k_2)P&#x3D;0$ 则两个解的差就是 $d&#x3D;\dfrac{Q}{\gcd(P, Q)}$, 然后你可以枚举 $k$ 预处理出每个 $v&#x3D;b-a$ 最小的解 $s_v$, 另外可能的 $k$ 显然最大是 $\dfrac{T-a-1}{P}$, 现在变成要求</p><p>$$<br>\begin{gathered}<br>\sum_{a\in A} \sum_{b\in B} \dfrac{\dfrac{T-a-1}{P}-v_{b-a}}{d}\<br>\end{gathered}<br>$$<br>然后这个式子你可以对每个 $b-a$ 求出 $\sum \dfrac{T-a-1}{P}$, 啊不会了因为下取整你不能直接把他们加起来. 但是注意 $\dfrac{T-a-1}{P}$ 最多有两种取值($a&lt;P$), 所以就分别对每个 $b-a$ 求两种取值的个数(把 $a$ 分成两类分别贡献), 而统计这个你只需要NTT.</p><p>什么? 这其实不是NTT题&#x2F;kx枚举 $a$ 之后, 你不是每次走 $P$ 吗, 这会形成若干环, 可以直接预处理每个环走 $k$ 步经过的所有 $b$.</p><h3 id="SNOI2019-积木"><a href="#SNOI2019-积木" class="headerlink" title="[SNOI2019] 积木"></a>[SNOI2019] 积木</h3><blockquote><p>有一块 $n$ 行 $m$ 列的网格板, $n, m$ 都是奇数. 网格上平铺着一些 $1\times 2$ 的积木. 积木可以旋转, 不能重叠. 这些积木共有 $\frac{nm-1}{2}$ 块, 也就是说, 网格板上只有一格的空位.</p><p>你可以做两种操作:</p><ol><li>将一块与空白格相邻(指有公共边)的积木旋转 $90^\circ$ 到空白格中;</li><li>将一块与空白格积木相邻的积木平移至空白格中.</li></ol><p>如图所示(被移动的积木颜色较浅):</p><p><img src="https://cdn.luogu.com.cn/upload/pic/58669.png"></p><p>请你用以上两种操作将给定的网格板变换为指定的状态.</p><p>对于所有数据, $1\leq n, m\leq 2000$.</p></blockquote><p>要勇于尝试! 长成这样不一定是不可做题.</p><p>你发现你每次可以把格子附近一个长方形放到正确的位置, 不断重复你会走到目标空格, 那么你的空格停下当且仅当旁边的所有格子都是正确的, 所以唯一可能的停止位置是目标位置, 但可能有些位置不在你走到目标的路径上, 你就直接胡乱把它移动过去然后用刚才的办法让它一路调整回来.</p><h3 id="SNOI2019-通信"><a href="#SNOI2019-通信" class="headerlink" title="[SNOI2019] 通信"></a>[SNOI2019] 通信</h3><blockquote><p>$n$ 个排成一列的哨站要进行通信. 第 $i$ 个哨站的频段为 $a_i$.</p><p>每个哨站 $i$ 需要选择以下二者之一:</p><ol><li>直接连接到控制中心, 代价为 $W$;</li><li>连接到前面的某个哨站 $j$($j&lt;i$), 代价为 $\vert a_i-a_j \vert$.<br>每个哨站只能被后面的至多一个哨站连接.</li></ol><p>请你求出最小可能的代价和.</p><p>对于所有数据, $1 \leq n \leq 1000$, $0 \leq W, a_i \leq 10^9$.</p></blockquote><p>首先把你的dp放下拿起网络流. . .</p><p>然后你会很快建一个模, 大概是 $S \stackrel{1, 0}{\longrightarrow} i, i \stackrel{1, w}{\longrightarrow} t, i’\stackrel{1, 0}{\longrightarrow}t, i \stackrel{1, \vert a_i-a_j\vert }{\longrightarrow}j’$</p><p>然后你的边数显然爆炸了, 要优化 $i\to j$ 的连边, 发现这是个二维数点, 在你前面的限制和 $a$ 的限制, 那么只好用二维数据结构, 拿主席树优化建图应该是最好的, 当然还可以分块和KDT.</p><h3 id="SNOI2019-网络"><a href="#SNOI2019-网络" class="headerlink" title="[SNOI2019] 网络"></a>[SNOI2019] 网络</h3><blockquote><p>有 $n$ 个数据中心, 编号为 $1, 2, ……, n$. 它们被 $n-1$ 条光缆连通, 形成一棵树.</p><p>每条光缆传输数据时有 $1$ 单位时间的延迟, 两个数据中心之间的延迟为连接它们的光缆的延迟之和.</p><p>现在要在这 $n$ 个数据中心中选若干个作为通讯站, 要求任意两个通讯站之间的延迟不超过 $d$. 设选出的通讯站为 ${w_1, w_2, ……, w_k}$, 则通讯总延迟为这 $k$ 个通讯站两两之间的延迟之和.</p><p>现在有 $q$ 次询问, 每次选定一个数据中心 $u$, 你需要求出: 如果 $u$ 是一个通讯站, 最大可能的通讯总延迟是多少.</p><p>对于所有数据, $1 \leq n \leq 5*10^5 , 0 \leq d&lt;n , 0 \leq q \leq 10$.</p></blockquote><p>你最后的答案一定是一个以包含 $u$ 的直径不超过 $d$ 的极大连通块, 那你可以预处理出每个点&#x2F;边为直径中心的答案, 那你要合并 $u$ 的子树外和 $u$ 的子树内, 你需要满足条件的点各自到 $u$ 的距离和, 各自内部的距离和, 各自的点数, 因为距离就是深度子树内的你直接长剖, 合并的时候就都有了, 子树外的答案可以换根扫一遍, 你现在在一个节点, 先把所有轻子树的信息合并上去然后递归重链, 然后再对每个轻子树删去它们的信息并递归轻链, 这样你复杂度也是线性的.</p><h2 id="Div2是DP和数数专场"><a href="#Div2是DP和数数专场" class="headerlink" title="Div2是DP和数数专场"></a>Div2是DP和数数专场</h2><h3 id="CF294C-A-Shaass-and-Lights"><a href="#CF294C-A-Shaass-and-Lights" class="headerlink" title="CF294C A. Shaass and Lights"></a>CF294C A. Shaass and Lights</h3><p>考虑没点亮的若干连续段, 段间独立, 段内是每一步从左边点还是右边点.</p><h3 id="CF1753C-Wish-I-Knew-How-to-Sort"><a href="#CF1753C-Wish-I-Knew-How-to-Sort" class="headerlink" title="CF1753C Wish I Knew How to Sort"></a>CF1753C Wish I Knew How to Sort</h3><p>只考虑 $0$, 你就是要将前若干个变成 $0$, 设 $0$ 的个数为 $c$, $f_i$ 为前 $c$ 位有 $i$ 个 $0$ 的期望时间, 则 $f_c&#x3D;0$, $f_i&#x3D;f_{i+1}\dfrac{(c-i)^2}{tot}+f_i\dfrac{1-(c-i)^2}{tot}$ 就行了.</p><h3 id="CF660E-Different-Subsets-For-All-Tuples"><a href="#CF660E-Different-Subsets-For-All-Tuples" class="headerlink" title="CF660E Different Subsets For All Tuples"></a>CF660E Different Subsets For All Tuples</h3><blockquote><p>对于 $a_n, a_i\in [1, m]$, 求所有的 $a_n$ 的本质不同子序列个数的和.<br>$n, m\le 10^6$</p></blockquote><p>考虑计数包含某个特定子序列的序列有多少种, 为了让这个不重, 假设这个子序列是原序列的第一个等于该值的子序列, 于是若子序列是 $t_k$, 原序列是 $a_n$, 子序列第 $i$ 个元素的位置是 $p_i$, 则 $1\ldots p_1-1$ 的位置不能有 $p_1, p_1+1\ldots p_2-1$ 的位置不能有 $p_2$, 也就是 $p_k$ 之前的方案数是 $(m-1)^{p_k-k}$, 之后的是 $m^{n-p_k}$, 于是直接枚举 $p_k$, 要求<br>$$<br>\begin{gathered}<br>\sum_k m^k \sum_p m^{n-p}(m-1)^{p-k}\binom {p-1}{k-1}\<br>&#x3D;\sum_k \sum_p m^{n+k-p}(m-1)^{p-k}\binom {p-1}{p-k}\<br>&#x3D;\sum_{d&#x3D;p-k} m^{n-d}(m-1)^d\sum_p \binom{p-1}{d}<br>&#x3D;\sum_{d} m^{n-d}(m-1)^d \binom{n}{d+1}<br>\end{gathered}<br>$$<br>最后一步是组合数列前缀和.</p><h3 id="CF785D-Anton-and-School-2"><a href="#CF785D-Anton-and-School-2" class="headerlink" title="CF785D Anton and School - 2"></a>CF785D Anton and School - 2</h3><blockquote><p>给定一个长度为 $n$ 的括号序列, 求该括号序列满足如下条件的子序列个数:</p><ol><li>长度为正偶数</li><li>假设该子序列长度为 $2m$, 则该子序列前 $m$ 个均为 <code>(</code>, 后 $m$ 个均为 <code>)</code>.</li></ol><p>对 $10^9+7$ 取模.</p><p>$n \le 2 \times 10^5$.</p></blockquote><p>考虑枚举这个子序列的中心的那个左括号, 就是 $\sum_m \binom{p_i}{m-1}\binom{s_i}{m}&#x3D;\sum_m \binom{p_i}{m-1}\binom{s_i}{s_i-m}&#x3D;\binom{p_i+s_i}{s_i-1}$, 范德蒙德卷积</p><h3 id="CF1540B-Tree-Array"><a href="#CF1540B-Tree-Array" class="headerlink" title="CF1540B Tree Array"></a>CF1540B Tree Array</h3><blockquote><p>给定一棵 $n$ 个节点的树.<br>对于这棵树, 我们通过下列方法来生成一个序列:</p><ol><li>等概率选择这 $n$ 个节点中的一个节点, 并对这个节点打上标记(初始时没有节点被打上标记);</li><li>在所有没被打上标记且与至少一个打上标记的节点相连的节点中等概率选择一个节点并对这个节点打上标记;</li><li>重复步骤 2 直到所有节点都被打上标记, 此时生成的序列就是所有节点编号按照节点被打上标记的时间排序后的形成的序列.</li></ol><p>求生成序列的期望逆序对数对 $10^9+7$ 取模后的值.<br>$2\leq n\leq200;$ 给出的是棵树.</p></blockquote><p>用老套路, 逆序对数就是两个数逆序的概率之和, 然后你可以枚举一个根, 然后如果是祖先关系贡献确定了, 否则考虑不是祖先关系, 那么只考虑影不影响选他俩的概率这件事上, 发现只和他俩之间链上的点有关, 设两个点到 $lca$ 的距离分别为 $a, b$, 枚举 $a$ 删除的时间 $i$</p><p>$$<br>\sum_{i&#x3D;0}^{a+b} \binom{i-1}{a-1}\dfrac{1}{2^i}<br>$$</p><p>就做完了啊</p><p>吐槽题解区为啥一页全都是dp求上面按个概率.</p><h3 id="CF1716F-Bags-with-Balls"><a href="#CF1716F-Bags-with-Balls" class="headerlink" title="CF1716F Bags with Balls"></a>CF1716F Bags with Balls</h3><blockquote><p>这里有 $n$ 个袋子, 每个袋子里面有 $m$ 个带有从 $1$ - $m$ 标记的球. 对于每一个 $1\le i \le m$ 来说, 每个袋子中都一定存在一个带有 $i$ 标记的球.</p><p>你需要在每个袋子中取出一个球 ( 所有的袋子都是不同的, 比如在 $1$ 号袋子取 $2$ 号球 并且从 $2$ 号袋子里取 $1$ 号球 与 从 $1$ 号袋子取 $1$ 号球并且从 $2$ 号袋子取 $2$ 号球是不同的两种方案 ) 然后计算出你取出的标号是奇数的球的数量, 记这个数量为 $F$.</p><p>你的任务是计算所有可能的取球方案的 $F^k$ 之和.</p><p>$n, m\le 998244352, k\le 2000$</p></blockquote><p>你只关心奇数的数量, 所以一个可以先把 $m$ 扔了取奇数偶数的概率分别是 $a, b$, 那EGF, 式子就是 $<a href="b+ae%5Ex">x^k</a>^n$ 然后就可以做了啊多项式快速幂划掉.</p><p>另外, 斯特林数看起来本质上就是 $e^x$ 和 $x$ 换元的系数, 所以换元 $x$ 展开然后斯特林数可以得到更好的式子.</p><h2 id="NOIP2023模拟赛53"><a href="#NOIP2023模拟赛53" class="headerlink" title="NOIP2023模拟赛53"></a>NOIP2023模拟赛53</h2><h3 id="A-谜域的界外"><a href="#A-谜域的界外" class="headerlink" title="A. 谜域的界外"></a>A. 谜域的界外</h3><blockquote><p>有无穷个点 $(x_i, y_i)$, $x_0, y_0$ 给定, $x_i&#x3D;a_xx_{i-1}+b_x, y_i&#x3D;a_yy_{i-1}+b_y$, 你可以每秒走 $1$ 的曼哈顿距离, 问你从 $x, y$ 出发在 $t$ 时间里能经过多少点.</p><p>$x, y, x_0, y_0, t\in 10^{16}, a_x, a_y\in [2, 100], b_x, b_y\in [0, 10^{16}]$</p></blockquote><p>你看这个 $a_x, a_y\ge 2$, 就知道只有 $\log t$ 个点有用, 随便做了.</p><h3 id="B-失落的世界"><a href="#B-失落的世界" class="headerlink" title="B. 失落的世界"></a>B. 失落的世界</h3><blockquote><p>交互题, 你知道 $n$, 不知道 $c\in [1, n]$, 每次你可以询问一个数 $x\in [1, n]$, 设上次询问的是 $x’$, 会告诉你 $c$ 是否 $\ge \vert x-x’\vert$, 求 $c$.</p><p>询问次数 $64$, $n\le 10^{18}$</p></blockquote><p>考虑你肯定想二分, 问题就是可能跳出去, 发现答案是 $n$ 的情况是最紧的, 于是你从后模拟看如果每次二分都递归右侧一开始可以在哪即可.</p><p>另外, 直接从 $\lceil \dfrac{n}{3}\rceil$ 跳也对, 因为 $\dfrac{1}{3}&#x3D;\sum_{i&#x3D;1} \dfrac{1}{4^i}$</p><h3 id="C-最短路"><a href="#C-最短路" class="headerlink" title="C. 最短路"></a>C. 最短路</h3><blockquote><p>给定 $Graph(n, m)$, 边权序列 $w_m$, 设一条路径经过的边权序列是 $p_1\ldots p_d$, 长度是 $\sum_{i&#x3D;2}^d cost(p_i, p_{i-1}), cost(x, y)&#x3D;\sum_{i&#x3D;0}^k c_ix^{a_i}y^{b_i}$, 问 $1$ 到每个点的最小代价.</p><p>$n, m\le 2\times 10^5, k, a, b\le 5$</p></blockquote><p>这种一般图看起来肯定要dij, 另外因为这个路径序列跟边关系很大但跟点关系不大, 应该想到做点边互换成为线图, 于是暴力就 $n^2$ 了.</p><p>考虑如何更新出边, 因为dij每次是拿出距离最小的, 则一个点的所有出边中只有 $w$ 最小的那一条可能被用来松弛, 其他边只有在它被用来松弛之后才会可能被用来松弛, 于是考虑每次只更新最小的出边, 每次用一条边 $u\to v$ 松弛后就更新 $u$ 的出边中没被松弛的边中 $w$ 最小的, 这就需要一个数据结构支持添加一个 $5$ 次函数或修改一个 $5$ 次函数的常数项.</p><p><del>然后你掏出了EI科技用二进制分组+分散层叠维护包络线</del>然后你注意到, 首先修改常数项是假的因为你每次都改小, 相当于每次重新插入一个. 又发现五次函数是假的因为若 $w_i&gt;w_j$, 则 $F_i$ 除了常数项的每一项系数都大于 $F_j$, 于是任意两个函数最多有 $1$ 个交点, 李超树维护了.</p><p>但这个实际上可以不带 $\log$, 观察性质说我们每次查的位置单调递增, 而更大的 $x$ 一定对应 $w$ 更小的 $F$, 于是开个队列维护即可.</p><p>李超树上界开大爆longlong 100 挂到 37.</p><h3 id="D-聚合的塔尖"><a href="#D-聚合的塔尖" class="headerlink" title="D. 聚合的塔尖"></a>D. 聚合的塔尖</h3><blockquote><p>给定 $DAG(n, m)$, $q$ 次查询除了 $u_i\ldots u_k$ 这些点之外到 $s$ 的最长路是多少.</p><p>$n, q\le 10^5, m\le 2\times 10^5$</p></blockquote><p>不能DAG剖, 那个是关于路径数的. 然后你又知道什么DAG上线段树合并是假的, 基本上排除了log结构</p><p>考虑根号, 感觉只要想到根号分治立马就能做出来了, 对于 $k$ 大于根号的暴力, 对于 $k$ 小于根号你只要对每个点预处理根号个到它最近的即可.</p><p>另外这个暴力不用拓扑排序, 直接扫就行.</p><h2 id="NOIP2023模拟赛54"><a href="#NOIP2023模拟赛54" class="headerlink" title="NOIP2023模拟赛54"></a>NOIP2023模拟赛54</h2><h3 id="A-你还没有卸载吗"><a href="#A-你还没有卸载吗" class="headerlink" title="A. 你还没有卸载吗"></a>A. 你还没有卸载吗</h3><p>模板整除分块</p><h3 id="B-仪式感"><a href="#B-仪式感" class="headerlink" title="B. 仪式感"></a>B. 仪式感</h3><p>CF Make It One 模板gcd卷积</p><h3 id="C-Warrior"><a href="#C-Warrior" class="headerlink" title="C. Warrior"></a>C. Warrior</h3><blockquote><p>给定 $a_n$, 求一个区间使得把区间的元素拿出来当成可重集, 这个可重集是所有区间中第 $k$ 小, 可重集字典序定义为 $S&lt;T$ 当且仅当最小的两个集合中出现次数不同的元素 $S$ 出现的多.</p></blockquote><p>简单做法是, 考虑可以 $n\log n$ 求一个序列的 $rank$, 因为对于一个区间固定一个端点字典序单调, 所以对于一个给定的序列, 单调增加右端点, 满足恰好小于它的左端点肯定也单调右移, 那就是每次给一个数出现次数改变 $1$ 判断是否小于给定序列, 线段树即可.</p><p>于是直接随机二分, 对每个右端点维护可能作为答案的左端点区间, 每次从所有可行区间中等概率随一个然后判 $rank$, 根据 $rank$ 和 $k$ 的大小可以把可行区间缩小, 期望缩一半, 不断重复即可, 因为随机所以期望 $n\log^2 n$<br><img src="/img/2023-11-10-15-23-46-image.png" alt="picture 0">  </p><p>UPD: 评论区有人说实际上随机二分的期望步数是 $\log_{1. 5} n$</p><h3 id="D-摩拉克斯"><a href="#D-摩拉克斯" class="headerlink" title="D. 摩拉克斯"></a>D. 摩拉克斯</h3><blockquote><p>给一棵树, 有边权, 求两个点 $x, y$ 使得 $\sum_u a_u\min(dis(u, x), dis(u, y))$ 最小.</p></blockquote><p>显然是子树内外的重心, 赛时是无脑2log, 幻想乡战略游戏的树剖做法可以支持改点权求带权重心, 于是直接拍上一份, 然后求子树内的直接做求子树外的把子树里面点维护的子树大小都设成 $0$ 再求全局重心.</p><p>然后更厉害的是树的重心一定在根所在的重链上, 那么求子树内的时候在子树内重链上二分, 子树外的话相当于删掉子树, 此时要么在以根为起点的次重儿子的重链上, 要么还是根开始的重链. 直接在这上面二分是单log, 那我离线遍历链是不是线性.</p><p>方法3, dfn中位数一定在重心子树内, 因为它子树大小大于一半, 此题换成带权中位数, 然后倍增着跳找重心.</p><h2 id="NOIP2023模拟赛55"><a href="#NOIP2023模拟赛55" class="headerlink" title="NOIP2023模拟赛55"></a>NOIP2023模拟赛55</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="A."></a>A.</h3><blockquote><p>求能否把 $n$ 划分成 $k$ 个不同的正整数之积, $T&#x3D;4000$ 次询问, $n\le 10^9$</p></blockquote><p>爆搜题哈哈</p><p>直接搜索, 剪枝是把剩下约数都选上到不到 $k$ 和无论怎么选乘积都大于 $n$.</p><h3 id="B-闪烁之光"><a href="#B-闪烁之光" class="headerlink" title="B. 闪烁之光"></a>B. 闪烁之光</h3><blockquote><p>有无向图 $Graph(n, m)$, 可以 $q$ 次询问点集 $S$ 的导出子图边数, 请确定这张图.</p><p>$n\le 2000, m\le 4000, Q\ge 75000$</p></blockquote><p>降智题, 显然这个数给的是 $m$ 单log, 那你对每个点 $u$ 去二分 $v&lt;u$ 的边 $u\to v$, 此时你已经知道除了 $u$ 以外的所有编号小于 $u$ 的点之间的边所以只问一次就能判断 $u$ 到这个集合中的边了.</p><h3 id="C-反射"><a href="#C-反射" class="headerlink" title="C. 反射"></a>C. 反射</h3><blockquote><p>有以 $n$ 为根的有根树, 保证父亲编号大于儿子, 对一个排列 $p_{n-1}$, 依次在<strong>原树</strong>上删掉第 $i$ 条边 $u_i\to v_i$, 然后在一个<strong>新图</strong>上添加 $(a, b)$, 其中 $a, b$ 分别为 $u_i, v_i$ 各自在<strong>原树</strong>上的连通块中编号最大的点, 这样会得到另一棵树. 问对所有排列新得到的树有多少种.</p><p>$n\le 3000$</p></blockquote><p>先尝试对删边过程dp, 发现很难进行, 因为底下一个点可能会接到祖先链上的很多点很难数. 再考虑最终可能的树的形态, 把每个点到新父亲这条边画到原树上一定是一条祖孙链, 发现合法当且仅当没有两条这样的链相交(可以端点处有交, 可以包含, 不能有一个点的一个端点在另一个链非端点上而另一端点不在).</p><p>然后就dp, 设 $f_{u, i}$ 表示 $u$ 的祖先中有 $i$ 个点可以选, 转移时枚举 $u$ 的父亲是这 $i$ 个点中从上往下第 $j$ 个, 则 $u$ 子树的点都不能选比 $j$ 深的, 也就是 $f_{u, i}&#x3D;\sum_{j\in [1, i]} \prod_v f_{v, j}$ 了.</p><h3 id="D-人赢"><a href="#D-人赢" class="headerlink" title="D. 人赢"></a>D. 人赢</h3><blockquote><p>给定 $a_n$, 寻找排列 $p_n$ 使得 $\min a_i \mathrm{xor} a_{p_i}$ 最大.</p><p>$n\le 5\times 10^5$</p></blockquote><p>找排列等价于找若干个环覆盖, 就是把每个点拆两个点, 让他们完美匹配, 这样保证每个点入度出度各 $1$.</p><p>于是问题转化为ABC304G, 见dp</p><p>然后在那个题基础上:</p><p><img src="/img/2023-11-13-16-53-52-image.png" alt="picture 1">  </p><h2 id="NOIP2023模拟赛56"><a href="#NOIP2023模拟赛56" class="headerlink" title="NOIP2023模拟赛56"></a>NOIP2023模拟赛56</h2><h3 id="A-平方"><a href="#A-平方" class="headerlink" title="A. 平方"></a>A. 平方</h3><blockquote><p>给定 $a_n$, 要求构造 $b_n$ 使得 $\forall i\in[1, n-1], b_ib_{i+1}a_ia_{i+1}$ 为完全平方数. $a, b$ 为整数. 最小化 $\prod_i b_i$</p><p>$n\le 10^5, a_i\le 10^6$</p></blockquote><p>居然被这个智障题骗了1h. 脑子不清醒了吧.</p><p>一开始想先确定 $c_i&#x3D;b_ib_{i+1}$ 的值, 但这样很难保证 $b$ 是整数. 考虑对于 $a$ 的一个质因数出现次数先都模 $2$, 然后最后要么所有数都有这个质因数要么都没有(模 $2$ 意义下), 所以直接统计次数模 $2$ 为 $1$ 的数的个数即可.</p><h3 id="B-路径覆盖"><a href="#B-路径覆盖" class="headerlink" title="B. 路径覆盖"></a>B. 路径覆盖</h3><blockquote><p>题目背景: 给 $n$ 个点的无根树, 你想用若干路径覆盖所有边, 且保证任意一条边恰被覆盖一次. “奇数度点数除以2”——小A同学脱口而出. 既然这题已经被秒了, 你只好重新出一道题.<br>给定 $Tree(n)$, 有操作 $1$ 覆盖与一个点相连的所有边, 操作 $2$ 覆盖一条路径, 边不能重复覆盖, $q$ 询问若先对 $x$ 用一次操作 $1$, 则最少用几次才能把所有边覆盖恰好一次.</p><p>$n, q\le 10^5$</p></blockquote><p>换根dp简单题.</p><p>你可以直接照着题目背景设状态, 设 $f_{u, 0&#x2F;1&#x2F;2}$, $0$ 表示 $u$ 使用 $1$ 操作, $1&#x2F;2$ 表示不使用 $1$ 操作, 是否考虑 $u$ 的父边这条边的情况下, 子树内奇度点的个数. 转移的话 $0$ 是直接累加儿子的 $2$ 再加 $2$ 表示一次操作, $1&#x2F;2$ 是先把子树儿子们的 $0&#x2F;1$ 卷起来(选择 $0$ 不增加 $u$ 的度数, 选择 $1$ 增加一个度数, 用背包合并), 然后再根据 $1&#x2F;2$ 是否增加 $u$ 的度数去合并.</p><p>换根同理, 你就设 $g_{u, 0&#x2F;1&#x2F;2}$ 表示 $u$ 子树外的即可. 需要预处理前后缀儿子背包合并结果.</p><h3 id="C-条占"><a href="#C-条占" class="headerlink" title="C. 条占"></a>C. 条占</h3><blockquote><p>左右各 $n$ 点的二分图, 有 $m$ 次加边每次加入 $w_i$ 条 $u_i\to v_i$, $a_n, b_n$, 表示要求左边前 $i$ 个点最多连出 $a_i$ 条边, 右边前 $i$ 个点最多连 $b_i$ 条边, 求最多能加多少边.<br>$n, m\le 4\times 10^6$</p></blockquote><p>考虑一个网络流, 两边先建两排点 $i, i’$, 认为 $s&#x3D;n+1, t&#x3D;(n+1)’$, 则 $i+1\stackrel{a_i, 0}{\longrightarrow} i$, $i’\stackrel{a_i, 0}{\longrightarrow} (i+1)’$, 若有 $(u_i, v_i, w_i)$ 则 $u_i\stackrel{w_i, 1}{\longrightarrow} v_i’$</p><p>然后要模拟费用流, 考虑动态加边模拟, 按照 $u$ 从小到大加入一条边, 你发现此时不会形成负环: 成环必定跨过由 $i\to i’$ 和 $i’\to i$ 相同次数, 也就是说环一定权值为 $0$, 并且因为 $u$ 从小到大变化, 去掉这个环之后的增广路一定已经被增广, 于是这是不流反悔边的模拟费用流.</p><p>于是只要维护后缀减后缀min, 直接上线段树维护! TLE.</p><p>麻了, 另一个做法是最小割加扫描线, 也就是断的边就是</p><h3 id="D-重逢"><a href="#D-重逢" class="headerlink" title="D. 重逢"></a>D. 重逢</h3><p>todo</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP2023游记</title>
      <link href="/2023/10/22/csp2023/"/>
      <url>/2023/10/22/csp2023/</url>
      
        <content type="html"><![CDATA[<h1 id="CSP2023游记"><a href="#CSP2023游记" class="headerlink" title="CSP2023游记"></a>CSP2023游记</h1><p>文中杜赢指do_while_true.</p><h2 id="Day-n"><a href="#Day-n" class="headerlink" title="Day -n"></a>Day -n</h2><p>开始停课, 打了4场模拟赛, 第一场爆了一个标, 剩下的都挺寄.</p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>上午复习数位dp, 看以前的blog, 中午出发, 晚上到达日照一个民宿, 晚霞很好!</p><p>试机, 抽到win10. 发现虚拟机不能用, 说晚上解决. 机子上放了3个不同的mingw, 最后只有dev自带的那个能用. 但是机子配了vscode, 即使没有c++插件也是vscode, 即使没有虚拟机也是vscode. 最可惜的是没有python. 考试过程中习惯性拿python当计算器&#x2F;暴力弹出的是微软商店. 面到杜赢, 他们机房虚拟机能用. 面到whc, 面到一个也来打比赛的初中同学.</p><p>晚上复习圆方树, 虚树, kmp. 没有python于是背了一个bat对拍板子.</p><h2 id="Day-1-比赛"><a href="#Day-1-比赛" class="headerlink" title="Day 1 比赛"></a>Day 1 比赛</h2><p>上午又看了看字符串<del>打开知乎</del>, 听说普及组某机房没断网(问号脸). 特意带了杯咖啡和零食, 切一个题吃一个.</p><p>提前30min左右进场, 配vscode, 打了空模板, 考场大概提前几分钟给了压缩包密码, 压缩包里看到名字”tree”打一个存树的模板, 看”struct”大样例猜是结构体对齐之类的模拟猜是T1(大模拟放T3? ? ), lock不知道是什么, game像个数数题, 但有字符串, 果断打一个kmp一个sam. 都没用上. 提醒自己去年寄大了今年要稳打要写对拍.</p><p>开题先看30min, 看T1, 想了1min发现诶好像不用计数可以枚举. 看T2, 这莫不是原, 发现在杜赢OJ上做过, 现在都这么搬题了吗? 看T3, 大模拟! 看T4, 暂时没思路, 先写前面的.</p><p>大概15min过了T1, 正解就是暴力就只测两组手造样例没拍.</p><p>然后写T2, 记得正解是dp, 但直接模拟括号序列匹配对过程中的栈哈希的做法也能过(甚至先学到的就是这种). 当时做杜赢OJ单hash会寄就写了个任意重hash的, 写unordered_map自定义hash函数, CE10min, 先用map, 发现大样例单hash果然过不了换双, 结果极限数据要跑2s. 于是还是得环unordered_map. 给自定义hash函数所有地方加上const终于不CE进了1s, 但是也塞不下3hash的时间了. 发现自己平时没背模数, 选择了1e9+7和998244853(出题人就算卡, 也想不到我用的居然不是998244353? ). 搞完T2记得大概还剩下2. 5h. 要是平常背背pbds的hashmap是不是能更稳一点.</p><p>再不开咖啡就来不及了, 喝咖啡.</p><p>开T3, 大模拟, 发现它还是能用类型套出 $10^{18}$ 的内存占用的, 一个一个操作的写很快就写完了, 然后调了一会发现自己印象里的结构体对齐和它的不一样(题目中结构体中的第 $i$ 个变量对 $a_i$ 对齐, 而不是对 $\max_j a_j$ 对齐), 改过来过大样例, 现在还剩1. 5h.</p><p>想T4, 能种树的形状很难dp且同一个父亲的不同兄弟之间不能独立出来, 感觉不是dp. 想二分答案, 然后发现可以忽略 $a, b, c$ 找到每个点 $u$ 最晚必须被种的时间 $t_u$, 因为排除了dp只能是贪心, 发现对于点 $u, v$, 若当前状态分别需要 $d_u, d_v$ 步能在它们的位置种下树, 那么一定要 $d_u\le t_u, d_v\le t_v$, 先种 $u$ 再种 $v$ 要求 $d_u+d_v\le t_v$, 先 $v$ 要求 $d_u+d_v\le t_u$, 于是直接按 $t$ 排序模拟应该就是对的. 那模拟只要暴力跳父亲就是均摊线性, 总复杂度是二分log和内层排序&#x2F;算 $t$ 二分log一共2log, 开冲, 调完测大样例答案是对的但最后一个T了.</p><p>二分算 $t$ 可以不二分直接解方程, 于是开始改解方程, 发现根本解不对, 一直解到还有40min, 先复制出一个原版的测一下过了大样例, 又把其它3个题拖进noi linux里测, 发现T2在 longlong 数组初始化写<code>1e9+7</code>在 noi linux 里会报错紧急修了. 然后接着解方程解到最后没解出来交了2log大概是寄了.</p><h2 id="Day-1-比赛结束"><a href="#Day-1-比赛结束" class="headerlink" title="Day 1 比赛结束"></a>Day 1 比赛结束</h2><p>面到杜赢一问他不挂分就AK了, 但T2写的dp, 我说这是你们学校OJ上原题, T4写的是2log且过了1s而且做法不一样, 开始怀疑我的贪心, 还没等讨论T4杜赢说他正在约npy(? ? ? )就扔下我走了. 出来的时候没面到人.</p><p>带进去一包零食都忘拿了, 捐CCF肉铺能加分吗?</p><p>发现WJQ会T4并且也不一样(二分+树剖之类的没有懂), <del>于是开摆</del></p><p>深夜教练发来代码, 但我已经关电脑了. 发来说云斗390, 到前面有两个400, 但这仍然是挂分挂的最少的一次.</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>因为前一天的民测令人震撼, 就又开洛谷测了一遍也是390, zyb测的榜也是390, T42logTLE了两个点, 都在1. 2s以内. 然后大概20min就从2log上重写了一遍解方程版本调出来过了云斗, 测luogu1WA1RE, 发现WA是边界错误云斗没测出来, RE是数据里有 $b&#x3D;0, c&#x3D;0$ 的点. 好像考试从最后1h就开始心跳加速了脑子比较急, 方程的式子错了也没检查出来. (赛时十年功, 赛后一分钟)</p><p>杜赢大模拟寄了&#x2F;kk&#x2F;kk&#x2F;kk T4 $\log^2$ T了 &#x2F;kk&#x2F;kk&#x2F;kk AK失败</p><p>在山上看日出.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZROI2021NOIP20连测</title>
      <link href="/2023/10/05/zr/"/>
      <url>/2023/10/05/zr/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="A-21-ZR联赛集训-day1-数字变换"><a href="#A-21-ZR联赛集训-day1-数字变换" class="headerlink" title="A. [21 ZR联赛集训 day1]数字变换"></a>A. [21 ZR联赛集训 day1]数字变换</h3><blockquote><p>你有一个素数 $p$ 和二元组 $(a, b)$, 它们的和不被 $p$ 整除.</p><p>你想对这个二元组进行若干次操作, 让它变成另外一个二元组. 每一步, 你可以二元组做如下操作中的一个:</p><ul><li>把 $(a, b)$ 变成 $(2a \mod p, (b+p-a) \mod p)$</li><li>把 $(a, b)$ 变成 $((a+p-b) \mod p, 2b \mod p)$</li></ul><p>你需要回答 $q$ 次询问, 每次询问, 给你 $a_i, b_i, c_i, d_i$, 问最少需要多少步能将 $(a_i, b_i)$ 变成 $(c_i, d_i)$. 如果不可行, 那么输出 $-1$.</p><p>注意, 这里 $(a, b)$ 和 $(b, a)$ 是不同的.</p><p>$2 \leq p \leq 10^9, 1 \leq q \leq 10^5, 0 \leq a_i, b_i, c_i, d_i &lt; p$, 保证 $a_i + b_i \not\equiv 0 \pmod p, c_i + d_i \not\equiv 0 \pmod p$.  </p></blockquote><p>操作不改变 $(a+b)$, 会判无解了, 此时只要让 $a&#x3D;c$, 而此时考虑 $b$ 不如考虑 $s&#x3D;a+b$, 因为不变.</p><p>发现每次 $a&#x3D;2a$ 或 $a&#x3D;2a-s$, 那么操作 $k$ 次后就成了 $2^a-vs$, 其中 $v\in[0, 2^k]$(用二进制表示 $v$ 照着操作即可). 而如果 $2^k&gt;p$, 因为 $p$ 是素数, 一定有解, 于是枚举 $k$ 判有无解即可.</p><h3 id="B-21-ZR联赛集训-day1-均分财产"><a href="#B-21-ZR联赛集训-day1-均分财产" class="headerlink" title="B. [21 ZR联赛集训 day1]均分财产"></a>B. [21 ZR联赛集训 day1]均分财产</h3><blockquote><p>有 $n$ 个数 $(2 \leq n \leq 2 \times 10^5)$, 你可以删除其中不超过 $k$ 个数 $(min(25, n-2) \leq k \leq n-2)$, 然后将剩下的数划分成两个子集(可以有重复的数字), 满足这两个子集中的数的和是相等的. 这 $n$ 个数都是在 $1$ 到 $W$ 内随机的, 其中 $W&#x3D;200000$.</p></blockquote><p>$n$ 小于 $40$, 可以Meetinthemiddle, 很大的时候, 在前面部分先从大到校贪心着随便放, 最后得到一个 $W$ 以内的数 $x$, 然后把它当成一个数添加进去, 和剩下的匹配, 40个数的话, 因为随机, 抽屉原理一下可能性还是非常大的.</p><p>至于 $k$, 不需要的(乐)</p><h3 id="C-21-ZR联赛集训-day1-查询工资"><a href="#C-21-ZR联赛集训-day1-查询工资" class="headerlink" title="C. [21 ZR联赛集训 day1]查询工资"></a>C. [21 ZR联赛集训 day1]查询工资</h3><p>重点就是分析一个点什么时候能被知道. 如果有兄弟一定不可知是显然的. 如果这个点子树大于 $k$, 那么直接用父亲子树减自己子树, 否则这个点子树大小不大于 $k$, 此时不能问这个点的子树信息, 那只能把子树删空变成叶子, 而父亲点就只有它一个儿子, 于是要用父亲的父亲点的子树减去所有儿子再减去其他儿子的子树.</p><p>分类完全, 考虑dp, $f_u$ 表示 $u$ 子树内的答案, 那么第一种转移显然, 若存在儿子 $v, siz_v&gt;k$, $f_u&#x3D;f_v+1$. 第二种转移一定是 $f&#x3D;0$ 的点都弄成叶子(大小一定不大于 $k$, 而大于 $k$ 的一定有dp值), 留下一个子树大小为 $2$ 的点 $v$, 然后 $f_u&#x3D;\sum f_v+1$.</p><h3 id="D-21-ZR联赛集训-day1-多项式题"><a href="#D-21-ZR联赛集训-day1-多项式题" class="headerlink" title="D. [21 ZR联赛集训 day1]多项式题"></a>D. [21 ZR联赛集训 day1]多项式题</h3><blockquote><p>听说联赛可以考多项式.</p><p>你有一个长度为 $n$ 的数字串, 你想把它划分成若干段(一整段也可以), 一共有 $2^n-1$ 种不同的划分.</p><p>你把每个子串看成一个十进制数字, 可以有前导0. 我们令一个划分的权值是所有子串的乘积.</p><p>输出所有划分权值的和, 对 $998244353$ 取模.</p><p>$n\le 2\times 10^5$</p></blockquote><p>简单题, 直接dp.</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="A-21-ZR联赛集训-day2-幻方"><a href="#A-21-ZR联赛集训-day2-幻方" class="headerlink" title="A. [21 ZR联赛集训 day2]幻方"></a>A. [21 ZR联赛集训 day2]幻方</h3><blockquote><p>三阶幻方, 每次交换相邻两个数, 求最少次数</p></blockquote><p>简单题, $9!$ 种记忆化去搜即可.</p><h3 id="B-21-ZR联赛集训-day2-数集"><a href="#B-21-ZR联赛集训-day2-数集" class="headerlink" title="B. [21 ZR联赛集训 day2]数集"></a>B. [21 ZR联赛集训 day2]数集</h3><blockquote><p>有一个集合 $S$, $q$ 次加入 $x$ 或询问 $\max_{y\in S} x \mathrm{op} y, \mathrm{op}\in {\mathrm{and}, \mathrm{or}, \mathrm{xor}}$<br>$q, x&lt;2^20$</p></blockquote><p>异或是字典树典题, 或操作相当于取反之后与再取反, 和与是一样的.</p><p>与的话, 高位到地位贪心, 相当于判定 $v$ 是否是 $S$ 中某一个元素的子集, 可以在插入的时候直接标记子集, 从大到小标记, 注意如果有个子集标记过了就不标记子集的子集, 复杂度是什么?</p><p>那就按照子集的枚举方式, 对一个集合, 先枚举删一个元素的, 如果被标记了就直接跳, 否则递归? 递归次数是 $O(V)$, 枚举次数是 $V\log V$, 非常好!</p><h3 id="C-21-ZR联赛集训-day2-染色"><a href="#C-21-ZR联赛集训-day2-染色" class="headerlink" title="C. [21 ZR联赛集训 day2]染色"></a>C. [21 ZR联赛集训 day2]染色</h3><blockquote><p>⼀棵树上有两个⿊点 , 其余都是⽩点.<br>接下来, 每过⼀个单位时间, 树上的每个⿊点可以选择⼀个它相邻的点染⿊.<br>请问, 在最优策略的情况下, ⾄少要经过多少个单位时间, 才能把整棵树染⿊<br>$n\le 3\times 10^5$</p></blockquote><p>如果两个相邻是直接dp的简单题</p><p>现在两个不相邻, 就要考虑中间的链, 要确定链上两边染色的分界点, 这玩意单调的吧! 三分!</p><h3 id="D-21-ZR联赛集训-day2-电路板"><a href="#D-21-ZR联赛集训-day2-电路板" class="headerlink" title="D. [21 ZR联赛集训 day2]电路板"></a>D. [21 ZR联赛集训 day2]电路板</h3><blockquote><p>一个电路板可以抽象为一个无向图, 图中每个点代表一个元件, 每条边代表一条导线. 每个元件 $a$ 有一个启动电压和一个功能属性 $b_j$. 当 $a_i \leq V$ ($V$ 代表整个电路的电压) 时, 这个元件将被激活. 激活的元件在原图中会形成若干个联通块(这里的联通块可以包含损坏的元件). 对于一个连通块 $A$, 我们说它包含功能属性 $p$, 当且仅当 $A$ 中存在元件满足 $b&#x3D;p$, 且这样的元件的个数是 $k$ 的整数倍.</p><p>在激活的元件中, 有一些联通块包含了损坏的元件, 它们无法正常工作. 现在给出若干个询问, 每个询问包含电路的电压 $V$ 和损坏的元件集合 $S$, 你需要回答在这个条件下, 一个没有损坏元件的联通块, 最多包含了几种功能属性.</p></blockquote><p>离线按 $V$ 排序, 启发式合并维护每个连通块里每个元素出现的次数. 开一个堆维护所有连通块的答案, 询问的时候, 删除包含禁用掉的连通块, 询问结束再插回去.</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="A-zr联赛集训day3-史上最简洁的题面"><a href="#A-zr联赛集训day3-史上最简洁的题面" class="headerlink" title="A. [zr联赛集训day3]史上最简洁的题面"></a>A. [zr联赛集训day3]史上最简洁的题面</h3><p>直接dp, $f_{S}$ 表示点集 $S$ 的导出子图边数, 转移就考虑去掉 $S$ 最低位 $u$, 设 $u$ 的边集是 $e_u$, 那么加上 $\mathrm{popcount}(e_u\mathrm{and} S)$.</p><h3 id="B-zr联赛集训day3-史上第二简洁的题面"><a href="#B-zr联赛集训day3-史上第二简洁的题面" class="headerlink" title="B. [zr联赛集训day3]史上第二简洁的题面"></a>B. [zr联赛集训day3]史上第二简洁的题面</h3><blockquote><p>给定一个长度为 $n$ 的序列 $a$, 给定 $m$ 个询问 $(l, r, x)$, 求 $a_l, a_{l+1}, . . . , a_r$ 中有多少个数与 $x$ 互质.  </p><p>$n, m, a_i, x\le 10^5$</p></blockquote><p>容斥, 变成 $qd$ 次求是某个数倍数的个数, 预处理每个值的倍数的下标, 离线, 在这个数组上双指针.</p><p>复杂度为什么不是 $nd\ln n$ 呢? 因为容斥的时候只会用到 $\mu^2(x)&#x3D;0$ 的数, 就能过了.</p><h3 id="C-zr联赛集训day3-史上第三简洁的题面"><a href="#C-zr联赛集训day3-史上第三简洁的题面" class="headerlink" title="C. [zr联赛集训day3]史上第三简洁的题面"></a>C. [zr联赛集训day3]史上第三简洁的题面</h3><blockquote><p>有 $n$ 个人排成一排, 从左到右编号为 $1. . . n$, 接下来你每次可以指定两个相邻的人战斗, 输的一方将会离开队伍, 直到最后只有一个人留在队伍里, 这个人将会称为最后的赢家. 你知道任意两个人打谁会赢, 求哪些人可能会成为最后的赢家.</p><p>$n\le 2000$</p></blockquote><p>区间dp, $f_{l, r, i}$ 表示 $l, r$ 内打完了剩下一个 $i$ 是否可能. 则转移是 $f_{l, r, i}&#x3D;f_{l, p, i}\mathrm{and} f_{p+1, r, j}\mathrm{and} s_{i, j}$ 以及反过来的. 复杂度是 $n^5$ 的爆炸.</p><p>考虑再维护 $g_{l, r, i}$ 表示 $[l, r]$ 内打完了剩下一个打不过 $i$ 的, 转移的时候用 $g$ 转移 $f$ 就只要枚举一个 $p$ 了, 变成了 $n^3$.</p><p>于是直接上个bitset就过了</p><h3 id="D-zr联赛集训day3-史上第四简洁的题面"><a href="#D-zr联赛集训day3-史上第四简洁的题面" class="headerlink" title="D. [zr联赛集训day3]史上第四简洁的题面"></a>D. [zr联赛集训day3]史上第四简洁的题面</h3><p>考虑最短路树, 则如果被堵死的路不在最短路树上就没影响, 则是最短路上的一条边. 于是设 $u\to fa_u$ 被堵死后 $u$ 到 $v$ 时间为 $t_u$, 答案为 $f_u$, 则 $f_u&#x3D;\max t_u, \min f_{a}+w_{u\to a}&#x3D;\min (\max f_a+w_{u\to a}, t_u)$, 可以跑最短路, 问题就是如何求 $t$.</p><p>求 $t_u$ 时, 路径一定是 $u\to a(a\in subtree(u))\to b(b\notin subtree(u))\to v$, 也就是只会走一条非树边, 代价就是 $dep_b-dep_u+dep_a+w$, 要求 $a$ 在 $u$ 子树内, $b$ 在 $u$ 子树外, dfs序转化一下就是两个区间了.</p><p>然而直接上线段树会被卡常卡爆, 考虑枚举一条边, 那它能贡献的点是一条链(边里较深的点到lca的一个儿子), 那么按值从小到大枚举, 就成了把链上没被赋值过的赋成当前边的 $dep_a+dep_b+w$, 可以用并查集实现找下一个没被赋值的点的操作.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCT National Holiday Training</title>
      <link href="/2023/10/02/bct/"/>
      <url>/2023/10/02/bct/</url>
      
        <content type="html"><![CDATA[<h2 id="DS"><a href="#DS" class="headerlink" title="DS"></a>DS</h2><h3 id="CF1672H"><a href="#CF1672H" class="headerlink" title="CF1672H"></a>CF1672H</h3><p>已收录</p><h3 id="CF1290E"><a href="#CF1290E" class="headerlink" title="CF1290E"></a>CF1290E</h3><p>大根笛卡尔树子树大小就是当前点作为最大值的区间, 于是想到逐个插入维护左右端点, 但相邻两个插入的元素之间未被插入元素多算的贡献是不好去除的, 所以需要插入的时候不是插入的原序列对应位置上而是无空隙紧挨着插入, 每次是区间取max&#x2F;min和区间加.</p><h3 id="CF809D"><a href="#CF809D" class="headerlink" title="CF809D"></a>CF809D</h3><p>LIS两个主要做法分别是记录以某值结尾的最短长度和某长度对应的最小结尾. 此题一维表示当前前 $i$ 个数, 若第二维表示当前的值那么转移是跳跃的, 如果记录长度则是连续的.</p><p>于是 $f_{i, j}$ 表示前 $i$ 个, 长度为 $j$ 的结尾最小值, 那么显然</p><p>$$<br>f_{i, j}&#x3D;\max f_{i-1, j},<br>\begin{cases}<br>    f_{i-1, j-1}+1, f_{i-1, j-1}+1\in [l_i, r_i]\<br>    l_i, f_{i-1, j-1}+1&lt;l_i\<br>    inf, f_{i-1, j-1}+1&gt;r_i<br>\end{cases}<br>$$</p><p>显然 $f_i$ 是递增的, 考虑数据结构维护状态, 那么第二种转移显然就是直接区间赋值了, 而第一种转移需要平移之后和原来的比较, 发现不用比较: $f_{i-1, j}$ 一定是某一 $k$ 由 $f_{k, j-1}$ 转移到了 $k$, 此时发现 $f_{i-1, j-1}\le f_{k, j-1}$, 所以可以不需要考虑max, 于是就成了平移, 平衡树好做的.</p><h3 id="CF1648D"><a href="#CF1648D" class="headerlink" title="CF1648D"></a>CF1648D</h3><p>考虑dp, 走到 $(2, i)$ 的代价为 $f_i$</p><p>那么要走到这个位置至少要点亮一个区间, 有两种情况, 在这个区间的范围内从第一行进入当前行走过来, 或者从区间左端点上一个过来.</p><p>那么考虑如何转移, 这个区间要包含当前点, 排序后是一个区间, 第一种情况的值可以直接挂钩到区间上, 第二种看来也可以, 于是直接线段树维护.</p><h3 id="CF407E"><a href="#CF407E" class="headerlink" title="CF407E"></a>CF407E</h3><p>等差数列先要同余, 于是先处理出同余段, 相同元素可以按照不同余处理划成两段, 然后只需关心 $b_i&#x3D;\lfloor \dfrac{a_i}{d}\rfloor$, 要求是一个连续的值域段. 也就是 $max-min+k\ge r-l$. 那么扫一个右端点, 维护 $max-min+l$, 单调栈配线段树</p><h3 id="CF1423G"><a href="#CF1423G" class="headerlink" title="CF1423G"></a>CF1423G</h3><p>考虑一个位置 $p$ 的贡献, 若它上次出现位置为 $lp$, 那么考虑这个区间出现的左端点, 贡献就是 $\min(i, n-k+1)-\max(lp+1, i-k+1)+1$, 然后发现可以把 $\min, \max$ 拆开, 因为这个等价于四种中最小的, 于是变成了</p><p>$$<br>f_i(k)&#x3D;\min{i-lp, k, n-i+1, n-k-lp+1}<br>$$</p><p>这个是关于 $k$ 的分段一次函数, 最多有三段(有两个是常函数), 那么直接维护出分界点, 查询就是对落在第一段, 第二段, 第三段的分别求个和.</p><p>而修改是简单的, 因为只有 $lp$ 会被改, 所以同镜中的昆虫, 颜色段均摊即可.</p><p>复杂度是单log.</p><h3 id="IOI13-Wombats"><a href="#IOI13-Wombats" class="headerlink" title="IOI13 Wombats"></a>IOI13 Wombats</h3><blockquote><p>给定一个 $n\times m$ 的网格图, 边有边权, 不允许向上走. 有 $q$ 次询问:</p><ul><li>修改网格图上一条边的边权.</li><li>询问从第一行某点走到最后一行某点的最短路径长度.</li></ul><p>$n\le 5000, m\le 200, q\le 2\times 10^5$, 最多 $500$ 次修改.</p></blockquote><p>考虑在行上建线段树, $f_{u, i, j}$ 表示从 $(l, i)$ 走到 $(r, j)$ 的最短距离, 其中 $(l, r)$ 表示 $u$ 代表的区间, 这是 $(\min, +)$ 卷积, 此时合并一次是 $m^3$, 总复杂度是 $m^3(500\log 5000+n)$</p><p>考虑合并 $g_{i, k}$ 和 $h_{k, j}$ 得到 $f_{i, j}$ 的过程中, 随 $j$ 增加, $k$ 一定也是增的, 证明可以考虑路径不会相交(可以有公共点, 但不会交完走向两边), 决策单调性, 那么二分分决策点成了 $m^2\log$.</p><p>考虑刚才的证明可以发现 $p_{i, j}\in (p_{i-1, j}, p_{i, j+1})$, 复杂度 $m^2$.</p><h3 id="LOJ6507"><a href="#LOJ6507" class="headerlink" title="LOJ6507"></a>LOJ6507</h3><p>拆位再线段树无论如何都有两个log.</p><p>考虑and和or都是丢信息的, 于是对线段树的每个节点以不全相同的位的个数为势能, 这样and和or都是单减的, 于是对当前节点, 没有影响就不更新, 如果有影响直接递归, 因为有影响一定会让势能减少, 总势能一开始 $n\log A$, 于是复杂度 $n\log A$</p><h3 id="UOJ191"><a href="#UOJ191" class="headerlink" title="UOJ191"></a>UOJ191</h3><p>只删不增你一定会动态构建线段树, 线段树节点上建凸包.</p><p>直接加删除会被卡, 因为删一个再加一个就可以付出 $O(len)$ 的代价.</p><p>解决方案是, 只有当自己同层的右边一个点可以建点了, 才合并成线段树上一个点, 于是删除的代价也均摊掉了. 好厉害!</p><h3 id="CF1340F"><a href="#CF1340F" class="headerlink" title="CF1340F"></a>CF1340F</h3><p>楼房重建线段树经典题</p><h3 id="BZOJ2138"><a href="#BZOJ2138" class="headerlink" title="BZOJ2138"></a>BZOJ2138</h3><p><img src="/img/2023-10-04-14-21-46-image.png" alt="picture 0">  </p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="UVA11022-String-Factoring"><a href="#UVA11022-String-Factoring" class="headerlink" title="UVA11022 String Factoring"></a>UVA11022 String Factoring</h3><p>区间dp, $f_{l, r}$ 表示的答案, 转移要么是拼接, 要么是求循环节, 用 KMP 求 border 即可. $n^3$</p><h3 id="CF696-Legen"><a href="#CF696-Legen" class="headerlink" title="CF696 Legen. . ."></a>CF696 Legen. . .</h3><p>我还以为这题目名字没打全</p><p>基本上, 你想要一个DFA, 包含所有整串, 所以直接建出AC自动机, dp就记录当前长度和走到了DFA的哪个节点上, 然后因为 $l$ 的范围优化成矩阵快速幂.</p><h3 id="P3311-SDOI2014-数数"><a href="#P3311-SDOI2014-数数" class="headerlink" title="P3311 [SDOI2014]数数"></a>P3311 [SDOI2014]数数</h3><p>数位dp, 状态记录走到自动机哪个位置即可.</p><h3 id="P2414-NOI2011-阿狸的打字机"><a href="#P2414-NOI2011-阿狸的打字机" class="headerlink" title="P2414 [NOI2011]阿狸的打字机"></a>P2414 [NOI2011]阿狸的打字机</h3><p>打字过程可以看成在字典树上走(前缀是公共的).</p><p>然后发现AC自动机中, 求x在y中的出现次数相当于走一遍 $y$, 看有多少次 $y$ 的fail出现在 $x$ 的子树中, 而每次走一遍 $y$ 爆炸了, 于是离线dfs一遍即可. 问题变成单点加子树求和.</p><h3 id="CF587F-Duff-is-Mad"><a href="#CF587F-Duff-is-Mad" class="headerlink" title="CF587F Duff is Mad"></a>CF587F Duff is Mad</h3><p>仍然AC自动机, 走一遍 $s_k$, $fail$ 出现在 $s_l\ldots s_r$ 中的和, 此时想到两种暴力, 对 $s_k$ 的每个前缀求自己被多少个 $s_l\ldots s_r$ 的元素包含, 对每个 $s_l\ldots s_r$ 求包含多少个 $s_k$ 的前缀. 于是根号分治, 如果 $s_k&gt;B$, 则 $s_l\ldots s_r$ 中可能包含 $s_k$ 的只有 $\dfrac{n}{B}$ 个, 直接用第二种暴力, 复杂度 $s\dfrac{n^2}{B}$; 如果 $s_k&lt;B$, 则遍历 $s_k$ 的代价成了 $B$, 对每个前缀求编号区间中包含一个点的区间个数, 是二维偏序, 那先差分编号, 扫编号, 然后dfs序变成区间加单点查, 复杂度 $nB\log n$, 平衡成 $n\sqrt{n\log n}$</p><h2 id="String-1"><a href="#String-1" class="headerlink" title="String"></a>String</h2><h3 id="异或最小生成树"><a href="#异或最小生成树" class="headerlink" title="异或最小生成树"></a>异或最小生成树</h3><p>经典的, brovka+全局trie+每个联通块一个trie</p><h3 id="几个怪题"><a href="#几个怪题" class="headerlink" title="几个怪题"></a>几个怪题</h3><p>他都不把范围说清楚啊</p><h3 id="一个图-询问集合-S-和集合-T-之间的最短路"><a href="#一个图-询问集合-S-和集合-T-之间的最短路" class="headerlink" title="一个图, 询问集合 $S$ 和集合 $T$ 之间的最短路."></a>一个图, 询问集合 $S$ 和集合 $T$ 之间的最短路.</h3><p>建源汇</p><h3 id="一个图-询问集合-S-里面的点-两两点距离最小值"><a href="#一个图-询问集合-S-里面的点-两两点距离最小值" class="headerlink" title="一个图, 询问集合 $S$ 里面的点, 两两点距离最小值"></a>一个图, 询问集合 $S$ 里面的点, 两两点距离最小值</h3><p>边权是正的的话, 多源bfs直到两个源扩展出的相交</p><h3 id="平面上给出-n-个点-求一个一般图最大权匹配-两点间边权为-max-vert-x-i-x-j-vert-vert-y-i-y-j-vert"><a href="#平面上给出-n-个点-求一个一般图最大权匹配-两点间边权为-max-vert-x-i-x-j-vert-vert-y-i-y-j-vert" class="headerlink" title="平面上给出 $n$ 个点, 求一个一般图最大权匹配. 两点间边权为 $\max{\vert x_i-x_j\vert, \vert y_i-y_j\vert}$"></a>平面上给出 $n$ 个点, 求一个一般图最大权匹配. 两点间边权为 $\max{\vert x_i-x_j\vert, \vert y_i-y_j\vert}$</h3><p>可以把绝对值拆了, 四个中取最大.</p><p>于是建四个点表示取四种最大, 每个点向四个点连边可以把图建出来了.</p><p>好吧现在虽然没有会这个题, 但直接网络流就会了AGC034D(二分图版+模拟费用流)</p><h3 id="P3825-NOI2017-游戏"><a href="#P3825-NOI2017-游戏" class="headerlink" title="P3825 [NOI2017] 游戏"></a>P3825 [NOI2017] 游戏</h3><p>考虑 $d&#x3D;0$ 时每个地图只有两种选择是2sat, 那么直接暴力枚举剩下 $x$ 是哪种地图, 只用枚举两种, 复杂度 $2^dn$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记</title>
      <link href="/2023/08/12/smallnote/"/>
      <url>/2023/08/12/smallnote/</url>
      
        <content type="html"><![CDATA[<h2 id="记录奇怪的思考"><a href="#记录奇怪的思考" class="headerlink" title="记录奇怪的思考"></a>记录奇怪的思考</h2><ul><li>存在确定结果的游戏等价于决策透明, 于是可以等价于一个人提出一个策略另一方对着你的策略卡.</li></ul><h2 id="记录代码细节错误"><a href="#记录代码细节错误" class="headerlink" title="记录代码细节错误"></a>记录代码细节错误</h2><ul><li>noip2022 旅行: 手动实现矩阵乘法<code>*=</code>, 注意顺序, 可能要用旧的值更新而旧的被变了.</li><li>csp2022 假期计划: 取max的初始值应设为-inf而不是0</li><li>csp2021 回文: 函数没有返回值, dev默认值为true(? )</li><li>P7916 区间dp时若转移到长度偶数则答案错的, 没有判</li><li>P7077 初始化问题</li><li>P7116 拉插次数没想清楚就往上试到不变化, 同时注意数组开小了</li><li>P5666 线段树合并怎么会有人想到写 $x&amp;y&#x3D;&#x3D;0$ 判断是否有一个是空? &#x2F;fn, 动态开点编号多测没清空&#x2F;fn</li><li>P5021 multiset erase(iter)会删除一个元素, erase(value)会删除所有等于这个值的元素.</li><li>P4606 圆方树点数最大是图的两倍, 点双弹栈连放点时不是”删到栈顶为 $u$”而是”直到把 $v$ 删掉”(指处理 $u\to v$ 这条边)</li><li>nfls vector, deque pushback后迭代器失效(重新分配空间)</li><li>写ODT, 不能有split返回set insert返回值的两个指针做端点, 因为分裂后一个端点的时候可能删前面的</li><li>满秩矩阵高斯消元也必须每次找一个非0行换上来.</li><li>用虚树统计答案注意区分作为原来点lca新增的点</li><li>错误的淀粉质深度有 $2$ 倍常数.</li></ul><h3 id="vector扩容和求值顺序"><a href="#vector扩容和求值顺序" class="headerlink" title="vector扩容和求值顺序"></a>vector扩容和求值顺序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;array&lt;<span class="type">int</span>, 2&gt;&gt; nxt;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">newnode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    nxt.<span class="built_in">resize</span>(tot);</span><br><span class="line">    <span class="keyword">return</span> tot - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">newnode</span>();</span><br><span class="line">    nxt[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">newnode</span>(); <span class="comment">//!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会RE, 为什么呢? 因为c++14及以前没有规定等号两边求值顺序, 所以对叹号处代码, 先获取<code>nxt[0][0]</code>的地址, 再调用<code>newnode()</code>使得<code>nxt</code>地址失效了! .</p><p>同理见<a href="https://www.cnblogs.com/yaoxi-std/p/17023579.html">yaoxi的blog</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023SDSC</title>
      <link href="/2023/07/14/2023_sdsc/"/>
      <url>/2023/07/14/2023_sdsc/</url>
      
        <content type="html"><![CDATA[<h1 id="2023夏令营"><a href="#2023夏令营" class="headerlink" title="2023夏令营"></a>2023夏令营</h1><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>垃圾山外宿舍6人</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="Contest"><a href="#Contest" class="headerlink" title="Contest"></a>Contest</h3><h4 id="T1-colour"><a href="#T1-colour" class="headerlink" title="T1 colour"></a>T1 colour</h4><blockquote><p>有序列 $a_n$, 初始 $a_i&#x3D;0$, 给定 $p_m$, $q$ 次询问按顺序遍历 $p_l\ldots p_r$, 对于 $p_i$, 选择给 $a_{p_i}$ 或 $a_{p_i+1}$ 赋值为 $i$.<br>$n\le 500, m\le 10^6, q\le 2000$</p></blockquote><p>对于位置 $i$, 有一些是和右边选一个赋值, 有些是和左边, 称为向左伸&#x2F;向右伸. 考虑每个位置最终颜色, 注意到 $i-1$ 中向右伸的最高的 $lt$ 是重要的, 如果 $i-1$ 的位置最终颜色比 $lt$ 小, 则右边必须选的比 $lt$ 大, 然后就想到 $f_{i, 0&#x2F;1&#x2F;2}$ 表示位置 $i$ 选的数与从 $i$ 向右伸的最后一次操作 $t$ 小于&#x2F;相等&#x2F;大于就能转移了.</p><p>复杂度 $nq\log m+m$</p><h4 id="T2-binary"><a href="#T2-binary" class="headerlink" title="T2 binary"></a>T2 binary</h4><blockquote><p><img src="/img/2023-07-14-13-59-22-image.png" alt="picture 0">  </p><p>$n, m\le 5\times 10^5$</p></blockquote><p>考虑已经选定了 $w$ 之后, 答案只在某一次没有 $x$ 或没有 $y$ 才变化, 很难注意到左右其实是独立的, 因为加入操作左边再操作右边, 你操作右边时的 $x$ 一定会找到刚才操作左边的操作位置的右边.</p><p>于是只考虑一边, 那么相当于给每个 $t&#x3D;1$ 的操作位置配一个 $s&#x3D;1$ 的, 相当于括号匹配, 于是 $t&#x3D;1$, $s&#x3D;1$ 分别赋值 $1, -1$, 然后求失配数, 所以直接线段树求最大前缀和&#x2F;后缀和.</p><p>现在对于给定的 $w$ 是1log算. 发现 $w$ 是单调的, 满足条件的一定是一个后缀, 因为 $w$ 往后了你的 $u$ 就不断往前然后后面就越不可能填满前面就越可能填满这样的.</p><p>于是二分2log, 考虑在刚才的线段树上二分, 但 $mid$ 处不一定 $t&#x3D;1$, 一种方法是 $mid$ 前后第一个 $t&#x3D;1$ 的 $w_1, w_2$, . 但其实可以直接把中间当成可以二分的地方, 因为 $w_1, w_2$ 里一定有一个可以把答案拆成 $[1, w_1], [w_2, n]$ 算.</p><h4 id="T3-tree"><a href="#T3-tree" class="headerlink" title="T3 tree"></a>T3 tree</h4><blockquote><p>给定 $n$ 点带权无根树, $q$ 次询问对于给定的 $u, v, A, B$, 从 $u, v$ 出发的不交路径 $l_1, l_2$, 最大的 $A\cdot f(l_1)+B\cdot f(l_2)$, 其中 $f(l)$ 表示边权和.</p><p>$n\le 5\times 10^5, q\le 10^5$</p></blockquote><p>容易想到可以用 $u\to v$ 上一条边分开树, 两个路径分别在一边. 然后答案就是两边的距离最大值.</p><p>距离最大值可以再拆开, 对于 $u\to x\to m$, 其中 $x$ 在 $u\to v$ 上, $m$ 在 $x$ 的子树中, 变成 $dis(u, x)+dis(x, m)$.</p><p>树剖之后这个 $dis(x, m)$ 可以预处理, 因为虽然它和所在链有关, 但是因为树剖之后只有 $\log n$ 个点所在的链不是重链, 这些单独处理即可.</p><p>然后继续拆贡献, 考虑 $u, v$ 为祖孙的情况, $dis(u, x)$ 差分成两个深度相减, 最后去掉只和 $u, v$ 相关的东西就成了 $Ag_u(x)+Bg_v(y)$, 其中 $g_u(x)&#x3D;l_x-dep_x, g_v(x)&#x3D;l_x+dep_x$ 这样的状物.</p><p>然后考虑这树剖后线段树对应的 $\log^2 n$ 个区间, 考虑 $x$ 和 $y$ 的位置, 他们要满足 $x&lt;y$. 如果他们所在的拆出的线段树区间不同可以直接做(枚举一个区间, 算另一边最小值), 另一种情况考虑它们所在的区间相同, 此时考虑那个用一条边分开树, 那么枚举这个区间中的分界线, 此时两边贡献就是一个前缀&#x2F;后缀max, 正反各扫一遍可以获得, 然后线性建凸壳. 这样建树就2log(每个区间跑一遍凸壳). 询问可以排个序砍掉在凸壳上二分的log.</p><p>法2是淀粉质</p><p>询问被拆成从分治重心出发的两部分, 仍然拆贡献, 然后直接从重心dfs, 维护凸包, 每进入一个点插入到凸包中, 退出一个点再撤销, 所以凸包要李超树, 复杂度是查询2log预处理1log.</p><p>得分100 + 0 + 15, 没打T2暴力大大失败</p><h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><h4 id="CF1764G3-Doremy’s-Perfect-DS-Class-Hard-Version"><a href="#CF1764G3-Doremy’s-Perfect-DS-Class-Hard-Version" class="headerlink" title="CF1764G3 Doremy’s Perfect DS Class (Hard Version)"></a>CF1764G3 Doremy’s Perfect DS Class (Hard Version)</h4><blockquote><p>-<strong>这是一道交互题.</strong></p><ul><li>交互库有一个 $[1, n]$ 的排列 $p$.</li><li>你可以询问 $l, r, k$, 交互库会返回 $\left\lfloor\dfrac{p_l}k\right\rfloor, \left\lfloor\dfrac{p_{l+1}}k\right\rfloor, \cdots, \left\lfloor\dfrac{p_r}k\right\rfloor$ 中不同数的个数.</li><li>你需要在 $20$ 次询问内找到 $p$ 中 $1$ 的位置.</li><li>$n\in[3, 1024]$.</li></ul></blockquote><p>$n$ 为奇数时, 考虑让 $k&#x3D;2$, 因为除以 $k$ 相等的数两两配对. 这样问前缀 $[1, i]$ 得到 $t$, 那么 $2t-i$ 就是出现恰好一次的, 再同样的问一下另一边, 那么 $1$ 就在多的那一边. 复杂度 $2\log n$</p><p>$n$ 为偶数时, 除了 $1$, $n$ 也没有配对, 问完之后如果两边恰好一次的一样多显然就 $1$, $n$ 各一个, 然后问一遍 $n$ 就能找到谁是 $n$, 以后就不用再问了($n$ 已经在区间外了), 次数 $2\log n+1$</p><p>考虑如何把 $+1$ 砍了, 那么看起来考虑最后一次长为 $2$ 的时候, 假设当前为 $p, p+1$, 则因为二分成了这个区间, 一定已经知道 $[1, p-1], [1, p+1], [p+2, n], [p, n]$ 这些区间, 那么考虑 $[1, p-1]$ 和 $[1, p+1]$, 它们中间增加了一个 $1$ 和一个 $p$ 通过看种类数加2还是加1就可以判断这两个数中除了 $1$, 另一个数的配对出现在哪一边, 假设在后缀, 然后再问 $[p+1, n]$, 判断种类数是否增加, 这样就把数量减少到 $20$ 次.</p><h4 id="luogu-P9393-紫丁香"><a href="#luogu-P9393-紫丁香" class="headerlink" title="luogu P9393 紫丁香"></a>luogu P9393 紫丁香</h4><blockquote><p>对于一个字符串 $A$, 记 $A_i$ 表示它的第 $i$ 个字符.</p><p>设 $S$ 是任意长度为 $m$ 的 $01$ 串. 我们有 $n$ 个操作, 第 $i$ 个操作可以表示成一个定义域和值域都是长度为 $m$ 的 $01$ 串集合的函数 $f_i$, 表示经过这次操作后 $S$ 会变成 $f_i(S)$. 而函数 $f_i$ 可以由一个长度为 $m$ 的串 $T_i$ 表示, $T_i$ 由 $\texttt{0, 1, -}$ 三种字符组成, 其中:</p><ul><li><p>$T_{i, j}&#x3D;\texttt{0}$ 表示 $[f_i(S)]_j&#x3D;\texttt{0}$.</p></li><li><p>$T_{i, j}&#x3D;\texttt{1}$ 表示 $[f_i(S)]_j&#x3D;\texttt{1}$.</p></li><li><p>$T_{i, j}&#x3D;\texttt{-}$ 表示 $[f_i(S)]_j&#x3D;S_j$.</p></li></ul><p>也就是说, 每个操作会将 $S$ 的一些位赋值为 $0$, 一些位赋值为 $1$, 还有一些位不变.</p><p>现在有 $q$ 次操作, 每次操作给定一个长度为 $m$ 的 $01$ 串 $S$, 你可以对它做任意多次操作, 操作的顺序任意, 一个操作可以做多次. 得到的串 $S’$ 可以被看做一个二进制数, 求对应二进制数最大的 $S’$.</p><p>$m\le 22, n, q\le 10^5$</p></blockquote><p>考虑倒着做, 因为正着操作是不可逆的而倒着操作每次操作都会变的更好, 那么撤销一次操作后串由 $0, 1, ?$ 组成, 要找到最大的 $01?$ 串可以匹配一开始的 $s$.</p><p>你发现3进制我们没法用各种子集dp, 集合科技, 因为存不下 $3^n$.</p><p>然后注意到因为我们最后要找最大的答案, 所以直接把 $0$ 都变成 $?$ 是不劣的, 而找到最大的 $1?$ 串之后所有 $?$ 最后一定都是 $0$. 于是变成 $2$ 进制问题. 然后就是要从结果开始不断用操作把 $1$ 消成 $?$ 直到弄不动了, 再判断能不能和初始状态匹配.</p><p>然后考虑 $f_i$ 表示可以把 $i$ 消去至少一个 $1$ 的操作, 一个FWT搞定. 然后考虑 $g_i$ 表示 $i$ 可以变成什么, 则 $g_i&#x3D;g_{f_i(i)}$ 就对了吧</p><p>最后要处理多组询问, 相当于求最大的 $g_i\supset s$, 也是一遍dp.</p><h4 id="CF1693E-Outermost-Maximums"><a href="#CF1693E-Outermost-Maximums" class="headerlink" title="CF1693E Outermost Maximums"></a>CF1693E Outermost Maximums</h4><blockquote><p>有一个长度为 $n+2$ 的序列 $a$, 其中 $a_0&#x3D;a_{n+1}&#x3D;0$, 其余元素均给定.<br>你可以进行下面两种操作任意次:</p><ol><li>设 $x$ 表示序列 $a$ 最靠左的最大值的位置, 则令 $a_x\leftarrow \max_{i&#x3D;0}^{x-1}a_i$.</li><li>设 $y$ 表示序列 $a$ 最靠右的最大值的位置, 则令 $a_y\leftarrow \max_{i&#x3D;y+1}^{n+1}a_i$.</li></ol><p>你需要求出使序列 $a$ 的所有元素均变成 $0$ 所需的最少的操作总次数.</p></blockquote><p>考虑一个 $n^2$ 做法, 对于当前最大值, 找到次大值位置, 然后左边的都用操作1右边的都用操作2, 中间的随便.</p><p>然后考虑优化, 因为不能实时维护最大值次大值, 考虑每个数放一个箭头表示它是由操作 $1$(左箭头)或操作 $2$(右箭头)得到, 如果当前最大值为 $x$, 那么左箭头是一个前缀, 右箭头是一个后缀, 不会有两个箭头相对, 一串箭头指向一个 $x$ 这一串都是 $x$. 那么这一次操作只需要定位当前次大值, 算出新的分界线(不一定是次大值, 还可能是某个箭头).</p><h4 id="CF1209G2-Into-Blocks-hard-version"><a href="#CF1209G2-Into-Blocks-hard-version" class="headerlink" title="CF1209G2 Into Blocks (hard version)"></a>CF1209G2 Into Blocks (hard version)</h4><blockquote><p>给你 $n$ , $q$, $n$ 表示序列长度, $q$ 表示操作次数.</p><p>我们需要达成这么一个目标状态:<br>如果存在 $x$ 这个元素, 那么必须满足所有 $x$ 元素都必须在序列中连续.</p><p>然后你可以进行这么一种操作, 将所有的 $x$ 元素的变为任意你指定的 $y$ 元素, 并且花费 $cnt[x]$ 的花费, $cnt[x]$ 代表 $x$ 元素的个数.</p><p>现在有 $q$ 次询问, 每次询问单点修改一个位置的值, 求修改完之后最小花费使得序列满足目标状态.</p><p>注意: 更新不是独立的, 之前的更新会保留.</p><p>$n, q\le 2\times 10^5$</p></blockquote><p>考虑合并到最后一定是若干段, 但合并是困难的, 所以改成考虑没有被同一个值覆盖的是分界线.</p><p>然后线段树维护, 分界线作为被覆盖次数最小的位置, 另外区间众数因为所有数都在一个区间里所以就是区间max.</p><h4 id="CF1656G-Cycle-Palindrome"><a href="#CF1656G-Cycle-Palindrome" class="headerlink" title="CF1656G Cycle Palindrome"></a>CF1656G Cycle Palindrome</h4><blockquote><p> 给定一个长度为 $n$ 的数列 $a_{1 \cdots n}$, 你需要找到一个<strong>循环数列</strong> $b_{1 \cdots n}$ 使得数列 ${ a_{b_{1}}, a_{b_{2}}, a_{b_{3}}, \cdots, a_{b_{n}} }$ 是一个<strong>回文数列</strong>且 $b$ 是一个长度为 $n$ 的<strong>排列</strong>.</p><p>$\sum n\le 2\times 10^5$</p></blockquote><p>因为循环排列很困难, 所以考虑随便构造一个回文串然后调整成这个</p><p>首先如果 $a_i&#x3D;a_j$, $i, j$ 不在一个环上显然 $i$ 和 $j$ 交换合并两个环.</p><p>然后现在所有相对位置都在一个环上.</p><p>考虑两对 $a_i&#x3D;a_j, a_k&#x3D;a_l$, 那么按顺序交换 $i, k$, $j, l$, $i, j$ 的出边交换.</p><h4 id="uoj783-新年的双区间操作"><a href="#uoj783-新年的双区间操作" class="headerlink" title="uoj783 新年的双区间操作"></a>uoj783 新年的双区间操作</h4><blockquote><p>给定 $a_n$ 和 $m$ 个操作 $(l, r, x, l’, r’, y)$, 表示如果区间 $[l, r]$ 中最大值大于 $x$, 就让区间 $[l’, r’]$ 中每个数和 $y$ 取max, 接下来有 $q$ 次单点修改, 在每次修改后求出进行所有操作后序列的最大值为多少.</p><p>$n, m\le 2\times 10^5, q\le 6\times 10^5$, 4s</p></blockquote><p>考虑每个操作可以写成如果被触发, 答案对 $f_i$ 取max, 于是如果求出 $f$ 只要考虑初始位置和修改贡献, 简单题.</p><p>那么问题就成了如何求 $f$, 那就是对每个区间找有哪些区间与自己有交, 自己的 $f$, 且 $x$ 比自己 $y$ 小, 且时间比自己晚, 对这些区间的 $f$ 取个max, 就是个偏序dp. 大概扫时间, cdq值域, 线段树维护序列维.</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="Contest-1"><a href="#Contest-1" class="headerlink" title="Contest"></a>Contest</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><blockquote><p>给定 $a_n$, $q$ 次区间询问 $[l, r]$ 最多可以选出多少个不交的和为 $0$ 的区间.<br>$n, q\le 4\times 10^5$, 32M</p></blockquote><p>先以每个点为左端点匹配出和为 $0$ 的区间, 然后每个点找到右端点最左的左端点在它右边的点, 于是询问就是不断跳这个.</p><p>倍增空间炸了, 写个树剖即可.</p><p>然后更强的方法是在得到的树上算出深度, 从询问左右端点分别向右找到第一个区间算出深度, 它们的深度差是答案或答案差 $1$, 于是离线树上 $k$ 级祖先可以做到时间空间线性.</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><blockquote><p>给定 $n$ 点树, 求一条链 $u\to v$ 最大化 $dis(u, v)\cdot f(u, v)$, 其中 $f(u, v)$ 表示最大的树上点到它的距离.<br>$n\le 5\times 10^5$</p></blockquote><p>这个信息很全局, 不要淀粉质.</p><p>考虑这个结构其实是一个树上的三叉, 枚举三叉中心也就是那个离链最远的点连到链上得到的那个点 $r$, 此时 $u, v$ 和最远点 $w$ 分别在一个子树, 那么答案一定是这三个子树中最远的叶子搞出来的.</p><p>然后计数就直接一次换根dp算最远叶子及叶子个数.</p><p>然后这个会让人产生一个问题就是你可能枚举两个 $r$ 对应同一组 $u, v$, 那么情况就是选出一组 $u, v$, 然后链的不同部分可以连出两个长度相等的 $w$.</p><p><img src="/img/2023-07-15-15-22-21-image.png" alt="picture 2">  </p><p>然后你发现一个 $u&#x2F;v$ 换到 $w$ 一定会严格更大, 于是直接在每个 $r$ 上计数就不会重.</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><blockquote><p><img src="/img/2023-07-15-14-55-14-image.png" alt="picture 1">  </p><p>$n\le 18$</p></blockquote><p>杜赢说你随机调整后打表可以过16.</p><p>考虑把所有 $2^n$ 种状态建图成点, 人的策略作为边, 因为人无法区分 $x, y$ 如果 $x, y$ 只有自己所在位不同, 则把 $x, y$ 连一条边, 这条边就表示如果判断出局面是 $x, y$ 之中, 那么它选择谁, 那么问题就成了要给所有边定向满足任意一个点有不少于一半的边指向自己, 于是直接跑欧拉回路使得每个点的度数正好是对的.</p><h3 id="Class-1"><a href="#Class-1" class="headerlink" title="Class"></a>Class</h3><h4 id="Swapping-Operation"><a href="#Swapping-Operation" class="headerlink" title="Swapping Operation"></a>Swapping Operation</h4><blockquote><p>给定 $a_n$, 定义<br>$$f(a)&#x3D;\max_k \mathrm{and}_ {i\le k} a_i +\mathrm{and}_{i\gt k} a_i$$<br>你可以进行至多一次交换两个数, 求之后的最大值.</p></blockquote><p>你先把原答案暴力出来, 那么众所周知and只变化log次, 两边各有log个, 如果不换这些则答案一定只会变小. 把这些点称作关键点.</p><p>交换两个关键点之间暴力.</p><p>于是问题是交换一个关键点和一个非关键点, 假设把前缀的关键点换走了, 那么后缀的部分和换走了谁没关系, 先枚举分界线, 再枚举换走的东西, 最后就成了最大化 $f(1, i-1)\mathrm{and}f(i+1, k)\mathrm{and} a_j$ 然后因为两个 $f$ 的值只有log种, 于是一共只有 $\log^2$ 种, 直接对每一种, 算出 $g(v, k)$ 表示 $k+1\le j\le n$ 表示与 $v$ 亦或之后的最大值.</p><p>要用st表优化求and和. 复杂度2log.</p><h4 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h4><blockquote><p>平面上 $2n$ 个点, 两两匹配, 最大化好的匹配个数, 好的匹配定义为点在同一行或同一列.</p></blockquote><p>考虑网格图网络流建模每个横坐标建点每个纵坐标建点, 原来的点变成行列之间的边.</p><p>此时就是有公共点的边之间是好的匹配, 上界显然是每个连通块 $\lfloor \dfrac{siz}{2} \rfloor$, 而这个是可以达到的, 只要把连通块拉成dfs树, 然后从下往上, 每个点都匹配完了或留一条父边就能构造出来了.</p><p>复杂度线性.</p><h4 id="Be-Careful-2"><a href="#Be-Careful-2" class="headerlink" title="Be Careful $2$"></a>Be Careful $2$</h4><blockquote><p>$n\times m$ 的矩形有 $k$ 个特殊点, 一个正方形是好的当且仅当完全位于矩形内且不覆盖任意一个特殊点, 求好的正方形面积之和.<br>做到 $k^2$</p></blockquote><p>先容斥算对覆盖 $S$ 所有点的方案数.</p><p>那么子集有 $2^k$ 个但点集包围盒只有 $k^4$ 个.</p><p>然后发现如果包围盒内部有点则容斥系数是 $0$, 因为每个点在&#x2F;不在就让系数消了, 只考虑所有点都在边界上的 $k^2$ 个</p><p>然后考虑如何找到所有包围盒, 考虑先枚举矩形左边界上的一个点, 再枚举矩形右边界上的一个点, 那么两个点为对角围成的矩形之间肯定没点, 那么所有的右端点是单调的, 同时上下边就是对应的这横坐标两个点之间, 纵坐标前驱后继的点. 于是单调栈维护右端点, 再用链表维护每个横坐标下所有点的前驱后继.</p><p>然后要统计答案, 对每个答案贡献是一个分段四次函数, 直接再做前缀和结束了.</p><p>复杂度 $k^2$</p><h4 id="Mystery-Square"><a href="#Mystery-Square" class="headerlink" title="Mystery Square"></a>Mystery Square</h4><blockquote><p><img src="/img/2023-07-15-19-56-52-image.png" alt="picture 6">  </p></blockquote><p>先从中间拆成两半, 考虑只有20个问号的一边.<br>todo</p><h4 id="回"><a href="#回" class="headerlink" title="回"></a>回</h4><blockquote><p><img src="/img/2023-07-15-19-56-12-image.png" alt="picture 4">  </p></blockquote><p>cdq分治让操作都在询问前 + 差分 + 维护关于原始数组的高次多项式</p><p>操作二维差分只会变成了主对角线副对角线加, 然后再差分成射线加, 再差分成一个点和一个方向.</p><p>然后维护奇妙而复杂的多项式, 找网上题解吧.</p><h4 id="Difficult-Constructive-Problem"><a href="#Difficult-Constructive-Problem" class="headerlink" title="Difficult Constructive Problem"></a>Difficult Constructive Problem</h4><blockquote><p><img src="/img/2023-07-15-19-56-37-image.png" alt="picture 5">  </p></blockquote><p>暴力枚举头尾的问号, 现在假设头尾已经确定.</p><p>然后发现翻转字符只改变2, 不改变奇偶性, 并且是连续的, 直接从前向后贪心, 每个位置看如果填了 $0$ 后面的能不能行</p><h4 id="Permutation-Arrangement"><a href="#Permutation-Arrangement" class="headerlink" title="Permutation Arrangement"></a>Permutation Arrangement</h4><blockquote><p>给定 $n$ 阶排列包含 $1\ldots n$ 和 $?$, 要求你在所有 $?$ 处填数补全排列, 满足任意相邻两位置不相邻</p></blockquote><p>先假设所有问号不相邻, 那么问题是匹配, 于是一个数最多只有四个空不能放, 于是当 $n\ge 8$ 的时候, 每个点至少连出 $4$ 条, Hall定理发现是一定有解.</p><p>于是现在有空位了, 那么把空位随便填, 留出8个不相邻的, 于是如果有至少15个空一定有解</p><p>于是前面随便填, 最后15个状压爆搜.</p><h4 id="workshop"><a href="#workshop" class="headerlink" title="workshop"></a>workshop</h4><blockquote><p><img src="/img/2023-07-15-19-29-30-image.jpg" alt="picture 3">  </p><p>数字最后要到 $2$</p></blockquote><p>因为一开始是排列, 所以考虑不断利用初始序列压缩初始序列的值域并始终保持互不相同的性质.</p><p>那么第一次只知道自己和右边, 要求一个函数满足 $f(u, v)\ne f(v, w)$, 那么一个方法是 $u, v$ lcp后第一位是几以及lcp长度, 值域变成 $2\log v$</p><p>然后因为中午和晚上能同时看到两边, 所以可以做两次, 就是 $v\to f(f(u, v), f(v, w))$</p><p>然后这样的话这个 $2$ 不够优秀, 考虑怎么不乘 $2$, 考虑使用lowbit为长度一半的二进制来编码, 那么因为没有两个不同的数互相包含, 所以可以直接记录第一个 $u&#x3D;1, v&#x3D;0$ 的位置, 此时中午结束后答案到 $0\ldots 3$</p><p>那么为了压成 $0\ldots 2$, 直接对当前位分类讨论, 如果当前位是 $0, 1, 2$ 不管, 如果是 $3$, 那么两边一定是 $0, 1, 2$ 中的, 所以选剩下的一个就做完了.</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="Contest-2"><a href="#Contest-2" class="headerlink" title="Contest"></a>Contest</h3><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h4><p>CF37E. Trial for Chief, 在greedy里写过</p><h4 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h4><blockquote><p>维护 $n$ 个集合的序列 $s_n$, 每次给区间的集合都加一个数, 或者询问区间中集合最大的mex.</p></blockquote><p>考虑mex需要底下的全都出现过, 可以转化成没出现过的”空”的最小值.</p><p>先上一个颜色段均摊, 然后保证了删除一个空时所有集合都有这个空, 插入时都没有这个空.</p><p>然后上线段树套平衡树+标记永久化, 每个点开一个堆表示所有完整覆盖了的被插入的空, 于是一个点的集合的并的<code>mex</code>是它到根的路径上所有空的最小值, 而答案是它下面的所有叶子到根的路径上的空的最小值的最大值, 那么开一个<code>mx</code>表示以自己为根的答案, <code>pushup</code>时把两个子节点的<code>mx</code>取<code>max</code>, 然后再对自己的集合取min即可.</p><p>复杂度2log.</p><h4 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h4><blockquote><p>有 $n$ 个数, 每次可以擦掉两个和为偶数的数, 写上它们的平均数, 问最后是否能变成一个数. 构造方案.</p></blockquote><p>考虑对 $\bmod 4$ 余数分类, 那么如果全是偶数, 只要把所有余 $2$ 的余 $4$ 的内部合并掉, 最后合一次即可. 当然全是奇数一样做, 然后结论是如果 $1$ 类 $3$ 类均多于 $1$ 或者 $2$ 和 $4$ 类均多于 $1$.</p><p>然后如果 $1, 3$ 中只有 $1$ 个有肯定寄了, 如果 $2, 4$ 有一个就找到最低的二进制位不全相同的位, 找两个不同的取平均一定会得到在下一位不同的, 重复即可.</p><h3 id="Class-2"><a href="#Class-2" class="headerlink" title="Class"></a>Class</h3><h4 id="Eulerian"><a href="#Eulerian" class="headerlink" title="Eulerian"></a>Eulerian</h4><blockquote><p>给定 $n$ 个点的图, 可以 $60$ 次问一个点集的点的导出子图边数, 判断图是否有欧拉回路.</p></blockquote><p>看是否有点度数是奇数, 可以先问总点数, 然后问除了一个点的可以得到一个点的度数.</p><p>把点随机分两部分, 则总的减去两部分自己的就会得到两部分之间边的数量, 而它也就是一侧点的度数和的奇偶性, 因为对于所有的奇度点, 有 $\dfrac{1}{2}$ 的概率有一半分到奇数个, 所以一次成功概率为 $\dfrac{1}{2}$, 你可以进行最多29次, 十分正确.</p><h4 id="Multiple-Communications"><a href="#Multiple-Communications" class="headerlink" title="Multiple Communications"></a>Multiple Communications</h4><h4 id="Mapa"><a href="#Mapa" class="headerlink" title="Mapa"></a>Mapa</h4><blockquote><p>通信题, A收到 $100$ 组 $10^9$ 的 $G_x&#x3D;y$, 可以传给B $3000bit$ 的信息, 然后 $Q$ 次询问B $G_x$ 的值.</p></blockquote><p>在模 $10^9$ 之下把 $G(x)$ 看成 $n-1$ 次多项式, 然后拉格朗日插值出来把系数传过去.</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="琪露诺的符卡交换"><a href="#琪露诺的符卡交换" class="headerlink" title="琪露诺的符卡交换"></a>琪露诺的符卡交换</h4><blockquote><p>$n$ 个人, 每个人有 $n$ 种卡, 每种卡有 $n$ 张, 然后进行交换使得每个人拿到所有种类卡片各一张, 每张卡只能被交换一次, 求方案.</p></blockquote><p>发现写成 $a_{i, j}$ 表示 $i$ 人第 $j$ 个球的种数, 那么可以通过简单方案把 $a$ 转置($i$ 人 $j$ 球与 $j$ 人 $i$ 球换. )</p><p>然后只要重排 $a$ 的每一行让每一列互不相同, 这个是可以的因为考虑人向球连边形成二分图, 则是 $n$ 正则图, 你可以找出 $n$ 个完美匹配</p><h4 id="Trokuti"><a href="#Trokuti" class="headerlink" title="Trokuti"></a>Trokuti</h4><p>先解方程得到 $5$ 个点的关系.</p><p>然后开始每次加入一个点, 询问 $u$ 和 $a_1, a_2$, 减去 $a_1, a_2$ 之间的得到这个点和 $a_1, a_2$ 之间的, 如果是 $0, 2$ 则直接确定了, 否则一定一条连一条不连, 否则再问 $u, a_2, a_3$, 每次有 $\dfrac{1}{2}$ 的概率解出来, 复杂度正确, 那么到最后因为中间间隔相连, 所以直接看 $u, a_1, a_3$ 就确定了. 因为每回合有分别 $\dfrac{1}{2}$ 概率确定 $1$ 条边或 $2$ 条边, 所以期望一次问出 $1. 5$ 条边, 十分正确.</p><h4 id="Captivating-process"><a href="#Captivating-process" class="headerlink" title="Captivating process"></a>Captivating process</h4><blockquote><p>给定序列 $f_n, g_n$, 对每个 $x, y$ 求 $f^{(k)}(x)&#x3D;g^{(k)}(y)$, 多组询问.</p></blockquote><p>首先这是内向基环树森林, 分类讨论.</p><p>如果最后都没进环, 合法则当存在 $u$ 使得 ${dep_F}_u-{dep_F}_x&#x3D;{dep_G}_u-{dep_G}_y$, 等价于 $u$ 在两个图的深度差为 $x, y$ 的深度差, 这样直接塞到桶里, 然后又要满足 $u$ 是 $x$, $y$ 的祖先, 那么考虑dfs序就是二维数点.</p><p>如果都在环里, 可以先把 $x, y$ 相对入环点退深度步, 然后相当于两个点直接从环上走, 那么如果 $x$ 最终位移 $a$, $y$ 偏移 $b$, 当且仅当 $a-b&#x3D;0 \pmod gcd(l_f, l_g)$, 其中 $l$ 是环长, 最终条件就是走到的点 $u$ 在两个环里分别和 $x, y$ 同环, 以及刚才的同余式, 都是精确相等的.</p><p>最后一个在环里一个在环外的也形式相同.</p><h4 id="Stacking-Up"><a href="#Stacking-Up" class="headerlink" title="Stacking Up"></a>Stacking Up</h4><blockquote><p>你有一个空栈, 每次可以添加一个 $1$, 添加一个当前栈顶元素, 或合并栈顶的两个元素添加它们的和, 并给栈里其他元素都减 $1$.</p></blockquote><p>首先容易编出一个基于倍增的造出任意数, 问题变成减的部分.</p><p>于是倒着往后往回把减去的都加回来即可.</p><h4 id="Icy-Itinerary"><a href="#Icy-Itinerary" class="headerlink" title="Icy Itinerary"></a>Icy Itinerary</h4><p>增量构造, 对于已经有的链 $a\to b$ 维护分界点 $u$, 然后新添加一个点的时候考虑它连接到分界点的边是否存在, 再根据它前&#x2F;后那条边是否存在移动分界点.</p><h4 id="南京原神题"><a href="#南京原神题" class="headerlink" title="南京原神题"></a>南京原神题</h4><blockquote><p>给定 $n\times m$ 矩阵 $A$, 你可以交换相邻元素, 旋转相邻 $2\times 2$ 的矩阵, 或者把 $k$ 个给定的若干个模板子矩阵粘贴到原矩阵任意位置.</p><p>可以认为没有步数无限</p><p>$n, m\le 20, k\le 40$</p></blockquote><p>因为任意交换, 所以旋转没用, 首先和位置有 $0$ 个关系, 只要考虑每个东西的数量对了就行.</p><p>然后你倒着做, 每次把若干个字符换成若干个通配符, 去操作一定更优, 你每次至少粘贴至少要干掉一个, 于是就没有任何问题了.</p><p>然后操作数随便成 $k$ 次用没用过的章和 $nm-k$ 次用用过的章, 其中没用过的章可能会引起 $nm$ 个移动, 用过的只引起 $1$ 个移动</p><h4 id="南京不原神题"><a href="#南京不原神题" class="headerlink" title="南京不原神题"></a>南京不原神题</h4><blockquote><p>平面上一个正方形 $(0, 0, {10}^9, {10}^9)$, 要求找到 $k$ 个互不相交的锐角三角形且所有三角形的并是正方形.</p><p>$k\le 50$</p></blockquote><p>先人类智慧画出 $k&#x3D;8, 9, 10$ 的情况, 更大的直接对着一个三角形拆即可.</p><p>然后证明 $k\le 7$ 无解, 考虑点分成正方形角点 $4$ 个, 边点 $x$ 个, 空地点 $y$ 个三种, 分析他们至少在几个三角形里, 于是 $180k&#x3D;4*90+180x+360y, 3k\ge 2\times 4+3x+5y$, 得到 $y\ge 2$, 又因为每个点至少是 $5$ 个锐角三角形顶点, 同时拥有这两个点的三角形最多有 $2$ 个, 于是至少有 $8$ 个.</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="Contest-3"><a href="#Contest-3" class="headerlink" title="Contest"></a>Contest</h3><h4 id="T1-2"><a href="#T1-2" class="headerlink" title="T1"></a>T1</h4><blockquote><p>给定 $n$ 点无向有权基环树, $m$ 次操作为修改一条边边权, 或者询问 $k$ 次把一条边加 $1$ 后最大的 $s$, 其中 $s$ 为最小的两个点之间最大流.</p><p>$n, m\le 5. 5\times 10^5$</p></blockquote><p>注意到基环树, 问题解决. 树边和环边分别考虑, 注意到两个的答案都是 $k$ 的 $n$ 段一次函数, 一次函数是下凸的, 可以维护差分就成了区间加区间求和, 最后在数据结构上二分, 复杂度单log或2log(2log居然能过)</p><h4 id="T2-2"><a href="#T2-2" class="headerlink" title="T2"></a>T2</h4><blockquote><p>给定 $n$ 点 $m$ 边有向带权图, 每条边权值为 $[l, r]$ 中任意一个数, 给定 $d_k$, 求所有情况下, 最大的 $i$ 使得 $d_1\ldots d_i$ 是 $1\to n$ 的最短路的一部分</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>dwt发现一个类似题是CF360E</p><p>首先每条边一定是 $l$ 或 $r$, 最短路的部分选 $l$, 其他地方选 $r$.</p><p>二分答案 $x$, $d_1$ 到 $d_x$ 的部分都取 $l$, 然后考虑点 $1$ 和点 $d_x$ 出发的两个人比赛到达 $n$, 最后是不是平局, 于是同时跑dij, 如果某个位置从 $d_x$ 出发的人先到或同时到就取 $l$, $1$ 先到就取 $r$ 看最后谁先到 $n$.</p><h4 id="T3-2"><a href="#T3-2" class="headerlink" title="T3"></a>T3</h4><blockquote><p><img src="/img/2023-07-17-15-13-43-image.png" alt="picture 7">  </p><p>$n\le 5\times 10^5$</p></blockquote><p>考虑先求出所有 $(a, b, c, d)$ 表示一个人的移动范围为 $b, c$, 删掉左右的墙后为 $(a, c), (b, d)$. 于是按照纵坐标扫描线, 维护墙和竖线的交点, $(a, b, c, d)$ 就是相邻四个点, 直接插入删除时计算, 总数 $8n$(插入删除分别 $4$ 个)</p><p>然后考虑dp, 如果两个人能同时选当且仅当 $(b, c)$ 不交, 并且 $a, d$ 伸不进去, 那么按照 $a$ 排序, 就要找 $d_i&lt;b, c_i&lt;a$ 的部分中最小值转移, 简单数点1log</p><h3 id="Class-3"><a href="#Class-3" class="headerlink" title="Class"></a>Class</h3><h4 id="ABC-306-Ex"><a href="#ABC-306-Ex" class="headerlink" title="ABC 306 Ex"></a>ABC 306 Ex</h4><blockquote><p><img src="/img/2023-07-18-07-28-30-image.png" alt="picture 8">  </p></blockquote><p>关系建图, 等号变成一个连通块, 然后对连通块们求拓扑序数量, 那么可能算重是因为如果两个块都没有入度他们谁在前应该是一样的, 于是dp时每次枚举一个度数为 $0$ 的集合 $S$ 一起算, 但是钦定了这些入度为 $0$ 可能还有其他的, 所以容斥, 钦定 $T$ 的部分入度也为 $0$, 容斥系数是 $\vert T\vert$, 那么枚举 $C&#x3D;S+T$, 则最后容斥系数是 $\sum_i \binom {\vert C\vert}{i}{-1}^i&#x3D;(-1)^{\vert C\vert -1}$</p><p>但还留下一个问题, 因为有等号, 所以我们不知道一开始的连通块都长什么样, 但是这是没有关系的, 就是dp相当于每次钦点一些连通块, 那直接钦定选定的连通块内全是等号, 那些这里不是等号的部分会在钦点更小的连通块的时候计算, 而容斥系数按照连通块个数计算即可.</p><p>然后每次枚举入度为 $0$ 的dp即可. 复杂度 $3^n$</p><h4 id="CF1081G-Mergesort-Strikes-Back"><a href="#CF1081G-Mergesort-Strikes-Back" class="headerlink" title="CF1081G Mergesort Strikes Back"></a>CF1081G Mergesort Strikes Back</h4><blockquote><p>求一个随机序列进行 $k$ 层归并排序后逆序对期望, 其中进行 $k$ 层指当递归深度为 $k$ 时直接输出原序列对应区间的归并排序.</p></blockquote><p>大家都知道归并排序不改变前缀max, 然后不会了</p><p>哦, 实际上, 更厉害的是根据前缀max划分后段, 则段内顺序不变</p><p>对逆序对计数, 考虑 $x, y$ 形成逆序对的概率, 一开始在同一段的两个数概率是 $0. 5$, 否则和区间长度 $a, b$ 有关, 考虑 $a, b$ 一共只有两种取值, 枚举 $a, b$, 枚举 $i, j$ 表示 $x, y$ 在这 $a, b$ 中的位置, 再考虑 $s_x, s_y$ 表示 $x, y$ 所在段的开头的前缀max, 容易发现要想形成逆序对, 要满足 $s_y&gt;s_x&gt;x&gt;y$, 那么形成一棵树:</p><p><img src="/img/2023-07-14-2023_sdsc_1689592553504.png" alt="1689592553504"></p><p>然后这两块就是 $x$ 和 $s_x$ 之间的 $i-2$ 或 $y$ 和 $s_y$ 之间的 $j-2$ 个数, 因为 $x$ 以后都不影响 $s_x$ 称为前缀最大值, 于是只要满足这些关系就可以了, 那么答案就是子树大小倒数乘积, 处理逆缘前缀和就能优化成只枚举一个.</p><h4 id="No-Zero-Sum-Subsegment-Ucup-Stage-4-Ukraine-Anton-Trygub-Problem-N"><a href="#No-Zero-Sum-Subsegment-Ucup-Stage-4-Ukraine-Anton-Trygub-Problem-N" class="headerlink" title="No Zero-Sum Subsegment Ucup Stage 4 Ukraine (Anton Trygub), Problem N"></a>No Zero-Sum Subsegment Ucup Stage 4 Ukraine (Anton Trygub), Problem N</h4><blockquote><p><img src="/img/2023-07-18-07-30-25-image.png" alt="picture 9">  </p></blockquote><p>容易想到转化成前缀和模型, 然后你的每次拐一下就不能经过了.</p><p>假设总和为正, 那么路径最多是下到 $0$ 下走一个谷, 拐到 $0$, 上到总和, 再走一个单峰, 此时这几部分能选的都很有限.<br>比如最后一段一定是一段 $+2$, 一个 $+-1$, 一串 $-2$, 可以枚举 $+2$ 的个数, 原问题 $(a, b, c, d)\to (a-i, b, c, d-i)$, 就只需要考虑前面的部分, 剩下的直接组合数, 复杂度是一次 $min(a, d)$(枚举 $i$)</p><p>然后因为只有 $a, b$ 再变, 带入式子发现你的组合数是定值, 关于枚举的 $i$ 讨论直接加起来</p><h4 id="CF1525F-Goblins-And-Gnomes"><a href="#CF1525F-Goblins-And-Gnomes" class="headerlink" title="CF1525F Goblins And Gnomes"></a>CF1525F Goblins And Gnomes</h4><blockquote><p><img src="/img/2023-07-18-07-30-38-image.png" alt="picture 10">  </p></blockquote><p>先考虑spj怎么写, $i$ 个人看交不交的方法可以是, 把每个点变成入点出点, 出入之间连边建成二分图, 那么覆盖数等于点数减去最大匹配.</p><p>于是每次要删一个点, 删掉以后最大匹配减 $1$ 或不变, 那么因为最大匹配等于最小点覆盖所以一定存在点可以降低 $1$, 直接暴力枚举跑网络流验证.</p><p>于是知道了每次该删什么, 剩下的部分dp即可.</p><h4 id="CF1712F-Triameter"><a href="#CF1712F-Triameter" class="headerlink" title="CF1712F Triameter"></a>CF1712F Triameter</h4><blockquote><p><img src="/img/2023-07-18-07-30-49-image.png" alt="picture 11">  </p></blockquote><p>设 $m_u$ 表示离 $u$ 最近的叶子的距离, 那么 $dis(u, v)&#x3D;\min(m_u+m_v+x, dep_u+dep_v-2dep_{lca})$</p><p>考虑在lca处统计子树内的答案, 那么因为 $m_u&lt;$ 子树高度, 所以长链剖分维护 $g_{u, i}$ 表示 $u$ 子树内 $m_v&#x3D;i$ 的最深的 $u$ 并合并答案即可. 更新答案的时候只要每次去看答案能不能 $+1$, 均摊就是对的, 于是合并新子树时, 要查 $\min (i+j+x, g_{u, i}+g_{u, j}-2dep_u)$, 可以枚举轻子树里那个 $i$, 然后考虑 $j$, 因为 $g_u$ 是随 $j$ 单减的, 所以直接看 $ans-i-x$ 位置的 $j$ 能不能行即可.</p><h4 id="Ucup-Stage-16-Gomel-tourist-Problem-G"><a href="#Ucup-Stage-16-Gomel-tourist-Problem-G" class="headerlink" title="Ucup Stage 16 Gomel (tourist), Problem G"></a>Ucup Stage 16 Gomel (tourist), Problem G</h4><blockquote><p><img src="/img/2023-07-18-07-31-00-image.png" alt="picture 12">  </p></blockquote><p>峰表示调整法可以过</p><p>如果删一条边不产生孤立点且还满足叶子那个条件那就可以删边, 暴力删. 然后考虑删完了的形状.</p><p>一部分点会挂两个叶子称为 $A$ 类点, 剩下的称为 $B$ 类点, $B$ 点将 $A$ 点连起来. 一个 $B$ 一定连着两个 $A$. 那么让选了的贡献 $1$, 没选的贡献 $-1$, 最后要求绝对值不超过 $1$, 那么合并多个连通块显然, 考虑单个连通块. $A$ 点少于 $3$ 特盘掉.</p><p>增量构造每次加入一个 $u$, $u$ 的两个叶子和 $u$ 的关系肯定相反, 贡献和自身选不选相反, 考虑与 $u$ 相连的 $B$ 类点, 判断选的多还是不选的多, 去贡献少的那边, 相等的调总和, 而 $B$ 类如果连着的两个 $A$ 确定了那么一定可以把 $B$ 的贡献得到, 否则 $B$ 尽量去调总和.</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><h3 id="Contest-4"><a href="#Contest-4" class="headerlink" title="Contest"></a>Contest</h3><h4 id="T1-3"><a href="#T1-3" class="headerlink" title="T1"></a>T1</h4><blockquote><p><img src="/img/2023-07-18-15-00-02-image.png" alt="picture 13"><br>$n\le 2\times 10^6$</p></blockquote><p>写了log结果寄了.</p><p>先考虑一对点的贡献, 那么注意到它们能到只要它们走到各自走到最近的 $S$ 中的点然后一步冲过去这样, 算出这个路径的长度设为 $l$, 假设它们需要拆 $l$ 个点中的一个就不能连通, 贡献就是</p><p>$$<br>\begin{gathered}<br>\sum_t \dfrac{\binom{n-l}{t}}{\binom{n}{t}}\<br>\dfrac{(n-l)! }{n! }\sum_t \dfrac{(n-t)! }{(n-l-t)! }<br>\end{gathered}<br>$$</p><p>注意到和式里面是 $l! \binom{n-t}{l}$ 于是上指标求和得到结果为 $\binom{n+1}{l+1}$ 就得到了. (对就是这里写了愚蠢的ntt)</p><p>然后要考虑怎么算每个 $l$ 有多少对点, 记 $p_i$ 表示 $i$ 向前(下标增加)的第一个 $S$ 点, $s_i$ 表示向后, 那么按照 $S$ 把序列分成块, 块内和相邻两块的可以直接算, 问题只剩下 $g(l)&#x3D;\sum_{i&lt;j} [p_i+s_j&#x3D;l]$, 注意到满足限制的正好是不考虑下标限制的一半, 于是扔了下标限制.</p><p>块间的可以按块考虑, 发现对于块 $a, b$ 之间的贡献, $g(l)$ 关于 $l$ 的斜率是 $-1, 0, 1$ 的函数, 所以可以用二阶差分实现加法统计 $g$, 又因为所有块大小之和为 $n$, 本质不同的只有 $\sqrt n$ 种, 直接枚举就解决了.</p><h4 id="T2-3"><a href="#T2-3" class="headerlink" title="T2"></a>T2</h4><blockquote><p>给定 $n$ 个点 $m+n$ 条边的图, $m$ 条边确定, 另外 $n$ 条边都连向点 $0$, 单点修改这 $n$ 条边的权值 $a_i$, 询问最小生成树.</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>一种暴力是线段树分治加lct</p><p>考虑先求出 $m$ 条边的mst, 其他都都没有用, 然后问题就是把mst划分成若干连通块, 每个连通块中最小的 $a_i$ 连向 $0$.</p><p>于是一种厉害的暴力是线段树分治, 用树剖维护.</p><p>然后更厉害的是这个连通块选 $a_i$ 写成树形dp, 然后线段树树剖或静态lct维护ddp.</p><p>std是考虑Kruskal重构树, 在重构树叶子序列建线段树, 每个节点记录 $f_{u, 0&#x2F;1, 0&#x2F;1}$ 表示 $l$ 所在连通块有没有连 $0$, $r$ 所在连通块有没有连 $r$, 合并时看 $mid$ 和 $mid+1$ 是否连到 $0$, 这是对的因为如果两个有一个不连 $0$ 就一定要选lca, 选了lca还不连通的方法只会更劣.</p><h4 id="T3-3"><a href="#T3-3" class="headerlink" title="T3"></a>T3</h4><blockquote><p><img src="/img/2023-07-18-15-25-40-image.png" alt="picture 14">  </p><p>$n, m\le 10^6, nm\le 10^6$</p></blockquote><p>todo</p><h3 id="Class-4"><a href="#Class-4" class="headerlink" title="Class"></a>Class</h3><h4 id="P4672"><a href="#P4672" class="headerlink" title="P4672"></a>P4672</h4><p>如果知道了一个对应点, 就可以知道所有叶子节点, 因为它们到这两个点距离相等. 找到叶子之后一起跳父亲可以对应出其他点.</p><p>找对应点可以考虑直接找一个环, 然后删掉环图变成若干连通块, 那么一个连通块与环的交点最多只有两个点, 它们一定对应.</p><p>最后如果没有环或者没有两个交点都是平凡情况.</p><h4 id="P6935"><a href="#P6935" class="headerlink" title="P6935"></a>P6935</h4><p>网格没有边界</p><p>考虑没有bug的模式, 状态从 $P_0\to P_1$, 考虑由 $P_1$ 转化成 $P_0$, 注意到 $P_1$ 的外边缘一定比 $P_0$ 的外边缘大一圈, 那么就可以从一个角顺着推出整个 $P_0$, 可以用最后两列检验, 直到 $P_0$ 不合法(推出矛盾)</p><p>当有bug时, 考虑假设一个位置是bug, 把bug取反后推回去得到 $P_0$ 会导致周围 $3\times 3$ 出问题, 于是再回来会导致 $5\times 5$ 的格子和实际不同, 但实际上只翻了一个, 结论是bug位置实际只有唯一合法位置.</p><p>那么考虑推过来的时候, 假设碰到错误的位置, bug后的位置会间隔推对, 推错(相邻两个推错了会让下一个推对)因为我们有最后两个来检验所以一定能检验到错的, 于是找到第一行有错的即可. 然后同理可以找到第一列有错的, 确定bug的坐标, 不断重复往回退即可.</p><h4 id="P8392-BalticOI-2022-Day1-Uplifting-Excursion"><a href="#P8392-BalticOI-2022-Day1-Uplifting-Excursion" class="headerlink" title="P8392 [BalticOI 2022 Day1] Uplifting Excursion"></a>P8392 [BalticOI 2022 Day1] Uplifting Excursion</h4><blockquote><p>有 $2m+1$ 种物品, 重量分别为 $-m, -m+1, \ldots, m-1, m$. 重量为 $i$ 的物品有 $a_i$ 个.</p><p>你需要拿走若干物品, 使得这些物品重量之和恰好为 $l$. 在此基础上, 你需要拿尽可能多的物品.</p><p>问在物品重量之和恰好为 $l$ 的基础上, 你最多能拿多少物品.</p><p>$1\leq m \leq 300$, $-10^{18}\le l \le 10^{18}$, $0\le a_i\le 10^{12}$.</p></blockquote><p>首先这题肯定要背包, 考虑怎么转化成值域对的背包.</p><p>方法是, 先强制全选, 如果和大于 $l$ 就往下不选一个最大的, 小于就不选一个最小的, 直到现在和 $s\in [l-m, l]$</p><p>然后直接dp, 但这里值域仍然不确定, 考虑一定可以调整增删物体的顺序使得始终有 $s\in [l-m, l+m]$, 而调整过程中不应该出现两次有同一个和: 这说明可以用更多的之前删掉的数替换掉现在存在的一部分, 但我们一开始一直在操作绝对值最大的, 所以和相等的情况这是不可能的, 因此状态最多有 $2m$ 个, 我们最多只会增删 $2m$ 次, 值域开 $m^2$ 即可.</p><h4 id="P4737"><a href="#P4737" class="headerlink" title="P4737"></a>P4737</h4><p>先按最终局面算一个答案, 假设都是先插里面再插外面, 按照最后局面算每个连通块内的答案. 可以扫描线, 假设从右往左走, 碰到一个栅栏就二分出它纵坐标上到哪(把它下方比他出现晚的都删了), 扫到一个标记就给对应栅栏贡献.</p><p>但是考虑时间之后, 若两个栅栏 $i, j$ 满足 $x_i&lt;x_j, y_i&lt;y_j, i&gt;j$, 也就是 $i$ 被 $j$ 包含且 $i$ 更晚插入.</p><p>那么每个栅栏向它右上方包含它的那个点连边形成一棵树, 如果不考虑 $i&gt;j$ 显然一个点就加上他的子树, 现在有了这个限制则一个 $i$ 贡献到 $j$ 当且仅当 $i\to j$ 路径上都比 $i$ 出现的早, 发现贡献是连通块, 可以用并查集维护.</p><h4 id="CF1616G-Just-Add-an-Edge"><a href="#CF1616G-Just-Add-an-Edge" class="headerlink" title="CF1616G Just Add an Edge"></a>CF1616G Just Add an Edge</h4><blockquote><p>给定一个 DAG, 边一定从编号小的点连向编号大的点, 求有多少对 $(x, y)$ 使得 $x&gt;y$ 且添加 $(x, y)$ 这条边后的图存在哈密顿路径.</p><p>$n, m\le 1. 5e4$</p></blockquote><p>考虑哈密顿路一定是 $1\ldots x-1 \Longrightarrow y \to x\Longrightarrow y+1\ldots n$, 那么问题就是中间这一段, 考虑dp, 要找到 $(x, y)$ 使得 $x-1\to y$ 和 $y+1\Longrightarrow x$ 是两条互补的路径. 那考虑dp, $f_{i, 0&#x2F;1}$ 表示两条路径终点是 $i, i+1$ 或 $i+1, i$ 是否可行, 转移就是考虑一定是一条路径一个一个走, 另一个一下跳过来, 这样需要枚举起点复杂度 $nm$.</p><p>考虑优化掉枚举起点, 注意到如果 $i\to i+1$ 没有边, 那么两条路径一定要停留在这段点, 就可以以这两个点开始向前, 向后做刚才的dp, 然后直接乘起来两边选 $x$, $y$ 的方案. $x$, $y$ 在同一边的方案不存在因为无法跨过这个坎.</p><h4 id="P3266"><a href="#P3266" class="headerlink" title="P3266"></a>P3266</h4><p>没讲</p><h4 id="CF1110G"><a href="#CF1110G" class="headerlink" title="CF1110G"></a>CF1110G</h4><p>后手不可能赢, 只要看会不会平局.</p><p>容易发现如果没有白点, 容易发现存在度数大于 $3$ 的点, 或者度数等于 $3$ 且有两个分支链长大于 $2$, 先手必胜. 其他情况, 也就只有一条链的端点处可以再挂成3度点的情况可以是平局. 但是, 如果存在两个三度点, 中间链长是奇数则Alice仍然胜利.</p><p>然后有了白点.</p><p>发现一个三度点, Alice只要点三度点的在链上的相邻点, 那么Bob一定走那个三度点, 也就相当于白送给Alice点的这个点, 于是当有白点的时候, 可以把所有白点都替换成这个结构, 然后直接按没有白点判断即可.</p><h4 id="P7070-NWRRC2014-Kebab-House"><a href="#P7070-NWRRC2014-Kebab-House" class="headerlink" title="P7070 [NWRRC2014] Kebab House"></a>P7070 [NWRRC2014] Kebab House</h4><blockquote><p><img src="/img/2023-07-18-19-58-33-image.png" alt="picture 15">  </p></blockquote><p>考虑分段dp, 设 $f_{i, j}$ 表示第 $i$ 段结束, 还要再填 $j$ 个 $1$ 才能填 $0$ 的方案数, 然后考虑转移. 那么容易发现 $f_{i}\to f_{i+1}$ 是一个线性转移, 乘上一个 $t\times t$ 矩阵, 直接考虑矩阵的系数: $a_{i, j}$ 表示的是开头先填 $i$ 个 $1$, $j&gt;0$ 时末尾 $t-j$ 位置是 $0$ 后面是 $1$, 否则后面是一串 $1$ 随便.</p><p>先考虑 $j&gt;0$, 那就是这一段, 前后已经确定, 中间要在若干个 $0$ 之间插入若干个 $1$ 使得两个 $0$ 之间至少有 $t$ 个, 这个就简单隔板法, 有, 同时加上一种前面全填 $1$ 一直到这的方案 $[i-j&#x3D;q]$.</p><p>然后 $j&#x3D;0$ 相当于对所有 $j&lt;0$ 求和, 就是刚才的式子再加一个求和.</p><p>现在复杂度是 $nt^2$ 再乘上枚举 $01$ 数量的 $\dfrac{q}{t}$, 考虑优化, 注意到实际上刚才推出的式子只和 $i-j$ 有关, 然后 $j&#x3D;0$ 的只有 $t$ 个, 于是复杂度成了 $q+t^2$, 总的是 $nt^2+\sum q_i$</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><h3 id="Contest-5"><a href="#Contest-5" class="headerlink" title="Contest"></a>Contest</h3><h4 id="T1-4"><a href="#T1-4" class="headerlink" title="T1"></a>T1</h4><p>容易发现四边形不等式, 那么一个简单方法是wqs二分, 内层dp直接考虑每个点开始and和or最多变 $\log V$ 次, 又因为发现这个权值是单调的, 越长越大, 所以转移点直接就知道了, 复杂度 $\log^2 V$</p><p>然后因为决策单调性, 二分栈可以优化到单log.</p><h4 id="T2-4"><a href="#T2-4" class="headerlink" title="T2"></a>T2</h4><p>考虑直接把式子拆开:</p><p>$$<br>1+\dfrac{\sum_{i\ne j} w_iw_jt_{i, j}}{\sum {w_i}^2t_{i, i}}<br>$$</p><p>然后二分答案, 把答案乘过去拿回来, 就成了</p><p>$$<br>\sum_{i\ne j}w_iw_jt_{i, j}-ans\sum_i w_i^2 t_{i, i}&gt;0<br>$$</p><p>然后这个可以建模成最大权闭合子图, 网络流.</p><p>嗯, 赛时退火初始化解初始错了, 改过来就能过. 退火感觉初始解还是随机好()</p><h4 id="T3-4"><a href="#T3-4" class="headerlink" title="T3"></a>T3</h4><p>首先双向奔赴的都可以不管, 它们一定会互相选到, 考虑剩下的部分.</p><p>考虑一个点成功邀请 $a_i$ 的概率, 那么要满足 $a_i$ 匹配失败, $a_i$ 在他前面, 并且其他会匹配 $a_i$ 的不在 $i, a_i$ 之间. 那就又要求 $a_i$ 匹配成功的概率, 就递归了. 但不要放弃, 考虑不管递归下去, 因为 $i\to a_i$ 构成内向基环树, 所以它会走成一个ρ形, 考虑设为 $x_1\ldots x_c, x_{c+1}\ldots x_d$, $a_{x_d}&#x3D;x_c$ 这样, 设那些会插在 $x_i, x_{i+1}$ 之间的元素集合为 $b_i$, 显然 $b_i$ 互不相交, 不包含 $x$ 中的值, 答案只和 $b_i$ 集合大小有关.</p><p>然后怎么dp啊, 完全没懂todo</p><h3 id="Class-5"><a href="#Class-5" class="headerlink" title="Class"></a>Class</h3><h4 id="CF364D"><a href="#CF364D" class="headerlink" title="CF364D"></a>CF364D</h4><p>随机一个数答案有一半概率是其因子, 那么暴力check复杂度好像爆炸了.</p><p>不能暴力check, 假设随到 $x$, 直接把所有数和 $x$ 取gcd, 然后在用高维前缀和求每个因数的倍数个数.</p><h4 id="AGC028D"><a href="#AGC028D" class="headerlink" title="AGC028D"></a>AGC028D</h4><p>首先环上等价于随意断掉, 环上相交等价于序列上区间相交(不包括包含).</p><p>考虑一个区间的最外边界 $[l, r]$ 出现次数, 显然区间外不能匹配外面的. 设 $g_x$ 表示 $x$ 个点任意连的方案数, 但保证 $l, r$ 连通是困难的, 钦定 $l$ 最大连通到 $k$, 容斥得 $f_{l, r}&#x3D;g_{r-l+1}-\sum_i f_{i, k}\times g_{j-k}$</p><h4 id="CF542E"><a href="#CF542E" class="headerlink" title="CF542E"></a>CF542E</h4><p>你随便玩玩得到奇环一定不行, 那么显然二分图一定可以. 树的答案显然是直径.</p><p>猜一手图的直径, 然后把直径作为一条链拉出来, 考虑bfs树, 因为二分图所以同一层点一定不相邻, 每层之间随便合最后就是一条链. 然后因为删除一个点直径肯定不会变大所以确实是上界, 也可以考虑bfs树到叶子之后就没法往回走了.</p><h4 id="CF566E"><a href="#CF566E" class="headerlink" title="CF566E"></a>CF566E</h4><p>考虑两个点距离为 $3$ 则交只有中间的两个点, 这样能找出好多边, 只剩下叶子连向父亲的边.</p><p>然后相同点集都是兄弟叶子. 又因为一个叶子集合去掉父亲大小为 $1$ 的邻域, 去掉兄弟叶子就是父亲, 而除了叶子剩下点数不低于 $3$ 的时候, 每个点大小为 $1$ 的邻域不同, 但当只有 $2$ 的时候就是两个菊花连在一起特判就好了.</p><p>bitset可以优化掉一个 $w$</p><h4 id="P6961"><a href="#P6961" class="headerlink" title="P6961"></a>P6961</h4><p>考虑钦定第 $k$ 大为 $w$, 把小于 $w$ 的设边为 $0$, 更大的设为 $w$, 让答案是 $dis_n+kw$.</p><p>发现如果 $w$ 比第 $k$ 大大那么 $w$ 加多了, 比第 $k$ 大小则消成 $0$ 的不够, 所以都是算大了, 所以就做完了.</p><h4 id="P3771"><a href="#P3771" class="headerlink" title="P3771"></a>P3771</h4><p>先把直径拉出来, 变成一条链下面挂着若干子树, 显然不会选一棵子树内的点, 那么发现如果一个端点在子树内, 那么把它移动到父亲一定不劣, 因为只有子树底下的距离变大了, 但直径端点一定比这个子树最大深度大, 所以得到结论, 选的两个点都在直径上.</p><p>然后考虑二分答案, 设 $d_i, l_i$ 表示从点 $i$ 伸出去的子树最大深度和从直径一端到它的距离, 设我们连起来了 $a, b$, 那么对于任意 $d_i+d_j+l_i-l_j&gt;ans$ 要满足 $\vert l_i-l_a\vert +\vert l_j-l_b\vert +d_i+d_j\le ans$, 直接拆开绝对值成四个式子, 然后 $i, j$ 搞到一边, $a, b$ 搞到一边, 枚举 $i$ 求一边的四个最值, 然后因为对于一个 $a$, $b$ 一定是一个区间, 直接看四个式子求出的四个区间有没有交即可.</p><p>复杂度2log</p><h4 id="Astral-Birth"><a href="#Astral-Birth" class="headerlink" title="Astral Birth"></a>Astral Birth</h4><p>有若干段 $0$ 有贡献, 若干段 $1$ 有贡献, 但有一段两个都有贡献, 那就再多分一段, 于是都只有一种数有贡献.</p><p>可以把原序列连续的 $01$ 缩起来. 那么把选择变成删除, 注意到如果一次删了相邻两个元素, 一定不如单选, 而对段数的贡献相等, 于是问题变成了从序列上选若干个元素删除, 位置不相邻, 选边上代价为 $1$, 中间权值为 $2$, 求代价为 $m$ 情况下的权值最小值.</p><p>另一种做法是考虑实际上是做背包, whq说考虑 $f_{l, r, 0&#x2F;1, 0&#x2F;1}$ 表示区间 $[l, r]$ 中左右端点选不选的答案多项式, 用闵和线性合并, 复杂度单log. 但没听懂todo</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><h3 id="Contest-6"><a href="#Contest-6" class="headerlink" title="Contest"></a>Contest</h3><h4 id="T1-5"><a href="#T1-5" class="headerlink" title="T1"></a>T1</h4><p>简单题, 平衡树模板.</p><h4 id="T2-5"><a href="#T2-5" class="headerlink" title="T2"></a>T2</h4><p>考虑如果已经知道度数为 $1$, $n-2$, $2$ 的都是简单的, 对于 $u\to v\to w\to everything$, 如果知道了 $u, v, w$ 中任意一个都可以瞬间 $3n$ 验证.</p><p>考虑现在找到一个度数 $d\in [3, n-3]$ 的点, 考虑设 $S$ 为 $u, v$ 可能存在的点, $T$ 为 $w$ 可能存在的点, 让与一开始随便选的点与它相连的放进 $T$, 不相连的防到 $S$, 那么任取两个集合中各一个点 $u\in S, v\in T$, 查 $u\to v$, 那么如果有边可以从 $S$ 中删掉 $u$, 如果没有边, 考虑再选 $u’\in S$, 如果 $u’\to v$ 有边删掉 $u’$, 否则因为 $v$ 和他俩都没有边, 那么可以从 $T$ 中删掉 $v$.</p><p>于是可以用最多 $2$ 次询问从 $u&#x2F;v$ 中删掉一个点, 那么用 $2n$ 次就能找到一个 $u, v, w$ 中的, 可以通过.</p><h4 id="T3-5"><a href="#T3-5" class="headerlink" title="T3"></a>T3</h4><p>P9109</p><p>todo</p><h3 id="Class-6"><a href="#Class-6" class="headerlink" title="Class"></a>Class</h3><h4 id="萌萌哒"><a href="#萌萌哒" class="headerlink" title="萌萌哒"></a>萌萌哒</h4><p>在ds里</p><h4 id="P5605"><a href="#P5605" class="headerlink" title="P5605"></a>P5605</h4><p>$m$ 是 $p_m$ 保证存在原根, 于是 $x&#x3D;g^a, y&#x3D;g^b$ q, 求 $ak&#x3D;b\pmod \varphi(m)$, 也就是 $gcd(\varphi(m))\vert b$</p><p>回去补原根和阶</p><h4 id="LOJ2476"><a href="#LOJ2476" class="headerlink" title="LOJ2476"></a>LOJ2476</h4><p>不会</p><h4 id="SCOI2010-连续攻击游戏"><a href="#SCOI2010-连续攻击游戏" class="headerlink" title="[SCOI2010]连续攻击游戏"></a>[SCOI2010]连续攻击游戏</h4><p>终于有阳间题了.</p><p>容易想到 $a_i, b_i$ 连一条边, 要定向让每个点至少有一个入度, 那么小于答案的边构成的连通块只要不是树就有解.</p><h4 id="Ynoi2012-文化课"><a href="#Ynoi2012-文化课" class="headerlink" title="Ynoi2012 文化课"></a>Ynoi2012 文化课</h4><p>首先正常的维护线段树和, 积, 答案, 左右端点所在的段的乘积, 长度.</p><p>因为有改数所以要维护节点多项式, 但注意到次数是连乘段的长度, 因为总和是 $n$ 所以自然根号次数只有 $\sqrt n$ 种, 直接对每个点维护 $\sqrt n$ 项的多项式就行吧. 多项式求值直接快速幂增量是对的, 光速幂也是对的.</p><p>然后因为线段树区间长度每次除 $2$ 所以复杂度其实只有 $n\sqrt n$ 而没有log.</p><h4 id="HEOI2013-SAO"><a href="#HEOI2013-SAO" class="headerlink" title="[HEOI2013] SAO"></a>[HEOI2013] SAO</h4><p>容斥成都是一个方向号+然后带着系数dp, 然后别忘了外向树拓扑序答案应该是先选父亲剩下随意, 答案是 $n! \prod_u \dfrac{1}{siz_u}$</p><h4 id="反回文串"><a href="#反回文串" class="headerlink" title="反回文串"></a>反回文串</h4><p>考虑对于一个回文串数能转出多少个不同的串, 容易发现如果如果它能转出回文串一定说明有一个不是 $n$ 的周期. 但是偶数移动 $n&#x2F;2$ 是一个回文.</p><p>那么考虑把所有回文串都拆成小的, 设 $g_i$ 长 $i$ 的回文串数量, $f_i$ 是最小正周期为 $i$ 的数量, 发现 $f_i&#x3D;g_i*1$, 于是上一个莫反就能求出 $f$, 然后问题就解决了.</p><h4 id="趣味题"><a href="#趣味题" class="headerlink" title="趣味题"></a>趣味题</h4><p>这谁想得到啊</p><p>先把箱子随机排序, 然后开到 $x$ 就去开 $x$ 号箱子, 这样失败条件是排成排列之后存在一个长度大于一半的环, 概率算出来趋近于 $ln2$</p><h4 id="P7728"><a href="#P7728" class="headerlink" title="P7728"></a>P7728</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF</title>
      <link href="/2023/05/18/cf/"/>
      <url>/2023/05/18/cf/</url>
      
        <content type="html"><![CDATA[<h2 id="CF1827"><a href="#CF1827" class="headerlink" title="CF1827"></a>CF1827</h2><h3 id="B-Range-Sorting"><a href="#B-Range-Sorting" class="headerlink" title="B Range Sorting"></a>B Range Sorting</h3><blockquote><p>对一个数组 ${p_i}$ 的一段区间 $[l, r]$ 排序的代价为 $r-l$ , 对整个数组 $p_i$ 排序的代价为选定若干区间并排序, 使得整个数组有序的代价之和.<br>求 ${a_i}$ 的所有子段排序的代价之和.<br>$n\le 3\times 10^5$</p></blockquote><p>首先排序区间不交, 不然相交的用一个大的代替.</p><p>考虑贡献拆分到, 没有一个区间覆盖 $i, i+1$ 之间的间隔, 等价于 $\max p_{l: i}\le \min p_{i+1: r}$, 计数 $l, r$ 组数即可</p><p>直接枚举间隔+维护单调栈+双指针可以过 B1</p><p>考虑一个剪枝, 扫 $[i+1: ]$ 时若 $\min p_{i+1: j}&lt;p_i$ 则显然可以跳, 复杂度可以考虑一个小根笛卡尔树, 在后半部分前缀min的单调栈上走相当于身为左儿子跳父亲.</p><h3 id="C-Palindrome-Partition"><a href="#C-Palindrome-Partition" class="headerlink" title="C Palindrome Partition"></a>C Palindrome Partition</h3><blockquote><p>称一个字符串是好的, 当且仅当它是一个长度为偶数的回文串或由若干长度为偶数的回文串拼接而成.</p><p>给定一个长度为 $n$ 的字符串 $s$, 求有多少 $s$ 的子串是好的.</p><p>$1\le n\le5\times10^5$, $s$ 仅包含小写字母.</p></blockquote><p>结论是, 每个字符串存在唯一的最小划分. 考虑选了一个大的偶回文串, 又选了一个小的, 那么如果小的长度不超过大的一半的情况是显然的, 而可以证明如果存在一个长度超过大的一半的, 一定存在一个不超过的: 因为回文串, 于是一定其中短的是长的border, 超过一半长的border对应一个不到一半长的周期, 而周期倍数也是周期, 所以一定可以扩到一个超过一半的周期对应一个不超过一半的border, 所以一定存在.</p><p>于是只要每次选最短的长度即可. 先一遍求出所有回文串, 然后用一个单调栈维护所有中心(关于位置的后缀max)求出以每个位置结尾的最短的回文串, 然后一遍dp.</p><h3 id="D-Two-Centroids"><a href="#D-Two-Centroids" class="headerlink" title="D Two Centroids"></a>D Two Centroids</h3><blockquote><p>给定 $n$ 点树, 每次往一个点上挂一个叶子, 并询问此时至少加几个点才能让树有两个重心</p><p>$n\le 5\times 10^5$</p></blockquote><p>显然要加几个点才能让树有两个重心, 就是找一条边当最后的重心, 等价于找到一个点最小化 $\vert n-siz_u-siz_u \vert$.</p><p>然后这条边实际上和重心十分类似, 都是最小化删了之后剩下部分的差, 考虑去掉重心得到的连通块中大于一半的那一个和重心的连边即是这条边.</p><p>于是加点时维护当前这条边, 维护子树大小即可.</p><h3 id="E-Bus-Routes"><a href="#E-Bus-Routes" class="headerlink" title="E Bus Routes"></a>E Bus Routes</h3><blockquote><p>给定 $n$ 个点的树和 $m$ 条路径, 求是否任意两个点都可以通过沿着走不超过两条路径的区间到达.</p><p>$n, m\le 5\times 10^5$</p></blockquote><p>骗你一手点分治.</p><p>考虑所有叶子节点, 如果它们互相可达那么显然中间的点都可以.</p><p>考虑每个叶子找到一条路径内能到达的最浅点, 树合法当且仅当所有最浅点构成一条链.</p><p>复杂度 $n\log n$ </p><h2 id="CF1830"><a href="#CF1830" class="headerlink" title="CF1830"></a>CF1830</h2><h3 id="A-Copil-Copac-Draws-Trees"><a href="#A-Copil-Copac-Draws-Trees" class="headerlink" title="A. Copil Copac Draws Trees"></a>A. Copil Copac Draws Trees</h3><p>一眼题</p><h3 id="B-The-BOSS-Can-Count-Pairs"><a href="#B-The-BOSS-Can-Count-Pairs" class="headerlink" title="B. The BOSS Can Count Pairs"></a>B. The BOSS Can Count Pairs</h3><p>根号分治一眼题.</p><h3 id="C-Hyperregular-Bracket-Strings"><a href="#C-Hyperregular-Bracket-Strings" class="headerlink" title="C. Hyperregular Bracket Strings"></a>C. Hyperregular Bracket Strings</h3><blockquote><p>给定 $n, k$ 和 $l_k, r_k$, 求有多少个合法括号序列满足 $\forall i, [l_i, r_i]$ 也是合法括号序列.</p><p>$\sum n, \sum k\le 3\times 10^5$</p></blockquote><p>看到括号序列考虑前缀和. 设前缀和为 $s_n$</p><p>考虑如果有两个 $l_1\le l_2\le r_1\le r_2$, 因为 $s_i\ge s_{l}&#x3D;s_{r}, i\in [l, r]$, 所以显然 $s_{l_1}&#x3D;s_{l_2}&#x3D;s_{r_1}&#x3D;s_{r_2}$, 等价于要求三个不交的区间合法.</p><p>再考虑如果两个区间是包含的就更好处理了, 方案数就是子区间的合法括号方案数乘外面去掉子区间的.</p><p>于是一种方案就是直接暴力模拟上面的过程, 假设两个相交的区间有边, 就是找到连通块拆了, 剩下随便做.</p><p>官方题解省略了拆分的过程, 而是考虑把所有由同一子集的区间覆盖的位置拿出来, 每个子集对应的所有位置要构成括号序列.</p><h3 id="D-Mex-Tree"><a href="#D-Mex-Tree" class="headerlink" title="D. Mex Tree"></a>D. Mex Tree</h3><blockquote><p>给定一棵 $n$ 点树, 给边赋值 $v\in {0, 1}$, 最大化 $\sum_i \sum_j \mathrm{mex}{k\vert k \in path_{i, j}}$.</p><p>$n\le 2\times 10^5$</p></blockquote><p>考虑一个暴力dp, $f_{i, j, 0&#x2F;1}$ 表示如果 $i$ 的父边是 $0&#x2F;1$, $i$ 子树中有 $j$ 个点到 $i$ 只经过和父边相同颜色的边的情况下, $i$ 子树内的最大贡献.</p><p>转移到 $u$ 时, 只要逐个添加儿子, 维护前面有多少个点到 $u$ 只经过 $0$, 多少个只经过 $1$ 即可. 复杂度是树形dp的 $n^2$</p><p>不会做了, 猜 $j$ 很小.</p><p>考虑 $j$ 就是与 $i, fa_i$ 相连的同色连通块大小. 考虑二分染色构造下, $n(n-1)-ans\le 2n$, 于是在任何比二分染色优的方案中, 对于一个大小为 $s$ 的连通块, $\dfrac{s(s-1)}{2}\le 2n$. 也就是说 $s\le \sqrt 2n$</p><p>胜利, 复杂度 $n\sqrt n$</p><h3 id="E-Bully-Sort"><a href="#E-Bully-Sort" class="headerlink" title="E. Bully Sort"></a>E. Bully Sort</h3><blockquote><p>给定一个长度为 $n$ 的排列 $p$, 定义一个”bully swap”操作如下: 找到最大元素 $p_i$(且 $p_i\neq i$), 再找到最小的 $p_j$($i&lt;j$), 交换 $p_i$ 和 $p_j$. 定义 $f(p)$ 为通过执行”bully swap”操作将 $p$ 变成有序排列的次数. 给定 $n$ 和排列 $p$, 需要处理 $q$ 个更新操作, 每个操作给出两个整数 $x$ 和 $y$, 交换 $p_x$ 和 $p_y$, 然后计算新排列 $p$ 的 $f(p)$ 值. 注意, 更新是持久的, 对排列 $p$ 的更改将应用于处理未来的更新.</p><p>$n\le 5\times 10^5, q\le 5\times 10^4$</p></blockquote><p>注意到往左移的应该是一个后缀 $\min$, 其他的往右走, 左右是分开的.</p><p>当把一个最大值 $i$ 与后面最小值 $j$ 交换时, 逆序对变化为 $2(j-i)-1$. 考虑此时最小值移动了 $j-i$ 步, 而每个最小值一共应该移动 $i-p_i$ 步, 那么 $2\text{一开始的逆序对}-2\text{\sum_i \vert i-p_i\vert}&#x3D;ans$</p><p>于是问题就是动态维护逆序对了. 复杂度 $n\log^2 n$</p><h3 id="F-The-Third-Grace"><a href="#F-The-Third-Grace" class="headerlink" title="F. The Third Grace"></a>F. The Third Grace</h3><blockquote><p>给定一个数轴上的 $n$ 个区间和 $m$ 个点. 第 $i$ 个区间覆盖坐标 $[l_i, r_i]$, 第 $i$ 个点在坐标 $i$ 处, 并且具有系数 $p_i$.</p><p>最初, 所有点都未激活. 你需要选择一些点来激活. 对于每个区间 $i$, 我们定义它的代价为:</p><ul><li>若区间内没有被激活的点, 则代价为 $0$;</li><li>否则, 代价为在区间内坐标最大的被激活点的系数.</li></ul><p>你的任务是通过选择哪些点激活, 使得所有区间的代价之和最大.</p></blockquote><p>容易想到dp $f_i$ 表示最后一个选在 $i$, 不计算 $i$ 的贡献的情况下的最大价值. 转移就是枚举上一个点: $f_i&#x3D;\max_j f_j + W(i, j)*p_j$, 其中 $W(l, r)$ 表示覆盖 $l$ 不覆盖 $r$ 的区间个数.</p><p>考虑扫描过程中 $w_l$ 表示 $W(l, i)$, $g_i$ 表示 $f_i+p_i*w_i$, $i\to i+1$ 时, 所有 $[l, i]$ 区间执行 $g_i: &#x3D;g_i+p_i$.</p><p>考虑KTT, 就是区间右移函数, 单点改, 查询最大值, 复杂度2log.</p><h2 id="CF1835"><a href="#CF1835" class="headerlink" title="CF1835"></a>CF1835</h2><h3 id="B-Lottery"><a href="#B-Lottery" class="headerlink" title="B. Lottery"></a>B. Lottery</h3><blockquote><p>给定 $[0, m]$ 数轴上的 $n$ 个点, 现在随机一个点 $x$, 离 $x$ 最近的点 $k$ 个点被选中, 一样进优先不选你, 求 $p$ 最大化被选中的概率.</p><p>$n, k\le 10^6, m\le 10^{18}$</p></blockquote><p>$m$ 向右扫描, 过程中维护左边最远被选中的, 右边还没被选中的, 更新一定是把左边最后一个换成右边, 一定在中点切换, 这样就只用枚举更新位置了. 加上排序复杂度1log.</p><h3 id="C-Twin-Clusters"><a href="#C-Twin-Clusters" class="headerlink" title="C. Twin Clusters"></a>C. Twin Clusters</h3><blockquote><p>给定 $a_n$, 求 $a, b, c, d$ 满足 $[a, b]$, $[c, d]$ 不交且异或和相等.</p><p>$n&#x3D;2^{k+1}, a_i&lt; 4^k, k\le 17$</p></blockquote><p>显然相交直接删掉中间就是对的.</p><p>发现值域和区间个数是一样的.</p><p>于是期望 $\sqrt n$ 次随到相同数, 结束.</p><h3 id="D-Doctor’s-Brown-Hypothesis"><a href="#D-Doctor’s-Brown-Hypothesis" class="headerlink" title="D. Doctor’s Brown Hypothesis"></a>D. Doctor’s Brown Hypothesis</h3><blockquote><p>与此同时, 在征服行星中的一个星球上, 卢克正在准备参加一场非法的街头赛车比赛(考虑到他的家庭背景, 这也不奇怪). 卢克以速度表上的88英里每小时到达终点线. 下车后, 他迎来了一个新的现实. 事实证明, 战斗尚未发生, 将在恰好k个小时后开始.</p><p>叛军在每个星球上放置了一艘战舰. m个单向虫洞连接着各个星球. 通过每个虫洞需要一小时时间. 帝国的将军们精确地计划了战斗, 但是他们的部队无法动态适应不断变化的情况. 因此, 叛军足以在战斗前移动一些船只以混淆敌人、获得胜利并改变银河系的命运.</p><p>由于众多战略考虑, 现在我们暂时忽略, 叛军想选择两艘船来交换位置, 使它们都在整个时间(恰好k小时)内处于活动状态. 换句话说, 叛军寻找两个行星x和y, 使从x到y和从y到x的长度为k的路径存在.</p><p>由于燃料供应有限, 选择一艘船也是可以接受的. 这艘船应该在经过虫洞k小时后返回其初始星球.</p><p>有多少种方法可以选择完成任务的船只?</p><p>$n\le 10^5, m\le 2\times 10^5$</p></blockquote><p>注意到, 因为两个顶点有至少两条路径, 所以必然在同一个SCC.</p><p>考虑计算图中所有循环的gcd, 那么绕圈不会改变膜gcd余数. 找的方法是, 先随便找一个环, 让 $g$ 为环长, 然后不断看是否可以给 $g$ 除掉一个质因数, 判断的方法是是否存在 $[0, d-1]$ 中数染色使得每条边都满足 $color_v&#x3D;color_u+1 \pmod d$.</p><p>然后开始数答案, $(i, j)$ 成立可以是 $color_i&#x3D;color_j, g\vert k$, 也可以是 $k&#x3D;g&#x2F;2$ 的情况下两个的 $color$ 差 $k&#x2F;2$</p><h3 id="Old-Mobile"><a href="#Old-Mobile" class="headerlink" title="Old Mobile"></a>Old Mobile</h3><blockquote><p>给定序列 $a_n, a_i \in [0, m-1]$, 有 $m+1$ 个按钮, 包括 $[0, m-1]$ 和退格, 初始不知道每个按钮代表什么, 在按下一次之后知道, 求最优策略下期望多少次按出 $a_n$<br>$n\le 10^6, m\le 10^3$</p></blockquote><p>容易发现只有每个按钮第一次按的时候是重要的, 设第 $i$ 个出现的数出现位置为 $p_i$, 退格的发现时间是重要的.</p><p>考虑按的过程, 其中退格发现时间是重要的:</p><ul><li>发现之前<ul><li>a. 当前串是正确的前缀<ul><li>随地乱按, 遇到已知的直接敲上</li></ul></li><li>b. 当前串是错误的前缀<ul><li>随地乱按, 直到出现退格, 现在按的所有按钮都会被删</li></ul></li></ul></li><li>c. 发现之后<ul><li>先消除按的那下退格的影响</li><li>知道下一位直接敲上, 不知道随地乱按</li></ul></li></ul><p>考虑一个数不是第一次出现的出现, 如果在发现退格之后代价显然是 $1$, 如果在发现之前也是 $1$: 如果前面是对的我们会直接按上, 前面是错的会在都删除后重新按上. 所以只留每个数第一次出现组成一个新串, 最后再加上删掉的部分.</p><p>那dp, 因为不知道下一位是否已经出现过, 考虑在按错的时候(第一次发现这个按键的时候)处理贡献, 此时分成两种情况, 如果这个按键出现在 $a$ 中, 那么贡献 $3$(按下, 删除, 在下一次碰到时按下), 否则贡献 $2$(按下, 删除), 并且这两种情况转移到位置不同. 想到 $f_{i, j, 0&#x2F;1&#x2F;2}$ 表示当前知道按钮 $i$ 个, 其中 $j$ 个在 $a$ 中并且按过且按对了, 当前状态是过程中的a&#x2F;b&#x2F;c, 的贡献期望.</p><p>复杂度 $n^2$</p><p>感觉这个题就是, 观察出只和第一次出现有关的性质, 费用提前计算按错的代价, 转移的时候发现现在按错了可以用按对表示于是把状态设计成 $j$ 为已知且按下的来兼顾那些后面被按下且被提前算贡献的位置.</p><h2 id="CF1844"><a href="#CF1844" class="headerlink" title="CF1844"></a>CF1844</h2><h3 id="A-Subtraction-Game"><a href="#A-Subtraction-Game" class="headerlink" title="A. Subtraction Game"></a>A. Subtraction Game</h3><p>暴力</p><h3 id="B-Permutations-amp-Primes"><a href="#B-Permutations-amp-Primes" class="headerlink" title="B. Permutations &amp; Primes"></a>B. Permutations &amp; Primes</h3><p>首先肯定要包含 $1$, 于是 $1$ 一定在正中间, 然后因为要让尽量多的是 $2$ 肯定把 $2$ 放在头上, 又因为包含 $2$ 的如果不包含 $3$ 也很棒就把 $3$ 放在另一头上, 而同时包含 $2, 3$ 的一定是整个序列, 值是确定的, 所以问题解决.</p><h3 id="C-Particles"><a href="#C-Particles" class="headerlink" title="C. Particles"></a>C. Particles</h3><p>一开始为奇数的部分和一开始为偶数的部分是独立的, 不会相互合并, 于是枚举最后是奇数还是偶数留下. 然后显然把负数都删了.</p><h3 id="D-Row-Major"><a href="#D-Row-Major" class="headerlink" title="D. Row Major"></a>D. Row Major</h3><p>暴力处理不等关系, 复杂度 $nd(n)$</p><h3 id="E-Great-Grids"><a href="#E-Great-Grids" class="headerlink" title="E. Great Grids"></a>E. Great Grids</h3><p>难</p><p>改为填 $0, 1, 2$, 发现对于二乘二的矩形<br>$$<br>\begin{bmatrix}<br>a &amp; b\<br>c &amp; d<br>\end{bmatrix}<br>$$<br>满足 $a+b&#x3D;c+d \pmod 3$, 也就是 $a-c&#x3D;b-d\pmod 3$</p><p>于是相邻两行&#x2F;两列变化是相等的, 可以设 $c_i&#x3D;a_{i, j}-a_{i-1, j}$, $d_i&#x3D;a_{j, i}-a_{j, i-1}$, 那么若刚才小矩形中 $a$ 位于 $i, j$, 限制 $a&#x3D;d$ 就是 $c_i+d_i&#x3D;0\pmod 3$, $b&#x3D;c$ 就是 $c_{i+1}&#x3D;d_{i+1}$.</p><p>问题转化为 $2n$ 个01变量($c_i, d_i\ne 0$)和若干组相等&#x2F;不等关系, 直接并查集.</p><h3 id="F-Min-Cost-Permutation"><a href="#F-Min-Cost-Permutation" class="headerlink" title="F. Min Cost Permutation"></a>F. Min Cost Permutation</h3><p>如果 $c\ge 0$, 最小且字典序最小一定是升序</p><p>如果 $c\le 0$, 最小但不一定字典序最小一定是降序.</p><p>然后满足字典序的方法是调整, F1直接考虑把位置 $j&gt;i$ 移动到 $i$ 是否保持价值不变, 若 $f(x)&#x3D;\vert x-c\vert$ 列出式子应该是 $f(a_{j+1}-a_{j-1})+f(a_{i}-a_{j})+f(a_{j}-a_{i-1})&#x3D;f(a_i-a_{i-1})+f(a_j-a_{j-1})+f(a_{j+1}-a_j)$</p><p>注意到等式中部分绝对值内正负是确定的, 拆开发现变成了 $a_i-a_{i-1}-c\ge 0$ 和 $a_j-a_{i-1}-c\ge 0$, 用set维护满足条件 $a_j$, 再用链表维护 $a$ 序列支持快速插入即可.</p><h2 id="CF1858"><a href="#CF1858" class="headerlink" title="CF1858"></a>CF1858</h2><h3 id="B-The-Walkway"><a href="#B-The-Walkway" class="headerlink" title="B. The Walkway"></a>B. The Walkway</h3><p>遇到商人一定会吃, 所以每个商人前后独立, 所以直接枚举哪个商人被删了即可.</p><h3 id="C-Yet-Another-Permutation-Problem"><a href="#C-Yet-Another-Permutation-Problem" class="headerlink" title="C. Yet Another Permutation Problem"></a>C. Yet Another Permutation Problem</h3><p>只有不超过一半的数才能取到, 于是每个数和两倍放到一起.</p><h3 id="D-Trees-and-Segments"><a href="#D-Trees-and-Segments" class="headerlink" title="D. Trees and Segments"></a>D. Trees and Segments</h3><p>考虑对每个 $l_0$ 求对应 $l_1$, 然后拿出凸壳回答询问.</p><p>对于一个 $l_0$, 枚举最终的区间, 那么剩下一个前缀一个后缀, 只考虑前缀, 要求 $f_{i, j}$ 表示前 $i$ 个点修改 $j$ 次的最大长度.</p><p>那么显然让 $g_{i, j}$ 表示 $1$ 的区间强制延伸到 $i$ 的最大长度即可, 复杂度 $n^2$</p><h3 id="E-Rollbacks"><a href="#E-Rollbacks" class="headerlink" title="E. Rollbacks"></a>E. Rollbacks</h3><p>直接考虑困难版强制在线.</p><p>一个实现减法的考虑可以把查询范围改成序列前若干位, 于是做法就有了, 对每个数只在第一次出现位置统计, 维护序列长度 $l$, 加法则添加到 $l+1$ 位置上并存储原来这里是什么, 减法就直接改 $l$, 查询则是问 $1\ldots l$ 第一次出现的数的个数, 因为所有修改都在最后位置可以用前缀和代替树状数组.</p><h2 id="CF1856"><a href="#CF1856" class="headerlink" title="CF1856"></a>CF1856</h2><h3 id="B-Good-Arrays"><a href="#B-Good-Arrays" class="headerlink" title="B. Good Arrays"></a>B. Good Arrays</h3><p>不是 $1$ 就填 $1$, 是 $1$ 就填 $2$, 最后一位全满上, 重的话, 把一个是 $2$ 的加 $1$ 这个减 $1$</p><h3 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h3><p>模拟</p><h3 id="D-More-Wrong"><a href="#D-More-Wrong" class="headerlink" title="D. More Wrong"></a>D. More Wrong</h3><p>考虑判定一个位置 $p$ 是 $n$ 的办法发现不会, 但是问 $[1, p]$ 和 $[1, p-1]$, 如果相等则它是 $1, p$ 的最大值.</p><p>那么因为问一次看起来是个 $n^2$ 小常数代价, 那么基本是 $\log n$ 复杂度, 考虑先问出左右区间各自的最大值, 再用上面的办法判断右边的最大值是否比左边的大, 代价为 $T(n)&#x3D;2T(n&#x2F;2)+2n^2&lt;4n^2$, 于是可过.</p><h3 id="E-PermuTree"><a href="#E-PermuTree" class="headerlink" title="E. PermuTree"></a>E. PermuTree</h3><p>二叉树显然就是中序遍历, 对于多叉, 就是决定哪些点在根前哪些点在根后, 最大化两边点的乘积, 可以直接上一个树形背包算可以表示出哪些东西, 复杂度 $n^2$.</p><p>对于 $10^6$ 次方, 看上去subsetsum怎么也不能优化到线性或者单log啊, 考虑对于每一层的点容易做到 $\dfrac{n\sqrt n\log n}{w}$(二进制分组多重背包), 但再仔细考虑能拆出 $2^i$ 的数的集合假设为 $S_i$, 则 $\sum_{j\in S_I} j2^i \le n, \sum_j j \le \dfrac{n}{2^i}$, 又因为 $S$ 中元素互不相同所以开一个根号, 得到 $\vert \S_i\vert\le \sqrt{\dfrac{n}{2^i}}$, 求和发现收敛, 最后只有 $n\sqrt n$.</p><p>再考虑整颗树的复杂度, 每一层的复杂度是 $\dfrac{n\sqrt n}{w}$, 因为如果有一个点存在大于一半的儿子那么一定把这个子树放在根前面就行了, 于是每下一层至少除以 $2$, 但是又拿出来 $n\sqrt n$ 发现这个东西对除以 $2$ 累加它又收敛了. 所以最终复杂度还是 $\dfrac{n\sqrt n}{w}$</p><p>所以价值和为 $n$ 的 $01$ 背包二进制拆分是 $n\sqrt n$ 个物体! 好厉害!</p><h2 id="CF1854"><a href="#CF1854" class="headerlink" title="CF1854"></a>CF1854</h2><h3 id="A-Dual"><a href="#A-Dual" class="headerlink" title="A. Dual"></a>A. Dual</h3><p>考虑只是正数怎么做: 前缀和. 于是负数就后缀和. 考虑有负有正.</p><p>那么找到绝对值最大的数然后给 $n-1$ 个数都加一遍, 一共是 $2(n-1)$.</p><p>继续优化, 考虑假设是加少的一边, 比如有 $9$ 个正数, $11$ 个负数是边界, 那么选取负数里最小的, 但有可能这个最小值是 $-1$, 正数最大值是 $20$, 那么需要先花 $5$ 次让负数最小值大于正数最小值, 然后最多还能花 $7$ 次, 考虑 $8&#x2F;9$ 个正数的情况, 你突然发现只要把那 $5$ 次不敢了再加上 $7$ 次, 正好可以干完所有负数变成正的. 也就是总有一边是可以的, 于是就做完了.</p><h3 id="B-Earn-or-Unlock"><a href="#B-Earn-or-Unlock" class="headerlink" title="B. Earn or Unlock"></a>B. Earn or Unlock</h3><p>就是要从所有牌中选出若干牌用于摸牌.</p><p>那么设 $f_{i, j}$ 表示前 $i$ 张牌, 用于摸牌的牌和为 $j$ 是否可行, 这样可以转移到 $f_{i+1, j}$, 或者转移到 $f_{i+1, j+a_i}$, 条件是 $j&gt;&#x3D;i$. 发现这个容易bitset优化, 统计答案就是找到 $f_{i, j}&#x3D;1, i&#x3D;j$ 的地方了.</p><h3 id="C-Expected-Destruction"><a href="#C-Expected-Destruction" class="headerlink" title="C. Expected Destruction"></a>C. Expected Destruction</h3><p>考虑计算每个 $x$ 实际走到了哪. 显然如果 $i$ 走到 $p_i$ 没了, 那么最后答案就会加上 $p_i-i$.</p><p>那么问题就成了如何求 $i$ 到 $p_i$ 的概率, 可以只考虑它和一开始它前面那个元素, 对于任意一个操作序列, 我们总可以抽出对这两个元素的操作考虑, 此时下一位是谁都是 $\dfrac{1}{2}$, 设 $f_{i, j}$ 表示自己走到 $i$, 对方走到 $j$ 的概率即可统计答案了. 这样是 $nm^2$</p><p>仍然是观察数数中独立的性质.</p><h3 id="E-Game-Bundles"><a href="#E-Game-Bundles" class="headerlink" title="E. Game Bundles"></a>E. Game Bundles</h3><p>因为子集和非常多, 能看出可能的解应该非常多, 而这个问题看上去很没有靠谱的做法, 考虑乱搞.</p><p>于是想到我放 $x$ 个 $1$, 再放若干个 $&lt;60-x$ 的数, 这样贡献只能由 $1$ 和一个其他数产生, 也就是用 $\binom{x}{i}$ 去凑 $m$, 于是从小到大枚举 $x$, 爆搜剩下的数, 加上朴素的可行性最优性剪枝, 发现 testcase 46 搜不出来. 问题基本上是, 假设用了大量的 $1$, 那么搜到细节处时微调的能力就很弱了, 因为一调就至少动 $x-1$, 导致会和 $m$ 很接近但差一点点,</p><p>于是再加上 $2$, 放 $x$ 个 $1$ 和 $2$ 满足它们的和小于 $60$, dp算出 $f_i$ 表示用 $1, 2$ 凑出 $i$ 的方案数, 但是枚举 $1, 2$ 太慢了, 直接枚举总数 $x$, 随一个 $2$ 的个数, 可以搜出只有 $1$ 的部分. 但仍然会TLE.</p><p>最后想到, 从小往大枚举 $x$ 是很劣的, 因为刚刚可行(存在一种方案大于 $m$)的部分在 $m$ 附近的解的数量比较少, 所以改成从大到小枚举 $x$, 通过.</p><h2 id="CF1849"><a href="#CF1849" class="headerlink" title="CF1849"></a>CF1849</h2><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><p>直接用集合hash, 加法就能过.</p><p>但字符串hash方式被卡了, 可能也因为没随素数</p><p>好吧正解就是等效的缩小到实际发生排序的区间, 任意两个实际排序区间不同的都不同</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>简单dp</p><p>还可以贪心, 先染非0段, 再尝试干掉0段</p><h3 id="E"><a href="#E" class="headerlink" title="E"></a>E</h3><p>这种东西一律无脑扫描线, 对于某个 $r$ 维护, 区间最大值, 最小值分别是两个单调栈, 就是要求每个单调栈最小值距离他前面第一个最大值单调栈元素的距离和, 考虑用一个并查集维护连到一个最大值上的所有最小值, 那么新来一个最小值就是连到最大值栈顶, 弹出的时候每次并查集查对应元素减去贡献, 新来一个最大值就若干次弹栈, 每次合并当前集合到前面并计算贡献. 这样复杂度是 $n\alpha(n)$. 然后其实这个并查集注意到每个集合一定是连续的一段, 于是这种并查集可以做到线性, 考虑按 $w$ 分块, 块间开一个并查集, 块内直接位运算找lowbit.</p><h3 id="F"><a href="#F" class="headerlink" title="F"></a>F</h3><p>不断把最小值的点对加边直到不是二分图, 等价于找一个最小异或生成树, 右转去CF888G</p><h2 id="CF1852"><a href="#CF1852" class="headerlink" title="CF1852"></a>CF1852</h2><h3 id="A-Ntarsis’-Set"><a href="#A-Ntarsis’-Set" class="headerlink" title="A. Ntarsis’ Set"></a>A. Ntarsis’ Set</h3><blockquote><p>有一个集合, 初始状态里面有数字 $1$ 、 $2$ 、 $3$ 、 $4$ 、 $5$ 、. . . . . . 、 $10^{1000}$.</p><p>现在给你一个长度为 $n$ 数组 $a (1\leq a_i \leq 10^9 )$, 要进行 $k$ 次操作, 每次操作将当前集合中第 $a_1$ 小、第 $a_2$ 小、. . . . . . 、第 $a_n$ 小的数同时移除.</p><p>请问 $k$ 次操作之后, 最小的数是多少.</p></blockquote><p>容易发现每个数往后删的部分是好统计的, 因为 $a_i$ 不会影响 $a_j$ 若 $i&lt;j$, 于是直接从后往前就容易得到暴力</p><p>然后二分, 对于给定的答案, 对每个 $a_i$ 统计它删了 $[1, x]$ 的多少个数, 判断是否删空了即可.</p><h3 id="B-Imbalanced-Arrays"><a href="#B-Imbalanced-Arrays" class="headerlink" title="B. Imbalanced Arrays"></a>B. Imbalanced Arrays</h3><blockquote><p>对于一个给定的长度为 $n$ 的数组 $A$, 定义一个长度为 $n$ 的数组 $B$ 是不平衡的当且仅当以下全部条件满足:</p><ul><li><p>$-n \leq B_{i} \leq n$ 且 $B_{i} \ne 0$. 即每个数在 $[-n, n]$ 内且不为 $0$.</p></li><li><p>$\forall i, j \in [1, n], B_{i} + B_{j} \neq 0$. 即数组内不存在一对相反数.</p></li><li><p>$\forall i \in [1, n], \sum_{j &#x3D; 1}^{n} [ \left (B_{i} + B_{j} \right) &gt; 0] &#x3D; A_{i}$. 即对于任意的 $i$, 数组中与 $B_{i}$ 和大于 $0$ 的数的个数恰好为 $A_{i}$.<strong>注意: 这里需要计算本身. 也即 $i$ 与 $j$ 可以相等.</strong></p></li></ul><p>请构造长度为 $n$ 的不平衡序列.</p></blockquote><p>$b_i$ 要满足 $b_j&gt;-b_i$ 的有恰好 $a_i$ 个, 那么显然 $a_i$ 越大, $-b_i$ 就要越小, 于是得到结论若 $a_i&lt;a_j$, 则 $b_i&lt;b_j$. 对于相等的 $a_i$ 显然可以随意钦定顺序.</p><p>因为有了 $b$ 的顺序, 可以确定每个 $a_i$ 的 $-b_i\in [b_{n-a_i}, b_{n-a_i+1}]$, 属于同一个区间的 $-b_i$ 又因为已知 $b_i$ 的大小关系而可以确定, 于是我们得到了一条包含 $b_i$ 和 $-b_i$ 的大小关系的长 $2n$ 的不等式链, 因为一共只有 $2n$ 个数, 只要从小到大对应赋值, 然后判定是否对应位置为相反数即可.</p><h3 id="C-Ina-of-the-Mountain"><a href="#C-Ina-of-the-Mountain" class="headerlink" title="C. Ina of the Mountain"></a>C. Ina of the Mountain</h3><p>首先, 如果没有膜 $k$ 的话这是简单题, 答案是所有正的差分的和.</p><p>那么考虑膜 $k$ 之后, 相当于每个位置需要被减 $km_i+a_i$ 次. 考虑每个位置的贡献, 则 $i, i+1$ 的贡献就是 $\max (a_{i+1}-a_i+k(m_{i+1}-m_i), 0)$, 考虑 $m$ 的差分数组 $c$, 发现要保证 $\sum c_i&#x3D;0$(认为 $m_0&#x3D;0$), 不然会忽略一开始 $a_1$ 处的贡献. 那么直接成对贡献, 当扫到 $i$ 的时候, 要么 $c_i&#x3D;0$, 要么就要从前面找到一个位置让它的 $c_i$ 减 $1$, 注意到 $\vert c_i\vert&gt;1$ 一定不好, 于是每个地方只贡献一次, 又发现减 $1$ 的贡献和加一位置无关, 于是直接开堆维护.</p><p>有时dp第二维状态开不下可以像这样成对贡献的转移.</p><h3 id="D-Miriany-and-Matchstick"><a href="#D-Miriany-and-Matchstick" class="headerlink" title="D. Miriany and Matchstick"></a>D. Miriany and Matchstick</h3><p>容易想到一个朴素dp, $f_{i, j, 0&#x2F;1}$ 表示前 $i$ 个位置, 形成 $j$ 个对, 最后结尾是 $A&#x2F;B$ 是否可行.</p><p>然后发现 $f_{i, 0&#x2F;1}$, 为 $1$ 的 $j$ 是一个区间扣去一个点. 考虑归纳证明, 若 $f_{i-1}$ 满足条件, 那么转移的时候是 $f_{i, j, c}&#x3D;f_{i-1, j-[c&#x3D;0]-[c\ne a_i], 1} \mathrm{or} f_{i-1, j-[c&#x3D;1]-[c\ne a_i], 0}$, 那么若要 $f_{i-1, 0}$ 对应的孔没被堵上, 必须要对应一个为 $0$ 的 $f_{i-1, j, 1}$, 这个位置如果是区间外那没有关系, 如果也是孔则正好过来还是一个孔, 问题解决.</p><p>于是直接dp就好了! 但这个结论好厉害! 我觉得应该是先猜是区间, 然后打个表发现不是但没关系.</p><h2 id="CF1859-Codeforces-Round-892-Div-2"><a href="#CF1859-Codeforces-Round-892-Div-2" class="headerlink" title="CF1859 Codeforces Round 892 (Div. 2)"></a>CF1859 Codeforces Round 892 (Div. 2)</h2><h3 id="A-United-We-Stand"><a href="#A-United-We-Stand" class="headerlink" title="A. United We Stand"></a>A. United We Stand</h3><p>最大值放第一数组, 其他的都去第二</p><h3 id="B-Olya-and-Game-with-Arrays"><a href="#B-Olya-and-Game-with-Arrays" class="headerlink" title="B. Olya and Game with Arrays"></a>B. Olya and Game with Arrays</h3><p>移动不是最小值的没有意义. 每个最小值尽量去找次小值比它小的移动, 这样没有影响, 然后剩下的你要希望空出的次小最大, 于是全部移动向次小最小的里面.</p><p>然后你仔细想想, 后面那部分其实就是, 把所有最小值扔到次小最小的里面.</p><h3 id="C-Another-Permutation-Problem"><a href="#C-Another-Permutation-Problem" class="headerlink" title="C. Another Permutation Problem"></a>C. Another Permutation Problem</h3><p>最暴力的, 直接枚举 $ij$ 是最大值, 确定一个, 剩下的从大到小把每个数放到能放的最大位置上. 那要支持: ban掉一个点, 查找一个点往前能用的位置, 可以并查集整一个, 看起来是没啥问题.</p><p>然后比较厉害的: 打表发现是答案是 $1-n$ 的一个前缀加一个翻转了的后缀, 然后好像还是凸的()</p><h3 id="D-Andrey-and-Escape-from-Capygrad"><a href="#D-Andrey-and-Escape-from-Capygrad" class="headerlink" title="D. Andrey and Escape from Capygrad"></a>D. Andrey and Escape from Capygrad</h3><p>那这个完全可以线段树建图, 然后我直接从后往前走反图把所有能到的点打上标记. 好吧你这么建图多余, 注意到你不可能往回走(因为大包含小, 不可能出现需要往回才能到更远的地方的情况), 那你从后往前就是线段树进行区间取max-单点查.</p><h3 id="E-Maximum-Monogonosity"><a href="#E-Maximum-Monogonosity" class="headerlink" title="E. Maximum Monogonosity"></a>E. Maximum Monogonosity</h3><p>朴素dp是 $f_{i, j}$ 表示前 $i$ 个总长为 $j$, 转移 $O(k)$, 爆炸. 回忆一个性质说绝对值外面是max可以直接拆成4个, 那么就成了 $f_{i, j}&#x3D;\max f_{k, j-i+k}+a_i+a_{k+1}-b_i-b_{k+1}$ 等四种情况, 然后发现能转移过来的是一条斜线, 里面就成了 $f(j-i, k)+sgn_1 a_{k+1}+sgn_2 b_{k+1}$ 的形式, 那么直接把这玩意记录下来就可以 $O(1)$ 转移了, 设 $g_{x, 0&#x2F;1&#x2F;2&#x2F;3}$ 表示 $j-i&#x3D;x$, 且 $sgn_1, sgn_2$ 的情况是哪种的里面的值即可.</p><p>要点是拆绝对值和观察 $f$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023省队集训</title>
      <link href="/2023/04/19/2023_sdsj1/"/>
      <url>/2023/04/19/2023_sdsj1/</url>
      
        <content type="html"><![CDATA[<h1 id="2023省队集训"><a href="#2023省队集训" class="headerlink" title="2023省队集训"></a>2023省队集训</h1><h2 id="模拟赛"><a href="#模拟赛" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><blockquote><p>给定 $n$ 点简单无向图, 对每对 $(x, y)$ 求是否有一条 $x$ 开始 $y$ 结束的哈密顿路.</p><p>$n\le 24$</p></blockquote><p>注意到因为哈密顿路一定经过所有点, 所以对于 $x\to y$ 可以拆成 $1\to x, 1\to y$.</p><p>考虑求出 $f_S$ 表示经过 $S$ 能走到哪些点, 然后枚举每一个 $S$, 对于其中每一个 $x$, 考察 $f_{U&#x2F;S}$ 是否包括 $y$, 复杂度是 $n2^n$.</p><p>至于如何求 $f_S$, 考虑每次对于 $f_S$, 轮流拿出其中的点扩展一个得到新的 $f$, 复杂度是 $n2^n$</p><p>总复杂度 $n2^n$</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><blockquote><p><img src="/img/2023-05-25-16-58-39-image.png" alt="picture 9">  </p><p>对于 $100%$ 的数据, $1 \leq n, q \leq 10^6$, $1 \leq l_i \leq n$, $1 \leq H, a_i \leq 10^{12}$, $1 \leq t_i \leq 3$.</p></blockquote><p>相当于给了三种函数:</p><ul><li>$f(x)&#x3D;\begin{cases}x-a_i, x\ge a_i\-inf, x&lt;a_i\end{cases}$</li><li>$g(x)&#x3D;\begin{cases}a_i, x\ge a_i\-inf, x&lt;a_i\end{cases}$</li><li>$h(x)&#x3D;\begin{cases}-inf, x&lt;0\ x, x\ge a_i\a_i, x&lt;a_i\end{cases}$</li></ul><p>考虑函数复合后的形式:</p><ul><li>如果内层函数是 $g$, 嵌套后两个分支是对 $a$ 判断后直接赋值</li><li>如果内层函数是 $f$, 大量 $f$ 相当于减去总的该减的不然变成 $0$.</li><li>内层函数是 $h$ 也是判断后直接赋值.</li></ul><p>重点就是几种情况都只在外面判断后里面保留一个分支, 于是任意层函数嵌套后形式为 $m(x)&#x3D;\begin{cases}-inf, x&lt;a\ y, x\in [a, b] \ x-b+y, x&gt;b\end{cases}$.</p><p>于是直接线段树维护函数复合. 配个二分.</p><h2 id="lxl讲课"><a href="#lxl讲课" class="headerlink" title="lxl讲课"></a>lxl讲课</h2><h3 id="支配对问题"><a href="#支配对问题" class="headerlink" title="支配对问题"></a>支配对问题</h3><p>指的是, 对于询问某些对 $(a, b)$ 的贡献, 可以通过贪心干掉一些无意义对, 保留数量可接受的支配对.</p><h4 id="第一类支配对"><a href="#第一类支配对" class="headerlink" title="第一类支配对"></a>第一类支配对</h4><p>利用贡献本质只有 $O(n)$ 种使得可以枚举了上面两个中的一个贡献.</p><p>用启发式合并搞定对于某个确定的lca的点对数.</p><h5 id="P7880-Ynoi2006-rldcot"><a href="#P7880-Ynoi2006-rldcot" class="headerlink" title="P7880 [Ynoi2006] rldcot"></a>P7880 [Ynoi2006] rldcot</h5><blockquote><p>给定一棵 $n$ 个节点的树, 树根为 $1$, 每个点有一个编号, 每条边有一个边权.</p><p>定义 $dep(x)$ 表示一个点到根简单路径上边权的和, $lca(x, y)$ 表示 $x, y$ 节点在树上的最近公共祖先.</p><p>共 $m$ 组询问, 每次询问给出 $l, r$, 求对于所有点编号的二元组 $(i, j)$ 满足 $l \le i, j \le r$ , 有多少种不同的 $dep( lca(i, j))$.</p><p>$n\le 10^5$</p></blockquote><p>考虑支配对, 对于一个点作为lca, 需要有 $(a, b)$ 处于其不同子树, 目标是保留尽量少的对.</p><p>容易发现, 对于点 $x$, 只需要保留其在其他子树对前驱后继形成的对 $(pre, x), (succ, x)$ 即可. 但如果对其他每个子树分别搞出来数量还是 $n^2$ 的.</p><p>考虑每次把一个子树的点合并进当前子树, 正确性显然, 这样只有 $n\log n$ 个点对.</p><p>那么下面的问题是处理本质不同, 把问题抽象到平面上, 每个询问对应一个点, 一个点对贡献一个 $2-side$ 矩形, 注意到 $2-side$ 矩形并再拆成不交矩形数是线性的, 于是每次把面积并内的询问都加一就行了.</p><p>复杂度 $n\log^2 n+m\log n$</p><h5 id="P8528-Ynoi2003-铃原露露"><a href="#P8528-Ynoi2003-铃原露露" class="headerlink" title="P8528 [Ynoi2003] 铃原露露"></a>P8528 [Ynoi2003] 铃原露露</h5><blockquote><p>给定一棵有根树, 顶点编号为 $1, 2, \dots, n$, 对 $2\le i\le n$ 有 $f_{i}$ 为 $i$ 的父亲. $a_1, \dots, a_n$ 是 $1, \dots, n$ 的排列.</p><p>共 $m$ 次询问, 每次询问给出 $l, r$, 询问有多少个二元组 $L, R$, 满足 $l\le L\le R\le r$, 且对任意 $L\le a_x\le a_y\le R$, 有 $x, y$ 在树上的最近公共祖先 $z$ 满足 $L\le a_z\le R$.</p><p>以上所有数值为整数.</p><p>$1\le n, m\le 2\times 10^5$, $1\le f_i\le i-1$, $l\le r$.</p></blockquote><p>考虑这个相比上一个多套了个区间, 但上一个单点查, 所以这个仍然先求有贡献的内层 $L, R$, 然后矩形查.</p><p>那么考虑有贡献的对 $(x, y, z)$, 如果 $a_z\in [a_x, a_y]$ 则是废物, 否则如 $a_z&lt;a_x\le a_y$, 则会消去一个 $[a_z, a_x]\times [a_y, inf]$ 的3side矩形. 接下来只说这样的.</p><p>接下来枚举 $z$, 对于同一个 $x$, $y$ 一定是不同子树内的 $a$ 最小的, 于是又可以用启发式合并消到 $n\log n$.</p><p>然后求矩形内不被矩形覆盖的面积, 扫描线-区间加-区间历史min个数就ok了</p><p>也是俩log</p><h4 id="第二类支配对"><a href="#第二类支配对" class="headerlink" title="第二类支配对"></a>第二类支配对</h4><p>第一种是对每个 $i$, 可以用数据结构找出 $\log n$ 个 $j$ 支配了所有贡献, 此时分析 $i&lt;j&lt;k$ 中, $(i, k)$ 贡献需要不能被 $(i, j), (j, k)$ 取代</p><p>另一种是通过对一维分治, 会产生 $O(n)$ 对跨过分治中线的贡献, 支配了原来跨过中线的 $n^2$ 对. 此时一般对信息维&#x2F;复杂的一维分治.</p><h5 id="CF765F-Souvenirs"><a href="#CF765F-Souvenirs" class="headerlink" title="CF765F Souvenirs"></a>CF765F Souvenirs</h5><blockquote><p>经典之区间内绝对值最小的数对</p></blockquote><p>就是对于 $i&lt;j&lt;k$, 若 $j$ 与其构成支配, 那么 $i, k$ 要想构成支配需要 $\vert i-k\vert\le \vert i-j\vert, \vert j-k\vert$, 发现每次把值域减半, 于是支配对只有 $n\log n$ 对.</p><h5 id="CodeChef-MINXORSEG"><a href="#CodeChef-MINXORSEG" class="headerlink" title="CodeChef MINXORSEG"></a>CodeChef MINXORSEG</h5><blockquote><p>给定 $a_n$, $q$ 次问区间内最小的 $a_i \mathrm{xor} a_j$, 值域 $10^9$, $n, q\le 2\times 10^5$</p></blockquote><p>仍然考虑 $i&lt;j&lt;k$, 假设 $i, j$ 支配. 考虑 $a_i, a_j, a_k$ 的lcp后的第一个字符 $c, d, e$</p><p>如果 $c&#x3D;d\ne e$, 那么你选个锤子 $e$</p><p>如果 $c\ne d$, 那么 $e&#x3D;c\ne d$ 相同, 不然 $a_k \mathrm{xor} a_j&gt;a_k\mathrm{xor} a_i$, 应该选择 $j, k$.</p><p>于是惊喜的发现, 每次lcp增加至少1. 又只有 $n\log n$ 对了.</p><p>考虑如何找到它们, 建可持久化trie即可.</p><h5 id="Luogu8078-WC2022-秃子酋长"><a href="#Luogu8078-WC2022-秃子酋长" class="headerlink" title="Luogu8078 [WC2022] 秃子酋长"></a>Luogu8078 [WC2022] 秃子酋长</h5><blockquote><p>区间内排序后相邻的数在原序列种位置的绝对值的差.</p></blockquote><p>polylog!</p><p>对序列维分治, 那么设当前区间是 $[l, r]$, 中点为 $mid$</p><p>预处理 $[mid, x]$ 的答案, 是简单的.</p><p>假设排序后下标不跨过 $mid$ 的位置的差已经计算完了.</p><p>那么注意到, 对于左边两个数 $a_i&lt;a_j$, 若存在 $a_k\in (a_i, a_j)$, 那么 $a_i, a_j$ 一定会贡献 $mid-i+mid-j$ 这样的. 如果中间没有, 则贡献 $i-j$</p><p>左边的数对中, 只有 $O(n)$ 对相邻对是有用的, 所以直接从左往右扫描, 维护相邻对, 注意到单次变化是 $O(1)$ 的, 得到所有的对. 然后对每个 $(i, j)$ 求最小的 $k$, 就会得到一个对询问 $(ql, qr)$ 的矩形贡献.</p><p>右边对左边的贡献同理.</p><p>因为每层有 $n$ 对, 一共 $\log n$ 层, 作矩形加单点查单次 $\log n$, 所以复杂度 $n\log^2 n+m\log n$</p><h5 id="P9058-Ynoi2004-rpmtdq"><a href="#P9058-Ynoi2004-rpmtdq" class="headerlink" title="P9058 [Ynoi2004] rpmtdq"></a>P9058 [Ynoi2004] rpmtdq</h5><blockquote><p>给定一棵有边权的无根树, 需要回答一些询问.</p><p>定义 $\texttt{dist(i, j)}$ 代表树上点 $i$ 和点 $j$ 之间的距离.</p><p>对于每一组询问, 会给出 $l, r$, 你需要输出 $\min(\texttt{dist(i, j)})$ 其中 $l\leq i &lt; j \leq r$.</p><p>$n\le 2\times 10^5, q\le 10^6$</p></blockquote><p>考虑树分治, 进行边分, 树变成左子树, $x\to y$, 右子树三部分.</p><p>那么对于点 $u$, 考虑 $dis(v, y)\le dis(u, x)$ 的点, 如果 $u&lt;v&lt;w$, 那么因为 $dis(v, w)\le dis(x, v)+dis(x, w) \le dis(u, x)+dis(x, v&#x2F;w)$ 所以 $v, w$ 可以取代 $u, w$.</p><p>所以每个 $u$ 只和这个区域内的前驱和后继贡献. 按深度扫描一边, 处理另一边即可单log求出这线性对.</p><p>于是现在一共有 $n\log n$ 对, 每个贡献一个矩形, 问题解决</p><h5 id="Luogu9062-Ynoi2002-Adaptive-Hsearch-amp-Lsearch"><a href="#Luogu9062-Ynoi2002-Adaptive-Hsearch-amp-Lsearch" class="headerlink" title="Luogu9062 [Ynoi2002] Adaptive Hsearch&amp;Lsearch"></a>Luogu9062 [Ynoi2002] Adaptive Hsearch&amp;Lsearch</h5><blockquote><p>有 $n$ 个点 $p_1, p_2, \dots, p_n$ 在二维平面上.</p><p>有 $q$ 次询问, 在第 $i$ 个询问中, 给定两个数 $l_i, r_i$ ($1\leq l_i&lt; r_i\leq n$), 你需要找到一对 $(u, v)$ 满足 $l_i\leq u&lt;v\leq r_i$, $p_u$ 和 $p_v$ 之间的欧几里得距离 $\sqrt{(x_u-x_v)^2+(y_u-y_v)^2}$ 最小.</p><p>$n, q\le 2. 5\times 10^5$</p></blockquote><p>todo</p><h3 id="倍增值域分块-分组"><a href="#倍增值域分块-分组" class="headerlink" title="倍增值域分块(分组)"></a>倍增值域分块(分组)</h3><h5 id="CF702F-T-Shirts"><a href="#CF702F-T-Shirts" class="headerlink" title="CF702F T-Shirts"></a>CF702F T-Shirts</h5><blockquote><p>有 $n$ 种 T 恤, 每种有价格 $c_i$ 和品质 $q_i$.</p><p>有 $m$ 个人要买 T 恤, 第 $i$ 个人有 $v_i$ 元, 每人每次都会买一件能买得起的 $q_i$ 最大的 T 恤. 一个人只能买一种 T 恤一件, 所有人之间都是独立的.</p><p>问最后每个人买了多少件 T 恤? 如果有多个 $q_i$ 最大的 T 恤, 会从价格低的开始买.</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>转化成从大到小对每个衣服, 每次给所有买得起的人加一并减钱.</p><p>把 $v$ 排序, 如果能维护顺序就好做了, 注意到减并不改变相对顺序, 但 $[c, 2c]$ 的会和 $[0, c]$ 的归并, 而更大的不受影响.</p><p>于是做法出现: 每一次减的时候, 暴力改 $[c, 2c]$, $[2c, inf]$ 打标记, 这样暴力改的每个数都每次减半了.</p><h5 id="Ynoi2007-rgxsxrs"><a href="#Ynoi2007-rgxsxrs" class="headerlink" title="[Ynoi2007] rgxsxrs"></a>[Ynoi2007] rgxsxrs</h5><blockquote><p>给定一个长为 $n$ 的序列 $a$, 需要实现 $m$ 次操作:</p><p><code>1 l r x</code>: 表示将区间 $[l, r]$ 中所有 $&gt;x$ 的元素减去 $x$.</p><p><code>2 l r</code>: 表示询问区间 $[l, r]$ 的和, 最小值, 最大值.</p><p>$n, m\le 5\times 10^5, a_i, x\le 10^9$</p></blockquote><p>值域分块, 但第 $i$ 块大小是 $2^i$, 让第 $i$ 块是 $[l_i, r_i]$, 每个块开个东西维护.</p><p>如果这个 $l_i&gt;x$, 那么直接打标记, 并把最后几个元素干到下一块.</p><p>如果 $x\in [l_i, r_i]$, 从上暴力往下遍历, 因为每个减了的都会到下一块(至少会减 $2^{i-1}$ )</p><p>最后查询的时候把每个块的”东西”查一遍. 俩log真的能过这东西吗?</p><p>lxl推荐把开一个线段树, 每个区间存区间内的每个”东西”的信息</p><h5 id="Ynoi-Easy-Round-2022-堕天作战"><a href="#Ynoi-Easy-Round-2022-堕天作战" class="headerlink" title="[Ynoi Easy Round 2022] 堕天作战"></a>[Ynoi Easy Round 2022] 堕天作战</h5><blockquote><p>给定一个长为 $n$ 的序列 $a$, 有两种操作, 共 $m$ 次:</p><ol><li>给定 $l$ $r$ $x$, 对于所有 $i$ 满足 $l\le i\le r$ 且 $a_i \neq x$, $a_i\leftarrow a_i-x$.</li><li>给定 $l$ $r$, 求对于所有 $i$ 满足 $l\le i\le r$ 且 $a_i\neq 0$, $a_i$ 的和.</li></ol><p>对于 $100%$ 的数据 $1\le n, m \le 5\times10^5, 0\le a_i, x \le10^9$.</p></blockquote><p>仍然用上一题的办法, 只不过这次会给小于 $x$ 的也减了.</p><p>那么小于 $0$ 的数直接减, 大于 $0$ 的数一个一个的变成小于 $0$ 个数, 反正每个数只会跨过 $0$ 一次.</p><h5 id="CF1515I-Phoenix-and-Diamonds"><a href="#CF1515I-Phoenix-and-Diamonds" class="headerlink" title="CF1515I Phoenix and Diamonds"></a>CF1515I Phoenix and Diamonds</h5><blockquote><p>$n$ 种钻石, 一颗第 $i$ 种钻石重量为 $w_i$, 价值为 $v_i$, 一开始第 $i$ 中钻石的库存为 $a_i$. 接下来进行 $m$ 次操作:</p><ul><li><code>1 k d</code>: 进货了 $k$ 个种类为 $d$ 的钻石;</li><li><code>2 k d</code>: 卖出了 $k$ 个种类为 $d$ 的钻石;</li><li><code>3 c</code>: 如果你有一个大小为 $c$ 的袋子, 且按照第一关键字为价值(从大到小), 第二关键字为重量(从小到大)的顺序取钻石的话, 你最终可以取到钻石的价值为多少(注意操作不会真正执行)</li></ul><p>$1\leq n\leq 2\times 10^5$, $1\leq m\leq 10^5$, $1\leq k, d, a_i\leq 10^5$, $1\leq c\leq 10^{18}$.</p></blockquote><p>因为前两个操作, 考虑排序钻石的 $v$, 问题是解决询问.</p><p>考虑当前 $c$ 最高位是 $k$, 那么减一个大于 $2^k$ 的, 或一直减小于 $2^k$ 的元素直到减不动, 都让 $k-&#x3D;1$</p><p>于是做法是对于当前的 $k$, 只考虑小于 $2^k$ 的元素, 在这些元素中二分就行了.</p><p>最后复杂度2log</p><h5 id="loj-3527-「IOI2021」地牢游戏"><a href="#loj-3527-「IOI2021」地牢游戏" class="headerlink" title="loj #3527. 「IOI2021」地牢游戏"></a>loj #3527. 「IOI2021」地牢游戏</h5><blockquote><p><img src="/img/2023-04-21-17-21-04-image.png" alt="picture 1">  </p><p><img src="/img/2023-04-21-17-24-02-image.png" alt="picture 2">  </p></blockquote><p>辣鸡loj不能复制md题面</p><p>对当前能力 $s$ 分组, 假设当前处于 $[2^k, 2^{k+1}]$</p><p>比这个区间小的一定赢, 大的一定输.</p><p>如果敌人能力是这个区间的, 并且赢了一定能让 $k$ 变大. 因此考虑第一次赢这个区间的敌人的时间, 注意到之前若碰到小于 $2^k$ 的直接赢, 大于的直接输, 所以预处理 $f_{u, i}, g_{u, i}$ 表示 $u$ 在这种情况下走 $2^i$ 步的值, 以及 $h_{u, i}$ 表示 $u$ 走 $2^i$ 步碰到的 $s-\Delta c$ 的最小值.</p><p>复杂度是倍增log+分组log.</p><h5 id="FJOI2016-神秘数"><a href="#FJOI2016-神秘数" class="headerlink" title="[FJOI2016]神秘数"></a>[FJOI2016]神秘数</h5><p>收录在ds中.</p><h5 id="2019ICPC徐州-H-Yuuki-and-a-problem"><a href="#2019ICPC徐州-H-Yuuki-and-a-problem" class="headerlink" title="2019ICPC徐州 H - Yuuki and a problem"></a>2019ICPC徐州 H - Yuuki and a problem</h5><blockquote><p>维护一个长为 $n$ 的序列 $a_i$, 有 $m$ 次操作:</p><ol><li>单点修改</li><li>求区间中所有子集和的 $mex$<br>$a_i\le 10^9, n, m\le 10^5$</li></ol></blockquote><p>上一题加了单点修改. 但上一题俩log了已经, 换上树套树就3log寄了.</p><p>考虑把所有数按 $2^k$ 分组, 那么现在能表示的数最大在 $[2^k, 2^k+1]$ 则可以直接加底下的所有.</p><p>因为只要加一个当前组的数就可以进入下一组, 所以就能做了.</p><p>于是只要对每个组开个线段树, 维护区间和, 区间min即可.</p><h3 id="减半警报器"><a href="#减半警报器" class="headerlink" title="减半警报器"></a>减半警报器</h3><p>处理的大概是, 维护若干个范围, 每次把包含一个点的都减掉一部分, 问每个什么时候到 $0$.</p><p>思路大概是, 拆分成若干更简单的(自由度更低)的范围, 每次一个被改没了就平摊到所有被拆分出来的. 这么做代价是log值域</p><h5 id="CCPC2022-绵阳B-CF-gym-104065-B"><a href="#CCPC2022-绵阳B-CF-gym-104065-B" class="headerlink" title="CCPC2022 绵阳B CF gym 104065 B"></a>CCPC2022 绵阳B CF gym 104065 B</h5><blockquote><p><img src="/img/2023-04-23-08-31-25-image.png" alt="picture 3">  </p></blockquote><p>猫树分治, 给前缀后缀做就成了前缀&#x2F;后缀加了, 为了警报需要维护个最小值, 可以每层一个线段树, 每次修改 $log^2 n$, 平摊总代价是 $\log n \log v$</p><h5 id="CF-gym-102331-F-Fast-Spanning-Tree"><a href="#CF-gym-102331-F-Fast-Spanning-Tree" class="headerlink" title="CF gym 102331 F. Fast Spanning Tree"></a>CF gym 102331 F. Fast Spanning Tree</h5><blockquote><p>给你一张有 $n$ 个点的图, 每个点有非负点权 $w_i$.<br>有 $m$ 个三元组 $(a_i, b_i, s_i)$, $a_i\ne b_i$, $s_i$ 非负<br>一直进行如下的操作:<br>如果没有 $i$ 满足: $a_i$ 和 $b_i$ 在图中的两个不同的连通块中, 且($a_i$ 所在连通块的 $w_i$ 和)+($b_i$ 所在连通块的 $w_i$ 和)$\ge$ $s_i$, 则停机<br>否则找到最小的满足条件的 $i$, 输出 $i$, 并且将 $a_i$ 和 $b_i$ 连通</p></blockquote><p>相当于是 $m$ 条边. 不断加边.</p><p>把每条边权值划分到两个所在连通块中, 每个连通块开一个全局减和单点改, 找最小值的数据结构, 每次合并的时候给边减去一个什么东西, 就行了.</p><h5 id="Codeforces-gym-102452-I"><a href="#Codeforces-gym-102452-I" class="headerlink" title="Codeforces gym 102452 I"></a>Codeforces gym 102452 I</h5><blockquote><p><img src="/img/2023-04-23-08-49-53-image.png" alt="picture 4">  </p></blockquote><p>啊, 就是直接把每个国家的分摊到三个观察点上, 每个观察点开一个数据结构能找最小值, 删最小值, 全局减就行了.</p><h5 id="P7603-THUPC2021-鬼街"><a href="#P7603-THUPC2021-鬼街" class="headerlink" title="P7603 [THUPC2021] 鬼街"></a>P7603 [THUPC2021] 鬼街</h5><blockquote><p>那条街有”鬼街”之称, 十年前是 A 市最繁华的地段之一, 然而如今这里已无活人居住.</p><p>街边七零八落地排着 $n$ 座房子, 每栋房子都有一个 $1$ 到 $n$ 之间的独一无二的编号, 用仿佛来自地狱的黑漆涂在破瓦残砖上, 在黄尘中隐隐若现.</p><p>传说, 这条街上的鬼是与别处的鬼是不同的, 它们喜欢研究数论, 会根据数字的性质来选择自己的生活, 所以它们才为每一栋房子都画上了编号.</p><p>新上任的 A 市市长并不相信魑魅魍魉的传言, 为了探清真相, 他决定为这条街装上灵异事件监控器.</p><p>下面有 $m$ 个事件依次发生.</p><ul><li>灵异事件: 在以 $x$ 的所有质因子为编号的房子里, 都发生了 $y$ 次闹鬼. 由于神秘的原因, 次数 $y$ 可能为 $0$.</li><li>监控事件: 有一个监控器被安装, 其监控以 $x$ 的所有质因子为编号的房子, 当累计的闹鬼总次数达到阈值 $y$ 时, 该监控器会触发报警(若 $y &#x3D; 0$, 则不论被监控的房子是哪几栋, 下一次灵异事件都会立即触发该监控器的报警). 不同房子发生的灵异事件次数会被分开统计, 不同的监控器互不影响. 所有的监控器被从 $1$ 开始依次编号.</li></ul><p>请将所有的报警反馈给市长, 即每个灵异事件之后, 有哪些监控器被触发.</p><p>$n, m\le 10^5, x\le n, y\le 2^{32}$</p></blockquote><p>每个监控器最多看六个房子, 每次最多给六个房子加 $y$.</p><p>剩下的和上个题没有区别.</p><p>感觉这类题知道套路后有点套路.</p><h3 id="杂题选讲"><a href="#杂题选讲" class="headerlink" title="杂题选讲"></a>杂题选讲</h3><h2 id="sqy讲课"><a href="#sqy讲课" class="headerlink" title="sqy讲课"></a>sqy讲课</h2><p>是杂题选讲</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021省队集训-模拟</title>
      <link href="/2023/03/21/2021_sdsj1/"/>
      <url>/2023/03/21/2021_sdsj1/</url>
      
        <content type="html"><![CDATA[<h1 id="2021省队集训-模拟"><a href="#2021省队集训-模拟" class="headerlink" title="2021省队集训-模拟"></a>2021省队集训-模拟</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="A-数排列"><a href="#A-数排列" class="headerlink" title="A. 数排列"></a>A. 数排列</h3><blockquote><p>给定 $n$, 和排列 $x_m$, 求有多少个排列 $a_n$ 满足 $x$ 为 $a$ 字典序最小的长 $m$ 的子序列.<br>膜 $998244353$<br>$m\le n\le 2. 5\times 10^5$</p></blockquote><p>开门降智</p><p>考虑 $x$ 为字典序最小的子序列的条件.</p><p>容易发现, 如果某个位置存在 $x_i\le x_{i-1}$, 那么可以选择 $x_{1\ldots i-2}, x_{i\ldots m}$ 以及再往后一个, 这种情况不行当且仅当剩下的位置不够多, 也就是 $x_i$ 的位置后面恰好全是 $x_i$ 往后的部分.</p><p>于是我们只需要解决对于一个递增的 $x$ 的问题去凑组合数, 考虑把 $x$ 放一排, 从小到大插空即可.</p><p>复杂度线性.</p><h3 id="B-取石子游戏"><a href="#B-取石子游戏" class="headerlink" title="B. 取石子游戏"></a>B. 取石子游戏</h3><blockquote><p>Alice 和 Bob 在玩取石子游戏, 游戏规则是这样的: 游戏开始时在他们面前有若干堆石子, Alice 先手进行游戏, 两人轮流操作, 玩家每轮操作时可以选取一堆石子, 并从中至少取走 $1$ 颗石子, 可以把这堆石子取空, 如果某轮中某位玩家无法进行任何操作(即所有石子均被取完了), 则她或他输掉游戏, 另一方赢得游戏.</p><p>Alice 和 Bob 两人都十分聪明, 并且他们知道彼此均会以最优策略进行操作, 所以他们可以在游戏开始前就预知游戏的赢家是谁.</p><p>Charlie 为 Alice 和 Bob 准备了一项任务: 在 Alice 和 Bob 面前有 $n$ 堆石子, 编号为 $1. . . n$, 初始时第 $i$ 堆中有 $a_i$ 个石子.</p><p>Charlie 会依次执行 $q$ 次操作, 每次操作是以下两类之一:</p><ol><li>格式为 <code>1 l r x</code>: 对于编号在 $[l, r]$ 之间的石子堆 $i$, 如果不足 $x$ 颗石子, 把它补充到 $x$ 颗, 否则不做变化.</li><li>格式为 <code>2 l r x</code>: 询问 Alice 和 Bob 如果此时只保留编号在 $[l, r]$ 之间的石子堆, 再加入一堆新的含有 $x$ 个石子的石子堆, 然后进行游戏, 那么 Alice 在进行第一轮操作时有几种操作方案可以保证她的胜利, 两种操作方案不同当且仅当选取了编号不同的石子堆, 或选取了相同编号的石子堆但是取走了不同数量的石子.</li></ol><p>注意在第 $2$ 类操作中, Alice 和 Bob 并不会真的进行游戏, 所以也不会对石子堆有任何改变.</p><p>Alice 和 Bob 虽然回答了询问, 但是 Charlie 不相信他们的答案. 请你编写程序计算每次游戏时 Alice 在第一轮中的可行操作数.</p><p>$n, q\le 2\times 10^5$</p></blockquote><p>感觉较简单.</p><p>先考虑查询, 考虑求有多少种走完先手必败, 也就是异或和为 $x$, 那么求出当前区间异或和 $s$, 就是有多少个数 $a$ 使得 $a^(a-i)&#x3D;(s^x)$, 也就是 $a^(s^x)&lt;a$, 发现这个等价于 $a$ 在 $s^x$ 的最高位上为1.</p><p>瞪着那个修改, 显然有个均摊: 区间内值的个数是递减的, 可以用Segment Tree Beats, 如果当前区间不只有一个数就向下递归, 维护区间内每个位上的 $1$ 的个数, 复杂度是 $n\log n\log v$</p><h3 id="C-滑冰"><a href="#C-滑冰" class="headerlink" title="C. 滑冰"></a>C. 滑冰</h3><blockquote><p>有一个 $n\times m$ 的滑冰场, 其中有一些障碍物. 你一开始在滑冰场的某个位置上.</p><p>每次你可以选择上下左右四个方向之一进行移动, 因为冰面很滑所以你会一直朝选定的方向移动直到碰到边界或障碍物.</p><p>用 <code>. </code> 表示无障碍物的冰面, 用 <code>#</code> 表示障碍物, 用 <code>S</code> 表示你初始的位置(这个位置也是无障碍物的冰面), 例如:</p><p><code>. . . . . </code></p><p><code>. . . . . </code></p><p><code>#. S. #</code></p><p><code>. . . . . </code></p><p><code>. . #. . </code></p><p>就描述了一个可能的滑冰场. 将第 $i$ 行第 $j$ 列的位置记作 $(i, j)$, 则你在 $(3, 3)$, 向上会移动到 $(1, 3)$, 向下会移动到 $(4, 3)$, 向左会移动到 $(3, 2)$, 向右会移动到 $(3, 4)$.</p><p>现在将一些无障碍物的冰面上放上标记点, 用 <code>o</code> 表示, 也就是说 <code>o</code> 表示标记点, 而且这个位置也是无障碍物的冰面.</p><p>保证你初始的位置上没有标记点.</p><p>请问你能否规划一个移动方式, 使得你的移动路线可以经过所有的标记点呢?</p></blockquote><p>对于一个极长的横着&#x2F;竖着的段, 走到一个点就能走到全部.</p><p>对于每个标记点, 要求横着&#x2F;竖着的段至少选择一个.</p><p>这个限制是2SAT, 限制是若两个段不可以在某个方向连通, 就不能同时选, 考虑这样得到的最终选择集合以及其中表示”可以走”的关系的连边, 因为得到的是竞赛图+某些部分有双向边(当双连通时), 因此缩点后是链, 一定可以走出来.</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="A-我已经完全理解了DFS序线段树"><a href="#A-我已经完全理解了DFS序线段树" class="headerlink" title="A. 我已经完全理解了DFS序线段树"></a>A. 我已经完全理解了DFS序线段树</h3><blockquote><p>给定一棵有 $n$ 个结点的有根树, 根结点为 $1$ 号点.</p><p>每个点有权值 $a_i$, 初始时均为 $0$, 以及花费 $v_i$, 表示对它进行一次操作时要花费的代价.</p><p>对点 $u$ 进行一次参数为 $x$ 的操作, 即是在树中将它子树中的所有点的权值都加上 $x$. 要求 $x$ 为整数且 $1\le x\le 10^9$</p><p>要让每个叶子的权值互不相同且非零, 即当 $i, j(i\neq j)$ 为叶子时要满足 $a_i\neq 0$ 且 $a_i\neq a_j$.</p><p>你需要构造一个总花费尽量小的操作序列.</p><p>$2\leq n\leq 2\times 10^5, 1\leq v_i\leq 10^9$.</p></blockquote><p>考虑让花费最小: 容易发现一个简单贪心, 合法方案下, 一个点的作用是它可以等同于子树内的任意一点(你可以操作这个点, 然后不操作其子树里的每一个点), 于是可以从底向上贪心.</p><p>那么问题是确定了操作集合之后如何构造 $x$.</p><p>现在已经有了每个叶子到根的集合互不相同, 也就是任意两个叶子最深的操作点不同, 所以按照操作点从上往下操作, 就可以逐步确定叶子. 于是就可做了.</p><p>一个牛逼做法是, 随机, 冲突了就重新随, 大约30次就能找到.</p><h3 id="B-我已经完全理解了字符串哈希"><a href="#B-我已经完全理解了字符串哈希" class="headerlink" title="B. 我已经完全理解了字符串哈希"></a>B. 我已经完全理解了字符串哈希</h3><blockquote><p>对于两个合适的整数 $base$ 和 $m$, 可以定义字符串哈希函数 $h(s)$:</p><p>$$h(s)&#x3D;(\sum_{i&#x3D;1}^{|s|}s_i\cdot base^{|s|-i})\bmod m$$</p><p>其中 $s &#x3D; s_1s_2. . . s_{ \vert s \vert }$ 是一个由小写字母组成的字符串, 并且假设每个字符在式中被看成它在字母表中的编号, 例如字符 <code>a</code> 被看成 $1$.</p><p>本题中我们取 $base &#x3D; 2333333, m &#x3D; 998244353$.</p><p>给定一个字符串 $s$, 请求出它的所有连续子串中哈希值的最大值.</p><p>保证给定的字符串是随机生成的: 先指定字符串长度, 每个字符随机在 $26$ 个小写字母中选取.</p><p>$\sum \vert s\vert \le 10^6$</p></blockquote><p>第一反应是对着前缀和, 一个数据结构扫描线上去扫, 但被取模干爆了.</p><p>注意到数据随机, 那么可以当成有 $n^2$ 个随机数, 此时最大值应该在 $m-\dfrac{m}{n^2}$ 附近, 那么从 $m$ 开始, 每次 $O(n)$ 的验证某个答案, 复杂度是惊喜的 $\dfrac{m}{n}$, 又因为大家都会 $n^2$ 暴力, 平衡一下看起来就很好.</p><p>那么问题来到 $O(n)$ 验证是否存在某个答案, 容易想到先前缀和, 于是就是求 $j$ 使得 $s_i-s_j\cdot base^{i-j}&#x3D;v, \dfrac{s_j}{base^j}&#x3D;\dfrac{s_i-v}{base^i}$, 于是一个哈希表即可.</p><h3 id="C-我已经完全理解了多源BFS"><a href="#C-我已经完全理解了多源BFS" class="headerlink" title="C. 我已经完全理解了多源BFS"></a>C. 我已经完全理解了多源BFS</h3><blockquote><p>在平面直角坐标系中, 称横纵坐标均为整数的点为格点.</p><p>对于两个格点 $(x_1, y_1)$ 和 $(x_2, y_2)$, 定义它们相邻当且仅当 $\max( \vert x_1-x_2 \vert ,  \vert y_1-y_2 \vert ) &#x3D; 1$.</p><p>给出 $n$ 个互不相同的作为 BFS 源的格点 $(x_1, y_1), (x_2, y_2), . . . , (x_n, y_n)$, 以及一个参数 $k$, 从它们出发进行多源 BFS:</p><ol><li>对于所有格点 $(x, y)$, 令 $dis(x, y)\gets 0$. 并维护一个队列, 初始时为空.</li><li>对于 $1 ≤ i ≤ n$, 将 $(x_i, y_i)$ 入队, 并令 $dis(x_i, y_i)\gets 1$.</li><li>取出队首格点, 假设为 $(x_p, y_p)$, 如果 $dis(x_p, y_p) &#x3D; k$, 转到 $5$.</li><li>枚举所有与 $(x_p, y_p)$ 相邻的格点 $(x_q, y_q)$, 如果 $dis(x_q, y_q) &#x3D; 0$, 则将 $(x_q, y_q)$ 入队, 并令<br>$dis(x_q, y_q)\gets dis(x_p, y_p) + 1$.</li><li>如果队列非空, 转到 $3$, 否则多源 BFS 结束.</li></ol><p>对所有格点 $(x, y)$ 的 $dis(x, y)$ 求和, 可以证明这个数是有限的.</p><p>由于答案可能很大, 你只需输出答案对 $998244353$ 取模的结果.</p></blockquote><p>肯定要扫描线, 那么对于一条平行于 $y$ 轴的扫描线分成若干区间, 每个区间对应的起点相同, 那一个区间改变就是扫描线扫到了某两个出发点在横轴上的中点, 或者进入&#x2F;退出某个起点的区域, 次数是 $n^2$ 量级的.</p><p>开什么玩笑, 俩东西都交点是斜线.</p><p>官方正解是考虑按照 $k$ 分层, 每次加上这层的 $k$ 和上层的 $k$ 的面积差再乘 $k$ 的式子, 其中这个会发生 $n^2$ 次变化(两个起点同时拓展到某个区域), 注意到在某个不变化的区间内这个差是二次函数, 所以可以直接取三个点值插出答案. 算点值的方法就成了矩形并矩形面积, 复杂度 $n^3\log n$</p><p>另一个做法是直接转曼哈顿距离, 然后过每个起点画横竖线, 得到 $n^2$ 个矩形, 注意到每个矩形都是四个角先被拓展到, 然后才是里面的东西, 而两个角在矩形内的贡献的分割线是一条水平竖直线(相邻)或斜线(对角), 于是每个角的贡献是一个缺一个角的五边形的形态, 可以直接数学方法暴力算贡献, 复杂度为 $O(n^2)$</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="陌生的城市"><a href="#陌生的城市" class="headerlink" title="陌生的城市"></a>陌生的城市</h3><blockquote><p>济南对于小猫来说是一座陌生的城市. 今天小猫带来了家乡的土特产——FJOI 字符串题.</p><p>小猫喜欢循环串. 如果字符串 $s$ 的长度为 $n$ 而最小循环节长度为 $m$, 定义它的美观度为 $\frac{n^2}m$. 这里循环节要求 $m \vert n$.</p><p>FJOI 喜欢子序列. 给定一个只包含 $a, b, c$ 的字符串, 求其全体非空子序列的最大美观度.</p><p>多组数据.</p><p>$t\le 10, n\le 10^5$</p></blockquote><p>首先, 注意到它写的不是子串(? )</p><p>答案最小是 $\dfrac{n^2}{9}$, 于是只用考虑 $m\le 8$ 的那部分, 然后暴力跑匹配, 算一下计算量是 $10^10$</p><p>考虑预处理每个位置往后6位, 运算量是 $1. 6e9$.</p><p>考虑每个循环移位出来的串, 可以只跑一次匹配, 然后 $O(m)$ 的一起处理, 现在应该在 $2e8$ 到 $3e8$ 之间.</p><p>冲!</p><p>好吧, 正解表示, 设重复 $k$ 次, 答案是 $k^2m$, 而考虑出现次数最多的那个数的出现次数 $(k\dfrac{m}{3})$, 如果我们不是直接用这一个数更新答案, 那么就有一个不等式, 发现 $m\in {2, 3, 5, 6}$, 就直接做完了.</p><h3 id="大原题"><a href="#大原题" class="headerlink" title="大原题"></a>大原题</h3><blockquote><p>有 $n$ 个盒子, 第 $i$ 个盒子里有 $a_i$ 个标有数字 $i$ 的球, 代表第 $i$ 种奖品.</p><p>接下来依次进行 $m$ 次操作, 每次指定两个不同的盒子 $x_i, y_i$, 玩家可以从 $x_i, y_i$ 中各拿出一个球交换, 也可以放弃这次机会.</p><p>玩家最终会抱着第 $1$ 个盒子回家, 所以目标是最大化第 $1$ 个盒子中的数字种类数.</p><p>$n, m, a_i\le 3000$</p></blockquote><p>每个交换看作边, 盒子看作点, 就是一张图, 从 $1$ 出发, 走边权递增的不交的路径能到最多多少个盒子. 考虑网络流, 能到多少个点就成了每个点有 $1$ 的入流求最大流, 前面的部分可以来一个点边互换. 但这是无限 $a_i$ 版.</p><p>考虑 $a_i$ 点限制是同一时刻盒子里装的最大球数, 把盒子按照时刻拆点成一列, 每一时刻向下一时刻连 $a_i$, 这样点边互换部分可以删了. 每个点建连用到的时间, 点数是 $n+2m$, 边数是 $4m$ 这样的.</p><p>需要快速的网络流.</p><h3 id="美丽的世界"><a href="#美丽的世界" class="headerlink" title="美丽的世界"></a>美丽的世界</h3><blockquote><blockquote><p>小猫和粉兔在异世界探险. 他们得到了 $m$ 件装备, 要进行分配. 小猫和粉兔各有 $n$ 个装备栏, 每栏至多穿戴一件装备. 同一件装备会对两个人的战斗力都产生影响, 他们的战斗力也就是他们所有装备提供的战斗力之和. 现在要求符合条件下的所有分配方案中, 合作战斗力的最小值. 保证存在至少一种合法的分配方案.</p></blockquote><p>$n\leq 5 \times 10^5, m\leq 2n$</p><p>$1\leq x_i, y_i\leq n$</p><p>$0\leq a_i, b_i\leq 10^6$</p><p>$\sum^n_{i&#x3D;1} a_i, \sum^n_{i&#x3D;1} b_i\leq 2 \times 10^9$.</p></blockquote><p>容易想到把装备栏看成两排点, 每个装备看成一条边 $(x_i, y_i)$, 那么因为每个栏最后只有一个入度, 所以有解给出的一定是一个基环树-树的森林.</p><p>把两个人的得分画到平面上, 那么有若干点, 用 $y&#x3D;\dfrac{k}{x}$ 去切, 发现最后一定是一个左下凸壳, 于是把每个连通块的所有可能答案(基环树只有两个, 树枚举每个点作为根)算出来跑闵和.  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论</title>
      <link href="/2023/03/04/number/"/>
      <url>/2023/03/04/number/</url>
      
        <content type="html"><![CDATA[<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem ?"></a>Problem ?</h3><blockquote><p>给定排列 $a_n$, 求 $\sum_i \sum_j gcd(i, j)gcd(a_i, a_j)$</p><p>$n\le 10^5$</p></blockquote><p>$$<br>\begin{gathered}<br>\sum_i \sum_j gcd(i, j)gcd(a_i, a_j)\<br>&#x3D;\sum_i \sum_j \sum_{d|i, j} \varphi(d) \sum_{k|a_i, a_j} \varphi(k)\<br>&#x3D;\sum_d \varphi(d) \sum_k \varphi(k) (\sum_{d\vert i}[k\vert a_i])^2<br>\end{gathered}<br>$$</p><p>设 $g(d, k)&#x3D;\sum_{d\vert i}[k\vert a_i]$</p><p>考虑一个 $(i, a_i)$ 对的贡献, 那么发现 $g$ 一共是 $\sum d(i) d(a_i)$, 又因为是排列, 于是这个就是 $\sum_i d^2(i)$, 据说是 $n\log^3 n$ 的.</p><p>那么你只枚举 $g$ 有值的 $i, j$ 就能做3log了. 简单想法是哈希表, 空间爆炸.</p><p>考虑逐个 $i$ 处理, 即固定一个 $i$, 枚举 $i$ 和 $a_i$ 的因数就行了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZROI省选集训</title>
      <link href="/2022/12/31/zroisj/"/>
      <url>/2022/12/31/zroisj/</url>
      
        <content type="html"><![CDATA[<h2 id="Day1-数据结构"><a href="#Day1-数据结构" class="headerlink" title="Day1 数据结构"></a>Day1 数据结构</h2><h3 id="rprmq1"><a href="#rprmq1" class="headerlink" title="rprmq1"></a>rprmq1</h3><p>分治+同一分治深度的一起处理+扫描线+区间历史最大值, 参见sdjx1</p><h3 id="P8512-Ynoi-Easy-Round-2021-TEST-152"><a href="#P8512-Ynoi-Easy-Round-2021-TEST-152" class="headerlink" title="P8512 [Ynoi Easy Round 2021] TEST_152"></a>P8512 [Ynoi Easy Round 2021] TEST_152</h3><blockquote><p>转转有一个操作序列 $(l_i, r_i, v_i)$.</p><p>现在, 有 $q$ 个询问 $l$, $r$.</p><p>每次询问, 你初始有一个长度为 $m$ 的序列 $c$, 初值全是 $0$.</p><p>现在我们从 $l$ 到 $r$ 执行这 $r-l+1$ 个操作.</p><p>每个操作是将 $c[l_i]$ ~ $c[r_i]$ 赋值为 $v_i$.</p><p>询问所有操作结束后整个 $c$ 的序列所有数的和.</p><p>询问之间互相独立.<br>$n, q\le 5\times 10^5$</p></blockquote><p>考虑扫描线, 看出扫序列没前途, 于是扫操作.</p><p>那么扫描操作维 $r$, 过程中珂朵莉树维护序列维, 并在珂朵莉树每个节点上维护其插入时间 $t$, 对某个 $r$, 每个节点的贡献就成了当 $l&gt;t$ 时答案加上 $sum$.</p><p>注意此时珂朵莉树不会真删而是加入一个贡献 $-sum$ 的(理所当然)</p><p>于是在珂朵莉树维护的同时用一个树状数组维护在这个时刻后的连续段之和, 是一个后缀和.</p><p>复杂度是单log.</p><h3 id="P8337-Ynoi2004-rsxc"><a href="#P8337-Ynoi2004-rsxc" class="headerlink" title="P8337 [Ynoi2004] rsxc"></a>P8337 [Ynoi2004] rsxc</h3><blockquote><p>给定一个长为 $n$($1\le n\le 6\times 10^5$)的非负整数序列 $a_0, a_1, \dots, a_{n-1}$($0\le a_i&lt;2^{30}$).</p><p>有 $q$ 个询问($1\le q\le 10^6$).</p><p>每次询问给出两个整数 $l, r$($0\le l\le r&lt;n$), 求有多少对整数 $(x, y)$ 满足:</p><ul><li>$l\le x\le y\le r$;</li><li>$\forall i, j\in S\ : i\oplus j\in S$, 其中 $S: &#x3D;{a_k}_{k&#x3D;x}^y$.<br>$n, q\le 10^6$</li></ul></blockquote><p>区间线性基:</p><p>扫描线扫 $r$, 线性基中每个位置再维护一下这个数的下标, 使得每个位置是最靠右的使这一位为 $1$ 的位置.</p><p>于是 $[l, r]$ 的线性基就是这个线性基中所有下标大于 $l$ 的部分构成的.</p><p>于是考虑枚举 $\vert S\vert$(显然只有 $\log n$ 种), 然后确定大小之后双指针. 某个区间满足条件当且仅当其 $\vert S\vert$ 为 $2^{\vert V\vert}$, $V$ 为线性基. 这样就能解决全局了.</p><p>对于区间询问, 每个 $\vert S\vert$ 大小分别处理, 那么此时一个 $r$ 对应一个区间的 $l$, 且这个区间左右端点分别递增. 这个可以线性预处理常数查询.</p><h3 id="P8265-Ynoi-Easy-Round-2020-TEST-63"><a href="#P8265-Ynoi-Easy-Round-2020-TEST-63" class="headerlink" title="P8265 [Ynoi Easy Round 2020] TEST_63"></a>P8265 [Ynoi Easy Round 2020] TEST_63</h3><blockquote><p>定义一条链的权值是链上所有点编号的异或和, 维护一个森林, 支持加边, 删边, 查询森林中所有树上的所有重链放到一起, 权值的第 $k$ 小. 如果一个点有多个子树大小最大的儿子, 取其中编号最大的. 加边的时候新树的根改为第二个操作点, 删边的时候深度更大的点自动成为新树的根. $n\leq 10^5, m\leq 5\times 10^5$, 时限5s.</p></blockquote><p>对每个点维护重儿子, 最大轻儿子, 对每个重链开一个平衡树.</p><p>那么对于换根, 可以对当前点到根上的每个重链分别翻转, 所有轻边也换方向, 因为路径上经过的重链只有 $\log n$ 条所以没问题.</p><p>此时重儿子变化情况有三种:</p><ul><li>重儿子变父亲, 父亲变重儿子:<ul><li>因为翻转了这个重链, 所以不用管</li></ul></li><li>重儿子变轻儿子, 父亲变重儿子:<ul><li>表示出来是 $siz_fa&gt;siz_weightest&gt;siz_max$, 这种只有 $\log n$ 个, 可以二分出来.</li></ul></li><li>重儿子变父亲, 轻儿子变重儿子:<ul><li>同上一个</li></ul></li></ul><p>而link只要先把两个节点都换成根, 然后更新其中的一个重儿子.</p><p>cut $u, v$ 把 $u$ 变成根, 断掉之后更新重儿子.</p><p>查询可以开一个平衡树维护所有重链.</p><h3 id="Ynoi2010-y-fast-trie"><a href="#Ynoi2010-y-fast-trie" class="headerlink" title="[Ynoi2010] y-fast trie"></a>[Ynoi2010] y-fast trie</h3><blockquote><p>给定一个常数 $C$, 你需要维护一个集合 $S$, 支持 $n$ 次操作:</p><ul><li>操作1: 给出 $x$, 插入一个元素 $x$, 保证之前集合中没有 $x$ 这个元素</li><li>操作2: 给出 $x$, 删除一个元素 $x$, 保证之前集合中存在 $x$ 这个元素</li></ul><p>每次操作结束后, 需要输出 $\max\limits_{\substack{ i, j \in S \ i \ne j }} \bigl( (i+j) \bmod C \bigr)$, 即从 $S$ 集合中选出两个不同的元素, 其的和 $\bmod~C$ 的最大值, 如果 $S$ 集合中不足两个元素, 则输出 <code>EE</code>.</p><p>本题强制在线.</p><p>$n\le 5\times 10^5$</p><p>128m</p></blockquote><p>和上一个题很类似.</p><p>$\mod C$ 之后答案是 $\max a+b-C$, 或者 $\max a+b, a+b&lt;C$, 而后面这个把一维反转, 区别在于修改变成了插入删除. 此时就是求全局最近的前驱, map维护前驱, 修改时常数次更新.</p><h3 id="P6018-Ynoi2010-Fusion-tree"><a href="#P6018-Ynoi2010-Fusion-tree" class="headerlink" title="P6018 [Ynoi2010] Fusion tree"></a>P6018 [Ynoi2010] Fusion tree</h3><blockquote><p>给定 $Tree(n)$, 点有权值 $a_i$, $m$ 次操作, 每次对与 $u$ 距离为 $1$ 的点加1, 对 $u$ 减 $v$ 或询问与一个点 $x$ 距离为 $1$ 的所有节点的权值异或和.</p><p>$n, m\le 5\times 10^5$</p></blockquote><p>每个点开一个动态开点01trie, 支持全局加一和单点改, 维护所有儿子.</p><p>全局加一可以考虑, 从低位到高位建, 对于一个当前的加一, 左子树右子树交换, 然后要接着递归到交换后的左子树下面去即可. 这个过程维护一个异或和是简单的.</p><p>复杂度1log</p><h3 id="P8336-Ynoi2004-2stmst"><a href="#P8336-Ynoi2004-2stmst" class="headerlink" title="P8336 [Ynoi2004] 2stmst"></a>P8336 [Ynoi2004] 2stmst</h3><blockquote><p>已知 $n$ 个顶点的有根树, 以及 $m$ 个二元组 $(x_i, y_i)$, 其中 $x_i, y_i$ 是树的顶点.</p><p>对于树的顶点 $a, b$, 定义 $D(a, b)$ 为: 在以 $a$ 为根的子树中, 但不在以 $b$ 为根的子树中的顶点个数.</p><p>你需要求出以这些二元组为顶点的完全图的最小生成树, 其中 $(x_i, y_i)$ 和 $(x_j, y_j)$ 之间的边权是 $D(x_i, x_j)+D(x_j, x_i)+D(y_i, y_j)+D(y_j, y_i)$.</p><p>对于 $100%$ 的数据, 满足 $1\le n\le 10^6, 1\le m\le 10^5$. 对任意 $i&#x3D;1, 2, \dots n-1$, 满足 $1\le f_{i+1}&lt;i+1$. 对任意 $i&#x3D;1, 2, \dots m$, 满足 $1\le x_i, y_i\le n$.</p></blockquote><p>考虑brovka.</p><p>$D(a, b)+D(b, a)$ 表示, 若 $a, b$ 有祖先关系就是 $\vert siz_a-siz_b\vert$, 否则是 $siz_a+siz_b$.</p><p>于是要统计答案, $x$ 没有祖先关系的可以直接看成任意两 $x$ 之和, 然后再去算 $y$ 的即可($y$ 的子树内和 $y$ 子树外分别处理). 这部分是线性的. $y$ 没有的同理, 于是问题变成了两者都有祖先关系的情况.</p><p>这种情况你就分若干类讨论, 如果 $x_i, y_i$ 都是作为祖先的, 可以用线段树合并维护做到1log, 实际看起来是个二维数点.</p><p>如果不都作为祖先, 比如 $x$ 作为祖先, 那么dfs这棵树, 遇到一个 $x_i$ 的时候就在 $y_i$ 处单点改, 遇到一个 $x_j$ 要查它到根的最小值即可.</p><p>todo</p><h3 id="Ynoi2003-博丽灵梦"><a href="#Ynoi2003-博丽灵梦" class="headerlink" title="[Ynoi2003] 博丽灵梦"></a>[Ynoi2003] 博丽灵梦</h3><blockquote><p>矩形颜色数, 带权.</p><p>给定一个有 $n$ 个点的二维平面, 每个点坐标为 $(i, p_i)$ , 其有权值 $a$.</p><p>给定一个长为 $n$ 的数组 $b$, 其下标从 $1$ 到 $n$.</p><p>有 $m$ 次查询, 每次查询给定一个矩形 $l_1, r_1, l_2, r_2$, 定义集合 $S&#x3D;{a_i \vert l_1\le i\le r_1 \land l_2\le p_i\le r_2}$, 求对于集合 $S$ 中所有元素 $j$, $b_j$ 的和.</p><p>对于所有测试点: $2 \leq n \leq 10^5$, $1 \leq m \leq 10^6$, $1 \leq l_1\le r_1 \leq n$, $1 \leq l_2\le r_2 \leq n$, 保证 $p_i$ 为一个排列, 保证 $1\le p_i, a_i, b_i\le n$.</p></blockquote><p>莫队做 $l_1, r_1$, 在 $l_2, r_2$ 这一维做待修区间数颜色复杂度根号2log.</p><p>考虑优化区间数颜色, 问题变成了</p><ul><li>莫队时要查询前驱后继: 容易回滚莫队+每个颜色开链表解决(2022WC秃子酋长)</li><li>$m$ 次矩形查, $n\sqrt m$ 次单点加. 考虑二维分块, 先按 $B&#x3D;n^{\dfrac{3}{4}}$ 分块, 每个块再按 $C&#x3D;\sqrt n$ 分块, 此时查询一个2side矩形时, 每一维会拆成 $n^{0. 25}$ 个大块和 $n^{0. 25}$ 个小块, 发现直接加入所有这样的块的复杂度就是 $\sqrt n$. 而对于修改, 只有所在的四个块要改(四个块分别是两边边长为 $B$ 或 $C$ 的两种). 最后问题是散块, 查询时直接枚举一维, 判断对应的最多 $O(1)$ 个另一维是否有值即可($O(1)$ 说的是每个 $i$ 只对应一个 $last_i$, 每个 $last_i$ 也只对应一个 $i$, 任意时刻点集都是一一对应的).</li></ul><h3 id="P8419-THUPC2022-决赛-riapq"><a href="#P8419-THUPC2022-决赛-riapq" class="headerlink" title="P8419 [THUPC2022 决赛] riapq"></a>P8419 [THUPC2022 决赛] riapq</h3><blockquote><p>给出排列 $a_1, \dots, a_n$, 你需要维护序列 $b_1, \dots, b_n$, 初值为 $0$.</p><p>共 $m$ 次操作:</p><p>修改操作: 给出 $l, r$, 对每个 $(i, j)$ 满足 $l\le i\le j\le r, ; a_i\le a_j$, 将 $b_j$ 增加 $1$;</p><p>查询操作: 给出 $x$, 查 $b_x$.</p><p>对于 $100%$ 的数据, 满足 </p><p>$1\le n, m\le 2\times 10^5$;</p><p>$1\le a_i\le n$, $a_i$ 互不相同;</p><p>$1\le l\le r\le n$;</p><p>$1\le x\le n$.</p></blockquote><p>尝试操作分块, 失败.</p><p>把修改差分. 变成两部分, 其中 $[1, i-1]$ 对 $i$ 的贡献预处理.</p><p>还要去掉 $[1, l-1]$ 对 $i$ 的贡献, 考虑前 $j$ 个块对 $i$ 的贡献, 可以预处理后 $\sqrt n$ 查.</p><p>已经完成的这部分可以修改的时候直接打标记.</p><p>现在问题是 $[1, l-1]$ 剩下的散块对 $[l, r]$ 的贡献, 散块里面每个数相当于一个矩形加, 成了 $n\sqrt n$ 个矩形加, 线性个单点查, 把加和查对偶, 然后就成了 $n$ 次矩形加, $n\sqrt n$ 次查, 此时的性质是同一个散块贡献的时候横坐标对应的 $[l, r]$ 相同, 纵坐标是不同的后缀.</p><p>todo</p><h3 id="Ynoi2003-樋口円香"><a href="#Ynoi2003-樋口円香" class="headerlink" title="[Ynoi2003] 樋口円香"></a>[Ynoi2003] 樋口円香</h3><blockquote><p>给定两个序列 $a_1, \dots, a_n$, $b_1, \dots, b_n$, 一开始 $b_i&#x3D;0$;</p><p>你需要进行 $m$ 次操作:</p><p>每次操作, 给出 $l, r, L$, 需要对于 $k\in[l, r]$, 将 $b_{L+k-l}$ 增加 $a_k$;</p><p>最后输出经过所有操作后的序列 $b_1, \dots, b_n$.</p><p>对于 $100%$ 的数据  $0\le a_i\le 1000$; $1\le n\le 10^5$; $1\le m\le 10^6$.</p></blockquote><p>考虑对 $a$ 分块, 散块直接暴力加, 离线后单独考虑每个块 $c$, 卷上 $d$, 其中 $d_k$ 为 $L&#x3D;k$ 的个数.</p><p>最后平衡一下可以把 $\log$ 放到根号下面, 复杂度 $n\sqrt{q\log n}$.</p><h3 id="Ynoi2078-阅读报告-更新中"><a href="#Ynoi2078-阅读报告-更新中" class="headerlink" title="[Ynoi2078] 阅读报告(更新中. . . )"></a>[Ynoi2078] <How to represent part-whole hierarchies in a neural network>阅读报告(更新中. . . )</h3><blockquote><p>给定序列 $a_1, \dots, a_n$, 共 $m$ 次询问, 每次询问给出 $l, r$, 查询所有满足 $l\le L\le R\le r$ 的 $(L, R)$ 的权值的按位异或和, 二元组 $(L, R)$ 的权值是 $\vert {a_i\mid L\le i\le R}\vert$.</p><p>对于 $100%$ 的数据, 满足 $1\le n, m\le 4\times 10^5$, $1\le a_i\le n$, 所有数值为整数.</p></blockquote><p>考虑对 $r$ 扫描线, 维护 $a_l$ 表示 $l$ 到 $r$ 的颜色数, $b_l$ 表示 $[l, l]\mathrm{xor}[l, l+1]\ldots\mathrm{xor}[l, r]$, 问题变成了 $b_i\to b_i\mathrm{xor}a_i$, 查区间 $b_i$ 异或和, $a$ 区间加 $1$.</p><p>考虑分块, 再定义一个参数 $B$, 维护整块加标记, 整块异或 $a_i+x$ 标记(一个 $x$ 的集合), $a_i+x$ 的异或和, 对 $x\le B$, 以及整块 $b$ 异或和.</p><p>每次对 $a$ 区间加就整块标记散块暴力+重构, 对 $b$ 异或 $a$ 就整块标记散块暴力+重构, 区间查同理, 然后每当加法标记 $&gt;B$ 就重构. 显然重构次数线性, 问题就是如何重构.</p><p>重构一个块的时候:</p><ul><li>考虑如何维护 $a_i+x$ 的异或和, $x\le \sqrt n$<ul><li>传统 trick 逐位考虑 $a_i+x$ 的第 $k$ 位表示对应位相加, 再加上前 $k-1$ 位加起来是否到能进位.</li><li>于是要求所有的前 $k-1$ 位相加进位的个数</li><li>注意到, 若 $2^{k-1}\ge \sqrt n$, 它就只有 $k-1$ 位, 这些可以直接处理.</li><li>而对于不到 $n$ 的那些 $k$, 可以直接枚举所有值求个数.</li><li>todo</li></ul></li><li>还原 $b$ 的部分是对称的.</li></ul><h3 id="Ynoi2007-tmpq"><a href="#Ynoi2007-tmpq" class="headerlink" title="[Ynoi2007] tmpq"></a>[Ynoi2007] tmpq</h3><blockquote><p>给定三个长为 $n$ 的数组 $a, b, c$, 满足 $1\le a_i, b_i, c_i\le n$ 且为整数.</p><p>你需要进行 $m$ 次操作, 每次操作为:</p><p><code>1 k x</code>: 代表将 $a$ 序列的第 $k$ 个位置改为 $x$, 即 $a_k : &#x3D; x$.</p><p><code>2 r</code>: 代表查询有多少个三元组 $(i, j, k)$, 满足 $1\le i&lt;j&lt;k\le r$, 且 $b_{a_i}&#x3D;a_j&#x3D;c_{a_k}$.</p><p>对于 $100%$ 的数据, 满足 $1\le n\le 2\times 10^5$, $1\le m\le 5 \times 10^4$, $1\le a_i, b_i, c_i, x, k, r\le n$.</p></blockquote><p>实际上 $b_{a_i}$ 和 $c_{a_k}$ 并没有什么性质, 直接当成单点修改 $a, b, c$, 然后问 $b_i&#x3D;a_j&#x3D;c_k, i\le j\le k$.</p><p>对出现次数根号分治:</p><p>对于大于 $\sqrt n$ 的部分, 对每个颜色维护一个动态dp, $f_{p, 0&#x2F;1&#x2F;2}$ 表示位置 $p$ 左边已经有了 $1&#x2F;2&#x2F;3$ 个数对(比如 $2$ 表示 $b_i&#x3D;a_j$ 的对数), 那么转移可以写成矩阵, 就成了单点改前缀矩阵乘积.</p><p>对于小于 $\sqrt n$ 的部分, 修改的时候暴力处理这个颜色的dp, 然后每个位置贡献到一个后缀.</p><h3 id="UOJ-712-北大集训2021-简单数据结构"><a href="#UOJ-712-北大集训2021-简单数据结构" class="headerlink" title="UOJ#712. [北大集训2021]简单数据结构"></a>UOJ#712. [北大集训2021]简单数据结构</h3><blockquote><p>给定 $a_n$, 全局 $a_i+&#x3D;i$, 全局取min, 区间求和.</p><p>$n, q\le 2\times 10^5$</p></blockquote><p>考虑经过取min之后的点, 注意到如果先取min $v$ 再加 $i$ 等价于先加 $i$ 再取min $v+i$.</p><p>于是对于某一个时刻, 取min之后的点是单调的: 每个取min都是 $i$ 对 $v+ki$ 取min.</p><p>于是是若干条直线得到一个上凸包, 每次取min会把凸包上方的移动到凸包上.</p><p>于是分开维护, 那么凸包上的点线段树维护, 凸包下面的也是.</p><p>最后差的一步就是整体二分求所有点到凸包上的时间.</p><h3 id="UOJ-715-北大集训2021-小明的树"><a href="#UOJ-715-北大集训2021-小明的树" class="headerlink" title="UOJ#715. [北大集训2021]小明的树"></a>UOJ#715. [北大集训2021]小明的树</h3><blockquote><p>小明有一棵以 $1$ 为根的 $n$ 个节点的树, 树上每一个非根节点上有一盏灯, 他有一个 $2\ldots n$ 的排列 $a_{n-1}$. 他还有一个计数器, 初始为 $0$.</p><p>他会按照排列依次点亮这 $n−1$ 盏灯, 每进行一次点灯操作后, 他会检查整个树是否是美丽的, 如果是美丽的, 计数器会加上此时点灯的节点形成的联通块的个数.</p><p>$n−1$ 次点灯后计数器的值, 记为这棵树的答案.</p><p>一个树是美丽的当前仅当对于每一个被点亮的节点, 这个节点子树内的节点都是点亮的.</p><p>小明认为这个问题太简单了, 他觉得应该让树动起来.</p><p>在初始查询后, 他会删掉树中一条边并加上一条边, 保证修改后还是一棵树, 他想知道每一次修改后将计数器清零后重新点灯并计数, 这棵树的答案是多少.</p><p>$n, m\le 5\times 10^5$</p></blockquote><p>美丽的条件是未点亮的部分是一个连通块.</p><p>维护前缀, 后缀的点减边 $a_i, b_i$.</p><p>那么每条边的变化都是区间加减.</p><p>同时显然点减边最小为 $1$, 所以就维护所有 $a_i$ 为最小值的位置的 $b_i$ 的和即可.</p><p>todo 月球列车</p><h2 id="Day2-数数"><a href="#Day2-数数" class="headerlink" title="Day2 数数"></a>Day2 数数</h2><h3 id="Agc060c"><a href="#Agc060c" class="headerlink" title="Agc060c"></a>Agc060c</h3><blockquote><p>对所有的 $p_{2^n-1}$, 要求满足 $P_i&lt;P_{2i}, P_i&lt;P_{2i+1}$ 中, 给定 $a, b$, 求随机一个满足条件的排列 $P_{u&#x3D;2^a}&gt;P_{v&#x3D;2^{b+1}-1}$ 的概率.<br>$n\le 5000$</p></blockquote><p>$u, v$ 分别是 $a, b$ 层最左边和最右边的点.</p><p>考虑总数:</p><p>[trick] $n! \times \prod_i \dfrac{1}{siz_i}$</p><p>可以直接考虑从上到下对于每个子树根是其最小值.</p><p>考虑对最左链和最右链归并, 树的形态变成一条链, 链除了第一个(根)和两条链的末尾以外每个点都挂了一个子树, 于是问题就变成了最后一个点是左边的还是右边的.</p><p>然后直接对这条链dp, 每个子树的方案数已经确定, $f_{i, j, 0&#x2F;1}$ 表示前 $i$ 个点, 选了 $j$ 个左边的点, 最后一个是左边&#x2F;右边的方案数.</p><h3 id="Agc060d"><a href="#Agc060d" class="headerlink" title="Agc060d"></a>Agc060d</h3><blockquote><p>给定 $n$, 求有多少个排列对 $p, q$, 满足对于每个 $i$, $p_i, q_i$ 分别大于或分别小于 $p_{i+1}, q_{i+1}$.<br>$n\le 2\times 10^5$</p></blockquote><p>考虑枚举一个大于号集合 $S$, 方案数变成</p><p>$$<br>\begin{aligned}<br>  &amp;\sum_S (\text{大于号集合为S的方案数})^2\<br>  &#x3D;&amp;\sum_S (\sum_{T\supseteq S}(-1)^{\vert T\vert-\vert S\vert}\text{大于号集合}\supseteq \text{T个数})^2&amp;&amp;\text{子集反演}\<br>  &#x3D;&amp;\sum_S \sum_{T_1, T_2, S\subseteq T_1, T_2} (-1)^{\vert T_1\vert +\vert T_2\vert }(\text{大于号集合} \supseteq  T_1)(\text{大于号集合}\supseteq T_2)\</p><p>  &#x3D;&amp;\sum_{T_1, T_2} (-1)^{\vert T_1\vert+\vert T_2\vert}(\text{大于号集合}\supseteq T_1)(\text{大于号集合}\supseteq T_2)\times 2^{T_1\cap T_2}&amp;&amp;\text{传统艺能交换求和号干掉S}\<br>\end{aligned}<br>$$</p><p>其中, $T_1\cap T_2&#x3D;T_1+T_2-T_1\cup T_2&#x3D;T_1+T_2-(n-1)+(T_1, T_2\text{同时不包含的元素个数}$), 而最后一部分的意思就是两个序列再某个位置都不是大于号.</p><p>而考虑到, 大于号集合包含于 $T$ 的个数可以看成, 被钦定的大于号连成若干个递减段, 假设长度是 $l_1\ldots l_k$, 那就是 $\dfrac{n! }{\prod_i l_i! }$(每一段内部递减).</p><p>于是式子变成了</p><p>$$<br>2^{-n+1}\sum_{T_1, T_2}((-2)^{T_1}\dfrac{n! }{\prod l_{1, i}! })((-2)^{T_2}\dfrac{n! }{\prod l_{2, i}! })\times 2^{T_1, T_2\text{同时不包含的个数}}<br>$$</p><p>现在只有最后一小部分不独立, 考虑同时不包含, 也就是同时为小于, 把序列分成若干段, 每一段独立.</p><p>把每一段的贡献记作 $2[x^{len}]F(x)&#x3D;\sum_{T_1, T_2}2((-2)^{T_1}\dfrac{1}{\prod l_{1, i}! })((-2)^{T_2}\dfrac{1}{\prod l_{2, i}! })$, 最后乘一个 $\dfrac{1}{2}$, 就消掉了最后那个不独立的项. 答案就成了 $2^{-n+1}(n! )^2\dfrac{1}{2}\dfrac{1}{1-2F}$</p><p>于是只要考虑求 $F$, 这个 $F$ 要求不能有某个位置 $T_1, T_2$ 同时为小于, 考虑忽略这个限制的生成函数 $G$, 那么因为此时 $T_1, T_2$ 独立, $[x^k]G(x)&#x3D;(\sum_T (-2)^T \dfrac{1}{\prod l_i})^2$, 再按照分成若干个连续的大于号段, 长 $i$ 的段贡献 $-\dfrac{1}{2}\dfrac{x^i}{i! }$, 所以一段就是 $-\dfrac{1}{2}e^x$, $G$ 就是把这些段卷起来, 然后 $x^i$ 再乘上 $(-2)^{i+1}$, 再把每个系数平方.</p><p>然后要求 $F$, 发现一个 $G$ 可以在第一个同时为小于的地方断出一个 $F$, 而后面可以是一个 $G$ 或者什么都没有, 于是 $G&#x3D;F(G+1)$, 就可以根据 $G$ 求个逆求 $F$ 了.</p><p>于是就做完了.</p><h3 id="Agc059c"><a href="#Agc059c" class="headerlink" title="Agc059c"></a>Agc059c</h3><p>实际上等价于每个三元组 $(x, y, z)$, 最后问 $x, z$, 满足 $y$ 是三者之间的最大值或最小值.</p><p>以二元组 $(x, y, &lt;&#x2F;&gt;)$ 作为点表示 $x&lt;y$, $x&gt;y$, 对每个三元组在其中连边. 这样形成若干个连通块, 每个连通块内相互等价, 然后就二的(连通块个数&#x2F;2)次方, 无解当 $(x, y, &gt;)$ 和 $(x, y, &lt;)$ 等价.</p><h3 id="Agc054c"><a href="#Agc054c" class="headerlink" title="Agc054c"></a>Agc054c</h3><p>考虑 $P$ 变成 $P’$ 的过程, 我们一定可以找到一个位置 $i$ 满足有大于 $k$ 个大于 $P_{i+1}$ 且 $P_i&gt;P_{i+1}$, 然后进行一次, 于是最小次数就是 $\sum_i \max(0, x_i-k)$, 所以最后的排列和交换过程都是唯一的.</p><p>于是, 如果一个元素前只有小于 $k$ 个大于它的则它一定没有被swap过.</p><p>考虑所有等于 $k$ 的, 递增的子序列, 它可以放在以后的任意一个位置, 因为这些元素的后面的元素必然都大于它.</p><p>于是直接拿着个算答案即可.</p><h3 id="Agc043d"><a href="#Agc043d" class="headerlink" title="Agc043d"></a>Agc043d</h3><p>若最终排列中有 $p_i&gt;p_{i+1}$, 显然这两个元素一开始在同一个块里.</p><p>于是用前缀max划分这个序列成若干段, 要求每一段长度不超过3.</p><p>于是长度为 $2$ 的段的个数要小于等于长度为 $1$ 的, 不然无法都凑成长度为 $1$ 的段.</p><p>发现充要了.</p><p>然后用这个计数, 枚举长 $1$ 和长 $2$ 的个数 $n_1, n_2$, 得到 $n_3$, 答案就是</p><p>$$<br>\dfrac{(3n)! }{(3! )^{n_3}(2! )^{n_2}(1! )^{n_1}}2^{n_3}<br>$$</p><p>或者直接dp</p><h3 id="Agc039e"><a href="#Agc039e" class="headerlink" title="Agc039e"></a>Agc039e</h3><p>注意如果有一个X, 则X的对边不能连线.</p><p>于是对于一个连线 $a\to b$, 只有恰好一个点可以连出这个区间 $a, b$.</p><p>于是 $f_{l, r, x}$ 表示 $[l, r]$ 中只有 $x$ 连出了这个区间.</p><p>转移就是, 枚举一条跨过 $x$ 的边 $i\to j$, 其中 $j$ 是最后一个有跨过 $x$ 边的点, 它和 $x$ 的边形成一个X, 然后一定存在 $i, x$ 和 $x, j$ 中间的两个点 $p, q$ 将整个 $[l, r]$ 分成三段, 三段内部自己匹配, 于是就可以从 $f_{l, p, i}, f_{p, q, x}, f_{q, r, j}$ 转移</p><h3 id="Agc036f"><a href="#Agc036f" class="headerlink" title="Agc036f"></a>Agc036f</h3><p>如果把 $(i, p_i)$ 画出来, 相当于选距离原点大于 $n$, 小于 $2n$ 的点, 也就是两个圆之间, 并要求每一列, 每一行恰好放一个.</p><p>然后考虑如果只有上界, 也就是外面的圆, 问题是好做的: 把所有上界 $a_n$ 递增排序, 答案就是 $\prod_i a_i-i+1$.</p><p>于是容斥下界, 枚举容斥集合大小 $k$, 那么现在要求左边的 $n$ 列中有 $k$ 个上界为小圆 $b_i$, 剩下的其他 $2n-k$ 列上界为大圆 $a_i$ 的方案数, 考虑从下往上按上界(如果有小圆, 看小圆上界)从小到大dp, $f_{i, j}$ 表示dp了前 $i$ 列, 其中有 $j$ 列是容斥集合中的, 直接转移即可. 复杂度 $n^3$</p><h3 id="Agc035e"><a href="#Agc035e" class="headerlink" title="Agc035e"></a>Agc035e</h3><blockquote><p>在黑板上写有 $-10^{18}$ 到 $10^{18}$ 中的所有整数, 每次你可以选中一个 $[ 1 , N]$ 中还在黑板上的整数 $x$, 把它擦去并补写上 $x − 2$ 与 $x + c$(如果原来不存在的话). 你可以进行这个操作任意次(可以不进行), 求最终黑板上数字的可能状态有多少种, 答案对 $M$ 取模.</p><p>$1\leq c \leq N \leq 150 , 10^8\leq M\leq 10^9$</p></blockquote><p>首先肯定是转化成删掉的集合有多少种.</p><p>然后考虑一个集合什么情况下可以被删掉, 若建图, $i\to i-2, i\to i+c$, 则一个集合可以被删掉当且仅当导出子图无环(显然).</p><p>考虑如果 $c$ 是偶数, 那么奇偶独立, 显然对于奇偶分别做无环就是不能选长 $\dfrac{c}{2}$ 的连续段, 其他任意的方案数. 可以简单dp.</p><p>而如果是奇数, 发现此时这个环一定是先 $-2$, 再 $+c$, 再 $-2$, 再 $+c$ 成环, 其中恰好包含两个 $+c$. 考虑从小到大dp的过程中如何判断出环, 如果 $i$ 进行 $-2$, $+c$, $-2$ 后跳到的位置小于等于 $i+1-c$, 那状态不合法, 于是记录这个跳到的位置 $j$, 再记录一个 $i-1$ 这么跳到的位置 $k$, 这个 $j$ 和 $k$ 同时表示如果 $i&#x2F;i-1$ 不能跳到一个可以 $+c$ 后仍然小于 $i&#x2F;i-1$ 的位置, 那么就是光减2能到的位置.</p><p>另一个理解方式是把奇数偶数排成两条竖向下的链, 其中 $i$ 和 $i+c$ 对齐为同一层, 那么注意到环的长度一定是 $c+2$, 于是 $i$ 记录 $+2, -c, +2$ 后的长度 $j$, 以及偶数列向上连续选了多长 $k$, 状态合法当且仅当 $j&lt;c$.</p><p>复杂度都是 $n^3$ 的.</p><h3 id="Agc035d"><a href="#Agc035d" class="headerlink" title="Agc035d"></a>Agc035d</h3><p>设 $f_{l, r, x, y}$ 表示删掉 $l+1\ldots r-1$, 使得结束后 $xa_l+ya_r$ 最小.</p><p>转移就是枚举中间的数, $f_{l, r, x, y}&#x3D;f_{l, p, x, x+y}+dp_{p, r, x+y, x}+(x+y)a_p$, 复杂度是 $2^npoly(n)$</p><h3 id="Agc034f"><a href="#Agc034f" class="headerlink" title="Agc034f"></a>Agc034f</h3><p>dp表示成集合幂级数, 然后FWT多项式科技解出来</p><p>todo</p><h3 id="Agc032e"><a href="#Agc032e" class="headerlink" title="Agc032e"></a>Agc032e</h3><p>当一个0变成1的时候, 其左右一定恰好一个0一个1</p><p>于是, 实际上翻转01只是移动01的分界线, 而起始处和结尾处存着一堆分界线.</p><p>容易发现两个局面就是给分界线匹配然后对应移动过去.</p><p>因为本质不同的匹配分界线的方案数只有 $O(n)$ 种, 再加上计算代价, 复杂度就是 $n^2$ 了.</p><h3 id="某CTT题"><a href="#某CTT题" class="headerlink" title="某CTT题"></a>某CTT题</h3><p><img src="/img/2023-01-01-14-37-20-image.png" alt="picture 3">  </p><p>dp+高斯消元, 设 $f_u(x)$ 表示当前在 $u$, 当前权值是 $x$, 到 $u$ 的期望权值是多少, 归纳发现 $f$ 是一次函数, 同理得到平方的期望的 $f$ 是一个二次函数, 于是列出递推式高斯消元.</p><h3 id="另一个CTT题"><a href="#另一个CTT题" class="headerlink" title="另一个CTT题"></a>另一个CTT题</h3><p><img src="/img/2023-01-01-15-00-39-image.png" alt="picture 4">  </p><p>todo</p><h3 id="qoj5169"><a href="#qoj5169" class="headerlink" title="qoj5169"></a>qoj5169</h3><p>预处理在第 $i$ 家店花 $j$ 元钱的方式, 为 $[x^j]F_i(x)$, 这个就是每个娃娃机的卷起来, 也就是</p><p>$$<br>\prod_k \dfrac{1-x^{(c_{i, j}+1)b_{i, j}}}{1-x}<br>$$</p><p>卷起来即可.</p><p>于是在某一家店至少花 $k$ 元就要截取 $F$ 的一部分算.</p><p>每次询问卷积过于困难, 考虑点值.</p><p>todo</p><h3 id="qoj5089"><a href="#qoj5089" class="headerlink" title="qoj5089"></a>qoj5089</h3><p>可以环覆盖的意思是每个点度数是偶数.</p><p>假设把所有点度数奇偶性状压成一个数, 则选一条边就是异或上 $2^x+2^y$.</p><p>todo</p><h3 id="qoj5097"><a href="#qoj5097" class="headerlink" title="qoj5097"></a>qoj5097</h3><p>todo</p><h2 id="Day3-模拟"><a href="#Day3-模拟" class="headerlink" title="Day3 模拟"></a>Day3 模拟</h2><h3 id="A计算几何科技"><a href="#A计算几何科技" class="headerlink" title="A计算几何科技"></a>A计算几何科技</h3><blockquote><p>平面上有 $n$ 个互不相交的矩形, 求是否存在一条直线与所有矩形相交.<br>$n\le 2\times 10^5$</p></blockquote><p>特判斜率为 $0$ 的情况, 考虑如果斜率为正, 那么直线一定把矩形的左上端点和右下端点分开了, 于是对每个矩形的左上, 右下分别求凸包判断两凸包是否有交即可.</p><p>另一个做法是考虑直线 $y&#x3D;kx+b$, 对 $k$ 正负讨论之后, 可以根据每个矩形列出 $b$ 关于 $k$ 的不等式, 然后用ZJOI射箭的方法用半平面交解.</p><h3 id="B图论科技"><a href="#B图论科技" class="headerlink" title="B图论科技"></a>B图论科技</h3><blockquote><p>给定平面上 $n$ 个黑点和 $n$ 个白点, 你需要将其两两匹配, 使得曼哈顿距离和最大.</p></blockquote><p>把曼哈顿距离转化成切比雪夫距离, 把绝对值展开成 $\max$ 并拆开嵌套的 $\max$, 对于白点 $i$ 和黑点 $j$, 距离变成了 $\max(x_i-x_j, y_i-y_j, x_j-x_i, y_j-y_i)$ 四种. 因为是最大化的情况下拆开, 所以实质上是为每一个匹配任意选择这四种贡献方式中的一种, 再拆开就是为每个点任意选择四种贡献方式的一种, 并要求贡献 $x_i$ 的白点和贡献 $-x_j$ 的黑点数量, 和其他数量同理对应相同.</p><p>此时一个容易想到的做法是费用流, 结构是源点-白点-代表四种贡献的四个点-黑点-汇点, 就满足了这个条件.</p><p>于是想到模拟费用流, 那么一条增广路就是源点开始到某个颜色的点, 某个颜色的点经过黑点&#x2F;白点到另一个颜色的点, 某个颜色的点到汇点三部分, 因为增广路不会走环, 于是路径只有 $poly(4)&#x3D;O(1)$ 种, 直接对刚才增广路的三个部分分别开set动态维护, 复杂度是 $n\log n$</p><h3 id="C字符串科技"><a href="#C字符串科技" class="headerlink" title="C字符串科技"></a>C字符串科技</h3><p>todo</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2022/11/15/graph/"/>
      <url>/2022/11/15/graph/</url>
      
        <content type="html"><![CDATA[<h1 id="图论选做"><a href="#图论选做" class="headerlink" title="图论选做"></a>图论选做</h1><p>先开个坑.</p><h3 id="CF1687B-Railway-System-mst-kru"><a href="#CF1687B-Railway-System-mst-kru" class="headerlink" title="CF1687B Railway System [mst] [kru]"></a>CF1687B Railway System [mst] [kru]</h3><blockquote><p>有一张图 $Graph(n, m)$ , 现在给定 $n, m$ , 要求你通过 $2m$ 次询问一个边集的最大生成树森林权值和, 得到整张图的最小生成树森林权值和.</p><p>$n\le 200, m\le 500$</p></blockquote><p>最小生成树题基本模拟Kru或Br, 随便想想就知道不会是Br, 所以考虑Kru.</p><p>考虑从小往大加边, 那么一条边是否加入就直接判断已经得到的边集再加上这条边的最大生成树森林是不是原来的值加上这条边的边权, 如果是就加上, 否则说明它把另一条边顶下去了. 于是就先 $m$ 次问每一条的边权, 再 $m$ 次加边即可.</p><p>很套路.</p><h3 id="Gym102331F-Fast-Spanning-Tree"><a href="#Gym102331F-Fast-Spanning-Tree" class="headerlink" title="Gym102331F Fast Spanning Tree"></a>Gym102331F Fast Spanning Tree</h3><blockquote><p>给定 $n$ 点树, 点有点权边有边权, 用Kru求mst, 但每次是选择所有两端点不在同一个连通块中, 编号最小, 且两个连通块的点权和之和大于边权, 按顺序输出选择的边.</p><p>$n, m\le 3\times 10^5$</p></blockquote><p>考虑如果限制是, 两边任意一个连通块的和大于边权的做法, 可以每个连通块开数据结构维护出边, 启发式合并, 并且在外面再开一个堆维护所有满足条件的边, 复杂度2log.</p><p>然后用这个规约就行了, 若 $a+b&gt;c$, 则 $\min(a, b)\ge \dfrac{c}{2}$, 等这个满足之后, 把这条边删了, 并求出此时的 $a, b$, 现在还需要两个的大小加起来大于 $c-a-b$, 就成功的把问题减了一半, 递归下去即可.</p><p>因为一条边删了才加下一个, 所以实际上这个不会多log, 还是2log.</p><p>[trick] 这个不是我们减半警报器吗.</p><h3 id="CF888G-Xor-MST"><a href="#CF888G-Xor-MST" class="headerlink" title="CF888G Xor-MST"></a>CF888G Xor-MST</h3><blockquote><p>$n$ 个点, 两点边权位点权异或, 求 MST.</p></blockquote><p>注意到两个元素在 $01$ trie上的 $lca$ 的深度就是异或后最高位位置, 于是01trie相当于一个类似kruskal重构树的东西, 那么就直接自底向上合并即可, dfs, 找一个点两个儿子的子树中最小的异或对, 启发式合并即可. 复杂度最后是 $n\log n\log V$ </p><h3 id="ARC069F-Flags"><a href="#ARC069F-Flags" class="headerlink" title="[ARC069F] Flags"></a>[ARC069F] Flags</h3><blockquote><p>Snuke 将 $n$ 个标志放在一条线上.</p><p>第 $i$ 个标志可以放置在坐标 $x_i$ 或坐标 $y_i$ 上.</p><p>Snuke 认为当他们中的两个之间的最小距离 $d$ 更大时, 标志看起来更好. 找出 $d$ 的最大可能值.</p><p>$n\le 10^4$</p></blockquote><p>考虑一个暴力是二分之后2-sat. 但直接连边会寄, 但2sat也可以线段树优化建图.</p><h3 id="ABC282Ex-Min-Sum"><a href="#ABC282Ex-Min-Sum" class="headerlink" title="[ABC282Ex] Min + Sum"></a>[ABC282Ex] Min + Sum</h3><blockquote><p>给定序列 $A, B$, 求有多少对 $(l, r)$ 满足 $1\le l\le r\le n$, 且<br>$$<br>\sum_{i&#x3D;l}^rB_i+\min_{i&#x3D;l}^rA_i\le S<br>$$</p></blockquote><p>首先这题扫描线加分块毫无思维含量.</p><p>有意思的是序列分治做法和对最小值分治做法. 最小值分治重点是贡献只枚举一边在另一边二分, 感觉很棒.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prufer序列与Caylay定理</title>
      <link href="/2022/11/02/caylay/"/>
      <url>/2022/11/02/caylay/</url>
      
        <content type="html"><![CDATA[<p>做ZR题触及了知识盲区()</p><h1 id="Prufer序列与Caylay定理"><a href="#Prufer序列与Caylay定理" class="headerlink" title="Prufer序列与Caylay定理"></a>Prufer序列与Caylay定理</h1><p>不特殊说明均指<strong>有标号无根树</strong>.</p><h2 id="Prufer序列"><a href="#Prufer序列" class="headerlink" title="Prufer序列"></a>Prufer序列</h2><p>对于一个<strong>有标号无根树</strong>, 其prufer序列是, 每次删掉一个编号最小的叶子, 然后在序列上<code>push_back</code>这个叶子连向的点, 直到只有两个点.</p><p>于是Prufer序列的特征<del>(不好意思叫性质)</del>:</p><ul><li>长度是 $n-2$ .</li><li>最后留下的两个点中一个是Prufer序列上最后一个点, 另一个是 $n$ .</li><li>每个点出现次数为度数-1.</li></ul><p>于是发现显然可以直接对着序列重建树, 倒着做就行, 所以它是有标号无根树与序列的双射.</p><h2 id="Caylay定理"><a href="#Caylay定理" class="headerlink" title="Caylay定理"></a>Caylay定理</h2><h3 id="1-n-个点构成的树的方案数为-n-n-2"><a href="#1-n-个点构成的树的方案数为-n-n-2" class="headerlink" title="1. $n$ 个点构成的树的方案数为 $n^{n-2}$ ."></a>1. $n$ 个点构成的树的方案数为 $n^{n-2}$ .</h3><p>Prufer序列, 每个位置是在 $1\ldots n$ 中, 长 $n-2$ .</p><h3 id="2-n-个点-和指定的-k-个点-做出-k-棵树的森林使得-k-个点都不在同一棵树立的方案树为-kn-n-k-1"><a href="#2-n-个点-和指定的-k-个点-做出-k-棵树的森林使得-k-个点都不在同一棵树立的方案树为-kn-n-k-1" class="headerlink" title="2. $n$ 个点, 和指定的 $k$ 个点, 做出 $k$ 棵树的森林使得 $k$ 个点都不在同一棵树立的方案树为 $kn^{n-k-1}$ ."></a>2. $n$ 个点, 和指定的 $k$ 个点, 做出 $k$ 棵树的森林使得 $k$ 个点都不在同一棵树立的方案树为 $kn^{n-k-1}$ .</h3><p>考虑不指定这 $k$ 个点, 而是直接算最后除以 $\binom{n}{k}$ , 那么为了保证每一个 $k$ 子集只被算了一次, 钦定这 $k$ 个点为其所在生成树的根, 那么因为我们只会算一棵树的所以钦定 $0$ 为全局的根, $0$ 向其他所有根连边, 于是我们就要求prufer序列满足其中出现了 $k-1$ 个0, 方案数就是 $\binom{n-1}{k-1}\times n^{n-k}$ , 再除以 $\binom{n}{k}$ 即可.</p><h3 id="3-Graph-n-m-有-K-个连通块-要添加-k-1-条边使得其连通的方案数"><a href="#3-Graph-n-m-有-K-个连通块-要添加-k-1-条边使得其连通的方案数" class="headerlink" title="3. $Graph(n, m)$ 有 $K$ 个连通块, 要添加 $k-1$ 条边使得其连通的方案数."></a>3. $Graph(n, m)$ 有 $K$ 个连通块, 要添加 $k-1$ 条边使得其连通的方案数.</h3><p>$n^{k-2}\times \prod_{i&#x3D;1, k} s_i$ , 其中 $s_i$ 表示第 $i$ 个连通块的大小.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZROI2022NOIP20连测</title>
      <link href="/2022/10/24/zroi20/"/>
      <url>/2022/10/24/zroi20/</url>
      
        <content type="html"><![CDATA[<h1 id="ZROI2022"><a href="#ZROI2022" class="headerlink" title="ZROI2022"></a>ZROI2022</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="22冲刺day1-匹配"><a href="#22冲刺day1-匹配" class="headerlink" title="22冲刺day1-匹配"></a>22冲刺day1-匹配</h3><blockquote><p>给定 $n$ 个区间 $[l_i, r_i]$ , 两个区间之间的贡献是 $\max \vert a-b\vert , \ s. t. \ a\in [l_i, r_i], b\in [l_j, r_j]$ , 求把区间两两配对, 最大化贡献和.</p><p>$n\le 10^6, l_i, r_i\le 10^9$</p></blockquote><p>[trick] $\vert x-y\vert &#x3D;\max x-y, y-x$</p><p>[think]<strong>见到绝对值想拆贡献</strong></p><p>绝对值都拆开, 每个区间的贡献一定是最大值 $ma$ 或最小值 $-mn$, 那么先全选最大值减去最小的 $\dfrac{n}{2}$ 个 $ma+mn$.</p><h3 id="22冲刺day1-狼人"><a href="#22冲刺day1-狼人" class="headerlink" title="22冲刺day1-狼人"></a>22冲刺day1-狼人</h3><blockquote><p>给定一个 $n$ 个点的树, 点有颜色 $c_i$ , 求有多少个连通块有绝对众数, 绝对众数指出现次数大于一半的数.<br>$n\le 3000, c_i\le n$ , 膜998244353</p></blockquote><p>考虑一个连通块显然最多被一个颜色贡献. 那么对每个颜色计算连通块个数.</p><p>把当前颜色看成1, 其他颜色看成-1, 则相当于求有多少个和大于0的连通块, 这个问题直接dp, 设 $f_{u, s}$ 表示 $u$ 为根, 和为 $s$ 的连通块个数, 转移是树上背包, 于是这个可以用树上背包那个优化, 子树大小为 $a$ 的只保留 $\pm siz$ 的, 可以把树上背包优化到 $n^2$ , 但总复杂度是 $n^3$ .</p><p>不会了, 看题解, 思路完全一样, 除了说复杂度是 $n^2$ 的.</p><p>咋回事呢? 实际上每个节点的状态数是 $\min (siz, cnt)$ , 并且 $\sum cnt&#x3D;n$ , 考虑多叉树转二叉树简化分析, 那么于是对于一个 $k&#x3D;cnt$ , 考虑其所有极小的 $siz$ 大于 $k$ 的点(自己的两个儿子大小都小于 $k$ ), 那么这样的节点只有 $\dfrac{n}{k}$ 个, 每个节点内部代价可以视为 $k^2$ , 而上面以这些点为叶子的二叉树只会合并 $2\dfrac{n}{k}$ 次(因为二叉树叶子个数为 $\dfrac{n}{k}$ ), 于是复杂度成了 $\dfrac{n}{k}\times k^2+{\dfrac{n}{k}}k^2&#x3D;nk$ , 然后因为总和是 $n$ 所以复杂度是 $n^2$ .</p><h3 id="22冲刺day1-旅行"><a href="#22冲刺day1-旅行" class="headerlink" title="22冲刺day1-旅行"></a>22冲刺day1-旅行</h3><blockquote><p>数轴上有 $n$ 个点, 点 $i$ 出发可以到达 $[i+1, i+t_i]$ 的点, 对每个位置 $p$ , 求 $p$ 到 $n$ 的路径的最大权值, 权值为经过所有点的权值 $h_i$ 和减去移动的代价之和, 从 $i$ 出发到 $j$ 的代价是 $\lfloor \dfrac{j-i}{K} \rfloor\times D$ .<br>$n\le 2\times 10^6$</p></blockquote><p>考虑这个看起来直接dp, $f_i$ 表示点 $i$ 到最后的代价, 有</p><p>$$<br>f_i&#x3D;\max f_j-\lfloor \dfrac{j-i}{K} \rfloor\times D +h_i<br>$$</p><p>主要问题是下取整, 因为 $\lfloor \dfrac{j-i}{K} \rfloor&#x3D;\lfloor j \rfloor - \lfloor i \rfloor-[j\bmod K &lt; i\bmod K]$ , 所以可以对每个 $j\bmod K$ 分类, 每次可以转移到 $i$ 的是一个前缀, 所以现在已经变成单点加矩形max, 可以用树套树2log, 一层存 $i\bmod k$ , 一层存 $\lfloor \dfrac{i}{K} \rfloor$ 即可.</p><p>考虑当 $\lfloor \dfrac{i}{K} \rfloor&#x3D;\lfloor \dfrac{j}{K}\rfloor$ 时一定不需要减1, 所以把序列分成若干大小为 $k$ 的块, 在计算一块内的时候不需要插入, 等到一块结束后, 可以先直接算出本块内的前缀min, 然后再插入到矩形中. 单点插入从原来单点给出, 变成一次给出一行, 那么可以直接算出这一行的前缀max之后做了.</p><h3 id="22冲刺day1-密码"><a href="#22冲刺day1-密码" class="headerlink" title="22冲刺day1-密码"></a>22冲刺day1-密码</h3><blockquote><p>给定正整数 $K$ . 请构造两个 $01$ 串 $S, T$ , 使得它们有恰好 $K$ 个本质不同的最长公共子序列.</p><p>我们额外给定参数 $L$ , 只有你构造的串满足 $max(\vert S\vert , \vert T\vert)\le L$ 时才能得分.<br>$L\ge 1000, K\le 10^5$</p></blockquote><p>见鬼构造题.</p><p>考虑我们假设构造出来的有一个明显的循环节, 然后发现真的是, 在这个基础上进行调整.</p><p>[think] 限制不过强的时候自己钦定一个强性质结论</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="22冲刺day2-Relax"><a href="#22冲刺day2-Relax" class="headerlink" title="22冲刺day2-Relax"></a>22冲刺day2-Relax</h3><blockquote><p>每天有 $h$ 小时, 每小时有 $m$ 分钟, 求有多长时间分钟数大于等于小时数.<br>$h, m\le 10^9$</p></blockquote><p>智障题.</p><h3 id="22冲刺day2-Permutation"><a href="#22冲刺day2-Permutation" class="headerlink" title="22冲刺day2-Permutation"></a>22冲刺day2-Permutation</h3><blockquote><p>Cuber QQ 会给你一个 1, 2, 3, ⋯, n 的全排列, 现在他要求你选出尽可能多的数, 并对选出的这些数重新排序, 使得任意两个相邻的数的最大公约数大于等于 2 .</p><p>$4\le n\le 10^6$</p></blockquote><p>大于 $\dfrac{n}{2}$ 的质数显然放不进去, 大于 $\dfrac{n}{3}$ 的显然只能头和尾各放两个.</p><p>直接硬构造, 先放一堆2, 4, 6, 8, 那么所有小于 $\dfrac{n}{4}$ 的都可以放进去了(前面一个 $2p$ , 后面一个 $4p$ , 中间放所有 $kp$ ),</p><p>一开始以为 $[\dfrac{n}{4}, \dfrac{n}{3}]$ 的不行, 但实际也是可以的, 前面一个 $2p$ , 后面一个 $3p$ 即可. 于是</p><p>结果是<br>$$</p><p>P_0, 2P_0, 6, (2p_0, p_0, 4p_0, 5p_0\ldots 3p_0), (3p_1, p_1, 4p_1\ldots 2p_1), (2p_2\ldots), (3p_3\ldots)\ldots 12 2P_1, P_1<br>$$</p><p>其中, $P$ 是大于 $\dfrac{n}{3}$ 的质数, $p$ 是小于 $\dfrac{n}{3}$ 的质数, 发现这样可以把所有 $p$ 都放上所以是无敌的.</p><h3 id="22冲刺day2-Hotel"><a href="#22冲刺day2-Hotel" class="headerlink" title="22冲刺day2-Hotel"></a>22冲刺day2-Hotel</h3><blockquote><p>无限旅馆的故事(一个旅馆有无限个房间, 来有限个人就让所有人往后挪腾出前几个, 来无限个人就让所有人到编号二倍的位置), 现在 $q$ 次:</p><ul><li>新加入 $k$ 个 $c_i$ 国人(或无限个).</li><li>询问位置 $i$ 的人是哪国的.</li><li>询问住着 $i$ 国人的编号最小的房间是哪个.</li></ul><p>$q\le 3\times 10^5$</p></blockquote><p>一开始试图把每次插入的位置看作一个一次函数, 但走不通(没法做询问2, 并且有限多的人做不了)</p><p>考虑无限是特殊的, 那就每次插入一个无限就分一段, 现在每一段前面是插入若干有限的, 后面跟了一个无限.</p><p>那么考虑查询位置 $i$ 的颜色, 判断是不是开头的有限的, 如果不是的话通过位置奇偶性看出是不是这次插入的无限的, 如果不是, 那就是上次乘2到部分, 就可以把编号除以2继续找, 单次询问 $\log n$ .</p><p>[think] 发现难办的操作很多, 但影响当前位置的难办的操作只有 $\log n$ 个. 更多的操作已经失去影响.</p><h3 id="22冲刺day2-Tree"><a href="#22冲刺day2-Tree" class="headerlink" title="22冲刺day2-Tree"></a>22冲刺day2-Tree</h3><blockquote><p>给定树 $T_1&#x3D;Tree(n), T_2&#x3D;Tree(n)$ , 边有边权, 设 $dis(T, u, v)$ 表示 $u$ 和 $v$ 在 $T$ 上的距离, 对每个 $i$ 求 $\min_j dis(T_1, i, j)+dis(T_2, i, j)$ 的 $j$ .</p><p>$n\le 10^5, w_i\le 10^9$</p></blockquote><p>在两棵树上同时建点分树, 枚举一个点在两棵点分树上的 $\log^2$ 个祖先.</p><p>对于一个祖先对, 只要最小化 $j$ 到祖先的深度在两棵树上的和即可. 这个似乎需要 $O(1)$ 算了, 注意要踢出掉祖先的一个子树, 预处理子树前缀 $\min$ 和后缀 $\min$ 即可.</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="22冲刺day3-数字和"><a href="#22冲刺day3-数字和" class="headerlink" title="22冲刺day3-数字和"></a>22冲刺day3-数字和</h3><blockquote><p>大王给了小王一个长度为 $n$ 的序列 $a_1, a_2, \cdots, a_n$ , 对于序列中的每个元素 $a_i$ , 大王想知道在所有包含 $a_i$ 的子区间中求最大的子区间元素和.</p><p>$n\le 2\times 10^5$</p></blockquote><p>预处理每个位置开始的前后缀max.</p><h3 id="22冲刺day3-走迷宫"><a href="#22冲刺day3-走迷宫" class="headerlink" title="22冲刺day3-走迷宫"></a>22冲刺day3-走迷宫</h3><blockquote><p>大小双王在闯迷宫, 尽快熟悉迷宫是一件很重要的事. 大王想知道迷宫中有多少条通关的路径.</p><p>迷宫是一个 $n \times m$ 的网格, 每个格子里面有一个数字. 一条通关的路径是满足以下条件的路径:</p><ol><li>大小双王只能走上下左右4个方向的相邻格子;</li><li>大小双王只能走相邻数字比当前格子大2的格子;</li><li>大小双王走的路径长度(走过的格子个数)必须至少为4;</li><li>如果周围存在还能继续走的格子, 大小双王只能继续走;</li><li>起点周围不存在比它恰好小2的格子.</li></ol><p>$n, m\le 1000, \vert v\vert \le 10^6$</p></blockquote><p>第4条和第5条规定了路径是极长的, 第3条可以忽略, 因为单独数长度为4的可以随便做.</p><p>那么考虑如何计数极长路径, 直接 $f_{i, j}$ 表示走到 ${i, j}$ 的方案数即可. 是智障题.</p><p>对了, 可以不忽略第三条, 每个点存长度为1, 2, 3, 4即可, 复杂度不变.</p><h3 id="22冲刺day3-多米诺"><a href="#22冲刺day3-多米诺" class="headerlink" title="22冲刺day3-多米诺"></a>22冲刺day3-多米诺</h3><blockquote><p>大小双王对于多米诺有独特的理解.</p><p>现在有一个 $n \times m$ 的格子大小的木板, 大王想用 $1 \times 2$ 的多米诺骨牌把格子填满. 大王不满足于普通的填法, 大王还想让每个格点都不能被 $4$ 个多米诺骨牌顶点覆盖.</p><p>大小双王想问你有多少个方案把他们填满呢. 如果答案太大, 对 $998244353$ 取模.</p><p>$n, m\le 10^7$</p></blockquote><p>好困难啊, 而且极难用语言描述. . .</p><p>基本思路是分析骨牌的性质, 限制使得我们相当于用<br><img src="/img/2022-10-27-22-04-12-image.png" alt="picture 2"><br><img src="/img/2022-10-27-22-04-24-image.png" alt="picture 4"></p><p>两个图形来拼, 那么考虑边框是最不自由的位置, 看边框的拼法:</p><p><img src="/img/2022-10-27-22-05-48-image.png" alt="picture 5"></p><p>手动补全, 发现只要确定了边框一定能补出一个矩形, 而关键是, 当我们拓展边框的时候, 发现它无论如何都填不满, 于是得到结论, $n\times m$ 的矩形是由若干 $n\times k$ 的矩形拼成的.</p><p><img src="/img/2022-10-27-22-07-53-image.png" alt="picture 6"></p><p>于是对 $n$ 分奇数, 偶数讨论, 结论如下:</p><p><img src="/img/2022-10-27-22-10-47-image.png" alt="picture 7"></p><p>重点是通过分析性质发现它其实是一维问题的这一步.</p><h3 id="22冲刺day3-等差数列"><a href="#22冲刺day3-等差数列" class="headerlink" title="22冲刺day3-等差数列"></a>22冲刺day3-等差数列</h3><blockquote><p>给定数列 $a_n$ , 每次可以把一个数加2或减1, 求最少几次满足存在整数 $d$ 满足 $i\in [2, n], a_i-a_{i-1}&#x3D;d$ 的 $i$ 至少有 $n-2$ 个.<br>$n\le 10^5, a_i\le 5\times 10^5$</p></blockquote><p>条件相当于把序列变成两段公差相同的等差数列(看成三段了)</p><p>然后对于单独一段等差数列, 确定了斜率 $d$ 之后, 画出一条斜线, 如果都是 $+1$ 应该是直线经过所有点的截距的中位数, 有加2之后设每个点截距为 $c$ , 真实截距为 $x$ , 贡献是 $\sum_{c_i&lt;x} \lfloor \dfrac{x-c_i}{2} \rfloor +2[(x-c_i)\bmod 2&#x3D;1]+\sum_{c_i&gt;x} c_i-x$</p><p>这个问题忽略那个 $(x-c_i)\bmod 2$ 的部分之后, 最优解显然是数列的 $\dfrac{2}{3}$ 处, 加上这个之后只要看看是最优解上下一个位置即可.</p><p>此外, 可能的公差其实非常少, 设两段中长的一段长度为 $l&gt;\dfrac{n}{2}$ , 那么 $l\vert d\vert \le 5\times 10^5$ , 于是 $\vert d\vert\le \dfrac{v}{n}$ , 那么暴力枚举 $d$ , 每次遍历序列, 枚举划分点的时候动态维护最小值的是可行的. 因为 $nd$ 是和 $v$ 一个量级的.</p><p>考虑如何动态维护最小值, 其实就是不断添加&#x2F;删除一个数求第 $k$ 大的值, 区间和, 区间奇偶数个数即可.</p><p>题解表示这个常数比较大, 用一个对顶堆维护, 因为我们的 $kth$ 的 $k$ 固定, 所以让一边始终存前 $k$ 个这样.</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="22冲刺day4-签到题"><a href="#22冲刺day4-签到题" class="headerlink" title="22冲刺day4-签到题"></a>22冲刺day4-签到题</h3><blockquote><p>有 $n$ 台路由器, 按照 $1 \sim n$ 的顺序连接成一条链. 第 $i$ 台路由器向第 $i+1$ 台路由器传输 $1$ 比特的数据需要花费 $t_i$ 的时间. 多个路由器之间可以并发运行——即每个路由器可以同时给下一个路由器传递自己当前已经拥有的数据.</p><p>现在你需要从 $1$ 号路由器向 $n$ 号路由器发送 $m$ 比特的数据, 所花费的时间是多少?</p></blockquote><p>直接想象一下这个过程, 只有最慢的那个会堵住, 所以就是第1bit走完全程的时间, 加上 $t_{max}(m-1)$ , 就行了.</p><h3 id="22冲刺day4-简单题"><a href="#22冲刺day4-简单题" class="headerlink" title="22冲刺day4-简单题"></a>22冲刺day4-简单题</h3><blockquote><p>定义一个长度为 $n$ 的数组 $A$ 的价值为</p><p>$$<br>\sum_{l&#x3D;1}^n\sum_{r&#x3D;l}^nQ_{l, r}\cdot\max{A_l, A_{l+1}, \cdots, A_r}</p><p>$$</p><p>其中数组 $A$ 的第 $i$ 个位置上的数字是 $V_{i, 1}, \cdots, V_{i, K_i}$ 中的一个, 并且选择 $V_{i, j}$ 的花费为 $C_{i, j}$ . 你需要求出一个数组 $A$ , 使得价值减去花费最大.</p><p>$n\le 300, \sum K_i\le 3\times 10^5$</p></blockquote><p>考虑区间暴力dp, 设 $f_{i, j, k}$ 表示区间 $[i, j]$ , 最大值为 $k$ 的价值减花费. 前缀和优化复杂度 $n^2K$ . (最大值为 $k$ 这个条件同时记录了位置和大小)</p><p>删掉 $k$ , 设 $f_{i, j}$ 表示随便选最大值的情况, 仍然区间dp, 有</p><p>$$<br>f_{i, j}&#x3D;\max_k f_{i, k}+f_{k, j}+V_{k, v}\sum_{l\le k\le r} Q_{l, r} -C_{k, v}<br>$$</p><p>我们计算 $f_{i, j}$ 的时候枚举了中间的最大值 $t$ , 如果 $f$ 实际值小于 $t$ 那么算的是对的, 如果实际情况是大于 $t$ 那么你会把它算小, 在取 $\max$ 的情况下不会错.</p><p>于是状态数 $n^2$ , 考虑优化转移到时候 $v$ 的取值, 发现 $\sum_{l\le k\le r} Q_{l, r}$ 是容易确定的二维数点, 所以成了优化 $\max vq-c$ ( $v, c$ 都是单调的因为我们可以把 $v_1&gt;v_2, c_1&lt;c_2$ 的 $2$ 直接删了再排序), 然后 $vq-c&#x3D;b$ , 则 $vq-b&#x3D;c$ , 把 $v, c$ 看成点就是斜率优化, 要在凸包上求切线, 二分即可.</p><h3 id="22冲刺day4-数数题"><a href="#22冲刺day4-数数题" class="headerlink" title="22冲刺day4-数数题"></a>22冲刺day4-数数题</h3><blockquote><p>给定一个长度为 $n−1$ 的数组 ${ai}$ 和一个长度为 $n$ 的数组 ${ci}$ , 我们根据以下过程可以随机建立一棵树:</p><p>$T_1$ 是一棵仅包含节点 $1$ 的树;</p><p>$T_i(i&gt;1)$ 将 $i$ 号点连接到 $T_{i−1}$ 上, 其中连接到 $j(1\le j\le i−1)$ 号点的概率为 $\dfrac{a_j}{a_1+\ldots +a_{i−1}}$ , 边权为 $c_i+c_j$ .</p><p>接下来有 $Q$ 组询问, 每组询问给出 $(u, v)$ , 你需要回答 $u$ 到 $v$ 的期望距离, 膜 $10^9+7$</p></blockquote><p>组合意义天地灭, 代数推倒保平安!</p><p>考虑距离转化成 $u, v$ 的期望深度减去 $lca$ 的期望深度. 于是要算求一个点的深度期望, 拆开贡献之后是要求一个点是另一个点的祖先的概率, 结论是不管第二个点是谁概率都是 $\dfrac{a_i}{b_i}$ .</p><p>证明可以考虑当前两个大小为 $a, b$ 的节点 $a, b$ , 节点 $d$ 现在插入, 为 $a$ 的子孙的概率是 $\dfrac{a}{a+b}$ , 如果中间来了一个大小为 $c$ 的节点 $c$ 插入, 再插入 $d$ , 则总方案数 $(a+b)(a+b+c)$ , 其中有 $a^2+ab+ac$ 种方案 $a$ 是 $d$ 的祖先, 所以说明了任意挂一个点, 概率不变, 于是任意一个点是其子孙的概率和紧邻的一个点是它儿子的概率相同.</p><p>qyc通过构造双射也证明了这一点, 通过考虑两个点 $u, v$ 交换它们的子树的比的变化得到.</p><p>于是一个点 $u$ 的期望深度是 $c_1+c_u+\sum 2c_v\times \dfrac{a_v}{b_v}$ .</p><p>但这个代数推导不是白说的, 考虑设点 $u$ 到根路径上点集为 $S$ , 则概率是</p><p>$$<br>\begin{gathered}<br>     E(dep_u)&#x3D;c_1+c_u+\dfrac{a_1}{b_{u-1}}\sum_{S} \prod \dfrac{a_i}{b_{i-1}}\sum_{i\in S} 2c_i\<br>    &#x3D;c_1+c_u+\dfrac{a_1}{b_{u-1}}\sum_{i\in[2, x-1]}\dfrac{2c_ia_i}{b_{i-1}}\prod_{j\in[2, u-1]\And j\ne i}\dfrac{a_j+b_{j-1}}{b_{j-1}}\<br>    &#x3D;c_1+c_x+2\sum_{i\in [2, x-1]}\dfrac{c_ia_i}{b_i}<br>\end{gathered}<br>$$</p><p>再考虑一个点是它俩 $lca$ 的概率, 考虑设 $l$ 为 $u, v$ 的 $lca$ , $l$ 到 $u$ 上的点集为 $S_1$ , $l$ 到 $v$ 上的点集为 $S_2$ , 于是类似的:</p><p>$$<br>\begin{gathered}<br>    P(l, u, v)&#x3D;\dfrac{a_l^2}{b_{u-1}b_{v-1} }\sum_{S_1}\sum_{S_2}\prod_{i\in S_1} \dfrac{2a_i}{b_{i-1} }\prod_{j\in S_2}\dfrac{a_j}{b_{j-1} }\<br>    &#x3D;\dfrac{a_l^2}{b_{u-1}b_{v-1} }\prod_{i\in[l+1, u-1] }\dfrac{2a_i+b_{i-1} }{b_{i-1} }\prod_{j\in [u+1, v-1] }\dfrac{a_j+b_{j-1} }{b_{j-1} }\<br>    &#x3D;\dfrac{a_l^2}{b_{u-1}b_{u} }\prod_{i\in [l+1, u-1] }\dfrac{2a_i+b_{i-1} }{b_{i-1} }<br>\end{gathered}<br>$$</p><p>于是答案就是 $E(dep_u)+E(dep_v)-2\sum_l P(l, u, v)$ .</p><p>qyc表演一个组合意义:</p><blockquote><p>考虑怎么求 $i$ 是 $j$ 的祖先的概率, 设为 $\mathrm{anc}(i, j)$ . 设 $i$ 前面所有点的点权和是 $s_{i-1}$ , 定义一棵树的权值是每个点父亲的 $a_i$ 的乘积, 那么权值的比就是概率的比, 并且我们只关心 $i$ 是不是 $j$ 的祖先, 所以 $&lt;i$ 的点可以看成一个权值为 $s_{i-1}$ 的点. 考虑一个双射, 对于一个 $i$ 是 $j$ 的祖先的情况, 我们把 $i$ 的包含 $j$ 的子树接到 $&lt;i$ 的任何一个点上, 反过来也是一样的, 那么我们就得到了一个权值为 $ka_i$ 的方案和一个权值为 $ks_{i-1}$ 的方案的双射, 于是我们知道 $i$ 是 $j$ 的祖先的概率是 $\frac{a_i}{a_i+s_{i-1}}&#x3D;\frac{a_i}{s_i}$ . 当然, 当 $i&#x3D;j$ 它是 $1$ , $i&gt;j$ 时它是 $0$ .</p><p>考虑怎么求 $l$ 是 $i, j$ 的lca的概率, 设为 $\mathrm{lca}(l, i, j)$ , 其中 $i&lt;j$ . 还是双射, 我们把包含 $i$ 的子树接到前面, 包含 $j$ 的子树接到前面, 两个一起接到前面, 那么相当于把四种情况打了一包, 它们权值的比是 $a_l^2: a_l(s_l-a_l): a_l(s_l-a_l): (s_l-a_l)^2$ , 于是我们得到了一个 $l$ 是 $i, j$ 的lca和 $l$ 不是 $i, j$ 的公共祖先的双射. 设后者是 $\mathrm{ca}(l, i, j)$ , 就有 $\mathrm{lca}(l, i, j)&#x3D;\frac{a_l^2}{(s_l-a_l)(s_l+a_l)}(1-\mathrm{ca}(l, i, j))$ . 感觉上只差最后一个方程了, 计算 $l$ 是 $i, j$ 的公共祖先的概率, 不太能直接算, 因为它不独立, 但是考虑这个等于它是 $i, j$ 的lca的祖先的概率, 所以我们得到 $\mathrm{ca}(l, i, j)&#x3D;\sum\limits_{k&#x3D;l}^i\mathrm{anc}(l, k)\mathrm{lca}(k, i, j)$ . 直接解, 可以得到 $\mathrm{lca}(i, i, j)&#x3D;\mathrm{anc}(i, j), \mathrm{lca}(l, i, j)&#x3D;\frac{a_l^2}{s_l^2}\left(1-\sum\limits_{k&#x3D;l+1}^i\mathrm{lca}(k, i, j)\right)$ .</p><p>于是设 $\mathrm{slca}(l, i, j)&#x3D;\sum\limits_{k&#x3D;l}^i\mathrm{lca}(k, i, j)$ , 则有 $\mathrm{slca}(i, i, j)&#x3D;\mathrm{anc}(i, j), \mathrm{slca}(l, i, j)-\mathrm{slca}(l+1, i, j)&#x3D;\frac{a_l^2}{s_l^2}(1-\mathrm{slca}(l+1, i, j))$ , 也就是 $\mathrm{slca}(l, i, j)&#x3D;\frac{a_l^2}{s_l^2}+(1-\frac{a_l^2}{s_l^2})\mathrm{slca}(l+1, i, j)$ .</p><p>接下来考虑答案是两个点深度的期望之和减去两倍的lca深度的期望, 于是考虑计算一个点 $u$ 深度的期望. 到根路径上, 自己和根贡献 $1$ , 此外每个祖先贡献 $2$ , 所以答案是 $\mathrm{dep}(u)&#x3D;c_1+c_u+2\sum\limits_{i&#x3D;2}^{u-1}\frac{a_ic_i}{s_i}$ , 可以预处理.</p><p>最终答案就是 $\mathrm{dep}(i)+\mathrm{dep}(j)-2\left(\mathrm{anc}(i, j)\mathrm{dep}(i)+\sum\limits_{l&lt;i}(\mathrm{slca}(l, i, j)-\mathrm{slca}(l+1, i, j))\mathrm{dep}(l)\right)$ . 考虑 $\mathrm{slca}(l, i, j)$ 到 $\mathrm{slca}(l, i+1, j)$ 的变化, 注意到它们的转移相同只有初值不同, 于是考虑把它看成初值的一次函数, 相当于有一堆一次函数, 支持给每个在右侧复合一个一次函数, 并求所有的某个点点值的和. 拆一拆发现复合的和等于和的复合, 或者说这个是线性变换, 所以我们只需要维护一个和即可. 使用线性逆元, 复杂度线性.</p><p>PS: 他是糊的</p></blockquote><h3 id="22冲刺day4-最后一题"><a href="#22冲刺day4-最后一题" class="headerlink" title="22冲刺day4-最后一题"></a>22冲刺day4-最后一题</h3><blockquote><p>交互库里有一棵 $n$ 个点的树, 你可以通过做若干次如下询问来确定这棵树:</p><p>给定一个节点集合 $S$ 和节点 $x$ , 交互库会告诉你 $x$ 是否在包含 $S$ 的最小连通块中.</p><p>$n\le 1000, Q\le 22000$</p><p>交互库是 $O(S)$ 的</p></blockquote><p>考虑一个暴力, 确定一个点是叶子只要问 $u$ , 和 $U-{u}$ , 就行, 可以一层一层剥叶子. 次数是 $n^2$ 的, $S$ 大小是 $n^3$ 的.</p><p>另一个想法是我们可以通过一次询问确定祖先关系.</p><p>询问次数看起来像是log的, 考虑二分?</p><p>树上交互题, 考虑归纳?</p><p>拼一拼, 假设我们要确定 $u$ 的子树, 先通过二分得到 $u$ 的子树和未知的点集的一个交 $y$ , 然后递归的求 $y$ 的子树, 于是 $x$ 子树内部都已经确定, 考虑确定 $x$ 的儿子, 由于我们同样知道哪些点没有父亲, 所以仍然二分看 $x$ 是谁的父亲就是 $n\log n$ 了.  </p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><h3 id="22冲刺day5-组队"><a href="#22冲刺day5-组队" class="headerlink" title="22冲刺day5-组队"></a>22冲刺day5-组队</h3><blockquote><p>给定序列 $a_n$ , 选出一个长3的上升子序列最大化三个数的乘积.</p><p>$n\le 10^5, \vert a_i\vert \le 10^6$</p></blockquote><p>$f_{i, j}&#x3D;f_{i-1, j-1}*a_i$ , 随便维护</p><h3 id="22冲刺day5-串"><a href="#22冲刺day5-串" class="headerlink" title="22冲刺day5-串"></a>22冲刺day5-串</h3><blockquote><p>如果一个串 $S$ 中任意两个不同字符的出现次数都不相同, 就称 $S$ 是一个好串</p><p>如果一个串 $S$ 的任意一个前缀和后缀都是好串, 就称 $S$ 是一个大好串.</p><p>$q$ 次询问, 每次给定 $n, k$ , 求长度为 $n$ 且字符集为前 $k$ 个小写字母(每个字母必须出现)的大好串中字典序最小的串.</p></blockquote><p>构造</p><p>看不懂的构造题</p><p>todo</p><h3 id="22冲刺day5-树"><a href="#22冲刺day5-树" class="headerlink" title="22冲刺day5-树"></a>22冲刺day5-树</h3><blockquote><p>给定 $Tree(n)$ , 初始时边权是1, $q$ 次询问若必须恰好 $k$ 次给一条边增加1, 最终直径的最小值. 询问独立.</p><p>$n\le 2\times 10^5$</p></blockquote><p>考虑<strong>直径的中心</strong>.</p><p>那么上来给所有边之间加个点, 这样一开始和最后的直径的中心一定在某个点上.</p><p>那么我们一定把所有叶子都先加长到底, 并且能在底下加一定不在顶上加.</p><p>所以所有次数都用在连着叶子那条边上, 对于一个中心, 可以直接算出需要多少代价先补齐到最深的叶子, 再继续整上去.</p><p>于是每个节点为根对答案的贡献是一个一次函数: 每若干次操作答案加1, 前若干次不变这样的.</p><p>那么这样一堆折线可以直接离线询问扫, 或者在线李超树之类的做.</p><h3 id="22冲刺day5-排列"><a href="#22冲刺day5-排列" class="headerlink" title="22冲刺day5-排列"></a>22冲刺day5-排列</h3><blockquote><p>给定 $n$ 个节点的树, 要给每个顶点赋值 $c_i$ 满足 $c$ 是一个 $n$ 排列, 且对于相邻两点 $u, v$ , $\vert c_u-c_v\vert \le 2$ . 求方案数</p><p>$n\le 60$ , 膜 $10^9+7$</p></blockquote><p>好离谱的题啊</p><p>正解是, $f_{i, j, k, S}$ 表示填了 $1\ldots i$ , 其中第 $i$ , $i-1$ 次分别填到了 $j, k$ 上, 当前 $S$ 中的点已经被填上了的方案数, 要求 $k$ &#x3D; $u$ 的时候其邻接点都被填了, 猜测状态数其实很小(限制很强)于是去写发现能过.</p><p>考虑, 首先度数都不大于4, 其次对于状态 $i, j, k, S$ , 如果删掉 $j, k$ 两个点, 剩下的森林中每一棵树要么都被填了, 要么都没被填, 否则一定有一个小于等于 $i-2$ 的点与一个没染色的点相邻, 这两个点必然不合法. 于是对每个 $u$ , $S$ 只有 $2^7$ 种. 其中 $7$ 是删去两个点之后的连通块数.</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><h3 id="22冲刺day6-并王"><a href="#22冲刺day6-并王" class="headerlink" title="22冲刺day6-并王"></a>22冲刺day6-并王</h3><blockquote><p>给定一个长为 $n$ 的数组 $a_i$ , 求</p><p>$$<br>\sum_{1\leq i\le j\le k\le p\le q\leq n}(((a_i\otimes a_j)\vee a_k)\otimes a_p)\wedge a_q<br>$$</p><p>膜 $2^{64}$ .<br>$n\le 4\times 10^5, a_i\le 2^64$</p></blockquote><p>太愚蠢了! ! ! </p><p>为什么瞪了半天没想到每一位独立</p><p>[think] 全是二进制操作考虑每一位独立.</p><p>于是直接独立就做完了</p><h3 id="22冲刺day6-最小最大"><a href="#22冲刺day6-最小最大" class="headerlink" title="22冲刺day6-最小最大"></a>22冲刺day6-最小最大</h3><blockquote><p>给定 $a_n$ , 求 $a$ 的子序列 $b_k$ , 最小化 $value&#x3D;\max (b_1+b_2, b_2+b_3, \ldots, b_{k-1}+b_k, b_k+b_1)$ , 输出最小值.</p><p>$n, k\le 5\times 10^5, a_i\le 10^9$</p></blockquote><p>二分答案判定.</p><p>考虑最小值一定在答案里, 于是从最小值出发转一圈, 维护 $f_i$ 表示以 $i$ 结尾的情况下最多选了几个.</p><p>那么每次遇到一个新的值, 这个位置的值就是一个区间的max加1. 最后绕一圈判定即可.</p><p>但这个是2log的, 应该过不太去, 看看砍谁.</p><p>觉得二分答案砍起来过于离谱. 考虑干掉这个dp.</p><p>考虑不dp, 一开始开一个链表把所有数都加进去, 每次如果相邻两个数之和大于二分店答案就删了大的, 直到全部合法.</p><p>此时如果长度小于 $k$ 就死了, 大于 $k$ 就可以, 可以是因为考虑从最小值往外删删一定正确的.</p><h3 id="22冲刺day6-括号序列"><a href="#22冲刺day6-括号序列" class="headerlink" title="22冲刺day6-括号序列"></a>22冲刺day6-括号序列</h3><blockquote><p>给定一个长为 $2n$ 的正整数序列 $p$ , $1\leq p_i\leq n$ .<br>其中 $1$ 到 $n$ 每个值出现恰好两次, 将值相同的元素进行配对. 要求给每对元素赋上同一种括号<code>(</code>或者<code>)</code>, 使得最终序列构成一个合法的括号序列.<br>当然这个问题对你来说有点过于简单, 于是加上一个限制: 要求你给出的括号序列是所有可能的最终序列中字典序最小的(这里认为<code>(</code>的字典序小于<code>)</code>的).<br>$n\le 2\times 10^6$</p></blockquote><p>[think] 见到字典序想贪心!</p><p>但发现我们也不知道一个括号钦定之后是否有解.</p><p>[think] 有后效性, 考虑钦定+反悔.</p><p>发现我们不知道什么时候反悔. 可以考虑先选择最靠前的括号对 $\dfrac{n}{2}$ 当成<code>(</code>, 然后从左往右扫:</p><ul><li>如果当前前缀和小于0, 那么一定要调成正的, 从左边选一个最靠右到<code>)</code>变成<code>(</code>, 右边选一个最靠左都<code>(</code>变成<code>)</code>即可.</li></ul><p>于是把每个对都塞到堆里即可. 要一个堆维护左边的, 一个堆维护右边的.</p><h3 id="22冲刺day6-脉冲星"><a href="#22冲刺day6-脉冲星" class="headerlink" title="22冲刺day6-脉冲星"></a>22冲刺day6-脉冲星</h3><blockquote><p>给定 $L, R, x$ . 要求出一个整数序列 $A$ , 满足 $L\leq a_i\leq R$ , 并且 $\otimes_{i&#x3D;1}^n a_i&#x3D;x$ , 使得其能够最大化 $\sum_{i&#x3D;1}^n a_i$ . 求最大值.</p><p>$T\le 10^6, x, L, R\le 10^9$</p></blockquote><p>考虑从高位开始贪心, 那么最高位如果能选一定选上, 并且根据 $x$ 这一位是0还是1选奇数&#x2F;偶数个, 然后每一位有可能有3个数不选满.</p><p>有亿点细节.</p><h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><h3 id="22冲刺day7-A"><a href="#22冲刺day7-A" class="headerlink" title="22冲刺day7-A"></a>22冲刺day7-A</h3><blockquote><p>给定两个数的 $x\mathrm{and} y$ 和 $x\mathrm{xor} y$ , 求 $x\mathrm{or} y$</p><p>$x, y\le 2^{64}$</p></blockquote><p>直接做</p><h3 id="22冲刺day7-B"><a href="#22冲刺day7-B" class="headerlink" title="22冲刺day7-B"></a>22冲刺day7-B</h3><blockquote><p>给定一个无自环无重边的无向图, 求其最大团. 团的定义是一个点集使得其中任意两个不同的点之间都有一条无向边相连.</p><p>p. s. 出题人比较懒, 为了方便, 数据中所有的图都是由两个不相交的团, 两个团之间再连一些无向边构成的.</p><p>$n\le 500$</p></blockquote><p>考虑最大团是补图的最大独立集, 因为这个性质所以补图是二分图, 于是要求二分图最大独立集, 这个等于最小点覆盖, 考虑如何最小点覆盖, 可以求一个二分图建成网络流的二分图, 中间边设inf, 两边边设1, 求最小割, 那么任意两个有边的点的源汇边必然割了一条, 割了哪个就选哪个点即可.</p><p>图论功底太拉啊.</p><h3 id="22冲刺day7-C"><a href="#22冲刺day7-C" class="headerlink" title="22冲刺day7-C"></a>22冲刺day7-C</h3><blockquote><p>给定 $Tree(n)$ , 边有边权, 求选 $k$ 个点, 任意顺序, 使得按顺序走到这 $k$ 个点的距离和最大.</p><p>$n, k\le 2\times 10^5$</p></blockquote><p>就是选 $k$ 个点最大化虚树边权和. 啊, 不对, 顺序是重要的.</p><p>考虑dp, 设 $f_{u, i}$ 表示子树 $u$ 内选了 $i$ 个点, 每次算上 $u$ 到父亲这条边的贡献为 $\min(i, k-i)\times w$ 即可.</p><p>$$<br>\begin{gathered}<br>    f_{u, i}: &#x3D;\max f_{u, j}+f_{v, i-j}\</p><pre><code>f_&#123;u, i&#125;: =\max f_&#123;u, i&#125;, f_&#123;u, i-1&#125;\\f_&#123;u, i&#125;: =f_&#123;u, i&#125;+\min(i, k-i)\times w</code></pre><p>\end{gathered}<br>$$</p><p>于是考虑三个转移, 第一个是做max-加卷积, 也就是闵和, 第二个是平移, 第三个是加一次函数, 发现对于同一个 $u$ , $f_i$ 函数是凸的于是SlopeTrick维护即可, 闵和可以启发式合并, 复杂度2log.</p><h3 id="22冲刺day7-D"><a href="#22冲刺day7-D" class="headerlink" title="22冲刺day7-D"></a>22冲刺day7-D</h3><blockquote><p>给定一个DAG和 $k$ 条路径, 对每个 $i$ 求有多少条路径到1且不包含这 $k$ 条中的任意一条. 膜998244353.</p><p>$n, m, \sum l_i\le 10^5$ , $l_i$ 为第 $i$ 条路径长度.</p></blockquote><p>把所有边取反变成到1的方案数dp, 那么一个点的方案数是所有其出边的方案数之和, 但还要考虑那些以这个点为起点的路径, 考虑如果只在这里删掉后面仍然会影响, 所以直接把图改了: 把这个点开始的这条路径上的所有点 $u_1\ldots u_l$ 复制一份成 $u_1’\ldots u_l’$ , 然后复制出边, 把原来 $u_i’\to u_{i+1}$ 这一条出边改成 $u_{i+1}’$ , 在最后一个位置删掉 $u_{l-1}\to u_l$ , 最前面改成 $u_1\to u_l’$ , 那么以后的每次dp都是对的了.</p><p>考虑用数据结构维护这个可持久化, 于是对每个点开一个主席树存出边即可.</p><h2 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h2><h3 id="22冲刺day8-括号序列"><a href="#22冲刺day8-括号序列" class="headerlink" title="22冲刺day8-括号序列"></a>22冲刺day8-括号序列</h3><blockquote><p>给定一个括号序列, 求最少添加几个括号才能把它变成合法的括号序列. 可以在任意位置添加括号, 左括号和右括号都可以添加.<br>$n\le 10^6$</p></blockquote><p>那么我们只要把所有前缀和调成正的即可, 于是发现直接在最前面&#x2F;最后面加一定不劣.</p><h3 id="22冲刺day8-游戏"><a href="#22冲刺day8-游戏" class="headerlink" title="22冲刺day8-游戏"></a>22冲刺day8-游戏</h3><blockquote><p>A, B玩游戏, 有 $n$ 个石子, A显瘦, 每人每次最少拿一个石子, 最多拿 $k$ 个, A要求取完石子之后剩余质数个, B取完之后剩余合数个, 无法操作的人输, 问两个人都按照最优策略的情况下会进行多少轮. 最优策略指必胜的希望快点赢, 必负的希望慢点死的策略.</p><p>$n\le 5\times 10^6$</p></blockquote><p>直接dp</p><h3 id="22冲刺day8-树"><a href="#22冲刺day8-树" class="headerlink" title="22冲刺day8-树"></a>22冲刺day8-树</h3><blockquote><p>给定排列 $p_n$ 和 $n$ 个点, 求满足若 $i\to j$ , 则 $p_i\to p_j$ 的无向无根生成树数量. 两棵树不同指不同构.</p><p>$n\le 3\times 10^5$</p></blockquote><p>仍然考虑排列形成的若干个环, 如果一个环大小超过2环内不能连边.</p><p>如果两个环之间连边, 当且仅当其中一个是另一个的倍数. (画一画可知)</p><p>一个环只能与一个比它小的连边, 因为一个环的与其因数 $d$ 连边时是膜 $d$ 的每个余数连到一个点上, 于是如果有两个连的位置同余直接死, 但环是绕一圈所以总会死. 而和等于的或大于的没事可以任意多.</p><p>一个大小 $ka$ 的环连到大小 $a$ 的环上有 $a$ 种方案. (具体的, gcd).</p><p>然后就是对着数了, 刚才的性质让我们想到直接从小到大, 对每个点决定向比它小的部分连的是谁. 于是按照大小分为若干组, 每一组假设有 $k$ 个环要向比它小的连, 每个是独立的, 设大小为 $i$ 的环的个数为 $cnt_i$ , 组 $i$ 向前连的方案数就是 $\binom{n}{k}(\sum_{j&lt;i} cnt_j\times j)^k$ , 组内连的是把这些环分成 $k$ 棵生成树, $x_1\ldots x_k$ 不在同一棵的方案数, 是 $k\times n^{n-k-1}$ . 就做完了.</p><h3 id="22冲刺day8-序列"><a href="#22冲刺day8-序列" class="headerlink" title="22冲刺day8-序列"></a>22冲刺day8-序列</h3><blockquote><p>给定 $a_n$ , 每次单点修改, 或者询问对于区间 $a_[l, r]$ 提取成 $b$ , 任意次操作, 每次可以 $b_i: &#x3D;b_i-2, b_{i+1}: &#x3D;b_{i+1}+2$ , 或者若 $b_{i+1}&#x3D;0$ , $b_i: &#x3D;b_i-1, b_{i+2}: &#x3D;b_{i+2}+1$ , 问最后最多有多少个0.</p><p>$n\le 2\times 10^5$</p></blockquote><p>考虑可以先通过1操作变成01数组在最后跟一个数 $x$ .</p><p>发现然后对于所有不是最后位置的0都可以把0搬运到前面. 于是就成了一串0接一串1接一个s.</p><p>那么考虑两个区间的合并, 左区间的 $x$ 先被变成01加到右区间的 $x$ 上, 然后合并01段, 发现如果中间有奇数个0两个1段可以两两消去, 左边的1如果多还可能与s2再消一次. 偶数个则什么也做不了. 于是用这个去合并两个区间, 线段树即可.</p><h2 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h2><h3 id="22冲刺day9-逆序对"><a href="#22冲刺day9-逆序对" class="headerlink" title="22冲刺day9-逆序对"></a>22冲刺day9-逆序对</h3><p>这就是JOI冒泡排序或LOJ花火点弱化啊?</p><p>ZR退钱</p><h3 id="22冲刺day9-排序"><a href="#22冲刺day9-排序" class="headerlink" title="22冲刺day9-排序"></a>22冲刺day9-排序</h3><blockquote><p>给一个序列 $a_n$ , 每次可以选择相邻三个, 把第一个插入到最后一个位置( $a_i, a_{i+1}, a_{i+2}\to a_{i+1}, a_{i+2}, a_i$ ), 求不超过 $n^2$ 次将序列排序的方案数.</p><p>$n\le 1000$</p></blockquote><p>想一想 $n^2$ 排序有啥算法, 直接一个选择排序(每次选择最大值, 把它用操作移动到最后)拍上去就行了. 最后可能会剩下两个没法用操作移动, 那么在无重复元素的情况下就死了, 因为操作不改变逆序对奇偶性.</p><p>如果有相同元素, 那就直接有解了, 因为我们改变两个相同元素的顺序就必然有解.</p><p>交, 为啥FST20分啊? 又是 $n^2$ 的操作开 $n$ 的数组</p><h3 id="22冲刺day9-旅行"><a href="#22冲刺day9-旅行" class="headerlink" title="22冲刺day9-旅行"></a>22冲刺day9-旅行</h3><blockquote><p>给定数组 $c$ , 求所有重排方案中, 每个方案的权值和, 一个位置的权值和定义为, 最小的 $i$ 满足从 $i$ 开始走一圈, 除了一开始在 $i$ 的时候走过的元素之和都大于0.<br>$n\le 20$</p></blockquote><p>有点类似Raney的考虑, 如果和小于0直接寄, 否则一定是选择了第一个最小值开始走.</p><p>于是枚举最小值左右都放了哪些 $c$ , 也就确定了最小值的位置, 那么接下来要求右边前缀和大于0, 左边前缀和大于 $\sum c_i$ , 直接 $dp_S$ 表示选了 $S$ 内的点的方案数就行了. 复杂度 $n2^n$</p><h3 id="22冲刺day9-计数"><a href="#22冲刺day9-计数" class="headerlink" title="22冲刺day9-计数"></a>22冲刺day9-计数</h3><blockquote><p>求有多少长为 $n$ , 任意两个相邻数和不为 $m$ 或 $m+1$ 的方案数.</p><p>$n\le 10^9$ , $m\le 10^7$ , 膜 $10^9+7$</p></blockquote><p>qyc场切题. 15k.</p><p>考虑和为 $m$ 和 $m+1$ 的数, 可以连出 $m \to 1\to m-1\to 2\to m-2\to 3\ldots$ , 行成一条长 $m$ 的链, 要求链上不相邻的两点在位置上不相邻, 以及后面大于 $m$ 的部分点随便排.</p><p>于是考虑容斥, 钦定我们连出若干条边行成若干条链, 那么每条链有一种(长度为1)或两种(长度大于1)方案, 问题变成了要求把 $m$ 个元素划分成 $i$ 个链, 剩下随便放的方案数(把链看成元素做排列), 方案数为</p><p>$$<br>\sum_{i\in [0, m]} f_{m, i} (i+n-m)! (-1)^{m-i}<br>$$</p><p>$f_{i, j}$ 表示 $i$ 个元素划分 $j$ 个链的方案数.</p><p>dp计算 $f$ 可以做到 $m^2$ , 然后剩下的部分趋近于玄学, 官方题解猜测在 $n-m$ 一定时答案是关于 $m$ 的整式递推并且整式的次数和递推的阶数都很小, 直接暴力计算前几项然后解方程(高消)发现满足一个递推式, 做到 $O(m)$ .</p><p>另一个方法是在dp那一步写成生成函数用ODE自动机跑</p><h2 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h2><h3 id="22冲刺day10-距离"><a href="#22冲刺day10-距离" class="headerlink" title="22冲刺day10-距离"></a>22冲刺day10-距离</h3><blockquote><p>给定 $Tree(n)$ , 边权 $w_i$ , 求哪个点为根的时候根到其他节点的距离和最小, 距离指两点间边权最小值.</p><p>$n\le 10^6$</p></blockquote><p>上来都没看见距离定义, 和qyc一人一个换根dp往上冲</p><p>最小值可合并, 不可差分, 不可减, 贡献可合并, 可差分, 可减. 最小值毙掉了换根dp, 于是考虑从贡献角度考虑:</p><p>对于一个最小值把树分成两半, 那么两边之间的贡献都要经过它, 再加上内部贡献即可.</p><p>分割不好做做加边, 想了想配个启发式合并, 就行了.</p><p>于是我的做法是从大到小排序, 维护一堆联通块(一个vecotr记录联通块, 一个加法标记), 每次合并的时候加上贡献.</p><p>写了一发过不去? 把vector换成链表, 加个火车头和快读, 卡进1s, 时限开到2s.</p><p>看了看, 智障了, 这里启发式合并是不必要的, 可以换成Kru重构树, 可以直接Kru.</p><h3 id="22冲刺day10-哈夫曼树"><a href="#22冲刺day10-哈夫曼树" class="headerlink" title="22冲刺day10-哈夫曼树"></a>22冲刺day10-哈夫曼树</h3><blockquote><p>哈夫曼树常用于解决最优编码问题: 即给定若干种不同字符在文本中的出现次数(频率), 试为每个字符给出一个 $\texttt{01}$ 串作为编码, 使得 $频率\times 码长$ 之和最小, 且没有任何一个编码是另一个编码的前缀.</p><p>本题中, 需要解决的是一个非常类似的问题: 按字典序从小到大, 给出 $n$ 种不同字符及其频率, 试为每个字符给出一个 $k$ 进制字符串(即, 字符串中的每个字符为 $0\ldots k−1$ 中的一个)作为编码, 使得 $频率\times 码长$ 之和最小, 且没有任何一个编码是另一个编码的前缀. 同时, 你还需要保证给出的编码在字典序上是保序的, 即, 不会出现两个字符 $a, b$ , 使得字典序上 $a$ 比 $b$ 小, 但是 $a$ 的编码比 $b$ 的编码的字典序大.</p><p>只需输出最小的 $频率\times 码长$ 之和即可.<br>$n\le 500, k\le 60$</p></blockquote><p>首先考虑一个模型转化, 这个问题等价于在一个数组上石子合并, 每次可以合并至多 $k$ 个, 数组上对应值为频率算答案. 因为石子合并就是在搜一棵最优搜索树.</p><p>然后可以写一个 $n^3k$ 的dp, 设 $f_{l, r, i}$ 表示 $[l, r]$ 分 $i$ 段的方案区间dp转移即可.</p><p>注意到树上任意节点一定恰好有 $k$ 个儿子(除了儿子都是叶子节点的), 所以不用算出每一个 $i$ , 而是倍增只算一个 $f_{l, r, k}$ .</p><p>这题决策单调性是假的</p><p>这玩意倍增怎么写? 好像是预处理每个位置由哪些dp值拼起来, 看到有些实现写的类似线段树.</p><p>[think] 倍增优化dp别忘了</p><h3 id="22冲刺day10-欧拉"><a href="#22冲刺day10-欧拉" class="headerlink" title="22冲刺day10-欧拉"></a>22冲刺day10-欧拉</h3><blockquote><p>本题要解决的问题是, 给定一个正奇数 $n$ , 试找到一个数 $x\le 10^18$ , 使得 $x-\varphi(x)&#x3D;n$ .</p><p>$n\le 10^9$</p></blockquote><p>$x-\varphi(x)$ 没什么性质, 而且不要求最小化, 考虑构造一些特殊的 $x$ .</p><p>考场上尝试了 $x$ 为一堆小质数拼起来, 再搭一个巨大的质数, 但巨大质数太大没法弄, 但实际上只要构造 $x&#x3D;pq$ 即可, 因为 $pq-\varphi(pq)&#x3D;pq-(p-1)(q-1)&#x3D;p+q-1&#x3D;n$ , 也就是 $n+1&#x3D;p+q$ , 注意 $n+1$ 是偶数, 根据哥德巴赫猜想一定可以有这样的解.</p><p>于是直接枚举判断 $i$ 和 $p-i$ 是否都是质数. </p><p>[think] 第二次碰见哥德巴赫猜想数论题</p><p>[think] 构造题, 自己给方案钦定一个性质</p><h3 id="22冲刺day10-子图"><a href="#22冲刺day10-子图" class="headerlink" title="22冲刺day10-子图"></a>22冲刺day10-子图</h3><blockquote><p>给一个简单无向 $Graph(n, m)$ , 求所有导出子图中有几个边数为偶数.<br>$n\le 46$</p></blockquote><p>把偶数转化成乘法, $[c\bmod 2&#x3D;0] &#x3D; \dfrac{(-1)^c+1}{2}$ .</p><p>那么折半, 需要考虑跨过中间的贡献, 先搜左边, 注意到在左边的集合固定的情况下,<strong>右边的单个点的贡献是可合并的</strong>, 于是处理出右边到左边有奇数条边的单点组成, 左边为 $S$ 时这个点集设为 $P(S)$ .</p><p>于是考虑合并两边, 处理 $f_S$ 表示 $P(T)&#x3D;S$ 的 $T$ 的权值之和, $g_S$ 表示右边为 $S$ 的权值, 则要求</p><p>$$<br>\sum_{S, T} f_Sg_T (-1)^{\vert S\cap T\vert }<br>$$</p><p>于是对 $f$ 做FWT即可.</p><p>被教育了, 这个是FWT-XOR的定义.</p><p>[think] 看看什么情况下贡献是可合并的.</p><blockquote><p>这个题是可以 $n^3$ 的, 在榜上脱颖而出</p><p><img src="/img/2022-10-27-19-07-09-image.png" alt="picture 1"></p><p>离奇故事是, 这个可以多项式复杂度. 首先改成如果边数是 $c$ , 则贡献 $(-1)^c$ . 考虑找一条边 $(u, v)$ , 先假设 $u, v$ 都没有自环, 考虑它对剩下的部分的贡献. 对于剩下的部分的一个方案, 设单独再选 $u, v$ 的贡献是 $x, y$ , 那么选 $uv$ 是 $-xy$ , 不选当然是 $1$ , 那么总共是 $x+y-xy+1$ . 如果 $x&#x3D;1, y&#x3D;1$ 它是 $2$ , $x&#x3D;1, y&#x3D;-1$ 它是 $2$ , $x&#x3D;-1, y&#x3D;-1$ 它是 $-2$ . 所以乘个 $2$ 先.</p><p>那么也就是至少一边邻接偶数个点则贡献是 $1$ , 否则是 $-1$ . 考虑构造一个这个东西, 容易想起来偶数乘任何数都是偶数, 所以我们在剩下的点中, $u$ 的邻接点和 $v$ 的邻接点连成完全二分图(如果一个点同时邻接 $u, v$ , 则连一个自环), 那么选了 $c_u, c_v$ 个 $u, v$ 的邻接点, 贡献就带一个 $(-1)^{c_uc_v}$ , 于是可以把 $u, v$ 删掉了. 显然删掉一对重边不影响答案.</p><p>考虑有自环的情况, 我们让 $x, y$ 仍然是不考虑自环的贡献, 那么如果 $u$ 有自环而 $v$ 没有, 则贡献 $-x+y+xy+1$ , 如果 $x&#x3D;1, y&#x3D;1$ 它是 $2$ , $x&#x3D;1, y&#x3D;-1$ 它是 $-2$ , $x&#x3D;-1, y&#x3D;1$ 它是 $2$ , $x&#x3D;-1, y&#x3D;-1$ 它是 $2$ , 也就是 $c_u$ 是奇数而 $c_v$ 是偶数的时候贡献 $-1$ , 别的时候都是 $1$ . 还是连成完全二分图, 此时不对的贡献在 $x&#x3D;1, y&#x3D;-1$ 和 $x&#x3D;-1, y&#x3D;-1$ , 于是它可以看成 $(-1)^{c_uc_v+c_v}$ , 我们给 $v$ 的邻接点都连一个自环, 就把它调成对的了.</p><p>考虑 $u, v$ 都有自环, 此时贡献是 $-x-y-xy+1$ , $x&#x3D;1, y&#x3D;1$ 它是 $-2$ , $x&#x3D;1, y&#x3D;-1$ 它是 $2$ , $x&#x3D;-1, y&#x3D;-1$ 它是 $2$ . 可以感觉到应该把贡献写为 $(-1)^{(c_u+1)(c_v+1)}$ , 那么还是给 $u, v$ 的邻接点都连一个自环, 如果一个点同时是 $u, v$ 的邻接点则不连, 这样我们得到 $(-1)^{c_uc_v+c_u+c_v}$ , 再整个取反一下即可.</p><p>复杂度 $O(\frac{n^3}{w})$ .</p></blockquote><h2 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h2><h3 id="22冲刺day11-A-Subsequence"><a href="#22冲刺day11-A-Subsequence" class="headerlink" title="22冲刺day11-A-Subsequence"></a>22冲刺day11-A-Subsequence</h3><blockquote><p>给定序列 $a_n$ , 其中若干位置已经确定, 要求你在所有空着的位置上填上数, 使得所有区间和是质数.</p><p>$n\le 10^5$</p></blockquote><p>诈骗题.</p><p>考虑直接求前缀和 $s_n$ , 那么若 $s_i-s_{j-1}$ 为偶数当且仅当差是2, 而因为 $n\ge 2$ 就一定有偶数(而且偶数个数为 $\dfrac{n}{2}$ ), 所以 $n\ge 4$ 的时候无解, 写个爆搜验证一下, 确实.</p><h3 id="22冲刺day11-B-Battle"><a href="#22冲刺day11-B-Battle" class="headerlink" title="22冲刺day11-B-Battle"></a>22冲刺day11-B-Battle</h3><blockquote><p>给定空间中 $n$ 个点 $(x_i, y_i, z_i)$ , 每一轮, 若对于一个点不存在点 $j$ 满足 $x_j\le x_i, y_j\le y_i, z_j\le z_i$ , 且两点不相等则点 $i$ 被删掉, 求每个点在哪一轮被删掉.</p><p>保证数据随机</p><p>$n\le 10^5$ , $x_i, y_i, z_i\le 2^64$</p></blockquote><p>观察大样例发现答案很小( $3\times 10^4$ 的时候答案为 $68$ ), 于是猜测轮数不多.</p><p>于是暴力模拟, 把点按 $z$ 排序, 用set维护一个 $y$ 在 $x$ 上的前缀 $min$ (不存在两点 $x_1&lt;x_2, y_1&lt;y_2$ )即可.</p><p>注意一开始应该把点离散化.</p><p>QYC证实了猜测的正确: 随机数据下三维LIS的长度期望为 $\sqrt[3]{n}$ .</p><h3 id="22冲刺day11-C-Competition"><a href="#22冲刺day11-C-Competition" class="headerlink" title="22冲刺day11-C-Competition"></a>22冲刺day11-C-Competition</h3><blockquote><p>$n$ 个人比赛, 每个人有实力 $a_i$ , $i$ 战胜 $j$ 的概率是 $\dfrac{i}{i+j}$ , 没有平局, 现在排成一队, 每次队头的两个人比赛, 赢的人回到队尾, 最后留下的人胜利. 现在你知道你和其余 $n-1$ 个人的实力, 其余 $n-1$ 个人的相对位置确定, 求你插进每一个空的获胜概率.</p><p>$n\le 4096$</p></blockquote><p>想到BZOJ4985评分那个题, 于是可以建出一个树的结构.</p><p>朴素dp, 设 $f_{i, j}$ 表示点 $i$ 是第 $j$ 个人的概率, 可以做到 $n^3$ (算一个位置 $n^2$ , 一次转移是 $siz^2$ 的).</p><p>考虑虽然你自己的位置变了, 但树的结构不会变, 实际上你走一步只是交换了你和另一个相邻人而已.</p><p>于是现在只需要更新两个点到根的链上的dp值j即可. 复杂度仍然是 $n^3$ .</p><p>考虑实际上不需要算所有点的dp值, 如果这个点是 $x$ 的祖先那么只要保留 $x$ 的, 其他的点只有两种情况( $x$ 在它前面, $x$ 在它后面), 所以复杂度 $n^2$ 了.</p><h3 id="22冲刺day11-D-Tree"><a href="#22冲刺day11-D-Tree" class="headerlink" title="22冲刺day11-D-Tree"></a>22冲刺day11-D-Tree</h3><blockquote><p>给定 $Graph(n, m)$ , 求有多少种把 $1\ldots m$ 的全排列分配到 $m$ 条边上作为边权, 求对于所有前 $n-1$ 条边恰好是图的最小生成树的方案中最小生成树的边权和.</p><p>$n\le 20$</p></blockquote><p>想起Star MST那个题, 设 $f_{i, S}$ 表示加入了边权前 $i$ 小, 此时要求的前 $n-1$ 条边加入的集合为 $S$ , 转移则枚举新加的边是哪一条, 复杂度是 $n^32^n$ , 这个卡常可过.</p><p>优化状态, 考虑只记录 $f_S$ 表示从小到大, 树边状态是 $S$ 的方案数(不会显示枚举值域了), 每次转移往里面添加一条树边, 会让若干条非树边可以在大于这条树边的权值里随便选. 考虑假设最终状态已经确定, 设从倒数第 $i$ 条树边之后又多了 $c_i$ 个边可以随便选, 则方案数是:</p><p>$$<br>\prod_i (\sum_{j\in [1, i]} c_j+i)^{\overline{c_i}}<br>$$</p><p>这个的组合意义是考虑, 一条直线被树边分成若干段, 想象这是一个序列, 那么从后往前的过程中, 每次是<code>push_front</code>一条树边, 然后再后面任意位置<code>insert</code>若干边, 发现插入一条边之后可以选的位置是增加了的所以是上升幂.</p><p>于是这个可以dp, 预处理 $cnts_S$ 表示状态为 $S$ 时已经可以随便选的边数, 就能算出这次转移到时候以后的边数.</p><p>设 $g_S$ 表示状态 $S$ 的权值和, 然后你发现这个东西完全不会转移权值和.</p><p>考虑和从前往后转移是困难的, 因为在加一条边的时候我们不知道前面还有多少条边, 所以无法确定这个边的边权, 但是从后往前的时候, 插入一条树边的贡献是已有的树边个数, 而插入一条非树边时, 设 $a_i$ 表示第 $i$ 条树边现在都权值, 在这一条边可选择的所有位置中, 它有 $a_i$ 种方案插入到第 $i$ 条树边前面, 所以贡献是 $a_i$ , 因为每条树边可以是独立的(我们可以没有必要的跑 $n$ 遍, 每次求所有方案中第 $i$ 条树边的权值和, 最后加起来得到答案, 把这个累加的过程分摊到求和的各步骤同样正确. 另一种考虑方式是转成期望, 用期望的线性性), 所以插入的贡献就是 $\sum a_i&#x3D;g_S$ .</p><p>[think] 期望的线性性对应了排列中贡献拆分后独立性</p><p>于是就是说, 由于我们在都已经确定的情况下, 两种方案的计算模型都是从大到小的, 于是从小到大走的时候, $f$ 记录的是一个贡献, 但这个贡献不是当下的, 而是和未来穿插的, 所以对当下的转移就一点用也没有. 而顺着模型走的时候贡献是有其实际意义的–从大到小, 最小生成树的边已经确定了 $S$ 的方案数和权值和.</p><p>[think] 当dp时包含的贡献有对应状态的实际意义的时候是更容易思考的.</p><p>$g$ 的转移还是困难, 从大到小枚举 $S$ , $S’$ 表示转移到的状态, $cnt$ 是这次变化新的能随便选的树边, $det$ 是插入这些新的非树边的方案数, $x&#x3D;((m-n-1-cnts_S)+(n-1-\mathrm{popcount}(S))+1)$ , 意思是我们往后插入一条边的时候能插的空的数量:<br>$$</p><p>\begin{gathered}<br>g_{S’}: &#x3D;g_{S’}+(g_S+(n-1-\mathrm{popcount}(S)+1)f_S)det\\<br>g_{S’}: &#x3D;g_{S’}+cnt \times \dfrac{det}{x}\times g_S<br>\end{gathered}<br>$$</p><p>第一行是添加一条树边, 第二行是添加 $cnt$ 条非树边. 问题主要在非树边, 考虑一条边加在已经存在的边的所有间隔的方案数相同的, 所以因为我们一共加了 $cnt$ 条边, 一共有 $x$ 个空, 所以每个空里会插入 $\dfrac{cnt\times det}{x}$ 次, 而 $g_S$ 是每个空插一次的贡献, 所以答案就是这个了. 这个先乘再均摊的技巧好像很经典, 但确实不容易被我想到</p><p>数数都是神仙题</p><h2 id="Day12"><a href="#Day12" class="headerlink" title="Day12"></a>Day12</h2><p>评价: C &lt; D &lt; A &lt; B </p><h3 id="22冲刺day12-串串匹配"><a href="#22冲刺day12-串串匹配" class="headerlink" title="22冲刺day12-串串匹配"></a>22冲刺day12-串串匹配</h3><blockquote><p>给定长 $n$ 串 $s$ , 再给定 $q$ 个串 $t_{10}$ , 可能有通配符 $\texttt{? }$, 一个 $t$ 种最多有 $4$ 个 $\texttt{? }$ , 字符集是9, 对每个模板串求出现次数.<br>$n, q\le 2\times 10^5$</p></blockquote><p>降智题, 固定长度的子串只有 $O(n)$ 个. 于是预处理出长度为 $n$ 的有两个问号的所有串, 然后询问的时候也枚举两个问号的位置, 算一下发现能过了.</p><h3 id="22冲刺day12-博弈游戏"><a href="#22冲刺day12-博弈游戏" class="headerlink" title="22冲刺day12-博弈游戏"></a>22冲刺day12-博弈游戏</h3><blockquote><p>给定有向图 $Graph(n, m)$ , A, B轮流操作在图上走, A先手, A要最大化经过点的最大值, B希望最小化, 如果一个位置没有出边或者走了 $10^100$ 就结束.<br>对每个位置走一遍</p></blockquote><p>如果没有环, 可以直接dp设 $f_{u, 0&#x2F;1}$ 表示从 $u$ 出发, 谁先手的方案, 这个dp用spfa型更新就能过题.</p><p>如果有环, 考虑只算一个节点的情况, 二分答案, 把点拆成两个状态表示谁先手, 维护一个 $S$ 表示A获胜的点集, 如果一个A先手的点能走进S就加入S, 如果一个A后手的点所有出边都指向S就也加入S不断做就可以了, 最后所有S以内的点就是A获胜的.</p><p>现在考虑可以同时对所有节点处理, 去掉二分, 从大到小枚举答案, S肯定是越来越大的, 就行了.</p><h3 id="22冲刺day12-时空限制"><a href="#22冲刺day12-时空限制" class="headerlink" title="22冲刺day12-时空限制"></a>22冲刺day12-时空限制</h3><blockquote><p>给 $a_n$ , 求第 $k$ 小, 数据随机, $n\le 2. 5\times 10^8$ , 内存限制1Mb(不算程序自身), 值域 $v&#x3D;2^{64}-1$</p></blockquote><p>简单题, 显然分布均匀, 于是值域上相邻两个数间隔期望 $\dfrac{v}{n+1}$ , 那么第 $k$ 小期望在 $\dfrac{kv}{n+1}$ , 于是就读的过程中把值在这个数上下 $C\dfrac{v}{n}$ 的数全存下来, 记录小于这个区间的数的个数, 然后直接求就行了.</p><p>STD用了两个堆. </p><h3 id="22冲刺day12-弹跳声呐"><a href="#22冲刺day12-弹跳声呐" class="headerlink" title="22冲刺day12-弹跳声呐"></a>22冲刺day12-弹跳声呐</h3><blockquote><p>给树 $Tree(n)$ , 每次在 $t$ 时刻插入一个点 $u$ , 或询问 $t$ 时刻, 对于点 $u$ , 有多少个次在 $(v, t’)$ 的插入满足 $dis(u, v)&#x3D;t-t’$ .</p><p>$n\le 10^5$</p></blockquote><p>点分树, 模板</p><p>每层开2个 hash_table 即可. 注意 map 会 TLE. 如果不会去做 “震波”.</p><h2 id="Day13"><a href="#Day13" class="headerlink" title="Day13"></a>Day13</h2><h3 id="22冲刺day13-子串"><a href="#22冲刺day13-子串" class="headerlink" title="22冲刺day13 子串"></a>22冲刺day13 子串</h3><blockquote><p>给定 $s$ , 对每个 $i$ 求 $s_{1\ldots n}$ 与 $s$ 的 lcp在s中出现的次数.</p><p>$n\le 2\times 10^6$</p></blockquote><p>直接看出, 先求每个前缀和 $s$ 的lcp, 然后就是一个前缀在 $s$ 中的出现次数.</p><p>第一步直接Z函数, 第二步考虑lcp为 $j$ 表示从 $i$ 开始的有前 $j$ 个前缀, 直接给这些出现次数加1即可. 总复杂度线性.</p><p>直接字符串hash+二分也能直接冲.</p><h3 id="22冲刺day13-最大子矩阵"><a href="#22冲刺day13-最大子矩阵" class="headerlink" title="22冲刺day13 最大子矩阵"></a>22冲刺day13 最大子矩阵</h3><blockquote><p>给定 $a_n$ , 对每个 $i$ 求不包含 $i$ 的区间的最大权值, 一个区间的权值为区间最小值乘区间长度.</p><p>$n\le 2\times 10^5$</p></blockquote><p>求每个前缀和后缀的是相同的. 只考虑前缀.</p><p>考虑从左往右扫, 对于一个右端点, 考虑其和每个左端点匹配, 那么首先左端点是当前前缀的后缀min, 所以其出现时间是一个区间, 于是冲一个线段树分治+李超树的2log, 全T了. 不该啊</p><p>考虑不用线段树分治, 在线做砍掉这个log: 维护每个左端点的一次函数组成的凸包, 就写一个单调栈, 再同时维护一个凸包, 就行了.</p><h3 id="22冲刺day13-匹配"><a href="#22冲刺day13-匹配" class="headerlink" title="22冲刺day13 匹配"></a>22冲刺day13 匹配</h3><blockquote><p>给定 $a_{2n}$ , 进行完美匹配, 对每个 $k$ 求有多少个完美匹配的方案满足有 $k$ 个相交对, 两个匹配 $(a, b), (c, d)$ 相交指 $a&lt;c&lt;b&lt;d$ 或 $c&lt;a&lt;d&lt;b$ .<br>$n\le 100$ , 膜 $10^9+7$</p></blockquote><p>考虑dp, $f_{i, j, k}$ 表示前 $i$ 个, 其中已经形成 $j$ 个对, 有 $k$ 个左端点在 $i$ 前面而还没找到右端点即可.</p><h3 id="22冲刺day13-波波牛的星系"><a href="#22冲刺day13-波波牛的星系" class="headerlink" title="22冲刺day13 波波牛的星系"></a>22冲刺day13 波波牛的星系</h3><blockquote><p>给定 $Graph(n, m)$ 的仙人掌, 根为 $r$ , 无奇环, 有重边, 将边定向从距离 $r$ 小的到距离 $r$ 大的, 求形成的DAG的拓扑序个数.</p><p>$n\le 5000$</p></blockquote><p>仙人掌? 考虑圆方树上dp, 那么圆点的dp值代表圆方树的树内的方案数, 然后合并是一个组合数, 硬做就行(</p><h2 id="Day14"><a href="#Day14" class="headerlink" title="Day14"></a>Day14</h2><h3 id="22冲刺day14-灰烬十字"><a href="#22冲刺day14-灰烬十字" class="headerlink" title="22冲刺day14-灰烬十字"></a>22冲刺day14-灰烬十字</h3><blockquote><p>求 $n\times n$ 的国际象棋棋盘上放 $k$ 个象使得它们无法互相攻击的方案数, 对所有 $k$ 输出答案.</p><p>$n\le 4000$</p></blockquote><p>简单dp.</p><p>众所周知象棋的象分为黑格象和白格象, 两种是完全独立的.</p><p>此时单独拿出来所有黑格&#x2F;白格去, 那么把它相同长度的行放在一起递增的重排是等价的, 然后dp就行了.</p><h3 id="22冲刺day14-斗鸡"><a href="#22冲刺day14-斗鸡" class="headerlink" title="22冲刺day14-斗鸡"></a>22冲刺day14-斗鸡</h3><blockquote><p>给定 $2m$ 个互不相同的区间, 求构造 $a_n$ 使得其中恰好有 $m$ 个区间包含至少两个相同的数.<br>$2m, n\le 2\times 10^5$</p></blockquote><p>考虑互不相同这个条件, 发现那么让一个区间包含只要给两个端点处相等, 其他区间没有一个会同时包含这两个点.</p><p>那么得到一个做法: 按区间长度最大的 $m$ 个的两个端点设为相同的值, 其他的赋成互不相同的即可.</p><p>但这个不显然的是假的, 考虑如果有两个区间的端点相同后面的会把前面的覆盖了.</p><p>那么修补上这个好像就真了.</p><h3 id="22冲刺day14-猪尾巴"><a href="#22冲刺day14-猪尾巴" class="headerlink" title="22冲刺day14-猪尾巴"></a>22冲刺day14-猪尾巴</h3><blockquote><p>求字符集为 $C$ 的 $s_n$ 中不包含长 $k$ 的回文串的有几个. 膜998244353.</p><p>$n\le 5000, k\le 25, C\le 998244353$</p></blockquote><p>容斥, 带着系数dp, 设 $f_{i, U}$ 表示前 $n$ 个, 容斥后最最后 $k$ 个位置的并查集为 $U$ , 这里并查集指的是哪些位置值相同, 每次决策当前位置是不是一个回文串. 要预处理 $U$ 的转移. 看起来很爆炸但实际上 $U$ 的种类很少. (因为并查集中每次加 $k$ 条边)</p><h3 id="22冲刺day14-香蕉公司"><a href="#22冲刺day14-香蕉公司" class="headerlink" title="22冲刺day14-香蕉公司"></a>22冲刺day14-香蕉公司</h3><blockquote><p>给定排列 $a_n$ , $p_n$ , 一开始 $a_i&#x3D;p_i&#x3D;i$ , $A$ 为排列的序列, 满足 $A_1&#x3D;a, A_{i, j}&#x3D;A_{i-1, p_j}$ , 若干次操作, 每次交换 $a$ 中两个数, 交换 $p$ 中两个数, 或求 $A_x$ , $A_y$ 的字典序谁更大.</p><p>$n\le 2\times 10^5, x, y\le 10^18$</p></blockquote><p>好像还挺容易? 但根本写不动.</p><p>由于是排列的置换, 经典的把它拆成环, 考虑 $A_{x, i}&#x3D;A_{y, i}$ 不同当且仅当这个位置的环长 $l$ 满足 $a_x\equiv a_y \pmod l$ . 考虑线段树维护环的大小, 每个环存在其中下标最小的元素的位置, 这样只要看 $x, y$ 膜一个前缀的lcm是否同余就可以确定是否相同, 于是用这个线段树上二分处理查询, 再经典的用平衡树维护环, 因为维护lcm所以复杂度是 $\log^2 n$ .</p><p>lcm可能会溢出, 但是没有关系, 考虑因为取模运算大于被取模的数的数都不用管, 那么就记录成inf即可.</p><p>另外考虑, lcm的值域段只有 $\log$ 段, 通过这个可以做到1log.</p><p>值得注意的是平衡树维护序列, 支持串接和拆分当然众所周知, 实现的时候平衡树节点是没有满足二叉搜索树性质的键的, 就是我们合并, 拆分的操作不依赖对键值的判断维护其正确性, 而是天生满足了BST的结构, 这样做就不用纠结一开始该给节点赋什么下标, 或者后来需要对BST键值整体加的操作之类的了.</p><p>考虑另一种思路是不需要维护lcm, 只要判断 $\vert x-y\vert$ 是否被其中所有数整除, 所以直接维护gcd即可.</p><p>最后一个方案是直接根号, 不同的长度只有根号种, 暴力遍历, 因为数据是随的这个跑到比其他的都快.</p><h2 id="Day15"><a href="#Day15" class="headerlink" title="Day15"></a>Day15</h2><h3 id="22冲刺day15-面试"><a href="#22冲刺day15-面试" class="headerlink" title="22冲刺day15 面试"></a>22冲刺day15 面试</h3><blockquote><p>给定 $a_n$ , 求把它们分成若干组, 每组任意重排, 要求最后没有相邻两元素相同. 最小化组数.</p><p>$n\le 10^5$</p></blockquote><p>考虑, 如果出现次数最多的没有出现一半以上, 那一定可以用一组搞定, 因为让两个不相等的数变的相等只会让问题更困难, 而出现次数正好一半的十分好做: 直接插开即可. 而如果那个出现了一半以上, 就把多的部分每个单放一组, 剩下的一起一组.</p><p>于是对出现次数排序, 先把最大值插进去, 然后用一个链表一个指针维护着每次往里插入一个颜色的所有位置即可.</p><h3 id="22冲刺day15-对赌"><a href="#22冲刺day15-对赌" class="headerlink" title="22冲刺day15 对赌"></a>22冲刺day15 对赌</h3><blockquote><p>打赌, 有 $p$ 的概率赢, $1-p$ 的概率输, 输 $m$ 次你就重开, 不输 $m$ 次但你想开了也可以重开, 重开后会清空胜利和失败记录, 求最少期望多少次可以赢 $n$ 次.</p><p>$n, m\le 1000$</p></blockquote><p>直接dp, 就是 $f_{i, j}$ 表示赢 $i$ 次, 输 $j$ 次的期望次数, 于是 $f_{i, j}&#x3D;\max (pf_{i+1, j}+(1-p)f_{i, j+1} , f_{0, 0})$ , 转移成环, 但只取决于 $f_{0, 0}$ 这一个位置, 直接二分 $f_{0, 0}$ 的值直到推出的值和实际相同即可.</p><p>这个题要求期望与实际值绝对误差或相对误差不超过 $10^-6$ , 成功的因为卡绝对误差 $100\to 40$ , 不过qyc也被骗了</p><p>如果要求取模, 可以先用实数跑出来实际上每个位置选择重开还是不重开, 然后再用取模的跑出答案.</p><h3 id="22冲刺day15-探险"><a href="#22冲刺day15-探险" class="headerlink" title="22冲刺day15 探险"></a>22冲刺day15 探险</h3><blockquote><p>给定 $a_n, b_n$ , 表示了两条折线 $(1, a_1), (2, a_2)\ldots, (1, b_1), (2, b_2)\ldots$ , 保证 $a_i&gt;b_i$ , 于是求现在你选择两条平行线, 要求你可以在平行线内从线段 $(1, a_1), (1, b_1)$ 走到 $(n, a_n), (n, b_n)$ , 中途不穿过折线(可以沿着在上面走), 求平行线之间的最小距离.</p><p>$n\le 10^6$</p></blockquote><p>考虑把上折线的下凸壳和下折线的上凸壳求了, 那么一个凸壳要求你选的线必须在凸壳以外, 于是你就枚举上&#x2F;下凸壳上的边, 去另一个上面求即可.</p><h3 id="22冲刺day15-狮子"><a href="#22冲刺day15-狮子" class="headerlink" title="22冲刺day15 狮子"></a>22冲刺day15 狮子</h3><blockquote><p>给定 $a, b, c, p, q, n$ , 求 $\sum_{i\in [0, n]} \sum_{1\le cj\le ai+b} i^pj^q \pmod 998244353$</p><p>$n, c, a, b\le 10^9$ , $p, q\le 50$</p></blockquote><p>万欧冲!</p><h2 id="Day16"><a href="#Day16" class="headerlink" title="Day16"></a>Day16</h2><p>太拉了, 会0题.</p><h3 id="22冲刺day16-石头"><a href="#22冲刺day16-石头" class="headerlink" title="22冲刺day16-石头"></a>22冲刺day16-石头</h3><blockquote><p>给定序列 $a_n$ , 每个数有颜色 $c_i\in [0, 1]$ , 每次可以删掉一个数, 此时若相邻两个数和它颜色都不同并且它不在最边上你会获得 $a_i$ 分, 最大化得分.</p><p>$n\le 3\times 10^5$</p></blockquote><p>考虑首先一开始序列有若干个连续段, 可以等价把一个连续段看成一个点, 然后其价值是里面数的最大值. 你发现你干的事是每次删掉一个段, 然后合并与它相邻的两个连续段,<strong>这个操作等价于每次删掉相邻的两个连续段, 获得其中大的那个的贡献</strong>.</p><p>现在仍然不会dp&#x2F;贪心, 发现实际上通过这个策略可以得到原序列的任意一半的连续段, 于是答案是前一半大.</p><h3 id="22冲刺day16-序列"><a href="#22冲刺day16-序列" class="headerlink" title="22冲刺day16-序列"></a>22冲刺day16-序列</h3><blockquote><p>给定 $s_n, t_m$ , 求 $s$ 的最长子序列 $s’$ 的长度, 使得 $LCS(s’, t)\le 1$ .</p><p>$n, m\le 5\times 10^5$</p></blockquote><p>考虑题目的限制, $a$ 可以在 $b$ 前面出现当且仅当 $a$ 最后一次出现比 $b$ 第一次出现晚.</p><p>于是可以接在后面这一关系是传递的. 我天我居然没发现这一点.</p><p>那剩下就是线段树优化dp板子.</p><h3 id="22冲刺day16-工厂"><a href="#22冲刺day16-工厂" class="headerlink" title="22冲刺day16-工厂"></a>22冲刺day16-工厂</h3><blockquote><p>有 $n$ 个工厂, 每个需要 $1$ 的资源启动, 启动后每 $a_i$ 天生产 $b_i$ 的资源, 中间时刻不生产资源. 一开始你有 $1$ 个资源, 求最短时间把所有工厂启动.</p><p>$n\le 16, a_i\le 5\times 10^7, b_i\le n$</p></blockquote><p>考虑假设确定了工厂的依赖关系(谁用谁产的资源启动), 那么时间计算可以是树形dp, $f_u$ 表示 $u$ 子树内的答案, 于是因为由同一个启动的你肯定从时间长的开始启动, 所以就是</p><p>$$<br>f_u&#x3D;\max_i { a_u \lfloor \dfrac{i}{b_u} \rfloor + f_{v_i} }, \ s. t. \ v_i\le v_{i-1}<br>$$</p><p>于是对着这个dpofdp, 设 $f_{S}$ 表示 $S$ 内点的最小时间, 那么有</p><p>$$<br>f_S&#x3D;\min_{u, T_1\ldots T_l, \ s. t. \ T_1\cup T_2\ldots T_n \cup {u} } \max_i  { a_u (\lfloor \dfrac{i}{b_u} \rfloor + 1) + f_{T_n} }<br>$$</p><p>复杂度是子集内再dp的 $3^n n^2$</p><p>可以优化, 考虑设 $h_{u, S}$ 表示以 $u$ 为根, 不算 $u$ , 其余节点的代价, 再把 $b_u$ 个 $T_i$ 一起考虑, 设 $g_{k, S}$ 表示用 $k$ 个子集拼成 $S$ 的 $\min f_T$ , 于是用 $g$ 转移 $h$ , 用 $h$ 转移 $f$ . 复杂度就是 $n3^n$ .</p><p>这题有诸多乱搞, 包括什么shuffle点亮次序(这个是对的是因为同时点亮的部分是不计顺序的, 所以可以除掉不少阶乘), 退火, 还有神秘的爆搜和贪心性价比.</p><h3 id="22冲刺day16-火柴"><a href="#22冲刺day16-火柴" class="headerlink" title="22冲刺day16-火柴"></a>22冲刺day16-火柴</h3><blockquote><p>$(n-1)\times (m-1)$ 个格子的网格图, 每根火柴可以放在边上或对角线上, 任意两根不能在非端点处相交, 火柴看作边, 与格点形成连通图, 求有多少种方案把一个火柴移动到另一个位置让图仍然连通.</p><p>$n, m\le 700$</p></blockquote><p>首先跑个边双缩点成树, 缩起来的点都可以任意连, 现在只考虑树边.</p><p>于是对每个树边, 要计算有多少种方式从子树内连出去, 那么用平衡树&#x2F;hash启发式合并维护子树的外边界, 并且记录不能放置朝外的对角线的边界的个数(如果一个对角线火柴横在子树内外之间你不能放一个跨过它的), 就行了.</p><h2 id="Day17"><a href="#Day17" class="headerlink" title="Day17"></a>Day17</h2><h3 id="22冲刺day17-磁铁"><a href="#22冲刺day17-磁铁" class="headerlink" title="22冲刺day17-磁铁"></a>22冲刺day17-磁铁</h3><blockquote><p>给定区间 $[l, r]$ , 求区间中使得各位数码乘积最大的数(十进制).</p><p>$l, r\le 10^18$</p></blockquote><p>数位dp-模板</p><h3 id="22冲刺day17-假牙"><a href="#22冲刺day17-假牙" class="headerlink" title="22冲刺day17-假牙"></a>22冲刺day17-假牙</h3><blockquote><p>Alice 和 Bob 在进行一局酒馆战棋游戏. 他们想让你帮他们算出最后的胜负情况. 每个人初始会有不超过 7 个随从, 这里我们认为每个随从的初始攻击力等于初始血量.<br>游戏流程如下:<br>拥有随从数较多的一方会优先发起攻击, 如果随从数相同, 那么双方各有 50% 的概率优先发起攻击.<br>双方轮流发起攻击, 每一次攻击方发起进攻时, 会选择未被消灭的随从中最左侧的发起过攻击次数最少的随从, 让其随机攻击一个敌方未被消灭的随从. 若 $x&#x2F;y$ 表示一个攻击力为 $x$ , 当前血量为 $y$ 的随从. 当一个 $x_1&#x2F;y_1$ 的随从攻击 $x_2&#x2F;y_2$ 的随从时, 它们会互相造成等同于攻击力的伤害, 即 $y_1$ 会变成 $y_1-x_2$ , $y_2$ 会变成 $y_2-x_1$ . 在一个生物血量小于或等于 $0$ 时, 这个生物被消灭.<br>当有至少一方的随从全部被消灭时, 游戏结束, 还剩有随从的一方胜利. 若均无剩余随从, 该局游戏为平局.<br>你需要输出 Alice 胜利, Bob 胜利, 平局分别的概率.</p><p>保证 $1\leq n, m\leq 7, 1\leq a_i, b_i\leq 10^9$ .</p></blockquote><p>猜一手状态少, 爆搜过了!</p><h3 id="22冲刺day17-冰块"><a href="#22冲刺day17-冰块" class="headerlink" title="22冲刺day17-冰块"></a>22冲刺day17-冰块</h3><blockquote><p>给定 $s_1\ldots s_n$ , 求有多少个本质不同 $(p, q)$ 满足回文串 $p, q$ 均出现在至少一个 $s$ 中且 $p+q$ 是回文串.</p><p>$n\le 10^6$ , 3s</p></blockquote><p>考虑 $p, q, p+q$ 都为回文串的条件, 发现此时 $p+q$ 有三个对称轴, 就能产生出许多平移的条件, 结论是:</p><p>[trick]<strong>若 $p, q, p+q$ 为回文串, 则 $p, q$ 拥有共同的最小整周期.</strong></p><p>[trick] 一个字符串本质不同回文子串有线性个.</p><p>这个可以考虑SAM的每个等价类, 发现若包含两个回文串则对称两下一定出现次数不一样, 不是一个等价类.</p><p>[trick] 回文串的整周期也是回文串.</p><p>可以直接感觉一下.</p><p>于是就直接hash求所有本质不同回文子串, 再遍历每一个本质不同回文串当做最小整周期, 看它最多重复多少次即可.</p><h3 id="22冲刺day17-飞毯"><a href="#22冲刺day17-飞毯" class="headerlink" title="22冲刺day17-飞毯"></a>22冲刺day17-飞毯</h3><blockquote><p>给定正整数 $n$ , 你需要找到一个长度为 $n$ 的 $01$ 串使得本质不同子串个数最大.<br>$n\le 4\times 10^5$</p></blockquote><p>[trick] 存在 $k$ 满足最优解长度不超过 $k$ 的所有串均出现, 超过 $k$ 的所有区间互不相同. 其中 $k$ 为最大的满足 $2^k+k-1\le n$ 的数.</p><p>于是构造长 $k$ 的串均出现的字符串, qyc口中的经典结论是, $2^k$ 个点, 点 $x$ 连向 $2x$ 和 $2x+1$ (以下均在膜 $2^k$ 意义下), 则存在一个欧拉回路. 构造方式是, 因为 $x$ 与 $x+2^{k+1}$ 的出边相同, 均为 $2x, 2x+1$ , $2x, 2x+1$ 这两个都入边集合均为 $x, x+2^{k-1}$ , 所以可以分配出边使得每个点出度, 入度为1. 于是现在有若干个环, 发现一定存在 $x$ 和 $x+2^{k-1}$ 不在同一个环(反证, 如果所有 $x$ 和 $x+2^{k-1}$ 在一个环, 于是所有 $2x, 2x+1$ , 于是所有 $4x+1, 4x+2, 4x+3, 4x+4\ldots$ ), 于是交换两点出边合并环, 最后一定能合并到一个环.</p><p>当 $2^k+k-1&lt;n$ 时, 就是要在 $2^{k+1}$ 个点的有向图上找长 $n-k$ 的路径, 每个 $x, x+2^k$ 至少包含一个, 于是先找一个 $2^k+k-1$ 的环, 然后对于每个 $x\in [0, 2k)$ , $x, x+2^k$ 中有一个出边确定, 可以固定另一个的出边, 于是形成若干个小环和找到的答案, 那就用刚才的方式把小的不断合并到大的上, 最后从大环上取包含没有合并的那个大环的一个区间作为答案.</p><h2 id="Day18"><a href="#Day18" class="headerlink" title="Day18"></a>Day18</h2><h3 id="22冲刺day18-A-Typewriter"><a href="#22冲刺day18-A-Typewriter" class="headerlink" title="22冲刺day18-A-Typewriter"></a>22冲刺day18-A-Typewriter</h3><blockquote><p>求尽可能少的 $k$ 个十进制下不含01的整数加起来为 $n$ .</p><p>$n\le 10^100, T\le 1000$</p></blockquote><p>看起来是见鬼分类讨论构造.</p><p>首先很容易看成最多用3个, 可能用2个.</p><p>不想分类讨论, 选择dp: 直接 $f_{i, j, k}$ 表示最低的 $i$ 位, 向上进位为 $j$ , 现在还有 $k$ 个数不全为 $0$ (意思是, 剩下的数后面的部分都是前导0). 暴力转移.</p><p>分类讨论也是可以的, 打个表发现只有某些情况不能用两个, 就构造一个三上去, 反正怎么做都很麻烦.</p><h3 id="22冲刺day18-B-Graph"><a href="#22冲刺day18-B-Graph" class="headerlink" title="22冲刺day18-B-Graph"></a>22冲刺day18-B-Graph</h3><blockquote><p>给定 $Graph(n, m)$ , 点有权值 $v_i$ , 所有边权值都是 $1$ . 若 $v_i\mathrm{and} v_j&#x3D;v_j$ 则加边 $i\to j$ .</p><p>$n, m\le 2\times 10^5, v\le 2^20$</p></blockquote><p>看后面那个加边条件考虑FMT, 发现这是个子集和关系, 于是直接FMT优化建图+bfs即可.</p><p>来自dwt: 不用FMT, 直接值 $S$ 向 $S-2^i$ 连边即可.</p><h3 id="22冲刺day18-C-Cactus"><a href="#22冲刺day18-C-Cactus" class="headerlink" title="22冲刺day18-C-Cactus"></a>22冲刺day18-C-Cactus</h3><blockquote><p>如果一个无向联通简单图的每个点至多在一个简单环中, 我们就称之为点仙人掌.</p><p>我们现在定义一个新的概念有根外向点仙人掌, 如果一个有向图是有根外向点仙人掌, 它需要满足:</p><p>对于一个有向图, 将其所有的边全变为无向边后是一个点仙人掌;<br>从某一个节点(根)出发, 可以到达图中的任意节点;<br>图中的所有环(有向环)与无向图的环一一对应.<br>其实可以发现, 有根外向点仙人掌就是外向有根树的节点还可以是一个环.</p><p>现在 Cuber QQ 要在一个有根外向点仙人掌上随机游走了, 现在这个有根外向点仙人掌的根为 $1$ , 而且他有一个终点顶点的集合 $S$ , 他游走的流程是:</p><p>一开始位于节点 $1$<br>如果当前所在的顶点是 S 中的顶点, 则他会结束游走<br>如果从当前所在的顶点开始无法走到任意的 $S$ 中的顶点, 则回到节点 $1$ (也相当于都一条边); 否则, 从当前所在的顶点的出边中等概率的选择一个点作为下一个点<br>返回第二步<br>Cuber QQ 每走一条边都需要花费一个单位时间(包括回到节点 $1$    的过程), 现在 Cuber QQ 想知道他随机游走的期望时间模 $p$ 的结果.</p><p>$n\le 10^5$ , $p$ 是质数.</p></blockquote><p>考虑树怎么做, 直接dp, $f_i$ 表示从 $i$ 出发的期望, 确定起点dp值 $x$ 之后每个点dp值是 $ax+b$ , 直接dp完解方程即可.</p><p>现在有了环, 考虑对于一个环, 设其离根最近的点为 $u$ , 每个点 $v$ 设下一步在环上的概率为 $p_v$ , 走出去期望答案为 $e_v$ , 在设从 $u$ 走到 $v$ 的概率是 $h_v$ , 于是直接 $f_u&#x3D;\sum_{0}^k h_i(1-p_i)(i+e_i)+\prod p_i(f_u+(s+1))$</p><h3 id="22冲刺day18-D-Melody"><a href="#22冲刺day18-D-Melody" class="headerlink" title="22冲刺day18-D-Melody"></a>22冲刺day18-D-Melody</h3><blockquote><p>求 $a_n$ 满足 $a_i\in [1, v_i]$ 且 $\forall i, a_{[1, i]}\ne a_{[n-i+1, n]}$ 的数量, 膜998244353, $n\le 2\times 10^6$ .<br>$v_i\le v_{i+1}$</p></blockquote><p>它让我们求一个无border串个数.</p><p>考虑dp, 设 $f_i$ 表示长 $i$ 的串的方案数, 考虑用总共的减去有border的, 钦定只有最长&#x2F;最短的有贡献, 发现这里最短的border是性质好的: 一定是一个无border串. 于是就有</p><p>$f_n&#x3D;s_n-\sum_{2i\le n} \dfrac{f_i}{s_i}\times s_{n-i}$ , 其中 $s$ 为 $v$ 的前缀积.</p><p>然后所有人都知道下一步分治FFT可以2log, 如果没有这个 $2i\le n$ 的限制我们会直接转求逆1log.</p><p>好吧, 分治fft没敢写, 但std确实是在搞2log过 $2\times 10^6$ 啊. </p><p>[think] 钦定为最短的发现最短的一定无border这一步是经典trick.</p><h2 id="Day19"><a href="#Day19" class="headerlink" title="Day19"></a>Day19</h2><h3 id="22冲刺day19-k宝"><a href="#22冲刺day19-k宝" class="headerlink" title="22冲刺day19-k宝"></a>22冲刺day19-k宝</h3><blockquote><p>给定排列 $p_n$ , 有若干位置不确定, 问填数方案使得其最少被 $m$ 个奇偶性相同的子区间完全覆盖.</p><p>$n\le 300$</p></blockquote><p>直接dp, $f_{i, j, k, 0&#x2F;1}$ 表示前 $i$ 个数, 分 $j$ 段, 已经用了 $k$ 个奇数, 最后一段的奇偶性, 暴力转移即可.</p><h3 id="22冲刺day19-什么时候"><a href="#22冲刺day19-什么时候" class="headerlink" title="22冲刺day19-什么时候"></a>22冲刺day19-什么时候</h3><blockquote><p>定义一个数列 $c$ 是良好的, 对于整数 $k$ , 当且仅当它满足以下条件:</p><ol><li>$0\le c_i\le b_i$ .</li><li>$\sum c_i&#x3D;\sum a_i$</li><li>$c$ 数组中至少 $k$ 个 $0$ .</li></ol><p>令 $f(k)$ 表示对于所有良好的整数数列 $c$ , $\sum \vert c_i−a_i\vert$ 最小值. 对于 $k\in [0, n)$ , 求 $f(k)$ . 如果不可能满足输出 $−1$ .</p><p>$n, a_i, b_i\le 200$</p></blockquote><p>首先一个暴力dp: $f_{i, j, k}$ 表示前 $i$ 个数, 和为 $j$ , 已经有 $k$ 个0的最小值.</p><p>考虑因为 $\sum a_i&#x3D;\sum c_i$ , 答案为 $c_i&lt;a_i$ 部分的两倍, 又因为如果 $c_i&lt;a_i$ , 一定是 $c_i&#x3D;b_i&lt;a_i$ , 于是贡献就确定了.</p><p>$f_{i, j, k}$ 表示前 $i$ 位, 钦定了 $j$ 位是 $0$ , 不等于0的部分 $b_i$ 和为 $k$ , 复杂度 $n^3v$</p><h3 id="22冲刺day19-带我上"><a href="#22冲刺day19-带我上" class="headerlink" title="22冲刺day19-带我上"></a>22冲刺day19-带我上</h3><blockquote><p>给定 $n\times m$ 的矩阵, $q$ 次给第 $x$ 行, 第 $y$ 列加1, ( $(x, y)$ 被加两次), 求最后有多少种操作序列使得矩阵中恰好有 $k$ 个格子为奇数.</p><p>$n, m\le 2000, T\le 50, k\le nm, q\le 10^{18}$</p></blockquote><p>考虑行和列的相对合并, 设 $f_i, g_j$ 表示操作 $q$ 次后有 $i$ 行翻转, $j$ 列翻转的方案数, 那么显然若 $im+jn-2ij&#x3D;k$ , 则答案加上 $f_ig_j$ .</p><p>于是考虑怎么求 $f_i$ , 一个 $nq$ 的dp是简单的: $f_{i, j}$ 表示 $i$ 次操作, 现在有 $j$ 行被翻了奇数次, 直接转移.</p><p>考虑EGF去算组合数, 如果第 $i$ 行是翻转, 那么被覆盖的次数是 $1, 3, 5\ldots$ , EGF应该是 $\dfrac{e^x-e^{-x} }{2}$ , 否则是 $\dfrac{e^x+e^{-x}}{2}$ . 于是最后 $i$ 行翻转的方案数是</p><p>$$<br><a href="%5Cdfrac%7Be%5Ex-e%5E%7B-x%7D%7D%7B2%7D">z^q</a>^i(\dfrac{e^x-e^{-x} }{2})^{n-i}<br>$$</p><p>$q$ 很大, 但容易看出最后的结果一定是 $\sum a_ie^{ix}$ 形式, 就是说我们没必要把它拆开, 而是直接带着 $e^x$ 算, 此时算出 $k&#x3D;0$ 之后每次就是卷上一项再除掉一项, 单次线性, 于是复杂度就是 $n^2$ 的.</p><h3 id="22冲刺day19-炒饭大师"><a href="#22冲刺day19-炒饭大师" class="headerlink" title="22冲刺day19-炒饭大师"></a>22冲刺day19-炒饭大师</h3><blockquote><p>定义图 $Graph(n, m)$ 的线图 $L(G)$ 为 $G$ 边看作点, 与同一个点相连的边连一个团(就是做朴素点边互换)得到的图. $L^k(G)$ 表示变换 $k$ 次, 问 $L^k(G)$ 的最大独立集, 膜998244353</p><p>$n, m\le 2000, k\le 7$</p></blockquote><p>todo</p><h2 id="Day20"><a href="#Day20" class="headerlink" title="Day20"></a>Day20</h2><h3 id="22冲刺day20-薰衣草"><a href="#22冲刺day20-薰衣草" class="headerlink" title="22冲刺day20-薰衣草"></a>22冲刺day20-薰衣草</h3><blockquote><p>给定序列 $b_n$ , $a_n$ , A, B博弈, A先手轮流, 第 $i$ 次操作可以选择删掉所有 $j$ 为 $b_i$ 倍数的 $a_j$ 或者所有不为 $b_i$ 倍数的 $a_j$ , 游戏结束后得分为剩下的 $a$ 中数之和, A希望最小化, B希望最大化, 求最后得分.<br>$n\le 10^4, m\le 10^5$</p></blockquote><p>考虑一个人什么时候可以把结果变成0, 考虑一个人操作的数, 如果前面一个数是其他数的lcm的因数, 那么只要让那个数删是倍数, 其他数都删不是倍数, 就全是0了, 如果没有这种情况, 那么考虑必然每个数都要贡献整体的lcm(就是, 每个数都作为整体的lcm的至少一个质因子的最大值), 于是lcm最小是前若干个质数的乘积, 而且若lcm大于值域, 只要每个数都删不是倍数的就删空了. 所以一个人最多操作14次, 两个人28次就会全0.</p><p>于是如果 $m&gt;27$ , 那么两个人都有能力把结果变成0, 此时结果显然是0.</p><p>于是现在 $m\le 27$ , 可以直接写爆搜, 因为一个数每次只会进入一个分支, 所以搜的每一层的总数都是 $n$ , 复杂度是 $nm$ .</p><h3 id="22冲刺day20-风信子"><a href="#22冲刺day20-风信子" class="headerlink" title="22冲刺day20-风信子"></a>22冲刺day20-风信子</h3><blockquote><p>求下图的最大流: 源点为 $S$ , 汇点为 $T$ , 包括源汇总共 $n+2$ 个点. $S$ 向 $i$ 连边, 流量为 $a_i$ ; $i$ 向 $T$ 连边, 流量为 $b_i$ ; $i$ 向 $p_i$ 连边, 流量为 $c_i$ . 保证 $p_i\ne i$ .</p><p>$n\le 10^6$</p></blockquote><p>考虑这是内向基环树森林, 那么显然可以直接确定叶子: 先尽可能流汇点, 多的流到父亲, 于是现在剩下若干个环, 只要让每个环推流两遍就一定都推完了.</p><h3 id="22冲刺day20-栀子花"><a href="#22冲刺day20-栀子花" class="headerlink" title="22冲刺day20-栀子花"></a>22冲刺day20-栀子花</h3><blockquote><p>给定 $a_n$ , 单点修改, 或者询问区间 $[l, r]$ 中有多少子区间 $[l’, r’]$ 满足 $a_{l’+i-1}\ge i$ .</p><p>$n, q\le 10^6$</p></blockquote><p>先给每个位置减去下标, 判定标准变成 $\forall i\in [l, r], a_i\ge -l$</p><p>考虑类似CF1736C, 设 $r_i$ 表示一个左端点对应最大右端点位置. 发现我们只会改小不会改大, 改小是把前面一个区间取 $\min$ , 发现改大的时候左边的 $r$ 会延伸到我们也不知道哪, 但你应该意识到<strong>这就说明考虑 $r$ 的变化是走不通的, 不如考虑 $r$ 实际上是什么</strong>. 因为限制是 $a_i\ge -l\Longleftrightarrow -a_i\le l$ , 所以把 $a_i$ 取负似乎更好, 此时发现每个 $r$ 就是前缀最大值, 设第 $i$ 个前缀最大值为 $m_i$ , 则对应左端点为 $m_i-m_{i-1}$ .</p><p>于是我们要求的就是</p><p>$$<br>\sum_{j&#x3D;2}^k (m_i-m_{i-1})\times p_i<br>$$</p><p>那么可以用数据结构维护前缀max, 比如楼房重建线段树, $calc(x, y)$ 表示 $x$ 对应区间左边插一个 $y$ 的答案, 那么情况就是左区间最大值大于它, 就是左区间的这个和右区间维护的以左区间最大值位 $x$ 的, 左区间最大值小于就只有右区间, 去算就行了. 说是可以线段树套可持久化平衡树. 复杂度也是2log.</p><p>考虑因为只有单点修改, 所以扫描序列维维护时间维, 那么要做的就是每次区间取max, 查询是问一个点历史的这个信息, 问题是不是前缀询问啊?</p><p>发现实际上从某个左端点开始相当于赋初值 $l-1$ 即可, 每个查询都在一个单独的时间上即可.</p><h3 id="22冲刺day20-郁金香"><a href="#22冲刺day20-郁金香" class="headerlink" title="22冲刺day20-郁金香"></a>22冲刺day20-郁金香</h3><blockquote><p>给定 $k\times k$ 网格图, $(x, y)$ 与 $(x+1, y), (x, y+1)$ 连长1的边, 另有 $n$ 条边从 $(x_i1, y_i1)\to (x_i2, y_i2)$ , 边长为距离减1, 求每个无序点对的最短路长度之和.<br>膜 $998244353$ , $n\le 500, k\le 10^9$</p></blockquote><p>从 $(a, b)\to(c, d)$ , 假设 $a&lt;c, b&lt;d$ .</p><p>那么这是一个向右下走的过程, 容易发现因为特殊边只能节省1, 所以我们确实只会向右下走而不会有向左向上.</p><p>于是把横纵坐标离散化, 现在分别只有 $n$ 个, 一共就有 $n^2$ 个点和 $n^4$ 个点对, 在这上面算, 复杂度 $n^4$ .</p><p>考虑只枚举一个左上角, 此时第 $i$ 个特殊边的终点相当于对一个右下角矩形取max $dis_i$ , 其中 $dis_i$ 是左上角能到它经过的最多特殊边数, 最后查询全局和. 此时发现取同一个 $max$ 的一定是一个阶梯状, 于是扫描线扫max用set维护这条阶梯状分界线的所有拐点, 维护圈起来的面积, 每次插入一个矩形的时候就是从这条轮廓线上找到对应位置把这个矩形的轮廓并进去, 删掉里面的并更新面积, 复杂度 $n^3\log n$ .</p><p>考虑问题的性质, 发现若一个位置被取max了 $a$ , 一定在这之前被取max了 $a-1$ , 因为能走 $a-1$ 条特殊线的终点一定可以到达走 $a$ 步的, 于是可以对每一层分别算矩形面积并再加起来, 这个面积并不用线段树维护扫描线, 因为扫描线上区域只变多不变少(每一层都是阶梯). 复杂度 $n^3$ .</p><h2 id="Day21-赠送赛"><a href="#Day21-赠送赛" class="headerlink" title="Day21 赠送赛"></a>Day21 赠送赛</h2><p>打开题, 怎么是XIX OpenCup Grand Prix of Gomel原题.</p><h3 id="19金华普及线下-串"><a href="#19金华普及线下-串" class="headerlink" title="[19金华普及线下]串"></a>[19金华普及线下]串</h3><blockquote><p>给定 $s_n$ , 求有多少有序对 $(i, j, k)$ 满足 $[j+1, k]$ 可以由 $[i, j]$ 拓展而成, $t$ 的拓展是串 $a_1, a_2, \ldots a_k$ 串接起来, 其中 $a_1&#x3D;t$ , $a_i, a_{i-1}$ 至多只有一个字符不同.</p><p>$n\le 10^5, \vert \Sigma\vert \le 10^6$</p></blockquote><p>考虑 $n^2$ 做法, 枚举一个 $[l, r]$ , 若 $[l, r]$ 与 $[r+1, 2r-l+1]$ 只差一个, 则以 $[l, r]$ 开头的方案数等于 $[r+1, 2r-l+1]$ 的方案数加1.</p><p>考虑枚举长度 $L$ , 每 $L$ 个分一块, 那么按照求平方串的经典科技求一下这种差1的平方串(只要多求一次lcp, lcs), 表示为若干起点在 $[l, r]$ 的串, 因为 $[l, r]$ 只有 $\dfrac{n}{l}$ 个, 然后上面那个dp的转移旨在膜 $L$ 等价类内进行, 所以按照余数从小到大扫描线, 用set维护起点形成的连续段, 总复杂度2log.</p><h3 id="19金华普及线下-树"><a href="#19金华普及线下-树" class="headerlink" title="[19金华普及线下]树"></a>[19金华普及线下]树</h3><p>todo</p><h3 id="19金华普及线下-图"><a href="#19金华普及线下-图" class="headerlink" title="[19金华普及线下]图"></a>[19金华普及线下]图</h3><p>就是线图的线图</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杜赢OJ选做</title>
      <link href="/2022/10/23/dwtoj/"/>
      <url>/2022/10/23/dwtoj/</url>
      
        <content type="html"><![CDATA[<h2 id="21-BCT-NOIP-Day-1-2-暨-lt-高龙强总结-gt-登顶纪念赛"><a href="#21-BCT-NOIP-Day-1-2-暨-lt-高龙强总结-gt-登顶纪念赛" class="headerlink" title="21 BCT NOIP Day 1-2 暨&lt;高龙强总结&gt;登顶纪念赛"></a>21 BCT NOIP Day 1-2 暨&lt;高龙强总结&gt;登顶纪念赛</h2><h3 id="21-BCT-NOIP-Day-1-2-宝石-gem"><a href="#21-BCT-NOIP-Day-1-2-宝石-gem" class="headerlink" title="[21 BCT NOIP Day 1-2] 宝石 (gem)"></a>[21 BCT NOIP Day 1-2] 宝石 (gem)</h3><p>智障题</p><h3 id="21-BCT-NOIP-Day-1-2-小恐龙-dino"><a href="#21-BCT-NOIP-Day-1-2-小恐龙-dino" class="headerlink" title="[21 BCT NOIP Day 1-2] 小恐龙 (dino)"></a>[21 BCT NOIP Day 1-2] 小恐龙 (dino)</h3><blockquote><p>位置 $x$ 可以跳到 $x+1$ 或 $x+k$ , 若目标位置有障碍则不能跳, $q$ 次询问, 每次将一个格子变成障碍或者求恰好到第 $x$ 个格子的最小大跳(跳长 $k$ 的)次数.</p><p>$n, q\le 2\times 10^5, k\in [\dfrac{n}{100}, n-1]$</p></blockquote><p>我天看错题了!</p><p>看这个 $k\ge \dfrac{n}{100}$ 的特殊含义.</p><p>考虑一个朴素dp, $f_i$ 表示跳到 $i$ 的次数.</p><p>那么 $f_i$ 总和是 $100n$ 的. 考虑把这个做为势能.</p><p>那倒着做, 一开始每个势能都当成 $101$ , 每次会让一个位置能用, 就暴力更新它能更新到的所有位置, 如果一个位置更新了就往下接着更新否则就停, 就做完了.</p><h3 id="21-BCT-NOIP-Day-1-2-序列-sequence"><a href="#21-BCT-NOIP-Day-1-2-序列-sequence" class="headerlink" title="[21 BCT NOIP Day 1-2] 序列 (sequence)"></a>[21 BCT NOIP Day 1-2] 序列 (sequence)</h3><blockquote><p>给定序列 $a_n$ , 对每个 $k\in [2, n]$ , 求最短的区间 $[l, r]$ 满足在这个区间的数在 $a$ 中至少连续出现了 $k$ 次.</p><p>你的答案正确当且仅当与标准答案相对误差在 $6%$ 以内.</p><p>$n\le 10^5, a_i\le 10^6$</p></blockquote><p>这个 $6%$ 那必然是做法的关键.</p><p>考虑此时, 若真实答案是 $c$ , 那么 $[0. 94c, 1. 06c]$ 的答案都可以由 $c$ 表示. 那么你发现实际上 $10^6$ 种不同的答案可以由不到 $200$ 个 $c$ 表示.</p><p>那你就考虑对每个答案求连续出现长度, 如果值域上, 就是01序列, 支持单点改, 查全局最长连续段长度, 好像很难线性. 但从序列上是简单题, 双指针就完了.</p><h3 id="21-BCT-NOIP-Day-1-2-基础计数练习题-count"><a href="#21-BCT-NOIP-Day-1-2-基础计数练习题-count" class="headerlink" title="[21 BCT NOIP Day 1-2] 基础计数练习题 (count)"></a>[21 BCT NOIP Day 1-2] 基础计数练习题 (count)</h3><p>居然是CF1237F Balanced Domino Placements.</p><h2 id="21-BCT-NOIP-Day-1-1-暨-LKawaii-AK-纪念赛"><a href="#21-BCT-NOIP-Day-1-1-暨-LKawaii-AK-纪念赛" class="headerlink" title="21 BCT NOIP Day 1-1 暨 LKawaii AK 纪念赛"></a>21 BCT NOIP Day 1-1 暨 LKawaii AK 纪念赛</h2><h3 id="21-BCT-NOIP-Day-1-1-星形-star"><a href="#21-BCT-NOIP-Day-1-1-星形-star" class="headerlink" title="[21 BCT NOIP Day 1-1] 星形 (star)"></a>[21 BCT NOIP Day 1-1] 星形 (star)</h3><blockquote><p>给一个 $n$ 个点的树, 要删掉若干个点使得这棵树变成星形, 求方案. 星形定义是恰好一个点度数大于 $2$</p><p>$n\le 5\times 10^5$</p></blockquote><p>直接枚举每个节点为根去计数即可.</p><h3 id="21-BCT-NOIP-Day-1-1-树状数组-fenwick"><a href="#21-BCT-NOIP-Day-1-1-树状数组-fenwick" class="headerlink" title="[21 BCT NOIP Day 1-1] 树状数组 (fenwick)"></a>[21 BCT NOIP Day 1-1] 树状数组 (fenwick)</h3><blockquote><p>给定序列 $a_n$ , $q$ 次操作, 每次对区间 $\forall i\in[l, r]$ , 给 $[i-\mathrm{lowbit}(i), i]$ 加 $v$ , 或求区间和.</p><p>$n\le 10^6$</p></blockquote><p>把序列补齐成 $2$ 的幂, 则线段树节点和树状数组节点对应.</p><p>维护区间加标记和区间树状数组节点加标记, 树状数组节点加标记表示编号在这一区间的树状数组节点全被加了一个数值, 修改时如果被完整包含就给树状数组加标记加, 并且视情况打区间加. 因为可以预处理每个区间的树状数组加的实际对和大贡献所以可以合并标记. 复杂度 $m\log n$ .</p><h3 id="21-BCT-NOIP-Day-1-1-多叉树-ktree"><a href="#21-BCT-NOIP-Day-1-1-多叉树-ktree" class="headerlink" title="[21 BCT NOIP Day 1-1] 多叉树 (ktree)"></a>[21 BCT NOIP Day 1-1] 多叉树 (ktree)</h3><blockquote><p>给一个深度为 $n$ 的满 $k$ 叉树, 叶子节点权值初始为0, 非叶子节点权值为儿子之和. 一次操作可以给一个叶子加1, 求有多少操作序列满足, 对于任意一个节点 $u$ , $u$ 的儿子中权值的极差不超过1, 且满足 $m$ 条限制, $i$ 条是 $t_i$ 次操作的叶子必须是 $x_i$ .</p><p>膜998244353, $k\le 10^6$</p></blockquote><p>考虑 $m&#x3D;0$ 怎么做, 显然我们每次是对所有节点”轮着”加, 那么设 $f_n$ 表示深度为 $n$ 的答案, 发现 $f_n&#x3D;f_{n-1}\times (k! )^{k^{n-1}}$</p><p>解释就是经过 $k^{n-1}$ 次操作, 所有 $n-1$ 层节点的权值就会加1, ${(k! )}^{k^{n-1}}$ 就是考虑了这 $k^{n-1}$ 个第 $n-1$ 层的节点的孩子们加的顺序, 但还没考虑这 $k^{n-1}$ 个节点之间的顺序, 这个问题可以把这些节点视作叶子递归到 $f_{n-1}$ .</p><p>那么现在有了限制, 假设某个点的儿子种有 $x$ 个被固定, 显然方案数是 $(k-x)!$ , 那么分治的时候将限制分治到对应的儿子下面即可, 分治后有可能要对着同一个叶子加两次那就死了.</p><h3 id="21-BCT-NOIP-Day-1-1-括号序列-bracket"><a href="#21-BCT-NOIP-Day-1-1-括号序列-bracket" class="headerlink" title="[21 BCT NOIP Day 1-1] 括号序列 (bracket)"></a>[21 BCT NOIP Day 1-1] 括号序列 (bracket)</h3><blockquote><p>一个长 $2n$ 的括号序列是由 $n$ 种括号构成的序列, 保证每个括号只出现一正一反, 给出长 $2n$ 的序列 $a$ , 求方案把 $a$ 划分成两个子序列且子序列的括号配对合法.</p><p>$\sum n\le 1. 5\times 10^6$</p></blockquote><p>感觉D &lt; C啊.</p><p>考虑两个括号相交如 $\texttt{[(])}$ , 则必须分属不同的子序列.</p><p>那么你得到一个暴力建边+黑白染色的方法, 考虑如何在不建边的情况下做这个东西.</p><p>首先显然的, 把括号视作区间 $[l, r]$ , 那么相交的括号 $[x, y]$ 满足的限制是平面上两个 3-side 矩形. 也就是一个点连向一个矩形.</p><p>那么自然想到KDT, 但这里 $10^6$ 肯定过不了, 另一个想法是主席树优化建图(因为两个矩形都是3-side), 但常数太大实际也过不了.</p><p>考虑,<strong>数点实际上是丢了性质</strong>, 考虑从左往右扫, 把每个区间挂在右端点上, 当处理到 $[l, r]$ 时, 所有还挂在这个区间上的都作为它的儿子, 钦定 $[l, r]$ 是黑色, 那么可能会对所有儿子反色(子树取反), 这样求出来再check即可.</p><p>当我们不能建出所有关系的时候可以考虑把必要的关系建出来再判能不能行.</p><h2 id="21-BCT-NOIP-Day-2-暨-Dowt-总统膜拜功能上线纪念赛"><a href="#21-BCT-NOIP-Day-2-暨-Dowt-总统膜拜功能上线纪念赛" class="headerlink" title="21 BCT NOIP Day 2 暨 Dowt 总统膜拜功能上线纪念赛"></a>21 BCT NOIP Day 2 暨 Dowt 总统膜拜功能上线纪念赛</h2><h3 id="21-BCT-NOIP-Day-2-成绩-score"><a href="#21-BCT-NOIP-Day-2-成绩-score" class="headerlink" title="[21 BCT NOIP Day 2] 成绩 (score)"></a>[21 BCT NOIP Day 2] 成绩 (score)</h3><blockquote><p>两个随机排列 $a_n, b_n$ , 定义一个元素的排名它在两个排列中的位置之和的排名, 为现在已知某元素在第一个排列中位置为 $x$ , 第二个排列位置为 $y$ , 求它排名的期望.<br>膜998244353.<br>$n\le 998244352$</p></blockquote><p>用概率去考虑, 那么它的期望是每个元素在它前面的概率之和. (可以从期望的线性想).</p><p>那么一个元素在它前面的概率, 对于一个元素确定的在 $a$ 中排名 $u$ , 其 $b$ 中排名 $v$ 的可能取值是一个区间, 那就直接等差数列求和即可.</p><h3 id="21-BCT-NOIP-Day-2-插旗-flag"><a href="#21-BCT-NOIP-Day-2-插旗-flag" class="headerlink" title="[21 BCT NOIP Day 2] 插旗 (flag)"></a>[21 BCT NOIP Day 2] 插旗 (flag)</h3><blockquote><p>给定一棵 $n$ 点树, 每次你可以跳到一个当前没走过且距离不超过 $k$ 的位置, 求最小的 $k$ 可以走过树上所有点.<br>$n\le 10^4$</p></blockquote><p>考虑, 要走到一个子树一定要先走到其根, 并且我们要走一圈上来, 而我们希望最后一次往上跳的一布越靠上越好, 于是设 $f_u$ 表示 $u$ 出发从子树走一圈最后上来的那个节点的深度最小值, 每次会从最小的 $f_v$ 转移上来, 就行了.</p><h3 id="21-BCT-NOIP-Day-2-括号序列加强版-bracketplus"><a href="#21-BCT-NOIP-Day-2-括号序列加强版-bracketplus" class="headerlink" title="[21 BCT NOIP Day 2] 括号序列加强版 (bracketplus)"></a>[21 BCT NOIP Day 2] 括号序列加强版 (bracketplus)</h3><blockquote><p>小 T 得到了一个序列 $a$ . 如果一个序列能被看作一个括号序列, 那么小 T 称这样的序列为符合规范的超级括号序列.<br>“符合规范的超级括号序列”的定义如下:</p><ol><li>空序列, $S S$ 均是符合规范的超级括号序列, 其中 $S$ 表示一个在 $[1, n]$ 之间的正整数(以下规<br>则中的 $S$ 均为此含义);</li><li>如果 $A$ 为非空的符合规范的超级括号序列, 那么 $S A S$ 为符合规范的超级括号序列;</li><li>如果 $A$ 和 $B$ 均为符合规范的超级括号序列, 那么 $A B$ 为符合规范的超级括号序列;</li><li>所有符合规范的超级括号序列均可通过上述 $3$ 条规则得到.</li></ol><p>小 T 想知道有多少 $a$ 的非空子区间使得它是符合规范的超级括号序列.</p><p>$n\le 3\times 10^5$</p></blockquote><p>对着一个降智题想了一年并没想出来. 昨天qyc题明明是一样的技术</p><p>考虑判定一个整的可以直接用一个栈, 从左往右扫, 和栈顶一样就弹栈, 不一样就压栈.</p><p>然后发现一个区间合法当且仅当它这个栈在左端点和右端点长的一样, 直接hash就做完了.</p><h3 id="21-BCT-NOIP-Day-2-研究表明-string"><a href="#21-BCT-NOIP-Day-2-研究表明-string" class="headerlink" title="[21 BCT NOIP Day 2] 研究表明 (string)"></a>[21 BCT NOIP Day 2] 研究表明 (string)</h3><blockquote><p>给定一个01串 $a$ , 若 $a$ 生成 $b$ 当且仅当存在排列 $p_n$ 满足 $\forall i\in [1, n], -1\le p_i-i\le k, b_{p_i}&#x3D;a_i$ , 其中 $k$ 为给定的正整数, 求给定的 $a$ 的所有子区间能生成的01串个数之和. 并且因为 $a$ 太长了, 其是由输入串 $c_n$ 重复 $t$ 次得到的.</p><p>$n\le 2\times 10^6, t\le 10^9, k\le n-1$</p></blockquote><p>考虑对循环移位进行分解, 发现一定可以分解成<code>0 0 0 0 1</code>或<code>1 1 1 1 0</code>这样的段, 那么设 $f_i$ 表示以 $i$ 结尾的方案数, 发现它是区间 $f_j$ 和再加1得到. 而最后的答案就是 $f$ 的和, 发现这里暴力转移(而不是前缀和)的复杂度是对的, 因为它必须是一个01切换的时候付出前面连续段长度的代价. 现在可以做到 $nt$ 了.</p><p>考虑在这个基础上再进行一轮dp这个过程, 实际上只是给 $f_1$ 了一个初值, 而其他都没有变. 发现我们因为每次是一个求和, 所以实际上整个dp的值是一个一次函数, 把一次函数的值像这样复合到自己同样是一次函数, 所以我们是线性变换, 所以dp一轮直接写成矩阵快速幂即可.</p><h2 id="21-BCT-NOIP-Day-3-1-暨-gxd-停课纪念赛-amp-简单题信心赛"><a href="#21-BCT-NOIP-Day-3-1-暨-gxd-停课纪念赛-amp-简单题信心赛" class="headerlink" title="21 BCT NOIP Day 3-1 暨 gxd 停课纪念赛 &amp; 简单题信心赛"></a>21 BCT NOIP Day 3-1 暨 gxd 停课纪念赛 &amp; 简单题信心赛</h2><h3 id="21-BCT-Day-3-1-A"><a href="#21-BCT-Day-3-1-A" class="headerlink" title="[21 BCT Day 3-1] A"></a>[21 BCT Day 3-1] A</h3><p>智障题</p><h3 id="21-BCT-Day-3-1-B"><a href="#21-BCT-Day-3-1-B" class="headerlink" title="[21 BCT Day 3-1] B"></a>[21 BCT Day 3-1] B</h3><blockquote><p>给定序列 $a_n$ , 求最长的子序列 $c_k$ 满足 $c_i&#x3D;c_{i-1}+c_{i-2}$</p></blockquote><p>直接设 $f_{i, j}$ 表示以 $i$ 结尾, 上一个是 $j$ 的序列长度.</p><p>那么它能由 $f_{k, l}$ 转移过来, 当且仅当 $a_k&#x3D;a_j$ 且 $a_l&#x3D;a_i-a_j$ .</p><p>开个map.</p><h3 id="21-BCT-Day-3-1-C"><a href="#21-BCT-Day-3-1-C" class="headerlink" title="[21 BCT Day 3-1] C"></a>[21 BCT Day 3-1] C</h3><blockquote><p>给出一个 $n$ 个点的完全二叉树, 点有点权, 定义一个大小为 $k$ 的连通块 $s$ 的 $f_a(s)$ 为其第 $\lfloor\dfrac{k-a+1}{2}\rfloor$ 大的元素, 则对每个 $a\in [0, n-1]$ 输出 $\max_s f_a(s)$<br>$n\le 2\times 10^5, w_i\le n$</p></blockquote><p>考虑序列上怎么做, 考虑对于一个确定的 $a$ 判定一个答案, 把大于它的设为 $1$ , 小于它的设为 $-1$ 若最大子段和不小于 $a$ 就是对的.</p><p>那么对于所有 $a$ , 只要从小到大枚举一个答案, 每次区间赋值即可.</p><p>那么现在搬到树上, 就是要维护最大子连通块和即可. 这里暴力dp就行.</p><h3 id="21-BCT-Day-3-1-D"><a href="#21-BCT-Day-3-1-D" class="headerlink" title="[21 BCT Day 3-1] D"></a>[21 BCT Day 3-1] D</h3><blockquote><p>给定序列 $a_n$ , $m$ 次查询区间 $[l, r]$ 中最长的值域不等于 $[l, r]$ 的值域的子区间.<br>$n, m\le 2\times 10^6$</p></blockquote><p>考虑这个相当于求区间内, 相同值的相邻最大距离, 且把区间端点视为和所有数相同. 发现完整包含区间内的和与区间端点形成的都可以直接数点, 就做完了.</p><p>另一个想法是考虑直接扫描线, 扫右端点维护左端点出发的答案, 那么每次就是给一个区间取 $\max$ , 因为单调所以是区间赋值.</p><h2 id="22-正睿-AB班-DAY-1-暨-lixp-粉丝线下见面会"><a href="#22-正睿-AB班-DAY-1-暨-lixp-粉丝线下见面会" class="headerlink" title="22 正睿 AB班 DAY 1 暨 lixp 粉丝线下见面会"></a>22 正睿 AB班 DAY 1 暨 lixp 粉丝线下见面会</h2><h3 id="22AB-Day1-谁是演员"><a href="#22AB-Day1-谁是演员" class="headerlink" title="[22AB Day1] 谁是演员"></a>[22AB Day1] 谁是演员</h3><blockquote><p>给定正整数 $n$ 和一个长度为 $n$ 的序列 $a_1, a_2\ldots, a_n$ . 你需要将序列划分成 $k$ 个连续段, 每段的权值是内部序列的极差, 你需要最大化所有段的权值和. 你需要对 $k&#x3D;1, 2, \ldots, n$ 求出答案.<br>$n\le 10^5$ </p></blockquote><p>首先简单分析能得出极差这个函数是凸性的, 那么再用经典DAG定长最短路结论能得到整个答案也是凸性的.</p><p>考虑把答案看成一个函数 $f_i(x)$ 表示 $i$ 管辖的段中, 分 $x$ 段的方案. 那就直接分治, 每一层通过凸函数合并(闵和)得到答案. 复杂度就是 $n\log n$ . 然后比较麻烦的是要考虑中间那一段最大值在左&#x2F;右边.</p><p>这个题的启发仍然是把dp看作函数, 提醒我们凸性dp可以看成函数跑闵和.</p><h3 id="22AB-Day1-T-90A"><a href="#22AB-Day1-T-90A" class="headerlink" title="[22AB Day1] T-90A"></a>[22AB Day1] T-90A</h3><blockquote><p>你是一个水管工. 有一个 $n\times m$ 的长方形网格, 每一个格子的水管可以为以下这几种类型之一:<br><img src="/img/2022-10-20-20-13-08-image.png" alt="picture 1"><br>注意上述水管可以旋转. 我们称第四种水管(蓝色高亮标识)为<strong>高级</strong>的. 如果一个局面中每个位置都放置了如上六种水管之一, 并且所有水管都连起来了(每条水管接口都与相邻的水管相连), 那么就称这个局面是合法的. 注意不能朝向边界外.<br>目前有一些格子中放置了<strong>高级</strong>水管, 你能在若干个其他格子中放置一些<strong>高级</strong>水管. 在此之后, 你的同伴——另一个水管工会尝试在剩余未被放置水管的格子中放置水管, 使得最终变成一个合法的局面. 注意你和你的同伴不能旋转那些提前放置的水管. 此外, 对某些格子, 你不能够在其中放入<strong>高级</strong>水管, 并且对另外某些格子, 你必须要在其中放入一种<strong>高级</strong>水管.<br>你需要求出在你放完<strong>高级</strong>水管之后最多有多少个格子中为<strong>高级</strong>水管, 并使得你的同伴能完成工作. 如果无解, 输出 $-1$ .<br>$n, m\le 100$ </p></blockquote><p>把格子建成网格图, 一个高级水管等价于一个格子的对边两两连通性不同. 且发现其他情况是任意的.</p><p>困难的, 不会.</p><h3 id="22AB-Day1-探查民情"><a href="#22AB-Day1-探查民情" class="headerlink" title="[22AB Day1] 探查民情"></a>[22AB Day1] 探查民情</h3><blockquote><p>给一棵 $n$ 点树, 点有点权 $a_i$ , 边长度, 你要选择点集 $A$ , 获得 $(\sum_{u\in B} a_u t)-s\vert A\vert$ , 其中 $B$ 是所有到 $A$ 中点距离不大于 $d$ 的点. $s, t, d$ 为常数.</p><p>$n\le 1000$</p></blockquote><p>考虑树形dp如何计算子树对外面的影响, 发现取决于子树内最浅的在 $A$ 中的点(可能让一些子树外的 $B$ 加入贡献)或子树内最深的不在 $B$ 的点(可能让子树外的时候因子树内的 $B$ 贡献), 于是直接记录这两个dp, 可以达到 $n^3$</p><p>然后你发现实际上要么子树内延伸到外面, 要么外面到子树内, 两个事不会同时发生, 所以你只用记录一个, 就 $n^2$ 了.</p><p>杜赢提供了更厉害的做法</p><blockquote><p><img src="/img/2022-10-20-22-15-35-image.png" alt="picture 2">  </p></blockquote><h2 id="22-正睿-AB班-DAY-10-暨-lkw-人赢经验分享"><a href="#22-正睿-AB班-DAY-10-暨-lkw-人赢经验分享" class="headerlink" title="22 正睿 AB班 DAY 10 暨 lkw 人赢经验分享"></a>22 正睿 AB班 DAY 10 暨 lkw 人赢经验分享</h2><h3 id="A-22-AB-Day10-签到"><a href="#A-22-AB-Day10-签到" class="headerlink" title="A. [22 AB Day10] 签到"></a>A. [22 AB Day10] 签到</h3><blockquote><p>问所有长度为 $n$ 的合法表达式, 其中其中每个字符一定是 $\texttt{123456789+*}$ 中的一种, 运算结果的和.</p><p>一个表达式合法当且仅当:</p><p>首尾字符不能是 $\texttt{+}$ 和 $\texttt{*}$ .</p><p>不能连续两个字符是运算符号.</p><p>输出答案对 $998244353$ 取模的结果.</p><p>$n\le 10^18$</p></blockquote><p>考虑表达式像是被加号分割单若干个连乘的部分, 那么记录最后一个加号前的和, 最后一个加号往后乘积, 以及最后一个乘号之前到最后一个加号这一部分的乘积, 设为向量 $v&#x3D;[a, b, c]$ , 则后面增加一个数字 $d$ 会变成 $[a, 10b+cd, c]$ , 加一个乘号变成 $[a, b, 0]$ , 加一个加号变成 $[a+b, 0, 1]$ .</p><p>于是假设三个转移分别写成变换矩阵 $A, B, C$ , 要求 $v$ 乘上 $A, B, C$ 组成的一个序列的和, 你发现这玩意实际是 $v(A+B+C)^n$ , 那就直接矩阵快速幂. 但是它要求不能有两个符号接起来的, 所以实际上是 $v_i&#x3D;v_{i-1}A+v_{i-2}(B+C)A$ 的 $v_n$ , 矩阵大小是7.</p><p>[think] 对线性变换做线性变换还是线性变换, 如这里后面加一个是线性变换, 那么整体求和仍然是线性变换.</p><p>[think] 如果范围给你矩阵快速幂的感觉, 但转移不线性, 那么枚举状态设计可能会让它线性.</p><h3 id="B-22-AB-Day10-送分"><a href="#B-22-AB-Day10-送分" class="headerlink" title="B. [22 AB Day10] 送分"></a>B. [22 AB Day10] 送分</h3><blockquote><p>给定 $n$ 个点 $(x_i, y_i)$ , $x_i$ 互不相同, 询问矩形内任选两点连线斜率最小值是多少.</p><p>$n\le 7000, q\le 7\times 10^5$</p></blockquote><p>结论数据结构题.</p><p>[trick] 斜率最小的两点一定是 $y$ 方向上最接近的两个点.</p><p>然后就是简单题了, 在 $x$ 方向上扫描进行莫队, 维护 $y$ 方向上两相邻点之间的斜率即可. 复杂度 $n\log n\sqrt q$ </p><h2 id="22-正睿-AB班-DAY-2-暨-hws-粉丝线下交友会"><a href="#22-正睿-AB班-DAY-2-暨-hws-粉丝线下交友会" class="headerlink" title="22 正睿 AB班 DAY 2 暨 hws 粉丝线下交友会"></a>22 正睿 AB班 DAY 2 暨 hws 粉丝线下交友会</h2><h3 id="A-22-AB-联考-Day2-序列"><a href="#A-22-AB-联考-Day2-序列" class="headerlink" title="A. [22 AB 联考 Day2] 序列"></a>A. [22 AB 联考 Day2] 序列</h3><blockquote><p>给定 $a_n$, $q$ 次问区间 $[l, r]$ 中有多少子区间使得区间内部不同数的个数为奇数.</p><p>$n, q\le 5\times 10^5$</p></blockquote><p>考虑扫描线, 维护每个左端点到当前右端点的区间内不同数个数. 于是每次加一个数是给区间奇偶性取反.</p><p>然后问题变成了要累加这么个东西, 那这个就是把询问挂在右端点, 扫描到右端点的时候问区间历史和. 扫到左端点的时候也要问(差分一下).</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LYHDP选做</title>
      <link href="/2022/10/21/lyh/"/>
      <url>/2022/10/21/lyh/</url>
      
        <content type="html"><![CDATA[<h1 id="LYHDP"><a href="#LYHDP" class="headerlink" title="LYHDP"></a>LYHDP</h1><h2 id="slide-pptx"><a href="#slide-pptx" class="headerlink" title="slide. pptx"></a>slide. pptx</h2><p>day6那个做不动啊, 还是看看简单点的.</p><h3 id="CF1409F-Subsetsequences-of-Length-Two"><a href="#CF1409F-Subsetsequences-of-Length-Two" class="headerlink" title="CF1409F Subsetsequences of Length Two"></a>CF1409F Subsetsequences of Length Two</h3><blockquote><p>给定 $s_n, t(\vert t\vert&#x3D;2)$ , 可以修改 $s$ 的最多 $k$ 个字符使得 $t$ 作为子序列在 $s$ 中出现次数最大.</p><p>$n\le 200$</p></blockquote><p>$f_{i, j, k, l}$ 表示前 $i$ 个, 修改 $j$ 个, $t_1$ , $t_2$ 的个数分别为 $k, l$ 的 $t$ 出现次数.</p><p>哦, $t_1, t_2$ 只需要记录一个.</p><h3 id="CF1404B-Tree-Tag"><a href="#CF1404B-Tree-Tag" class="headerlink" title="CF1404B Tree Tag"></a>CF1404B Tree Tag</h3><blockquote><p>给定一棵树 $T&#x3D;Tree(n)$ , $AB$ 初始时在 $a, b$ 两点, 每次可以移动到距离不超过 $d_a, d_b$ 的点, 交替移动 $A$ 先手, 若 $A$ 能抓住 $B$ , $A$ 获胜. 问谁赢.<br>$n\le 10^5$ .</p></blockquote><p>考虑因为无限步数, 可以忽略前面过程, 直接想什么时候必然抓住:</p><ul><li>$A$ 站在直径中点上, $B$ 死了</li><li>$d_b\le 2d_a$ , 此时它不能跨过 $A$ , 那 $A$ 只要一步一步压缩即可.</li><li>一开始 $B$ 离 $A$ 太近</li></ul><h3 id="CF1349C-Orac-and-Game-of-Life"><a href="#CF1349C-Orac-and-Game-of-Life" class="headerlink" title="CF1349C Orac and Game of Life"></a>CF1349C Orac and Game of Life</h3><blockquote><p>给定 $n\times m$ 01矩阵, 每次若一个位置与它四连通的位置01相同就取反, $q$ 次询问 $i, j$ 在 $p$ 秒后是几.</p><p>$n, m\le 1000, t\le 10^5, p\le 10^18$</p></blockquote><p>一个连通块总是同步的, 可以缩起来.</p><p>如果一个格子某一时刻变了, 那么它接着会一直变.</p><p>于是直接求每个格子最早的变化时间(容易发现非常早), bfs一遍转移.</p><h3 id="CF1338B-Edge-Weight-Assignment"><a href="#CF1338B-Edge-Weight-Assignment" class="headerlink" title="CF1338B Edge Weight Assignment"></a>CF1338B Edge Weight Assignment</h3><blockquote><p>给定无根树 $Tree(n)$ , 为每条边赋值 $w&gt;0$ , 使得任意两个叶子路径异或和为0, 求最少最多的颜色数.</p><p>$n\le 10^5$</p></blockquote><p>要求任意两个叶子中所有数出现偶数次, 那最少的情况显然可以中间的全相等, 在叶子上调整(再找两个数异或等于刚才的数一调就行了).</p><p>最多的情况, 考虑一个点的所有叶子儿子到它的边要相同, 除了这个之外都可以不同(初始化一个相同的解, 然后在非常高的位置调整出一个1)</p><h3 id="CF1334D-Minimum-Euler-Cycle"><a href="#CF1334D-Minimum-Euler-Cycle" class="headerlink" title="CF1334D Minimum Euler Cycle"></a>CF1334D Minimum Euler Cycle</h3><blockquote><p>给定 $n$ 点的有向完全图(任意两点之间有两条边), 求字典序最小的欧拉回路的第 $l$ 到第 $r$ 个点.</p><p>$n\le 10^5$</p></blockquote><p>出发位置是最小值, 以后每次走出边最小的就是策略了.</p><p>考虑这么做形成若干个环, 对每个点统计这里出发的环的大小? 不对.</p><p>降智, 正确做法: 完全图, 所以实际上你可以任意走, 要保证每条边正反各一次, 直接构造:</p><p>$1\to 2\to 1\to 3\to \ldots 1\to n\to 2\to 3\to 2\ldots$</p><h3 id="CF1329A-Dreamoon-Likes-Coloring"><a href="#CF1329A-Dreamoon-Likes-Coloring" class="headerlink" title="CF1329A Dreamoon Likes Coloring"></a>CF1329A Dreamoon Likes Coloring</h3><blockquote><p>你有序列 $a_n$(初始为 $0$) , 进行 $m$ 次区间 $l_i, r_i$ 赋值 $i$, 要求最后每个颜色 $i&gt;1$ 出现至少一次, 且 $a_i\ne 0$. $r_i-l_i+1$ 给定, $l_i$ 不给定.</p><p>$n, m\le 10^5$</p></blockquote><p>考虑直接把 $l$ 对应 $r$ 排序然后随便模拟.</p><h3 id="CF1322B-Present"><a href="#CF1322B-Present" class="headerlink" title="CF1322B Present"></a>CF1322B Present</h3><blockquote><p>给定 $a_n$ , 求 $a$ 中任意两数对的和的异或和.</p><p>$n\le 4\times 10^5, a_i\le 10^7$</p></blockquote><p>每一位分别考虑, 要求一个数与其他所有数在第 $i$ 位上为 $1$ 的个数. 两种情况: 要么是直接加的, 要么是进位出来的.</p><p>进位就是每个数只取前 $k-1$ 位, 加起来大于 $2^k$ , 于是可以直接做了.</p><h3 id="CF1320C-Battle-for-Azathoth"><a href="#CF1320C-Battle-for-Azathoth" class="headerlink" title="CF1320C Battle for Azathoth"></a>CF1320C Battle for Azathoth</h3><p>矩形加-最大矩形和, 扫掉一维即可.</p><h3 id="CF1312E-Array-Shrinking"><a href="#CF1312E-Array-Shrinking" class="headerlink" title="CF1312E Array Shrinking"></a>CF1312E Array Shrinking</h3><p>直接区间dp, 注意若一个区间可以合并成单点, 这个数是唯一的.</p><h3 id="CF1288D-Minimax-Problem"><a href="#CF1288D-Minimax-Problem" class="headerlink" title="CF1288D Minimax Problem"></a>CF1288D Minimax Problem</h3><p>二分答案+变成一堆二进制数或起来全1+FMT. 想不到吧, 是可以直接枚举两个二进制数的(值域很小)</p><h3 id="CF1276B-Two-Fairs"><a href="#CF1276B-Two-Fairs" class="headerlink" title="CF1276B Two Fairs"></a>CF1276B Two Fairs</h3><p>$a, b$ 是割点, 于是图分成三部分, 答案是两边两部分的积.</p><p>哦, $a, b$ 不一定是割点, 而是删掉它们之后, $u, v$ 是分别只和 $a, b$ 相连的两部分.</p><h3 id="CF1213G-Path-Queries"><a href="#CF1213G-Path-Queries" class="headerlink" title="CF1213G Path Queries"></a>CF1213G Path Queries</h3><p>离线排序从小到大, 问连通块平方和之类的.</p><h3 id="CF1030E-Vasya-and-Good-Sequences"><a href="#CF1030E-Vasya-and-Good-Sequences" class="headerlink" title="CF1030E Vasya and Good Sequences"></a>CF1030E Vasya and Good Sequences</h3><p>可以对每个数都把一整到最前面, 一定不劣? 不对, 比如6, 7, 14这个样的, 你会让它们下面的抵消, 最后用6消掉上面的.</p><p>于是实际条件是, 1的个数为偶数, 并且最大的数的1的个数不超过总共个数的一半, 发现不满足第二个限制的区间最长是 $w$ 的, 于是暴力即可.</p><h3 id="CF959E-Mahmoud-and-Ehab-and-the-xor-MST"><a href="#CF959E-Mahmoud-and-Ehab-and-the-xor-MST" class="headerlink" title="CF959E Mahmoud and Ehab and the xor-MST"></a>CF959E Mahmoud and Ehab and the xor-MST</h3><p>异或和为1的会连接任意 $2i, 2i+1$ .</p><p>异或和为2的会连接差2的点.</p><p>发现加入异或和为 $2^i$ 的会合并前 $2^i$ 位, 其他的不会合并.</p><p>于是答案就是</p><p>$$<br>\sum_i \lfloor \dfrac{n}{2^i*2} \rfloor 2^i<br>$$</p><h3 id="CF900D-Unusual-Sequences"><a href="#CF900D-Unusual-Sequences" class="headerlink" title="CF900D Unusual Sequences"></a>CF900D Unusual Sequences</h3><p>都除以 $x$ , 问题变成互质序列加起来是 $\dfrac{y}{x}$ 的方案数.</p><p>没有互质可以直接隔板法是 $2^{y-1}$ . 于是你就容斥, $g(x)$ 表示 $\gcd$ 为 $x$ 的因数的方案数, $f(x)$ 表示恰好为 $x$ 的方案数, 莫反即可.</p><h3 id="CF859D-Third-Month-Insanity"><a href="#CF859D-Third-Month-Insanity" class="headerlink" title="CF859D Third Month Insanity"></a>CF859D Third Month Insanity</h3><p>直接dp, 一遍算在点 $u$ , $x$ 获胜的概率, 一遍dp点 $u$ 子树内走到 $u$ 的是 $i$ 的情况下得分期望和.</p><h3 id="CF853C-Boredom"><a href="#CF853C-Boredom" class="headerlink" title="CF853C Boredom"></a>CF853C Boredom</h3><p>简单容斥+二维数点</p><h3 id="CF1408E-Avoid-Rainbow-Cycles"><a href="#CF1408E-Avoid-Rainbow-Cycles" class="headerlink" title="CF1408E Avoid Rainbow Cycles"></a>CF1408E Avoid Rainbow Cycles</h3><p>考虑把图简化, 一个集合连一个团可以变为给每个集合建一个点, 集合内的点向它连边.</p><p>此时原边权是现在两条边中间那个点的点权.</p><p>发现因为集合每个点多颜色是唯一的, 这样做又不会形成同集合的环, 所以只要有环就是rainbow.</p><p>然后开始想什么网络流建图可以约束没有环这一条件, 哦, 是最大生成树啊&#x2F;hanx.</p><h3 id="CF1217E-Sum-Queries"><a href="#CF1217E-Sum-Queries" class="headerlink" title="CF1217E Sum Queries?"></a>CF1217E Sum Queries?</h3><blockquote><p>给你 $n$ 个数 $a_i$ .<br>对于一个子序列 $p$ , 定义 $s_p$ 为子序列中所有数的和.<br>定义一个子序列 $p$ 是好的, 当且仅当 $s_p$ 用十进制表示时, 对于 $\forall i$ , 都能在子序列 $p$ 中找到一个数 $x$ , 使得 $s_p$ 从低到高的第 $i$ 位与 $x$ 从低到高的第 $i$ 位相等.<br>你需要对序列 $a$ 做 $2$ 种操作:</p><ol><li>把 $a_i$ 修改成 $x$ .</li><li>在 $a_l, a_{l+1}\cdots, a_r$ 构成的序列中, 找一个 $s_p$ 最小的子序列 $p$ , 使得 $p$ 是坏的. 你需要输出 $s_p$ . 如果不存在, 输出 $-1$ .<br>$1\le n, m\le 10^5, 1\le x, a_i&lt;10^9$</li></ol></blockquote><p>考虑如果一个集合是坏只要有一位不全为0. 于是每一位开线段树维护最小值和次小值.</p><h3 id="CF1215E-Marbles"><a href="#CF1215E-Marbles" class="headerlink" title="CF1215E Marbles"></a>CF1215E Marbles</h3><blockquote><p>有 $n (n \le 4 * 10^5)$ 个珠子 , 第 $i$ 个珠子颜色是 $c_i (c_i \le 20)$ , 每次操作把<strong>相邻</strong>的两个珠子交换. 现在要把相同颜色的珠子排列在相连的一段, 问至少要多少次操作 .</p></blockquote><p>给珠子钦定一个顺序之后就是排序了, 排序是好做的.</p><p>那么设 $cost(a, b)$ 表示 $a$ 排在 $b$ 之后的代价, 直接状压dp即可.</p><h3 id="CF1188C-Array-Beauty"><a href="#CF1188C-Array-Beauty" class="headerlink" title="CF1188C Array Beauty"></a>CF1188C Array Beauty</h3><blockquote><p>定义一个序列 $b_1, \ldots, b_n$ 的美丽值为 $\min_{1 \leq i &lt; j \leq n}{\vert b_i-b_j\vert }$ . 给定一个长度为 $n$ 的序列 $a$ , 求 $a$ 的所有长度为 $k$ 的子序列的美丽值之和对 $998244353$ 取模的结果.<br>$2 \leq k \leq n \leq 1000$ , $0 \leq a_i \leq 10^5$ .</p></blockquote><p>先枚举一个美丽值, 计算有多少个子集.</p><p>把 $a$ 排序.</p><p>$f_{i, j}$ 表示 $a$ 的前 $i$ 个里选 $j$ 个, 美丽值大于当前值的方案数, 复杂度 $n^2$ . 或者确切的, $nk$</p><p>似乎过不了, 但是你再想想, 值域其实不是 $\max a_i$ , 而是 $\dfrac{\max a_i}{k - 1}$ ! 你就过了.</p><p>[think] 分析复杂度确切一点!</p><h3 id="CF1111E-Tree"><a href="#CF1111E-Tree" class="headerlink" title="CF1111E Tree"></a>CF1111E Tree</h3><blockquote><p>给定 $Tree(n)$ , $q$ 次询问给定 $k, m, r, a_k$ , 求将 $a_k$ 中点分为不超过 $m$ 组使得以 $r$ 为根的时候没有同组两点有祖先关系的方案数. 膜 $10^9+7$</p><p>$n, q\le 10^5, m\le \min(k, 300)$</p></blockquote><p>直接虚树dp, $f_{i, j}$ 表示以 $i$ 的子树内分 $j$ 组的方案. 问题是合并两个子树信息的时候, 可能有跨过子树的组, 我们也不知道怎么办了(</p><p>枚举扫描线方向, 子树dp相当于从儿子到祖先, 考虑先祖先再儿子, 于是想到dfs序排序, 设 $f_{i, j}$ 表示前 $i$ 个点, 分 $j$ 组, 那么点 $i$ 的不能和它的祖先一组, 可以挤进去或者新开一组, 简单 $nm$ .</p><p>那么现在也不用虚树了, 只要求有多少个祖先是关键点, 简单单点加链求和.</p><p>但实际上手够硬也是可以的, 考虑一开始组带着标号算, 并且允许空组, 此时两个子树合并的时候就是直接 $f_{i, j}$ 相乘, 因为就相当于一共有这么多组, 每次把一个子树的东西填进去, 合并两个子树的时候就是直接对应相乘, 容斥出非空盒子个数除掉阶乘即可. 复杂度相同.</p><p>[think] 树上dp的扫描线方向, 带标号简化问题+容斥.</p><h3 id="CF1097D-Makoto-and-a-Blackboard"><a href="#CF1097D-Makoto-and-a-Blackboard" class="headerlink" title="CF1097D Makoto and a Blackboard"></a>CF1097D Makoto and a Blackboard</h3><blockquote><p>给定 $n, k$ , 一共会进行 $k$ 次操作, 每次操作会把 $n$ 等概率的变成 $n$ 的某个约数<br>求操作 $k$ 次后 $n$ 的期望是多少, 答案对 $10^9+7$ 取模<br>$1 \le n \le 10^{15}, 1 \le k \le 10^4$</p></blockquote><p>考虑把 $n$ 质因数分解, 发现答案关于每个因子 $p^a$ 是独立的, 此时就可以直接计算了.</p><p>[think] 计数要找独立! 独立!</p><h3 id="CF1044D-Deduction-Queries"><a href="#CF1044D-Deduction-Queries" class="headerlink" title="CF1044D Deduction Queries"></a>CF1044D Deduction Queries</h3><blockquote><p>给定 $a_n$ 和 $q$ 次操作 $(1 \leq q \leq 2 \times 10^5)$ , 两种操作类型:<br><code>1, l, r, x</code>: 表示已知 $a$ 的区间 $[l, r]$ 的异或和为 $x$ , 或者与已知矛盾忽略.<br><code>2, l, r</code>: 表示询问 $a[l, r]$ 的异或和或判断不可知.<br>强制在线. $(0 \leq l, r, x \leq 2^{30})$</p></blockquote><p>它确实长了一张并查集的脸啊!</p><p>考虑带权并查集, 每个点维护到根的点的异或和, 就行了.</p><h3 id="CF1043F-Make-It-One"><a href="#CF1043F-Make-It-One" class="headerlink" title="CF1043F Make It One"></a>CF1043F Make It One</h3><p>在数数题里.</p><h3 id="CF891C-Envy"><a href="#CF891C-Envy" class="headerlink" title="CF891C Envy"></a>CF891C Envy</h3><blockquote><p>给出一个 $n$ 个点 $m$ 条边的无向图, 每条边有边权, 共 $Q$ 次询问, 每次给出 $k_i$ 条边, 问这些边能否同时在一棵最小生成树上.</p><p>$n, m, q, w, \sum k_i\le 5\times 10^5$</p></blockquote><p>考虑Kru的过程, 那么一条边权为 $w$ 的可以在最小生成树上当且仅当所有边权小于 $w$ 的都被插入之后 $w$ 两端点不连通. 于是如果询问边权没有相同的可以直接可持久化并查集. 如果有相同的元素按照任意顺序都是对的, 于是按照任意顺序一个一个合并进去即可.</p><p>哦, 实际上可以干掉可持久化, 建操作树+撤销即可.</p><h3 id="CF875F-Royal-Questions"><a href="#CF875F-Royal-Questions" class="headerlink" title="CF875F Royal Questions"></a>CF875F Royal Questions</h3><blockquote><p>给定二分图, 左边 $n$ 个点, 右边 $m$ 个点, 右边第 $i$ 个点连向左边第 $a_i$ , $b_i$ 个点, 权值为 $w_i$ , 求权值最大的匹配.</p><p>$n, m\le 2\times 10^5, w_i\le 10^4$</p></blockquote><p>将右边点看成边, 于是一个连通块合法当且仅当是基环树或树. 于是用最大生成树的做法去做.</p><p>[think] 枚举多种建图方式.</p><h3 id="CF870E-Points-Lines-and-Ready-made-Titles"><a href="#CF870E-Points-Lines-and-Ready-made-Titles" class="headerlink" title="CF870E Points, Lines and Ready-made Titles"></a>CF870E Points, Lines and Ready-made Titles</h3><blockquote><p>在一个平面上有 $n$ 个不同的点( $n$ 给出). 而对于每一个点而言, 你可以对它作一条垂直线, 也可以作一条水平线, 并且也可以不对它进行任何操作. (若有重合的线段则视为一条直线). 请问你能得到多少种不同的图片呢? 得出的答案对 $10^9+7$ 取模.</p></blockquote><p>考虑点相互影响的关系, 发现只有在同一水平竖直线才相互影响, 于是每个点向四方向最近点连边, 拆成若干个独立连通块.</p><p>考虑单独计算一个连通块, 结论是, 对于一个连通块, 如果是树, 答案为 $2^{A+B}-1$ , 否则是 $2^{A+B}$ .</p><p>考虑如果一个连通块是树, 选择一个根, 钦定其方向, 然后让每个点和父亲的方向不相同, 发现可以铺满除了根所在的所有行&#x2F;列, 于是只有全满的一种方案无法选择. 如果一个连通块有环, 此时选择环上一点做为根, 就能全满.</p><h3 id="CF868F-Yet-Another-Minimization-Problem"><a href="#CF868F-Yet-Another-Minimization-Problem" class="headerlink" title="CF868F Yet Another Minimization Problem"></a>CF868F Yet Another Minimization Problem</h3><p>显然四边形不等式. 直接分治决策单调性. 然后这个是莫队+分治的那个trick(分治的时候用莫队计算决策, 端点移动量级是 $n\log n$).</p><h3 id="CF856B-Similar-Words"><a href="#CF856B-Similar-Words" class="headerlink" title="CF856B Similar Words"></a>CF856B Similar Words</h3><blockquote><p>单词是由小写英文字母组成的非空串.<br>若一个单词去掉首字母后与另一个单词相同, 则这两个单词相似.<br>现给定 $n$ 个单词(可能重复), 请挑选尽量多的新单词组成集合 $T$ 并满足条件:</p><ol><li>$T$ 中的新单词为原 $n$ 个单词的前缀(包含自身)</li><li>$T$ 中的新单词两两不相似.<br>求 $\max \vert T \vert$<br>$\sum s_i\le 10^6$</li></ol></blockquote><p>考虑先求出所有前缀和每个前缀相似的字符串, 可以用hash, 把看每个前缀向删掉第一个字符之后得到的点连边, 最后就是选最多的点使得没有两点有父子关系, 直接树形dp.</p><h3 id="CF815C-Karen-and-Supermarket"><a href="#CF815C-Karen-and-Supermarket" class="headerlink" title="CF815C Karen and Supermarket"></a>CF815C Karen and Supermarket</h3><blockquote><p>在回家的路上, 凯伦决定到超市停下来买一些杂货. 她需要买很多东西, 但因为她是学生, 所以她的预算仍然很有限.<br>事实上, 她只花了 $b$ 美元.<br>超市出售 $n$ 种商品. 第 $i$ 件商品可以以 $c_i$ 美元的价格购买. 当然, 每件商品只能买一次.<br>最近, 超市一直在努力促销. 凯伦作为一个忠实的客户, 收到了 $n$ 张优惠券.<br>如果 Karen 购买第 $i$ 件商品, 她可以使用第 $i$ 张优惠券, 将该商品的价格减少 $d_i$ 美元. 当然, 不买对应的商品, 优惠券不能使用.<br>然而, 对于优惠券有一个规则. 对于所有 $i\ge 2$ , 为了使用第 $i$ 张优惠券, 凯伦必须也使用第 $x_i$ 张优惠券 (这可能意味着使用更多优惠券来满足需求. )<br>凯伦想知道. 她能在不超过预算 $B$ 的情况下购买的最大商品数量是多少?<br>$n\le 5000$</p></blockquote><p>考虑 $x_i$ 形成的结构显然是森林, 依赖是自顶向下的, 设 $f_{u, i, 0&#x2F;1}$ 表示 $u$ 子树内是否使用优惠卷, 此时用了 $i$ 元的最大收益, 不行, 换成买 $i$ 件物品的最少价格, 转移就是背包.</p><h3 id="CF804D-Expected-diameter-of-a-tree"><a href="#CF804D-Expected-diameter-of-a-tree" class="headerlink" title="CF804D Expected diameter of a tree"></a>CF804D Expected diameter of a tree</h3><blockquote><p>给一片森林, $q$ 个询问, 每个询问两个点, 问从这两个点所在的连通块内各自均匀随机两个点, 连接起来组成的新连通块, 它的最远两点的距离的期望值是多少.<br>$n, q\le 10^5$</p></blockquote><p>先考虑一次询问.</p><p>一个点的贡献是 $b(\max_i dis_{u, i}+\dfrac{1}{2})$ , 其中 $b$ 为对面集合的大小, 那就对每个集合维护这个即可. 显然 $u$ 是两个直径之一.</p><p>不对, 新直径可能是原来两个连通块的直径.</p><p>那么算两个集合的和小于 $x$ 的个数和总和, 考虑分别排序, 那么双指针就能算. 或者在里面二分+前缀和.</p><p>现在多次询问, 不会了.</p><p>好厉害的自然根号, 考虑如果二分+前缀和, 我们的询问只与小的那个大小有关, 对于小于 $\sqrt n$ 的连通块算一次是 $\sqrt n$ , 对于大于 $\sqrt n$ 的只有 $\sqrt n$ 个大于它的, 所以只要对大于 $\sqrt n$ 的记忆化复杂度就是1log.</p><p>[think] 总和为 $n$ 的集合, $\sum_a \sum_b \min(a, b)\le O(n\sqrt n)$</p><h3 id="CF600E-Lomsat-gelral"><a href="#CF600E-Lomsat-gelral" class="headerlink" title="CF600E Lomsat gelral"></a>CF600E Lomsat gelral</h3><p>模板-线段树合并</p><h3 id="CF1379F2-Chess-Strikes-Back"><a href="#CF1379F2-Chess-Strikes-Back" class="headerlink" title="CF1379F2 Chess Strikes Back"></a>CF1379F2 Chess Strikes Back</h3><blockquote><p>给出一个 $2n\times 2m$ 的黑白交错棋盘, 其中格子 $(1, 1)$ 为白色. 每次拿走或放回一个白格, 问能否在剩下的白格中放入 $n\times m$ 个国王使得它们不互相攻击.</p><p>$n, m, q\le 2\times 10^5$</p></blockquote><p>考虑有解条件, 首先这个 $n\times m$ 和 $2n\times 2m$ 的关系不是没用的, 考虑分成 $2\times 2$ 的块, 于是任意一个块里恰有两个白格, 一个国王. 形成了一个类似2sat的限制, 图上显然只有偶环.</p><p>没前途, 2sat的模型并不适合性质, 考虑一个矩形, 发现要确定对角顶点的状态才唯一, 于是发现没有一方格满足, $A$ 左上角不能放, $B$ 右下角不能放, 且 $B$ 在 $A$ 的右下方, 仅在此时中间的矩形不满足. (否则, 一定在内部已经出现这样的格子对).</p><p>于是直接线段树维护两种最靠左上的 $A$ 和最靠右下的 $B$ 即可.</p><h3 id="CF1310C-Au-Pont-Rouge"><a href="#CF1310C-Au-Pont-Rouge" class="headerlink" title="CF1310C Au Pont Rouge"></a>CF1310C Au Pont Rouge</h3><blockquote><p>给出一个长度为 $n$ 的字符串 $S$ 以及整数 $m, k$ .<br>对于一个把 $S$ 分割成非空的 $m$ 段的一个方案, 我们用这个方案中分割出的字典序最小的一个串代表这个分割方案.<br>eg. $S&#x3D;abaabb, m&#x3D;3$ , 存在分割方案 ${ab, aab, b}$ , 则我们用字典序最小的 $aab$ 来代表这个分割方案.<br>现在把<strong>所有分割方案对应的代表该方案的串</strong>按字典序<strong>从大到小</strong>排序, 求排序后的第 $k$ 个串.<br>$n, m\le 1000, k\le 10^18$</p></blockquote><p>考虑二分字典序, 现在求大于一个串 $t$ 的划分方案数.</p><p>显然为了满足 $m$ 和大于的条件, 考虑记录 $f_{i, j}$ 表示 $[1, i]$ 划分 $j$ 段的方案数, 那么此时有</p><p>$$<br>f_{i, j}&#x3D;\sum f_{k, j-1}, \ s. t. \ s[k+1, i]&gt;t<br>$$</p><p>此时转移是 $n^3$ 的, 因为我们找不到转移到性质–字典序更多取决于开头的 $k$ 而不是 $i$ , 所以同一个 $i$ 的决策看不到性质.</p><p>那么考虑倒着dp, 记录最后一段 $[i, n]$ 的, 此时转移的是一个后缀, 就直接做了.</p><p>看看lyh的解法, 考虑正着dp的时候一个 $j$ 可以转移到一个后缀的 $i$ , 于是用转移 $f_{i, j-1}\to f_{i, j}$ , $f_{i-1, j-1}\to f_{i, to_j}$ 做到这个转移.</p><p>[think] 可以感受到dp的自动机特性, lyh的解法相当于做了前缀优化建图. 适用于前后缀(因为自动机不能记忆你是什么时候开始的区间).</p><h3 id="CF1270F-Awesome-Substrings"><a href="#CF1270F-Awesome-Substrings" class="headerlink" title="CF1270F Awesome Substrings"></a>CF1270F Awesome Substrings</h3><blockquote><p>给定 $s, s_i\in {0, 1}$ , 求它有多少个子串满足其长度为1个数的倍数.</p><p>$\vert s\vert \le 2\times 10^5$</p></blockquote><p>倍数一般与某些自然根号, 对数性质有关.</p><p>考虑一个经典做法是对于一个固定倍数 $k$ , 把 $0$ 当成 $-1$ , 1当成 $k$ , 有解就是区间和为0, 可以扫一遍得答案. 那么此时想到根号分治, 这个用于 $k&lt;\sqrt n$ .</p><p>对于 $k&gt;\sqrt n$ , 则 $1$ 的个数要小于根号, 于是枚举小于根号的1的个数就行了.</p><h3 id="CF1270H-Number-of-Components"><a href="#CF1270H-Number-of-Components" class="headerlink" title="CF1270H Number of Components"></a>CF1270H Number of Components</h3><blockquote><p>给一个长度为 $n$ 的数组 $a$ , $a$ 中的元素两两不同.<br>对于每个数对 $(i, j)(i&lt;j)$ , 若 $a_i&lt;a_j$ , 则让 $i$ 向 $j$ 连一条边. 求图中连通块个数.<br>支持 $q$ 次修改数组某个位置的值, 每次修改后输出图中连通块个数.<br>$n, q\le 5\times 10^5, 1\le a_i\le 10^6$ , 保证任意时刻数组中元素两两不同.</p></blockquote><p>首先考虑连通块的性质, 发现若 $i, j(i&lt;j)$ 连通, 则任意 $k\in [i, j]$ 都连通, 于是一个连通块一定是一个区间.</p><p>于是问题变成有多少个 $i$ 满足 $\min_{j\in [1, i]} a_j&gt;\max_{j\in [i+1, n]} a_j$</p><p>考虑一个折线模型, 发现 $i$ 满足条件代表 $y&#x3D;a_i-\dfrac{1}{2}$ 这条线与整个折现只有一个交点, 发现我们成功的把修改时信息的影响变得局部–折现只与它左右两边的元素有关, 于是用值域线段树维护每个位置被折现覆盖了多少次的最小值何最小值个数(或者, $y&#x3D;x$ 与多少条折现经过), 修改就是区间加了.</p><h3 id="CF1260F-Colored-Tree"><a href="#CF1260F-Colored-Tree" class="headerlink" title="CF1260F Colored Tree"></a>CF1260F Colored Tree</h3><blockquote><p>给定一棵树, 每个节点有一个颜色 $h$ , $h_i$ 为 $[L_i, R_i]$ 内的一个整数.<br>现在, 对于所有 $\prod (R_i-L_i+1)$ 种不同的染色方案, 求出下列式子之和:<br>$$\sum_{h_i&#x3D;h_j, 1\leq i&lt;j\leq n}dis(i, j)$$<br>$n\leq 10^5, 1\leq L_i\leq R_i\leq 10^5$ , 答案对1e9+7取模.</p></blockquote><p>能不能拆成边的贡献啊. . . 一条边的贡献为每种颜色 所有方案下在两边的个数乘起来 之和, 然后呢?</p><p>那再考虑对每个颜色分别求, 这个好像可以虚树实现.</p><p>于是问题变成求一个颜色在一个子树内的所有出现方案的出现点数之和.</p><p>考虑写成 $a+x$ 卷起来, 要求系数和次数的点积. 那是不是求导把次数移下来就好了. 所以是问在1处的导数.</p><p>这个是可以做的, $(\prod_i a_i)’&#x3D;\sum_i (a_i’\prod_{j\ne i}a_j)$ , 于是就是在这个区间里选一个的贡献是导数, 剩下的是原来的, 这个问题是可合并的, 或者从ddp上想. 于是可以单点修改&#x2F;查子树.</p><p>设 $R_i-L_i&#x3D;l_i$ .</p><p>诶好像建虚树是错的啊. . . 复杂度假了. . . 但上面那部分是对的, 再想想, 考虑扫描线颜色维(这里颜色实际是有大小关系的), 设每个边两边的这种颜色的所有方案的出现点数之和分别是 $A, B$ , 那么 $A\times B$ 就是这条边的贡献, 那么现在扫着扫着要支持添加一个点或删除一个点, 发现按照刚才的做法求导之后 $A&#x3D;\sum_i \prod_{j\ne i}l_j$ , 就要求 $(\sum_i \prod_{j\ne i} l_j)\times (\sum_k \prod_{l\ne k}l_k)$ , 发现添加一项不是线性变换, 但可以直接两边都除以 $\prod_i l_i$ , 这个对所有点是相同的提出来, 就成了 $(\sum_i \dfrac{1}{l_i})(\sum_j \dfrac{1}{l_j})$ , 就是线性变换了.</p><p>然后写成矩阵, 发现行列式恒为1, 于是是可逆的, 就支持加点删点了, 用线段树维护dfs序, 复杂度1log.</p><p>这个题还有其他做法啊: 好像大家都是考虑的点对贡献而不是边.</p><p>于是点对 $u, v$ 贡献就是</p><p>$$<br>dis(u, v)\times \dfrac{all}{l_ul_v}<br>$$</p><p>然后依旧扫描线, 这次用点分树维护跨过根的即可.</p><h3 id="CF1254D-Tree-Queries"><a href="#CF1254D-Tree-Queries" class="headerlink" title="CF1254D Tree Queries"></a>CF1254D Tree Queries</h3><blockquote><p>给定一棵 $N$ 个节点的树, 有 $Q$ 次操作</p><p>$1\space v\space d$ 给定一个点 $v$ 和一个权值 $d$ , 等概率地选择一个点 $r$ , 对每一个点 $u$ , 若 $v$ 在 $u$ 到 $r$ 的路径上, 则 $u$ 的权值加上 $d$ (权值一开始为 $0$ )  </p><p>$2\space v$  查询 $v$ 的权值期望, 对 $998244353$ 取模<br>$1\leqslant N, Q \leqslant 150000$</p></blockquote><p>固定 $r$ , $v$ 决定了加到子树的哪一边. 好像很不可做.</p><p>固定 $u, v$ 考虑被加了几次, 显然是 $dis(u, v)$ , 问题就成了每次给 $u$ 加上 $dis(u, v)*d$ , 单点询问.</p><p>那么这个很经典啊, 点分树+线段树. 等等, 看成给 $r$ 到 $v$ 的路径上了加.</p><p>再看看, 是给 $v$ 子树外的点加子树大小次, 自己加 $nd$ 次, 关键是子树内的点, 每个被加了子树大小减自己所在的子树的大小.</p><p>最后这块不好办, 考虑树上差分, 并且每个位置维护子树被加了几次, 就是要给 $v$ 子树加1, 每个儿子这个次数减1, 上科技的做法是毛毛虫剖分</p><p>考虑一个阳间做法, 树剖, 每次修改的时候给重儿子区间加, 对于轻儿子, 跳它祖先上每一条轻边算贡献即可.</p><h3 id="CF1223F-Stack-Exterminable-Arrays"><a href="#CF1223F-Stack-Exterminable-Arrays" class="headerlink" title="CF1223F Stack Exterminable Arrays"></a>CF1223F Stack Exterminable Arrays</h3><p>收录在dp里.</p><h3 id="CF1220F-Gardener-Alex"><a href="#CF1220F-Gardener-Alex" class="headerlink" title="CF1220F Gardener Alex"></a>CF1220F Gardener Alex</h3><blockquote><p>给定排列 $p_n$ , 可以进行 $k$ 次向左循环移位, 问大根笛卡尔树深度的最小值以及循环移位次数</p><p>$n\le 2\times 10^5$</p></blockquote><p>考虑动态的做: 每次从左边拿一个到右边叫 $u$ , 则原来 $u$ 的右儿子挂到 $u$ 左边第一个大于它的, 新的父亲是它左边第一个大于它的点 $v$ , 小于 $v$ 的没有影响, $[v, u]$ 之间的点挂到了 $u$ 的左子树且结构不变. 现在可以LCT+线段树1log.</p><p>考虑不LCT, 而是变成每个位置维护其深度, 是不是就做完了.</p><h3 id="CF1188D-Make-Equal"><a href="#CF1188D-Make-Equal" class="headerlink" title="CF1188D Make Equal"></a>CF1188D Make Equal</h3><blockquote><p>给出 $n$ 个数字 $a_1 , a_2 , \ldots , a_n$ , 每次操作可以给其中一个数加上 $2$ 的非负整数次幂. 求最少的操作次数, 使得这 $n$ 个数相等.<br>$n\le 10^5, a_i\le 10^17$</p></blockquote><p>考虑不能直接dp, 因为进不进位是乱的, 因为只能加不能减, 发现最优策略一定是, 先操作最大值, 然后把所有数操作到同一个数, 设 $ma&#x3D;\max_i a_i$ , 则要最小化 $\sum_i \mathrm{popcount}(ma+x-a_i)$ , 所以设 $b_i&#x3D;ma-a_i$ , 就是让它们加同一个 $x$ 了.</p><p>考虑此时再dp, 仍然要进位, 但因为都是加上同一个数, 所以进位到第 $k+1$ 位的只能是前 $k$ 位最大的那些数, , 设 $f_{i, j}$ 表示前 $i$ 位, 进位的是最大的 $j$ 个, 就可以了.</p><p>[trick] 加同一个数时进位的一定是一个后缀, 同CF1322B.<br>[think] 是构造了满足某条件(这里的进位)的一个偏序关系去压缩状态.</p><h3 id="CF1142D-Foreigner"><a href="#CF1142D-Foreigner" class="headerlink" title="CF1142D Foreigner"></a>CF1142D Foreigner</h3><blockquote><p>给定数字串 $s$ , 求其中有多少子串表示的数是特殊的. 定义特殊的数是 $[1, 9]$ 的数, 或者对于 $k&#x3D; \lfloor \dfrac{x}{10} \rfloor$ , $k$ 是第 $i$ 个特殊的数, 则要求 $x\bmod 10&lt;k\bmod 11$ .</p><p>$n\le 10^5$</p></blockquote><p>考虑在序列上扫, 维护以 $i$ 结尾的特殊的数, 那么显然它们必须在第 $i-1$ 位结尾时也特殊, 并且第 $i$ 位要小于它们的编号, 发现我们并不需要维护每一个特殊的数–编号膜11相同的对后面贡献相同, 所以 $f_{i, j}$ 表示以第 $i$ 位结尾, 编号膜11余 $j$ 的数的个数, 我们希望知道 $j$ 这一维怎么转移.</p><p>发现我们需要算编号为 $a$ 的数往后加上数 $b$ (这个操作起名拓展)后的新编号, 考虑由 $c&lt;a$ 拓展得到的数一定都小于 $a$ 拓展得到的, 于是新编号就是</p><p>$$<br>9+\sum_{j\in [1, k-1]} (i\bmod 11)+c+1<br>$$</p><p>意思是算上不是被拓展的9个数, 以及比 $k$ 小的拓展的所有数. 发现 $i$ 每11个加的数是一样的(是 $0+1+2+\ldots+10&#x3D;55\equiv 0 \pmod 11$ ), 于是我们确实可以像上面一样只记录余数转移了.</p><h3 id="CF1129D-Isolation"><a href="#CF1129D-Isolation" class="headerlink" title="CF1129D Isolation"></a>CF1129D Isolation</h3><blockquote><p>给出一个长度为 $n$ 的序列, 把它划分成若干段, 使得每一段中出现过<strong>恰好</strong>一次的元素个数 $\le k$ , 求方案数对 $998244353$ 取模后的结果.<br>$n\le 10^5$</p></blockquote><p>设 $f_i$ 表示前 $i$ 个的方案数, 转移就是枚举最后一段断在哪, 是 $n^2$ 的.</p><p>于是优化这个, 考虑维护 $cnt_j$ 表示区间 $[j, i]$ 这一段恰好出现一次的数的个数, 那么现在加入一个位置 $i+1$ 后, 发现若设最大的 $k$ 满足 $a_k&#x3D;a_{i+}$ , 则 $[k, i+1]$ 的 $cnt$ 加 $1$ , $[1, k]$ 的 $cnt$ 减 $1$ , 然后求 $cnt$ 大于一个数的 $f$ 的和, 可以时间分块+根号平衡, 或者直接序列分块.</p><h3 id="CF1098D-Eels"><a href="#CF1098D-Eels" class="headerlink" title="CF1098D Eels"></a>CF1098D Eels</h3><blockquote><p>小V有一个水缸和一堆鱼, 水缸初始是空的, 小V接下来会向水缸内加入一些鱼, 同时也可能将已加入的鱼捞出来.<br>水缸里的鱼会相互攻击, 直到只有一条鱼为止. 也就是说如果有 $n$ 条鱼, 则会发生 $n-1$ 次攻击. 如果一条鱼的重量为 $A$ , 另一条鱼重量为 $B$ , 如果 $A\le B$ , 则 $B$ 鱼会吃掉 $A$ 鱼, 然后 $B$ 鱼体重变为 $A+B$ .<br>对于一场攻击来说, 如果一条鱼的重量为 $A$ , 另一条鱼重量为 $B$ , 如果 $A, B$ 满足条件 : $A\le B$ 而且 $B\le 2A$ 那么我们定义这场攻击是危险的.<br>现在小V会有 $q$ 次操作, 包括加入一条体重为 $x$ 的鱼, 或捞出一条水缸内的、体重为 $x$ 的鱼.<br>小V想知道, 在每次操作后, 水缸内能发生的最多的危险攻击次数是多少.</p><p>$q\le 500000$</p></blockquote><p>考虑一次询问怎么做? (好像不会啊. . . )</p><p>首先发现能现在危险的一定可以不拖到以后, 所以你先尽可能合并危险的.</p><p>直到现在任意两个鱼打都不是危险的, 发现此时最多有 $\log v$ 条.</p><p>发现不会.</p><p>考虑猜一个更厉害的结论, 一定每次拿最小的两个合并.</p><p>那么如果此时最小的 $a, b$ 是危险的你就直接合并, 现在发现 $a&lt;2b$ , 那么假设此时合并 $bc, c&gt;b$ 是危险的, 发现首先 $a$ 和后面的合并永远不是危险的了, 并且把 $a$ 先合并到 $b$ 上一定不劣, 就证完了.</p><p>于是考虑维护一个有序的数字, 答案就是 $a_i\le s_{i-1}$ 的 $i$ 个数, 其中 $s$ 为前缀和.</p><p>考虑不合法的合并只有 $\log V$ 次, 那么开个平衡树, 每个位置维护当前值减前缀和, 就要做到插入, 后缀加, 查询大于0的数的个数, 很遗憾这个做不了, 但是可以查区间最小值是简单的, 因为只有 $\log V$ 次每次往后跳复杂度是对的(finger search 1log! )</p><p>啊, 不对, fingersearch是2log的</p><p>看看题解的高妙做法, 根据权值划分段, $[2^i, 2^{i+1})$ 作为一段, 每一段只有最小的可能不是危险的, 直接维护和就做完了.</p><h3 id="CF1044F-DFS"><a href="#CF1044F-DFS" class="headerlink" title="CF1044F DFS"></a>CF1044F DFS</h3><blockquote><p>给定 $T&#x3D;Tree(n), G&#x3D;Graph(n)&#x3D;T$ , $q$ 次每次在 $G$ 中加一条边或删一条边, 不会删 $T$ 中的边, 问 $G$ 中有几个点满足从这里开始dfs有可能得到dfs树为 $T$ .</p><p>$n, q\le 2\times 10^5$</p></blockquote><p>考虑一次怎么做.</p><p>那么要求, 若点 $u$ 在 $T$ 上是叶子, 你在图上走到 $u$ 的时候它的相邻点都走过了. 然后发现除了 $u$ 的其他 $fa_u$ 的相邻点应该都走过了这样的.</p><p>这样会在树上建一个DAG, 边数是线性的, 问一个点能不能走一个路满足这个先后关系, 好像完全不可做.</p><p>[think] 考虑单个操作的简单影响而不是全体操作复杂的限制.</p><p>发现对于一条非树边 $u\to v$ , 相当于让链 $u$ , $v$ 之间的点以及它们的子树全不行了, 发现也就是只有 $u, v$ 和链不同向的子树满足条件, 就直接区间加全局最小值个数.</p><h3 id="CF917C-Pollywog"><a href="#CF917C-Pollywog" class="headerlink" title="CF917C Pollywog"></a>CF917C Pollywog</h3><blockquote><p>$n$ 个位置编号 $1\ldots n$ , $x$ 只青蛙, 开始在最左侧的 $x$ 个位置上, 每一秒最左侧的青蛙向右跳, 位于石头 $i$ 的青蛙可以跳跃到 $[i+1, i+k]$ , 体力花费为 $c_1\ldots c_k$ , 不能有两个青蛙在同一位置.</p><p>另有 $q$ 个石头是特殊的, 若一个青蛙是特殊的, 则会额外花费 $p$ 的体力.</p><p>求它们跳到最右边的 $x$ 个石头的最小代价.</p><p>$x\le k\le 8, n\le 10^{18}, q\le \min(25, n-x)$</p></blockquote><p>状压dp.</p><p>压缩 $f_{i, S}$ 表示最靠前的青蛙在 $i$ , 其中 $[i-7, i]$ 是否有青蛙的状态是 $S$ .</p><p>然后想到矩阵快速幂, 矩阵大小256*256, 那么预处理 $2^k$ 次转移的矩阵, 特殊点分成若干段, 每次用矩阵乘向量优化?</p><p>然而发现预处理已经上天了, 矩阵太慢了.</p><p>但倍增的思路一定是对的, 考虑设 $g_{i, S_1, S_2}$ 表示 $S_1$ 转移 $i$ 次到 $S_2$ 的代价, 发现可以倍增 $g$ , 转移 $f$ , 但这个和矩阵显然本质相同啊, 复杂度也没变.</p><p>不会了, 看lyh题解, 就是这个倍增dp, 只能用常数小解释了. </p><p>不过其实是可以优化到能过的范围的, 考虑实际上 $\vert S\vert&#x3D;n$ , 所以矩阵大小不是 $2^k$ 而是 $\binom{n}{k}$ , 最大是 $\binom{8}{4}&#x3D;70$ ! . 就无敌了.</p><p><del>刷</del>糊完了lyh的一个课件! </p><h2 id="Day6-slide-pdf"><a href="#Day6-slide-pdf" class="headerlink" title="Day6-slide. pdf"></a>Day6-slide. pdf</h2><p>数数题默认膜998244353.</p><h3 id="CF1408G-Clusterization-Counting"><a href="#CF1408G-Clusterization-Counting" class="headerlink" title="CF1408G Clusterization Counting"></a>CF1408G Clusterization Counting</h3><blockquote><p>给定 $n$ 点带权无向联通图, 求把其划分成 $k$ 个不交的组的方案, 满足任意 $s, f, x, y$ 中若 $s, f, x$ 同组, $y$ 与 $x$ 不同组, 则 $w_{x, y}&gt;w_{s, f}$</p><p>对 $1\ldots n$ 的每个 $k$ 输出答案.</p><p>$n\le 1500$</p></blockquote><p>考虑这个限制的实际含义是组内边大于组间边<del>(然后用形式化题意恶心人)</del>.</p><p>于是考虑直接按边权递增加边, 相同边权一起加, 那么每个组必然是出现过的连通块.</p><p>考虑连通块的总个数, 发现若形成新的连通块必然要加入新点和已有合并, 只有 $O(n)$ 个.</p><p>于是把 $O(n)$ 个连通块的包含关系建树, 那么问题就成了在树上选 $k$ 个没有祖先关系的点的方案数.</p><p>考虑dp, $f_{u, i}$ 表示 $u$ 子树内选了 $k$ 个即可.</p><p>[think] 把限制变成更实际意义的形式理解<br>[think] 不交的关系在包含关系的树上(父亲代表的集合包含儿子)表示为树上没有祖先关系.</p><h3 id="CF1383E-Strange-Operation"><a href="#CF1383E-Strange-Operation" class="headerlink" title="CF1383E Strange Operation"></a>CF1383E Strange Operation</h3><blockquote><p>有一个长度为 $n$ 的 $01$ 串 $s$ , 可以对该串进行若干次操作, 每次操作可以将两个相邻的数字合并为两者的最大值(操作之后字符串长度减少 $1$ ). 问操作后有多少种可能的字符串.</p><p>$n \le 10^6$</p></blockquote><p>考虑合并操作实质是让一个连续0段或1段缩短一个, 但1段不会消失, 0段有可能消失.</p><p>那么考虑判定串 $t$ 可以被 $s$ 得到, 从头开始扫, 如果当前0段长度大于 $s$ 的0段, 那么认为 $s$ 的这个段被消没了接着往下匹配, 如果当前1段大于 $s$ 的1段, 那么认为下一个0段被消没了打通到下一个, 这么贪心的匹配.</p><p>那么考虑dp方案, 用dpofdp的思想, 内层状态只需要记录 $t$ 是0&#x2F;1段, 长多少和 $s$ 的一段长多少, 显然是过不了的.</p><p>毫无用处.</p><p>看题解, 它用 $a_i$ 表示 $s$ 第 $i$ 个1和第 $i+1$ 个1之间0的个数, 认为可以得到叫包含, 则设 $f_i$ 表示 $a_1\ldots a_i$ 能够, 而更小的前缀无法包含的序列个数. 假设能包含的序列最后一项是 $x$ , 那 $x$ 肯定被 $a_i$ 包含, 考虑如果上一项被 $a_j$ 包含, 那么 $i, j$ 之间的 $a_k$ 都要小于 $x$ 不然就能被更短的包含了. 于是要找到最大的 $a_k\ge x$ 的 $k$ , 贡献到每个位置的 $k$ 是一个 $a$ 上从 $i$ 开始的后缀max, 容易发现每个 $k$ 只能贡献到一个 $i$(因为 $k&lt;i$, 后面由 $i$ 贡献), 可以单调栈做.</p><p>然后再处理点边界, 如果 $s$ 只有0是简单的, 并且假设 $s$ 最后最前分别有 $x, y$ 个0, 那么可以把它们剥去, 最后乘上 $(x+1)(y+1)$ , 用两边都是1的做.</p><p>[think] 感觉就是, 当我们不知道如何数数的时候, 可以思考一个状态数 $O(1)$ 的判定($t$ 当前前缀最少被 $a_k$ 包含), 把它塞到dp里. 其实就是dpofdp</p><h3 id="CF1372E-Omkar-and-Last-Floor"><a href="#CF1372E-Omkar-and-Last-Floor" class="headerlink" title="CF1372E Omkar and Last Floor"></a>CF1372E Omkar and Last Floor</h3><blockquote><p>给一个 $n\times m$ 的网格, 每一行被分成若干块, 要把格子里填满0&#x2F;1, 每个块内仅有一个1, 最大化 $\sum {q_i}^2$ , 其中 $q_i$ 为第 $i$ 咧的元素和.</p><p>$n, m\le 100$</p></blockquote><p>考虑一定会让最多的列填满.</p><p>那么至少让一列填满. 填满的这一列可以把它分成两半, 每一半结论相同.</p><p>那么区间dp, 设 $f_{l, r}$ 表示 $[l, r]$ 完整包含的块的答案, 那么枚举一个满的列分成两边就行了. 注意只要完整包含是因为如果没有完整包含一定在其他地方有了1.</p><h3 id="CF1366G-Construct-the-String"><a href="#CF1366G-Construct-the-String" class="headerlink" title="CF1366G Construct the String"></a>CF1366G Construct the String</h3><blockquote><p>给定一个包含小写字母和 $\texttt{. }$ 的串 $s$ , 字符 $\texttt{. }$ 表示backspace, 按顺序按下这些按键, 空串再删会崩溃, 求删除最少的字符使得结果为 $t$ 且不崩溃.</p><p>$\vert t\vert\le \vert s\vert \le 10^4$</p></blockquote><p>$f_{i, j}$ 表示 $s$ 的前 $i$ 个, 匹配 $t$ 的前 $j$ 个都最小代价. 不会转移.</p><p>设 $f_{i, j}$ 表示前 $i$ 个删 $j$ 个得到 $t$ 的最长长度, 也不会转移.</p><p>哦第一个是可以转移的啊. 考虑如果一个区间如果执行完是空的, 那么就可以从这个区间前转移, 因为删这个区间中某个不是<code>. </code>的东西等价于直接在前面删, 删这个区间中的<code>. </code>相当于保留区间最前面的元素, 相当于把最后一个<code>. </code>删了, 于是 $f_{i, j}$ 可以由 $f_{i-1, j-1}, f_{i, j-1}, f_{p, j}(\vert f(p+1, j)\vert &#x3D;0)$ 转移过来, 预处理每个位置从哪里转移过来是简单的.</p><p>[think] <code>. </code>的删除我们是会做的, 不会做的是<code>. </code>生效, 于是把不删调整成跳过一段转移过来.</p><h3 id="CF1342F-Make-It-Ascending"><a href="#CF1342F-Make-It-Ascending" class="headerlink" title="CF1342F Make It Ascending"></a>CF1342F Make It Ascending</h3><blockquote><p>给一个长度为 $n$ 的序列 $a$ , 你可以若干次选择 $i\ne j$ , 让 $a_j: &#x3D;a_j+a_i$ 并删除 $a_i$ , 用尽可能少的操作将序列变成严格增.</p><p>$n\le 15$</p></blockquote><p>$n\le 15$ , 但没有那么高妙, 只要猜状态.</p><p>考虑题目是要你选若干个集合, 和递增, 且每个集合选择其中的一个元素的位置递增, 且选的集合尽量多.</p><p>那你就设 $f_{S, i, j}$ 已经选了集合 $S$ , 已经选了 $i$ 个集合, 然后最后一个集合的元素的位置是 $j$ 的情况下最后一个集合的和的最小值.</p><p>状态好像挺自然? 小于20的dp要使劲设!</p><p>[think] upd: 隔一年来看不会做了. . . 直接dp满足条件的终态而非考虑过程</p><h3 id="CF1326F2-Wise-Men-Hard-Version"><a href="#CF1326F2-Wise-Men-Hard-Version" class="headerlink" title="CF1326F2 Wise Men (Hard Version)"></a>CF1326F2 Wise Men (Hard Version)</h3><blockquote><p>给定一个 $n$ 个点的无向图, 对于一个排列 $p_n$ , 对应一个 $01$ 序列 $a_{n-1}$ , 其中 $a_i$ 表示 $p_i$ 和 $p_{i+1}$ 之间是否有边, 给出图, 求对于每个01序列对应多少排列.</p><p>$n\le 18$</p></blockquote><p>居然是容斥题.</p><p>考虑限制是第 $i$ 位为1或无所谓, 求方案数, 那么只要容斥就能得到答案了. 把这个得到的用FMT可以得到答案.</p><p>那么现在一个限制串 $s$ , $s_i$ 为1表示这一位必须为1, 否则任意, 那么其中的0将1分成若干段, 每一段内必须有边, 段间随便走.</p><p>那么每一段的大小加一(长 $k$ 的段决定排列中长 $k+1$ 的区间中路径必须都走有边的)构成的可重集相同的 $s$ 答案相同. 原因是考虑: 段间不做要求所以两个段可以任意互换.</p><p>于是对每个可重集求答案. 因为可重集总和是 $n$ , 所以只有18的划分数大概不到400种情况.</p><p>那么处理长度为 $i$ , 走过 $S$ 中点的方案数 $g_{i, S}$ , 要求的 $f$ 是若干个 $g$ 的卷积, 要满足 $S$ 的并是全集, 并且对应的大小是 $i$ . 那就对每个划分卷一遍就行了. 复杂度 $385\times 2^n+2^nn^2$ .</p><p>[think] 容斥放宽限制</p><p>[think] 计数问题找等价类(这里的 $S$)</p><p><img src="/img/2022-10-21-20-05-27-image.png" alt="picture 2">  </p><h3 id="CF1290F-Making-Shapes"><a href="#CF1290F-Making-Shapes" class="headerlink" title="CF1290F Making Shapes"></a>CF1290F Making Shapes</h3><blockquote><p>给定 $n$ 个向量, 你可以把它们接起来走回原点得到多边形, 求这个多边形是凸的且可以被 $m\times m$ 的矩形框住的方案数. 不同位置的凸多边形算不同的.</p><p>$n\le 5, m\le 10^9, x_i, y_i\in [-4, 4]$</p></blockquote><p>考虑实际上多边形的形状仅取决于每种向量的个数, 因为凸多边形意味着我们对向量极角排序.</p><p>于是问题变成确定每组向量个数使得它们两个方向上和为0. 设个数分别是 $c_1, c_2, \ldots, c_n$</p><p>这个东西很难做, 因为它们的数量实在太大. 考虑<strong>逐位确定个数</strong>, 设 $f_{i, x_pos, x_neg, y_pos, y_neg, 0&#x2F;1, 0&#x2F;1}$ 表示 $c$ 的前 $i$ 位确定时, $x, y$ 的正负部分的进位和正负部分和的前 $i$ 位是否等于 $m$ 的前 $i$ 位的方案数, 每次枚举 $n$ 个 $c$ 在下一位是0&#x2F;1的 $2^n$ 种情况.</p><p>[think] 逐位确定个数, 用类似数位dp的方法设计状态, 用在值域大, 且我们关心的性质相对简单(比如这里只是大小关系)</p><h3 id="CF1299D-Around-the-World"><a href="#CF1299D-Around-the-World" class="headerlink" title="CF1299D Around the World"></a>CF1299D Around the World</h3><p>等好好学线性基, 考虑dp, 则 $t$ 要么包含 $s$ 作为子串, 要么它的前缀是 $s$ 的后缀, 它的后缀是 $s$ 的前缀.</p><h3 id="CF1292F-Nora’s-Toy-Boxes"><a href="#CF1292F-Nora’s-Toy-Boxes" class="headerlink" title="CF1292F Nora’s Toy Boxes"></a>CF1292F Nora’s Toy Boxes</h3><blockquote><p>$m$ 个不同正整数 $a_m$ , 每次选择不同的 $i, j, k$ 满足 $a_i$ 整除 $a_j, a_k$ , 然后删掉 $a_k$ , 求不同的最长的删除序列数.</p><p>$m\le 60, a_i\le 60$</p></blockquote><p>关系建图, $ka_i&#x3D;a_j$ 则 $a_i\to a_j$ , 图有很多个来连通块, 每个是独立的. 现在可以只考虑一个连通块.</p><p>于是每次可以选一条边, 然后在起点连出去一个点.</p><p>考虑这是个偏序图, 所以所有点都由连通块没有入度的点直接相连, 并且因为它是一个连通块, 所以只要有一个数就能拓展出, 所以只要保留一个数就可以拓展出其他所有的.</p><p>[think] 关系建图辅助思考</p><p>[think] 删&#x2F;加转化</p><p>再考虑计数重建的过程, 能加入点 $a$ 需要存在 $b$ 能与其有共同因数是根, 所以设 $f_{S}$ 表示连向加入的点的根的集合是 $S$ , 那么新的点的集合必然要与 $S$ 有交集并且没有加入过, 发现不会判断没有加入过这个条件. 发现如果新的点的质因子集合 $T$ 不被 $S$ 包含肯定没加入, 否则我们可以再加一维表示已经加入的点数, 此时知道被 $S$ 包含的总点数和已经加入的点数, 于是知道还没加入的点数, 那么从这里面挑一个转移就也能做了. 复杂度是 $2^r\times (n-r)^2$ , 其中 $r$ 是根的个数.</p><p>[think] 我们不知道某个性质的东西, 但可以知道它们的总数, 那么数数的话有的时候只要知道总数就能转移了.</p><p>考虑如果一个根超过 $\dfrac{n}{2}$ , 显然连不到任何东西是孤立点, 现在考虑小于 $\dfrac{n}{2}$ 的互不包含的数, 发现只考虑质因数2(删去所有质因数2后的不同数个数)就已经能分析到 $r&lt;\dfrac{n}{4}$ , 所以可以过.</p><h3 id="CF1286F-Harry-The-Potter"><a href="#CF1286F-Harry-The-Potter" class="headerlink" title="CF1286F Harry The Potter"></a>CF1286F Harry The Potter</h3><blockquote><p>假设有一个包含 $n$ 个元素的数组 $a$ , 现在需要把此数组的每个元素都变为 $0$ .<br>可以进行的操作有:</p><ul><li>选定两个数 $i$ 和 $x$ , 然后把 $a_i$ 减去 $x$ . (注意, $x$ 可以是负数)</li><li>选定三个数 $i, j$ 和 $x$ , 然后把 $a_i$ 减去 $x$ , 把 $a_j$ 减去 $x+1$ .<br>请输出最少的操作次数.</li></ul><p>$\vert a_i\vert \le 10^{15}, n\le 20$</p></blockquote><p>完全不会.</p><p>考虑用2类操作节省必须是 $k-1$ 步干掉 $k$ 个数, 所以是划分若干集合, 每个集合用2操作 $k-1$ 步删完, 剩下的用操作1.</p><p>[think] 用不弱的操作等效替换. 通过极大, 极小的性质简化(这里要求集合是极小的才有这个性质).</p><p>每个集合内的从左可以形成一棵树(边是 $k-1$ 个操作, 点是 $k$ 个数, 又要连通, 显然不能有环). 树是二分图, 可以将点分到两边, 发现每一步是将两边的差改变1并将一个数变成0. 于是差最多变化 $\vert S\vert-1$, 于是能不能节省的条件就是差在这个范围内并且差的奇偶性与 $\vert S\vert -1$ 一样. 于是现在判定一个集合就是要找到左右两边.</p><p>[think] 博弈论, 操作这类的抽取关键特征(左右两边的差)证充要.</p><p>那么判定一个集合这件事用meet in the middle是简单的, 现在要判定所有集合, 那么直接暴力是</p><p>$$<br>\sum \binom{n}{i} \cdot 2^{(\dfrac{i}{2})}&#x3D;(1+\sqrt 2)^n<br>$$</p><p>没问题.</p><p>最后就是dp, $f_S$ 表示 $S$ 能找出多少个这样的集合, 可以或者 $3^n$ dp.</p><p>说是可以子集卷积, 但是我不会啊.</p><h3 id="CF1279F-New-Year-and-Handle-Change"><a href="#CF1279F-New-Year-and-Handle-Change" class="headerlink" title="CF1279F New Year and Handle Change"></a>CF1279F New Year and Handle Change</h3><blockquote><ul><li>给出一个01串(表现为大小写), 可以最多选择 $k$ 个 $l$ 长度的子串, 全部变为0或1.</li><li>求操作后的 $\min(cnt_0 , cnt_1)$ 的最小值</li><li>$1 \le n, k, l \le 10^6$</li></ul></blockquote><p>感觉 $10^6$ 很难做, 而且我们会不限次数的版本($f_i$ 表示前 $i$ 个的最小值, 直接转移), 所以想一想得干掉 $k$ 这一维.</p><p>感觉能用的方法只有wqs二分. 显然收益是递减的, 否则可以把收益更大的放到前面做. 于是做完了.</p><h3 id="CF1276D-Tree-Elimination"><a href="#CF1276D-Tree-Elimination" class="headerlink" title="CF1276D Tree Elimination"></a>CF1276D Tree Elimination</h3><blockquote><p>给定一棵 $n$ 个点的树, 点编号 $1 \sim n$, 第 $i$ 条边连接 $a_i$ 和 $b_i$.<br>初始时你有一个空的序列, 树上的 $n$ 个点都有标记.<br>现在按照边的编号从小到大考虑每一条边:</p><ul><li>如果这一条边连接的两个点都有标记, 则选择其中的一个点, 擦除它的标记并将它的编号放入序列的末端;</li><li>否则什么都不做.<br>求能够由上述操作得到的不同的序列数量 $\bmod\  998244353$.</li></ul><p>$n\le 2\times 10^5$</p></blockquote><p>不同的序列就是不同的消除编号方案.</p><p>从边权维考虑很扯, 并且因为限制相对局部, 只能从树这一维去做.</p><p>对于一个点的方案, 一个点向上转移时我们只需要知道这个点和父亲见面的那次结果. 考虑把出边权值排序, 设 $f_{u, 0&#x2F;1&#x2F;2&#x2F;3}$ 表示 $u$ 没被删掉&#x2F;在遇到父亲前被删掉&#x2F;遇到父亲时被删掉&#x2F;遇到父亲之后被删掉.</p><p>$f_{u, 1&#x2F;3}$ 转移是考虑枚举这个点被哪个儿子干掉了, 那么这个儿子前的儿子只能选 $1, 2$, 干掉父亲的儿子可以选 $0, 3$, 后面的只能选 $0, 1, 3$. 懂了这个其他的就显然了.</p><p>[think] 枚举树上扫描线方向, 有些问题(比如这个)看起来是序列维的(比如这里从小到大插入边), 但实际上树上一个点邻边是一个局部的东西, 所以可能仍然是树这一维.</p><h3 id="CF1225G-To-Make-1"><a href="#CF1225G-To-Make-1" class="headerlink" title="CF1225G To Make 1"></a>CF1225G To Make 1</h3><blockquote><p>给定 $a_n$ 和 $k$, 保证 $k\not{\vert}\ a_i$, 每次可以选择 $x, y$ 删除并加入新的数 $f(x+y)$, 其中<br>$$<br>f(x)&#x3D;<br>\begin{cases}<br>    f(\dfrac{x}{k}), k\vert x\<br>    x, otherwise<br>\end{cases}<br>$$<br>问最后能不能只剩下 $1$. 构造方案.<br>$n\le 16, k\le 2000, \sum a_i\le 2000$</p></blockquote><p>$f_{S, i}$ 表示 $S$ 中集合凑出 $i$ 是否可行. 转移的时候删掉一个拼过来, 复杂度是 $2^nnv^2$</p><p>不会了. 考虑每个数对总答案的贡献是 $\dfrac{a_i}{k^{p_i}}$, 显然如果有这样一组 $p_i$ 使得和为1, 那么一定可以找到答案, 只要每次选择最大的两个合起来即可.</p><p>那么考虑找到 $p$ 的方式, 模拟 $p$ 的形成过程, 也就是一开始找到若干数的和是 $k$ 的倍数, 合并并给它们 $p$ 加1, 不断重复, 于是类比模拟设计dp, $f_{S, i}$ 表示集合 $S$ 中数的贡献和是 $i$, 转移是除以 $k$ 或者新加一个数, 复杂度是 $2^nnv$(真的能过啊算一算, 不过bitset优化到 $\dfrac{1}{w}$).</p><p>[think] 考虑一个数经过若干操作后对答案的贡献, 通过一组合法贡献构造策略.</p><p>[think] 把一个策略形成过程的几种操作作为dp的转移设计dp, 比如这里的 $p$</p><h3 id="CF1197F-Coloring-Game"><a href="#CF1197F-Coloring-Game" class="headerlink" title="CF1197F Coloring Game"></a>CF1197F Coloring Game</h3><blockquote><ul><li>有 $n$ 条纸条, 第 $i$ 个纸条被分成了 $a_i$ 个格子, 编号从 $1$ 到 $a_i$, 最开始每个格子是 $3$ 种颜色中的一种.  </li><li>游戏开始时, 有 $n$ 个棋子放在每个纸条的第 $a_i$ 个格子(即最后一个格子). 然后两个玩家进行轮流操作, 先不能操作者输.  </li><li>每次操作选择一枚棋子, 向后移动 $1, 2$ 或 $3$ 格. 要求棋子不能越过纸条的边界, 且若要从颜色为 $i$ 的格子向前移动 $j$ 个格子必须满足 $f_{i, j}&#x3D;1$.  </li><li>现在有些格子是未进行过染色的, 问有多少种染这些格子的方案, 使得后手有必胜策略, 对 $998244353$ 取模.<br>$1\le a_i\le10^9$, $1\le m\le 1000$, $1\le x_i\le n$, $1\le y_i\le a_{x_i}$, $1\le c_i\le 3$, $0\le f_{i, j}\le1$.</li></ul></blockquote><p>先考虑单个纸条算SG, 因为一个位置只能移动到往后三个位置, 所以SG值最多是3.</p><p>一个dp说 $f_{i, j}$ 表示第 $i$ 个格子颜色为 $j$ 的SG值, 那么dpofdp说 $f_{i, j, k}$ 表示第 $i$ 个格子, 颜色为 $j$, SG值为 $k$ 的方案数. 这个东西仍然性质很局部, 写成矩阵就冲了.</p><h3 id="CF1194G-Another-Meme-Problem"><a href="#CF1194G-Another-Meme-Problem" class="headerlink" title="CF1194G Another Meme Problem"></a>CF1194G Another Meme Problem</h3><blockquote><p>定义一个分数 $\dfrac{y}{x}$ 是好的当且仅当其等于某个 $\dfrac{x’}{y’}$, ($x’, y’\in [1, 9]$), 其中 $x’, y’$ 分别出现在 $x, y$ 的十进制表示中. 求有多少 $x, y\le n$ 的分数是好的.<br>$n\le 10^{100}$. 膜 $998244353$.</p></blockquote><p>首先可能的 $\dfrac{y}{x}$ 的值只有81种. 枚举一个 $(x’, y’)$ 计算.</p><p>于是要求 $x&#x3D;kx’, y&#x3D;ky’$, 可以数位dp, 但是有重复的情况, 于是钦定互质, 但那样的话同一个 $x, y$ 可能不满足 $(x’, y’)$ 而满足 $(ax’, ay’)$, 注意到 $a$ 很小(最大是 $9$, 第二大是 $4$), 所以状压dp, 就是 $f_{i, s_1, s_2, 0&#x2F;1, 0&#x2F;1, 0&#x2F;1, 0&#x2F;1}$ 表示前 $i$ 位, $x, y$ 分别可能的 $a$ 的集合是 $s_1, s_2$, 两者分别的进位, 与 $n$ 的大小关系即可.</p><p>这里分析复杂度的话注意不需要具体的 $s_1, s_2$, 而是两者只要包含了相同的 $a$ 之后立刻就没有意义, 所以实际状态数更小一些.</p><h3 id="CF1152F2-Neko-Rules-the-Catniverse"><a href="#CF1152F2-Neko-Rules-the-Catniverse" class="headerlink" title="CF1152F2 Neko Rules the Catniverse"></a>CF1152F2 Neko Rules the Catniverse</h3><p>欸刚刚杂题里写了.</p><h3 id="CF1146H-Satanic-Panic"><a href="#CF1146H-Satanic-Panic" class="headerlink" title="CF1146H Satanic Panic"></a>CF1146H Satanic Panic</h3><blockquote><p>给定平面上 $n$ 个点问以5个点为顶点能组成多少五角星, 对边长无要求, 对边的相交方式有要求.</p><p>保证无三点共线, $n\le 300$.</p></blockquote><p><img src="/img/2022-11-17-19-45-07-image.png" alt="五角星">  </p><p>需要先观察一下五角星. 发现是任何一个凸五边形即可.</p><p>第一个反应是用点dp, $f_{i, j, k}$ 表示点 $i$ 开始, 第一条边的角度是 $j$, 走 $k$ 条的方案数, 状态数是 $n^3$, 转移的时候要枚举另一个状态就成了 $n^4$. 那如果 $j$ 一维用线段树是不是可以 $n^3\log n$ 啊.</p><p>考虑把点对作为对象, 那么可以极角排序, $f_{i, j}$ 表示走了 $i$ 条边走到点 $j$, 再枚举一个起点即可.</p><p>注意不会重复计算某个多边形因为极角排序了, 相当于它只会沿着递增的斜率走.</p><p>[trick] 在 $n$ 几百的情况下凸多边形的问题可以考虑把点连成边用边做. 这个套路和 P2924 [US  ACO08DEC]Largest Fence G 是一样的.</p><h3 id="CF1142D-Foreigner-1"><a href="#CF1142D-Foreigner-1" class="headerlink" title="CF1142D Foreigner"></a>CF1142D Foreigner</h3><p>slide. pptx里面有了, 讲了两遍啊.</p><h3 id="CF1119F-Niyaz-and-Small-Degrees"><a href="#CF1119F-Niyaz-and-Small-Degrees" class="headerlink" title="CF1119F Niyaz and Small Degrees"></a>CF1119F Niyaz and Small Degrees</h3><blockquote><p>有一个 $n$ 个结点的树, 每条边有边权, 结点度数就是与之相连的边数量. 对于 $0 \le x &lt; n$, 删掉一些边使每个结点的度数不大于 $x$, 求出删掉的边的权值和最小值. 对每个 $x\in [0, n-1]$ 求答案.</p><p>$n\le 250000$</p></blockquote><p>先考虑一个确定的 $x$. $f_{u, 0&#x2F;1}$ 表示 $u$ 的子树内的最少代价, 其中有没有删 $u$ 的父边. 转移考虑先都选 $f_{v, 0}$, 然后把 $f_{v, 1}-f_{v, 0}$ 排序, 把一个前缀删了. 复杂度是 $n\log n$</p><p>[trick] 注意只要关心度数大于 $x$ 的点, 发现所有 $x$ 关心的点的个数总和是度数和 $2n-2$.</p><p>但暴力转移不对–一个菊花的边就能炸掉.</p><p>要让复杂度关于点, 那么考虑关心的点形成若干连通块, 每个连通块分别做, 那么每个点开一个数据结构维护所有已经不敢兴趣的点的边, 如果大小超过要删的个数就干掉最大值, 此时堆内元素和即为叶子答案, 对于每个连通块, 先求连通块的叶子, 然后把答案传给父亲, 将感兴趣的孩子传上来的放到堆里求最小的若干个再复原即可让复杂度和不感兴趣的儿子无关. 数据结构是个堆, 复杂度 $\log n$</p><h3 id="CF1103D-Professional-layer"><a href="#CF1103D-Professional-layer" class="headerlink" title="CF1103D Professional layer"></a>CF1103D Professional layer</h3><blockquote><p>给定 $1 \le n \le 10^6$ 个正整数 $a_i, 1 \le a_i\le 10^{12}$ , 修改第 $i$ 个正整数 $a_i$ 的花费为 $e_i, 1 \le e_i \le 10^9$ , 以及正整数 $1 \le k \le 10^{12}$ .<br>要求选出若干个正整数进行一次修改, 使得修改后所有正整数的最大公约数等于 $1$ . 修改操作为: 对于正整数 $a$ , 选择 $a$ 的一个约数 $d \le k$ , 把 $a$ 修改为 $\frac{a}{d}$ .<br>设选出并修改的正整数有 $x$ 个, 他们的花费之和为 $y$ , 则总的修改花费为 $x \times y$ . 求最小花费.</p></blockquote><p>考虑全局的 $gcd$ 设为 $g$, $g$ 显然最多有 $m&#x3D;11$ 个不同的质因数. 那么首先其他质因子都等于没有直接杀了, 此时还剩下 $M&#x3D;12000$ 个数(打表算啊). 每种数效果显然是相同的, 那么最多是都从同一种数操作, 所以每一种数只需要保留 $m$ 个数. 那么可以算出这个数消掉每个 $g$ 的质因子的子集的代价, 复杂度 $Mn2^m$.</p><p>于是对于每个子集, 我们知道了哪些数可以消掉它, 此时仍然只有前 $m$ 个有用(因为我们最多用 $m$ 个数消完, 所以前 $m$ 个数一定不会全都被其他因子用了).</p><p>于是考虑状压dp, $f_{i, j, S}$ 表示前 $i$ 个数字 $c$ 次操作消掉集合 $S$ 的代价, 转移只要枚举 $i$ 对应的子集和与其不相交的 $T$ 即可从 $f_{i-1, c-1, T}\to f_{i, c, T\cup S}$, 复杂度 $m^23^m$</p><h3 id="CF1097G-Vladislav-and-a-Great-Legend"><a href="#CF1097G-Vladislav-and-a-Great-Legend" class="headerlink" title="CF1097G Vladislav and a Great Legend"></a>CF1097G Vladislav and a Great Legend</h3><blockquote><p>给定 $Tree(n)$, 对于点集 $X$, 设 $f(X)$ 表示至少选多少条边可以使点集联通, 求 $\sum_{X\subseteq {1\ldots n}, X\ne \varnothing} f^k(X)$</p><p>$n\le 10^5, k\le 200$</p></blockquote><p>考虑工业化的处理 $f^k(X)$ 而不是在这里试图智慧的处理这个幂, 普通幂对组合意义没有下降幂友好, 斯特林数变成</p><p>$$<br>\begin{gathered}<br>    n^k&#x3D;\sum_i {k \brace i}n^{\underline{i}}\<br>    \sum f(X)^k&#x3D;\sum_i {k \brace i}(f(X))^{\underline{f(X)}}\<br>    &#x3D;\sum_i {k\brace i} i! \sum \binom{f(X)}{i}<br>\end{gathered}<br>$$</p><p>前面那部分不用管了, 组合意义说后面相当于对于每个虚树选 $i$ 条边的方案数之和. 要 $nk$ 算所有的.</p><p>考虑dp, $f_{u, i}$ 表示 $u$ 的子树内选 $i$ 条边的答案. 其中一条边被选了要求它下方的子树有点在 $X$ 中被选. 再设 $g$ 是多考虑了父边. 那么 $f$ 的转移是先合并所有子节点的 $g$, 而 $g_{u, i}&#x3D;f_{u, i}+f_{u, i+1}$(关于上面那条边选不选). 因为每次都要考虑当前节点选不选, 所以 $u$ 合并儿子的时候初始状态是 $f_{u, 0}&#x3D;2$. $g_{u, 1}$ 要减1表示子树内并没有点但你选了个父边.</p><p>对于统计答案, 钦定在一个虚树的根统计这个虚树, 那么不是根的情况就是所有的全来自同一子树, 其他点和根都没选, 此时减去 $g_{v, i}$.</p><p>总复杂度 $k^2+nk$.</p><h3 id="CF1085G-Beautiful-Matrix"><a href="#CF1085G-Beautiful-Matrix" class="headerlink" title="CF1085G Beautiful Matrix"></a>CF1085G Beautiful Matrix</h3><blockquote><p>一个矩阵是漂亮的当且仅当其中只包含 $1\ldots n$ 的正整数, 每行元素互不相同, 每个上下相邻的元素不相同. 给定漂亮的矩阵 $A$ 问这个矩阵在所有的漂亮矩阵中的字典序(从0开始). 字典序是从上到下逐行比较.</p><p>$n\le 2000$</p></blockquote><p>那肯定是计数有多少个矩阵字典序小于当前矩阵, 因为是字典序所以只要钦定第一个小于 $A$ 的位置就是不重不漏. 再考虑所有漂亮矩阵的方案数是 $n! \cdot {D_n}^{n-1}, D_n$ 为错排数. 那么假设钦定了 $i, j$ 是第一个小于的, 问题就变成了这一行 $j$ 之后有多少种方案. 发现这个方案数只和有多少数在前面出现了有关(因为是等价的, 可以认为是 $k$ 个位置 $a_i\ne i$ 的排列), 若 $A_{i-1, j+1\ldots n}$ 和 $A_{i, j+1\ldots n}$ 有 $k$ 个数相同, 则这个比它小的也有 $k$ 个相同. 求相同个数是简单的.</p><p>于是问题就变成如何求长 $i$ 的序列有 $j$ 个钦定不能的方案数 $f_{i, j}$, 考虑递推, 是 $f_{i, j-1}-f_{i-1, j-1}$(长 $i$ 的限制了 $j$ 位的减去最后一个选了 $n$ 的).</p><p>总复杂度是 $n^2\log n$($\log n$ 来自求相同个数的时候用的树状数组).</p><h3 id="CF1082F-Speed-Dial"><a href="#CF1082F-Speed-Dial" class="headerlink" title="CF1082F Speed Dial"></a>CF1082F Speed Dial</h3><blockquote><p>给定 $n$ 个电话号码 $t_i$, 第 $i$ 个被输入 $m_i$ 次, 你可以设置 $k$ 个串 $s_i$, 每次输入一个电话号码的时候可以选择一个 $s_i$(或者不选), 在其基础上补充完剩下的部分. 最小化输入次数(设置 $k$ 个串的部分不算次数).</p><p>$n, \sum t_i\le 500, k\le 10$</p></blockquote><p>因为预先设置的都作为前缀, 考虑建一个trie. 此时问题变成选择 $k$ 个节点, 每次输入的代价是到最近的点的距离.</p><p>以子树为扫描线方向去做, 关键问题是如何统计子树内到 $u$ 的贡献. $f_{u, k, i}$ 表示 $u$ 的子树内选了 $k$ 个点, 到 $u$ 的路径上没有选点的权值总和为 $i$. 转移如果 $u$ 选就 $i$ 置为 $0$, 否则就累加起来再加 $1$($u$ 自己). 转移需费用提前计算. 复杂度是爆炸.</p><p>不会了, 看看lyh的dp是设 $f_{u, c, d}$ 表示 $u$ 距离上面最近的关键点距离为 $d$, 子树内有 $c$ 个的最小代价. 相当于假定一个关键点计算代价. 感觉与费用提前计算本质相同.</p><p>[think] upd: 对于一个子树, 我们不知道的是没有选到关键点的点的代价, 它相当于一个内部外部选点组合的代价 $cost(S, T)$, 一个是内部选点, 一个是外部选点, 内部的方案对贡献本质有 $\sum m$ 种, 而外部只本质有 $n$ 种.</p><h3 id="CF1067E-Random-Forest-Rank"><a href="#CF1067E-Random-Forest-Rank" class="headerlink" title="CF1067E Random Forest Rank"></a>CF1067E Random Forest Rank</h3><blockquote><p>给定一棵 $n$ 个节点的树, 每条边有 $\frac{1}{2}$ 的概率出现, 可以得到一个森林, 求这个森林邻接矩阵的秩的期望.</p><p>$n\le 5\times 10^5$</p></blockquote><p>好了第一步转化就不会了, 结论是 $rank$ 是最大匹配的两倍. 证明是考虑把这些点对应的行拿出来是原来的一组基且线性独立.</p><p>剩下的部分可以想一想, 要对森林的匹配求和. 肯定是子树结构, 想一想最大匹配怎么求, 可以贪心从下往上选, 那么设 $f_{u, 0&#x2F;1}$ 表示 $u$ 有没有被选的方案数, $g_{u, 0&#x2F;1}$ 表示答案就能转移.</p><h3 id="CF1063F-String-Journey"><a href="#CF1063F-String-Journey" class="headerlink" title="CF1063F String Journey"></a>CF1063F String Journey</h3><blockquote><p>给定 $s_n$, 求选出最多不交子串满足出现的位置不相交且一次排列($t_{i+1}$ 在 $t_i$ 之后), 且 $t_{i+1}$ 是 $t_i$ 的真子串. 求最大的 $k$.</p><p>$n\le 5\times 10^5$</p></blockquote><p>从后往前, 一定可以每次只添加一个新字符. 同时也能看出来 $k$ 和 $\vert t_k\vert$ 是 $\sqrt n$ 量级.</p><p>那么dp的几种可能是, $f_i$ 表示最后 $i$ 个字符最大匹配几个 $t$, 或最后 $i$ 个 $t$ 最少匹配到哪. 第二种不会转移, 第一种可以hashtable维护做到 $n\sqrt n$.</p><p>考虑优化: 首先显然相邻两个 $f$ 相差不超过1. 那么可以考虑一个判定来转移, 每次给定 $i, k$ 判断能否 $f_i\ge k$, 从第一个位置开始往下问就可以 $O(n)$. 考虑如何判定, 通过这个可以确定这次的 $t$, 枚举删哪个端点就判定知道上次的 $t$, 那么建SAM, 就是查 $t$ 在 $i-k$ 之前的 $endpos$ 的最大值, 然后直接查那个位置的 $f$ 即可.</p><h3 id="CF1060F-Shrinking-Tree"><a href="#CF1060F-Shrinking-Tree" class="headerlink" title="CF1060F Shrinking Tree"></a>CF1060F Shrinking Tree</h3><blockquote><p>给定 $Tree(n)$, 每次等概率随机删掉一条边 $u\to v$, 并在边的两个端点随机一个, 把这个点 $u$ 的所有边 $u\to v$ 接到另一个点 $w$ 上变成 $w\to v$, 问每个点被剩下的概率.</p><p>$n\le 50$</p></blockquote><p>怎么才2900. . . 好难想的状态. . . 是外国人都这么会DP所以分低吗?</p><p>先说解法, $f_{u, i}$ 表示 $u$ 的子树内, 删掉最后 $i$ 条边之前和之后根相同的概率. $g_{u, i}$ 是根是 $u$ 的父亲并且加上 $fa\to u$ 这条边.</p><p>那么对于合并 $u$ 的儿子 $v$, 转移分两步:</p><ul><li>加入 $v$ 父边, 也就是 $f$ 到 $g_{v, j}$, 只要考虑边 $u\to v$ 的加入时间 $i$:<ul><li>如果 $i&gt;j$, 也就是 $i$ 删除时间更早, 那么它的结果不影响(只关心 $j$ 之后的), 直接 $f_{v, i}\to g_{v, j}$</li><li>如果 $i\le j$, 也就是 $i$ 是 $j$ 之后删除的, 那么为了不影响根要求删它的时候必须选 $v$, 所以 $\dfrac{1}{2}f_{v, i}\to g_{v, j}$</li></ul></li><li>合并, 也就是 $g_v$ 到 $f_u$, 枚举最后 $i$ 条中 $g_v$ 中有 $j$ 条, $f$ 中有 $i-j$ 条, 转移是两个隔板法的组合数.</li></ul><p>[think] 至于状态设计, 我的理解是考虑到每个点表示原图的一个连通块, 并且根可能移动, 所以设计”根相同”这样离谱的状态, 而最后 $i$ 条是考虑到 $u\to v$ 没删的时候子树 $v$ 内部的顺序不影响 $u$.</p><p>最后复杂度是 $n^3$(第一部分前缀和优化, 第二部分树形背包分析).</p><p>写了代码, 如果按照概率写(这个题要求输出小数, 这样有精度), $g_v$ 合并到 $f_u$ 这一步, 若最后 $i+j$ 条有 $j$ 条来自 $v$, $i$ 条来自已经合并完的 $u$ 的部分, 那么你的新概率应该是 $g_{v, j}f_{u, i}\cdot \dfrac{\binom{siz_u}{i}\binom{siz_v}{j}}{\binom{siz_u+siz_v}{i+j}}$. 考虑如果求的是方案数, 你不能直接插板: 直接插板不能保证插完了最后 $i+j$ 个里面有 $i$ 个来自 $u$, 你需要前面后面分开插. 同时, 因为 $f_u$ 实际上是 $\dfrac{f’_u}{siz_u! }$, 这个推一下就产生分母上的组合数.</p><h3 id="CF1038F-Wrap-Around"><a href="#CF1038F-Wrap-Around" class="headerlink" title="CF1038F Wrap Around"></a>CF1038F Wrap Around</h3><p>考虑dp, 则 $t$ 要么包含 $s$ 作为子串, 要么它的前缀是 $s$ 的后缀, 它的后缀是 $s$ 的前缀.</p><p>设 $f_{i, l, r, p, 0&#x2F;1}$ 表示 $t$ 的前 $i$ 个字符, $t$ 最长的是 $s$ 子串的前缀对应子串为 $s_{l\ldots r}$, 最长的后缀对应 $s$ 的前缀是 $s_{1\ldots p}$, 是否包含 $s$ 作为子串.</p><p>这里这么设是因为, 在往 $t$ 的后面添加字符的情况下, 我们可以容易的确定匹配 $s$ 的前缀, 但不能容易的确定匹配 $s$ 的后缀, 所以第一部分要记录 $l, r$ 而第二部分只记录 $p$. 而 $0&#x2F;1$ 位的转移更是简单的.</p><h3 id="CF995F-Cowmpany-Cowmpensation"><a href="#CF995F-Cowmpany-Cowmpensation" class="headerlink" title="CF995F Cowmpany Cowmpensation"></a>CF995F Cowmpany Cowmpensation</h3><blockquote><p>$n$ 个点的有个树, 需要给每个点赋 $[1, D]$ 之间的值, 满足每个点的权值不超过其任意祖先. 问方案数.</p><p>$n\le 3000, D\le 10^9$</p></blockquote><p>$f_{u, k}$ 表示这棵子树, 所有点权不超过 $k$ 的方案数, 有 $f_{u, k}&#x3D;f_{u, k-1}+\prod_v f_{v, k}$, 发现是关于 $k$ 的 $size_u$ 次多项式(归纳可得). 所以拉插.</p><h3 id="CF981H-K-Paths"><a href="#CF981H-K-Paths" class="headerlink" title="CF981H K Paths"></a>CF981H K Paths</h3><blockquote><p>给定 $Tree(n)$, 找到 $k$ 条有编号的路径, 满足树上每条边只能被 $0&#x2F;1&#x2F;k$ 条路径覆盖且至少有一条被 $k$ 条覆盖. 求方案数.</p><p>$n, k\le 10^5$</p></blockquote><p>考虑固定了 $u, v$ 为这 $k$ 条路径的交的两个端点, 有两种可能: $u, v$ 有祖先关系, 或者没有.</p><p>那么问题就是处理出 $f_u, g_u$ 表示一个端点为 $u$, 另一个端点在 $u$ 子树内&#x2F;外的方案数, 于是没有祖先关系的直接相乘 $f$, 再给每个点 $u$ 加上 $g_u \sum_{v\in subtree(u)} f_v$. 问题变成如何求 $f, g$.</p><p>先考虑 $f$, 注意到不会有两个链延伸到相同的子树, 而在一个子树内显然另一个端点随便选, 所以有 $i$ 条没有停留在点 $u$ 的生成函数就是 $F&#x3D;\prod_{u\to v} (1+siz_v\cdot x)$, 某个 $i$ 的方案数是 $[x^i]F$, 总方案数就是 $\sum_i k^{\underline{i}}a_i$. 这个复杂度是 $c\log^2 c$, 其中 $c$ 为儿子个数, 因为度数总和是线性所以没问题.</p><p>但不会算 $g$, 这个东西复杂度现在和父亲度数有关. 考虑直接带着和答案一起算, 那么设 $G&#x3D;\sum b_ix^i$ 刚才说的 $g_u \sum_{v\in subtree(u)} f_v$ 就是 $\sum_i k^{\underline{i}}b_i(\sum_{v\in subtree(u)}f_v)$. 前面那部分不变, 问题就是 $\sum_i \sum_v b_ix^i(\sum_v f_v)$, 设 $S_u&#x3D;\sum_{v\in subtree(u)} f_v, A_v&#x3D;1+siz_v\cdot x, B_v&#x3D;S_v(1+(n-siz_u)x)$, 就是选一个 $B$, 其他都选 $A$ 的多项式的和, 可以用消失之物的那种分治去分治FFT算.</p><p>总复杂度 $n\log^2 n$</p><h3 id="CF724E-Goods-Transportation"><a href="#CF724E-Goods-Transportation" class="headerlink" title="CF724E Goods Transportation"></a>CF724E Goods Transportation</h3><blockquote><p>小明升任了 CF 国的大总管, 他管辖的 $n$ 个城市, 编号为 $1. . n$. 每个城市生产了 $p_i$ 个货物, 限制最多可以卖掉 $s_i$ 个货物. 对于每两个城市 $i, j$, 如果 $i &lt; j$, 则可以最多从 $i$ 运送 $c$ 个货物到 $j$. 注意不能反向运送, 却可以在多个城市之间送来送去. 现在小明想知道, 经过运输后, 最多能卖掉多少个货物. </p><p>$n\le 10^4$</p></blockquote><p>考虑一个简单最大流: $S\stackrel{p_i}{\longrightarrow} i, i\stackrel{c}{\longrightarrow} j, i\stackrel{s_i}{\longrightarrow} T$ 即可, 但即使前后缀优化建图看起来也过不了.</p><p>考虑转化成最小割设计dp, $f_{i, j}$ 表示前 $i$ 个点其中有 $j$ 个到 $s$ 有边, 那么对于新的 $i$ 要么割 $s\to i, a\to i(a&lt;i)$, 要么割 $i\to t$, 对应转移即可. 复杂度 $n^2$.</p><p>两个ppt过一遍了! 联赛完有空再去看第三个! 接下来该练练码力!</p><h2 id="杂题选讲2"><a href="#杂题选讲2" class="headerlink" title="杂题选讲2"></a>杂题选讲2</h2><h3 id="CF1407E-Egor-in-the-Republic-of-Dagestan"><a href="#CF1407E-Egor-in-the-Republic-of-Dagestan" class="headerlink" title="CF1407E Egor in the Republic of Dagestan"></a>CF1407E Egor in the Republic of Dagestan</h3><blockquote><p>给定一张有向图 $Graph(n, m)$, 边, 点有黑白两色, 边的颜色给定, 每个点只能走和它颜色相同的边, 求把点染色后 $1\to n$ 的最短路最大值, 不连通视为 $inf$.</p><p>$n, m\le 5\times 10^5$</p></blockquote><p>考虑每个点的选择只和它出边有关, 所以从后往前做, 直接bfs看每条边能不能堵死就可以了.</p><h3 id="CF1370F2-The-Hidden-Pair-Hard-Version"><a href="#CF1370F2-The-Hidden-Pair-Hard-Version" class="headerlink" title="CF1370F2 The Hidden Pair (Hard Version)"></a>CF1370F2 The Hidden Pair (Hard Version)</h3><blockquote><p>交互题, 给定一棵树和未知点对 $(u, v)$, 每次可以询问一个点集, 得到其中使 $dis(u, w)+dis(v, w)$ 最小的 $w$ 和最小值, $11$ 次询问找到未知点对.<br>$n\le 1000$</p></blockquote><p>考虑如果点集中有一个点在 $u, v$ 之间, 则 $w$ 是这个点, 最小值是 $dis(u, v)$, 所以要想办法让在 $u, v$ 之间的点尽可能少, 同时要想着利用我们得到的, 确定在 $u, v$ 之间的点 $x$.</p><p>根据这两个思想, 发现问与 $x$ 距离为 $\max dis(x, u), dis(x, v)$ 的点可以得到一个端点: 因为这个圆上的其他点必定不在路径上, 于是就得到一个端点, 然后去问与这个端点距离 $dis(u, v)$ 的点即可得到另一个端点.</p><p>于是问题是求 $\max dis(x, u), dis(x, v)$, 考虑二分, 发现很好判断: 最小值不是 $dis(u, v)$ 就说明当前答案大了, 于是就做完了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DFA最小化</title>
      <link href="/2022/10/19/dfaminimize/"/>
      <url>/2022/10/19/dfaminimize/</url>
      
        <content type="html"><![CDATA[<h1 id="DFA最小化学习笔记"><a href="#DFA最小化学习笔记" class="headerlink" title="DFA最小化学习笔记"></a>DFA最小化学习笔记</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>DFA: 众所周知啊.</p><p>DFA的等价类: 若DFA中两个节点相同字符的出边指向的节点属于同一等价类, 则它们是等价的.</p><h2 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h2><p>大致原理是选择一个等价类 $A$ 作为”证据”, 若所有能到 $A$ 中的节点集合为 $X$ , 而存在等价类 $Y$ 满足 $X\cap Y\ne \varnothing, X&#x2F;Y\ne \varnothing$ , 则可以把 $Y$ 划分成这两个部分.</p><p>于是算法流程就是初始化一个证据集合包含结束节点, 一个等价类, 每次取出一个证据, 然后执行上面的过程, 然后把它删了, 如果 $Y$ 在证据中就把 $Y$ 删了, 分成的两个部分, 否则加入两个部分中少的那一个, 直到证据集合为空.</p><p>复杂度是 $n\vert \sigma\vert \log n$ .</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>感觉主要用在dpofdp上, 因为本质相同的dfa最小化结果唯一, 就是说你内层dp的状态设计有很多种, 但最小化的结果应该是相同的. 会得到和你本质相同的所有dfa中最小的一个.</p><p>遇到这种题要大胆猜能用到的状态没看上去那么多.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> dfa最小化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比赛记录</title>
      <link href="/2022/10/10/contest-records/"/>
      <url>/2022/10/10/contest-records/</url>
      
        <content type="html"><![CDATA[<h1 id="比赛记录"><a href="#比赛记录" class="headerlink" title="比赛记录"></a>比赛记录</h1><p>已经不光是比赛了, 还有看的成套的题.</p><p>已经又都是比赛了, 成套的题移走了.</p><h2 id="ZSContest"><a href="#ZSContest" class="headerlink" title="ZSContest"></a>ZSContest</h2><p>很久以前写下zscontest的编号. . . zs是什么啊?</p><p>是不是振声啊</p><h3 id="A-博弈论-打表"><a href="#A-博弈论-打表" class="headerlink" title="A [博弈论] [打表]"></a>A [博弈论] [打表]</h3><blockquote><p>$n\times m$ 的网格上有若干硬币, 初始时全部为反, $q$ 次翻转一个矩形并询问, 若两人轮流操作, 每次先选择一枚正面硬币 $(x, y)$ , 再选择一个 $(a, y), a&lt;x$ 或 $(x, b), b&lt;y$ , 同时翻转这两个格子的硬币, 不能操作的人输, 是先手必胜还是后手必胜.</p><p>$n, m\le 10^9, q\le 10^5$ </p></blockquote><p>首先结论: 每一枚硬币是独立的. 这个操作实际上相当于硬币可以向左或向下移动若干步, 两枚硬币碰到一起就一起消失, 那么考虑假设硬币不会消失的情况和这个是等价的, 因为若选择移动多枚硬币位置相同, 后手仍然以相同方式移动这个位置到先手移动到的位置是不会让局面更优也不会更劣等, 所以是等价的.</p><p>于是每一枚硬币分别的SG值求出来异或, 打表SG值和其矩形前缀和找规律吧.</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote><p>有 $n$ 个数对 $(a, b)$ 构成的集合, 给定 $m$ , $k$ 和集合, 求最小的 $t$ 满足有至少 $k$ 个不同子集的 $\sum a+bt\ge m$ .</p><p>$n, k\le 10^5, a, b, m\le 10^9$ </p></blockquote><p>二分答案是容易想到的, 于是变成了求有多少个子集和大于 $m$ 或子集和的第 $k$ 大.</p><p>一般rank总是比kth容易, 发现k并不到 $2^n-1$ , 我们的复杂度一定是相关 $k$ 的, 然后就不会了.</p><p>一个我没见过的经典题求所有子集合的第 $k$ 大, 解法是爆搜子集, 当前结果大于等于 $m$ 就返回, 否则把个数加一继续搜.</p><p>这个复杂度的分析是重点, qyc一开始说因为每次递归让方案数变大1, 最多到 $k$ (不然直接停), 于是就解决了, 但实际上, 若初始状态为全部不选, 连续若干个不选并不会增加方案数, 正确的做法是先递增排序, 这样如果前面的不选后面的更选不了可以直接跳, 就仍然有每次递归方案数变大1了.</p><p>然而这个题还有负数, 考虑我们搜大于等于 $m$ 的子集, 就要满足:</p><ul><li><p>一旦和低于 $m$ 就能退出</p></li><li><p>若这个不选以后的也不能选</p></li></ul><p>所以初始状态为选所有正数不选所有负数, 并按绝对值排序, 这样做保证如果当前这一位相比初始状态不能改变以后的也不行可以直接跳.</p><h3 id="C-直径"><a href="#C-直径" class="headerlink" title="C [直径]"></a>C [直径]</h3><blockquote><p>单点修改边权, 查子树直径. $n\le 10^5$ .</p></blockquote><p>合并直径是简单的, 四个端点两两比一比就好了, 因为要查距离并支持修改所以用BIT维护点到根距离, 并用建在欧拉序上的线段树维护直径解决问题.</p><p>另一种做法是静态toptree说能1log, 但我还不会静态toptree, 需要学习一下.</p><h3 id="D-FFT-多项式"><a href="#D-FFT-多项式" class="headerlink" title="D [FFT] [多项式]"></a>D [FFT] [多项式]</h3><blockquote><p>给一个 $V\le 2$ 个点, 识别括号和空格的自动机, 字符集为 $(, ), space$ , 求有多少种从点 $s$ 到点 $t$ 走 $n$ 的方案行成合法括号串. </p><p>$n\le 10^5$ </p></blockquote><p>万恶多项式, 打完 $n\le 1000$ 走人.</p><p>等学了分治FFT再来.</p><h2 id="22-10-10-VP-CF1198-Codeforces-Round-576-Div-1"><a href="#22-10-10-VP-CF1198-Codeforces-Round-576-Div-1" class="headerlink" title="22. 10. 10 VP CF1198 Codeforces Round #576 (Div. 1)"></a>22. 10. 10 VP CF1198 Codeforces Round #576 (Div. 1)</h2><p>和wjw, 难度感觉不大到Div1.</p><p>过程大概是先切A, 然后看一眼B直接SegmentTreeBeats没冲出来发现自己不会STB. 然后去开C, D, E, F, 发现E好像可做. 仔细一想是个套路网络流把它冲出来了, 然后去做B写了个更简单的O(n)做法. 比赛结束.</p><p>wjw切了 $B\to A\to D$</p><h3 id="A-MP3"><a href="#A-MP3" class="headerlink" title="A MP3"></a>A MP3</h3><p>智障题.</p><h3 id="B-Welfare-State"><a href="#B-Welfare-State" class="headerlink" title="B. Welfare State"></a>B. Welfare State</h3><blockquote><p>单点改, 区间取max. $n, q\le 2\times 10^5$</p></blockquote><p>写吉老师线段树的都降智.</p><p>直接离线, 对每个点考虑, 一个点的值是它最后一次修改的值和从这一次修改开始往后这一段时间取max的最大值. 复杂度线性.</p><p>所以CF这种短时间比赛反而更不能急着码, 多想想是不是可以写的简单点.</p><h3 id="C-Matching-vs-Independent-Set"><a href="#C-Matching-vs-Independent-Set" class="headerlink" title="C. Matching vs Independent Set"></a>C. Matching vs Independent Set</h3><blockquote><p>给一个 $3n$ 个点, $m$ 条边的图, 你给出一个 $n$ 个点的独立集或一个 $n$ 个边的匹配.</p><p>$n\le 10^5, m\le 5\times 10^5$ . 多组询问.</p></blockquote><p>qyc的做法, 任意求一棵dfs树, 如果叶子多于 $n$ 个就选叶子, 否则现在叶子少于 $n$ 个, 除了叶子每个点都可以和自己的父亲&#x2F;儿子匹配, 于是至少有 $n$ 个边. 就结束了.</p><p>wjw看了看slime的做法, 说的是直接贪心求匹配(任意加边), 如果够 $n$ 条直接结束, 否则因为只使用了少于 $2n$ 个点, 且剩下的点已经选不出相邻的两个点形成匹配, 所以剩下的一起当独立集即可.</p><h3 id="D-Rectangle-Painting-1"><a href="#D-Rectangle-Painting-1" class="headerlink" title="D. Rectangle Painting 1"></a>D. Rectangle Painting 1</h3><blockquote><p>给一个 $n\times n$ 的网格图, 一开始格子有黑有白, 每次你可以花费 $\max w, h$ 的代价将一个 $w\times h$ 的矩形染白, 求全白的最小代价.<br>$n\le 50$</p></blockquote><p>降智题</p><p>做法是, 要么一个操作染了全局, 否则必然有一个未染色的分界点(分界成左上和右下), 然后可以递归下去做. 这样复杂度 $n^5$ .</p><p>还是不太敢想这种 $n^5$ 复杂度的东西啊, 明明是可以很简单的.</p><h3 id="E-Rectangle-Painting2"><a href="#E-Rectangle-Painting2" class="headerlink" title="E. Rectangle Painting2"></a>E. Rectangle Painting2</h3><blockquote><p>给一个 $n\times n$ 的网格图, 一开始格子有黑有白, 每次可以花费 $\min w, h$ 的代价将一个 $w\times h$ 的矩形染白, 求全白的最小代价.</p><p>黑色格子的给出方式是输入 $m$ 个矩形, 黑色格子为这 $m$ 个矩形的并.</p><p>$n\le 10^9, m\le 50$ .</p></blockquote><p>套路题. 首先我们显然会每次将染一行或一列全染白, 于是就成了选若干行和列覆盖所有位置. 这个模型有点像网络流, 然后发现一个最小割结束战斗(行点列点, 行向列连 $inf$ , 起点, 终点向行列连1). 然后突然发现黑色格子是由矩形给出的. 不过没关系, 直接离散化, $m$ 个矩形在平面上切割的连通块数是 $m^2$ 的, 所以就是 $4m$ 个点, $m^2+2m$ 个边冲就好了.</p><h3 id="F-GCD-Groups-2"><a href="#F-GCD-Groups-2" class="headerlink" title="F. GCD Groups 2"></a>F. GCD Groups 2</h3><blockquote><p>给出 $n$ 个整数, 要将它们划分成两个集合使得这两个集合各自 $\gcd$ 为1, 求方案或判断无解.</p><p>$n\le 10^5$</p></blockquote><p>有点意思.</p><p>智慧法: 从前往后扫, 考虑第一个集合, 如果当前这个数不是 $\gcd$ 的倍数就加入这个一集合, 这样 $gcd$ 一定变小. 然后一遍肯定不对就randomshuffle. 正确的原因是, $10^9$ 的不同质因数个数只有9, $10^9$ 到质数大约有 $5\times 10^7$ 个很多, 所以很难出现一种状况让一整个集合有一个共同质因子.</p><p>官方正解(搬运翻译):</p><p>首先, 你只要用 $9$ 个数干掉每一个因子. 所以有解情况下必然由一种情况使得在其中一个集合大小不超过9.</p><p>然后随机取两个数钦定它们在不同的集合中, 这样同一个集合的概率很小(因为其中一个集合只有9个数). 然后对一个集合做状压dp(压掉当前还活着哪些质因子). 这样做复杂度是 $n\times 2^{2k}$ .</p><p>最后实际不需要全部 $n$ 个数做这个dp, 可以对每个素数取 $2k$ 个, 这个数量可以杀掉其他所有素数, 无论如何会有一个空余的可用. 复杂度 $k^2\times 2^{2k}$ .</p><p>官方正解真阴, 随机化万岁! .</p><h2 id="22-10-12-VP-CF1736-Codeforces-Round-825-Div-2"><a href="#22-10-12-VP-CF1736-Codeforces-Round-825-Div-2" class="headerlink" title="22. 10. 12 VP CF1736 Codeforces Round #825 (Div. 2)"></a>22. 10. 12 VP CF1736 Codeforces Round #825 (Div. 2)</h2><p>又是降智的一天呢!</p><h3 id="A-Make-A-Equal-to-B"><a href="#A-Make-A-Equal-to-B" class="headerlink" title="A. Make A Equal to B"></a>A. Make A Equal to B</h3><p>智障题</p><h3 id="B-Playing-with-GCD"><a href="#B-Playing-with-GCD" class="headerlink" title="B. Playing with GCD"></a>B. Playing with GCD</h3><p>没切Div2B, 输麻从此刻开始</p><blockquote><p>给定序列 $a_n$ , 判断是否有可能构造序列 $b_{n+1}$ 满足 $a_i&#x3D;\gcd(b_i, b_{i+1})$ .</p><p>$\sum n\le 10^5$</p></blockquote><p>把每一个数看作向量, $\gcd$ 是对向量每个元素取 $\min$ , 考虑如果你的向量 $b_i$ 的一个元素同时比 $a_i$ 和 $a_{i-1}$ 的对应元素大, 那么一定是不优的(你不能用它做取 $\min$ 了). 所以结论是 $b_i&#x3D;\mathrm{lcm}{a_i, a_{i-1}}$ , 然后有可能不行, 所以再 check 一遍.</p><h3 id="C1-Good-Subarrays-Easy-Version"><a href="#C1-Good-Subarrays-Easy-Version" class="headerlink" title="C1. Good Subarrays (Easy Version)"></a>C1. Good Subarrays (Easy Version)</h3><p>写麻烦做法, 继续寄</p><blockquote><p>给定序列 $a_n$ , 求有多少子区间 $[l, r]$ 满足 $\forall i\in [l, r], \ a_i\ge {i-l+1}$</p><p>$\sum n\le 2\times 10^5$ , 多组询问</p></blockquote><p>赛时写了个, 从后面往前扫, 每次给当前后缀区间减1, 二分第一个小于 $0$ 的位置. 总结应该是, 还是太着急写代码, 明明想到某些单调性但觉得这个不难写就直接冲了.</p><p>考虑每个位置减去下标, 问题变成 $\forall i\in [l, r]\ , a_i\ge -l+1$ .</p><p>然后考虑每个左端点, 合法的右端点是一个前缀, 并且每个左端点对应的合法右端点是单增的, 那么可以直接从上一个左端点的右端点开始往后扫就能处理出每个位置为左端点对应的右端点, 把这个数组记为 $r$ .</p><p>不过看起来不给前后缀区间减一没有关系, 重点是要发现右端点单增可以直接扫</p><h3 id="C2-Good-Subarrays-Hard-Version"><a href="#C2-Good-Subarrays-Hard-Version" class="headerlink" title="C2. Good Subarrays (Hard Version)"></a>C2. Good Subarrays (Hard Version)</h3><p>接着刚才的做法, 区别是加了独立的单点询问.</p><p>发现改小是直接二维数点(平面上线段, 求矩形内线的总长), 改大比较问号, 我们根本不会追溯修改.</p><p>然后我在错误的道路上越走越远了.</p><p>然后汪娟突然跳出来: 改大不是比改小简单吗?</p><p>是的! 我们是智障! , 因为改大的时候, 你只会改一个数, 所以对一个 $i$ , 可以处理若 $r_i+1$ 被改对了那么新的 $r_i$ 是几, 就做完了.</p><p>CF官方题解上改大和改小是同一个处理厉害了</p><h2 id="Public-NOIP-Round-3-Div-1-提高"><a href="#Public-NOIP-Round-3-Div-1-提高" class="headerlink" title="Public NOIP Round #3 (Div. 1, 提高)"></a>Public NOIP Round #3 (Div. 1, 提高)</h2><h3 id="A-移除石子"><a href="#A-移除石子" class="headerlink" title="A. 移除石子"></a>A. 移除石子</h3><blockquote><p>给定平面上 $n$ 个点, 构造选择 $\dfrac{n}{2}$ 个正方形的方案使得每个正方形内恰好有两个点, 且正方形覆盖了所有点.</p><p>$T\le 60, n\le 3000, x_i, y_i\le 10^9$</p></blockquote><p>每个点对建一个点, 然后从构成点对的两个点指向代表点对的点, 遍历每个点对, 如果这个点对 $u$ 组成的矩形上或内有另一个点 $v$ 则连边 $u\to v$ , 然后在图上跑拓扑排序.</p><p>不对, 边数 $n^3$ , 一个矩形内可能有一摞点.</p><p>考虑从左往右扫, 如果当前左边的点没法消, 就把它插入到操作序列的最后, 否则放在操作序列的最前面, 就可以了.</p><p>提高不会A是怎么回事啊</p><p>然后qyc说, 汪娟看了这场说只会D, 于是看D</p><h3 id="D-数圈圈"><a href="#D-数圈圈" class="headerlink" title="D. 数圈圈"></a>D. 数圈圈</h3><blockquote><p>给定一个 $n\times m$ 网格, 每个位置是一个小写字母, 求有多少个矩形满足边框上字母相同.</p><p>$n, m\le 2000$</p></blockquote><p>直接对每个位置预处理向右向下向左向上最远到哪里, 那么枚举一个左上角, 就要求一个矩形内所有向左向上超过左上角坐标位置的, 就直接数点了. 要对每个颜色分开做即可.</p><p>诶不对, 这是2log的, 死了.</p><p>考虑竖着分治, 画一条横线, 考虑穿过它的矩形, 那么现在我们可以用 $n^2$ 的时间去干一层.</p><p>我们预处理每个位置向上向下延伸多远, 然后确定左边的一条竖线, 向右扫描, 维护当前有多少个向右的横线, 在每个竖线统计答案.</p><p>对于维护横线这一步, 我们先预处理出所有向右的横线, 然后在一个位置加入贡献, 在另一个位置删除贡献即可.</p><p>A, C todo</p><h2 id="CSP-S-2022"><a href="#CSP-S-2022" class="headerlink" title="CSP-S 2022"></a>CSP-S 2022</h2><p>遗憾疫情把csp杀了</p><h3 id="T1-假期计划-holiday"><a href="#T1-假期计划-holiday" class="headerlink" title="T1 假期计划(holiday)"></a>T1 假期计划(holiday)</h3><blockquote><p>给定 $Graph(n, m)$ , 点有点权 $w_i$ , 求 $a, b, c, d$ 满足 $1\to a\to b\to c\to d\to 1$ 这条路径中两两点距离不超过 $k$ , 且最大化 $w_a+w_b+w_c+w_d$ .</p><p>$n\le 2500, m\le 10000, k\le 100$</p></blockquote><p>先 $nm$ 求一遍距离应该没什么异议.</p><p>考虑 $n^2$ , 而且只出 $a, b, c, d$ 肯定是让你枚举的, 一般这种都是中间的比较重要, 考虑枚举 $b, c$ , 于是现在要确定 $a, c$ , 直接对每个点 $u$ 处理 $1\to u$ 路途中点权的最大的, 次大的, 发现还是可能重复, 那就再处理次次大的, 发现肯定行了.</p><p>问号 $k\le 100$ 是干什么的?</p><h3 id="T2-策略游戏-game"><a href="#T2-策略游戏-game" class="headerlink" title="T2 策略游戏(game)"></a>T2 策略游戏(game)</h3><blockquote><p>给定 $a_n, b_m$ , $q$ 次询问, 每次给定参数 $l_1, r_1, l_2, r_2$ , 求A先从 $a_{ [l_1, r_1] }$ 中选一个数, B再从 $b_{ [l_2, r_2] }$ 中选一个数, A想最大化两数乘积, B想最小化, 求最后乘积是多少.</p><p>$n, m, q\le 10^5$</p></blockquote><p>那就是最小值的最大值, 分正负数讨论, 然后用随便什么RMQ做就了.</p><h3 id="T3-星战-galaxy"><a href="#T3-星战-galaxy" class="headerlink" title="T3 星战(galaxy)"></a>T3 星战(galaxy)</h3><blockquote><p>给定有向图 $Graph(n, m)$ , $q$ 次操作, 每次删去一个边, 或恢复一条之前被删掉的边, 或删掉连向一个点的所有<strong>入</strong>边, 或恢复一个点的所有入边, 或者问当前的图是不是所有点出度为 $1$ .</p><p>$n, m, q\le 5\times 10^5$</p></blockquote><p>光想着对度数搞根号分治了</p><p>考虑hash边集, 维护全局hash值, 那么处理每个点周围的hash, 操作点直接做, 操作边要改全局hash和连向的点的hash即可.</p><p>为什么脑子里总是没有随机化这根弦啊?</p><h3 id="T4-数据传输-transmit"><a href="#T4-数据传输-transmit" class="headerlink" title="T4 数据传输 (transmit)"></a>T4 数据传输 (transmit)</h3><blockquote><p>给定 $Tree(n)$ , 点有点权 $w_i$ , $q$ 次询问对于点 $u, v$ , 选定序列 $c$ , 使得序列相邻两项距离不超过 $k$ , 序列首&#x2F;末项到 $u$ &#x2F; $v$ 的距离不超过 $k$ , 序列中点的权值和的最小值.</p><p>$n, q\le 2\times 10^5, k\le 3$</p></blockquote><p>$k\le 3$ ! ! !</p><p>直接DDP $f_{u, 0&#x2F;1&#x2F;2}$ 表示上一个点距离自己 $0&#x2F;1&#x2F;2$ 的情况的最小权值, 这里正反是一样的, 所以从 $u, v$ 分别矩阵乘到lca, 然后在lca处合并.</p><p>但是当 $k&#x3D;3$ 的时候, 有可能选择一个不在 $u, v$ 路径上的点, 但发现那样的话必然是路径上的点的儿子, 所以动态dp的时候搞一下权值就行了.</p><p>UPD: 写了代码, 这个题不难写, 注意一下那个不在路径上的点要算上父亲.</p><h2 id="ZSContest-20221105"><a href="#ZSContest-20221105" class="headerlink" title="ZSContest 20221105"></a>ZSContest 20221105</h2><h3 id="C0A-分开了哦算"><a href="#C0A-分开了哦算" class="headerlink" title="C0A 分开了哦算"></a>C0A 分开了哦算</h3><blockquote><p>给定括号序列 $s_n$ 和括号的颜色 $c_n\in {0, 1, 2}$ , 每次可一1代价翻转一个括号, 颜色不能改变, 求最小代价使得 $c_i\in {0, 2}$ 和 $c_i\in {1, 2}$ 的括号分别组成合法括号串.</p><p>$n\le 5000$</p></blockquote><p>考虑一个经典结论, 在插入&#x2F;修改一个括号序列使其合法的时候, 只把一个前缀的右括号改成左括号, 一个后缀的右括号改成左括号是不劣的. 证明可以考虑括号序列把<code>(</code>看作 $+1$ , <code>)</code>看作 $-1$ 的一个折现, 每次修改一个括号是给一个后缀加&#x2F;减2, 最后要所有位置都不低于0且最后位置等于0, 那就显然了.</p><p>于是一个 $n^3$ 做法是枚举 $c_i&#x3D;2$ 的括号被修改的前后缀, 在确定了它之后确定另外两个就是简单的了(就是给定一个括号串, 其中若干位置不能改, 要求改成一个合法的, 只要从前往后扫, 每次如果前缀和小于0就把一个最靠前的左括号改成右括号, 最后不断把最靠右的右括号改成左括号, 可以开俩堆).</p><p>考虑不枚举前后缀, 转而枚举 $c_i&#x3D;0$ 的括号的和, 这样一来另外两种括号的和同样是确定的, 那么先通过操作最左, 最右的括号把它的和调整对, 在这个基础上, 求出不断把最左边右括号变成左, 最右左括号变成右, 直到不能变了的情况下每个位置被弄到的次数, 设为 $x, y, z$ , 模拟一遍就出每个位置当前的值, 设当前位置堆三个颜色的操作次数为 $x’, y’, z’$ , 于是对每个位置就有了一个限制, 就是 $\min(x, x’)+\min(z, z’)&gt;C$ , $C$ 是确定的常数, 于是把min拆开, 就成了关于 $x’, y’, z’$ 的线性规划, 合并限制后限制数量很少所以可以直接手枚顶点.</p><p>最后发现当枚举的 $c_i&#x3D;0$ 的括号的和从大到小的时候, 可以维护 $x, y, z$ 每次最多变化1, 线段树合并限制, 复杂度1log.</p><h3 id="C0B-自身的成功"><a href="#C0B-自身的成功" class="headerlink" title="C0B 自身的成功"></a>C0B 自身的成功</h3><blockquote><p>给定 $n\times m$ 的01矩阵, 每次可以把一个0变成1, 同一行同一列的1变成0, 给定两个局面问是否可以把第一个变成第二个.</p><p>$n, m\le 1000$</p></blockquote><p>如果有一个0变成1, 并且这个1的同行同列有1, 那一定死了, 于是现在没有这种情况.</p><p>如果所有的都是1变成0, 最后全是0, 也死了.</p><p>考虑先把所有0变成1的点了, 一定不劣, 然后现在要清除所有1变成0, 那就找到一个可以操作的行&#x2F;列(最后没有1), 然后用这行&#x2F;列干掉这个1即可. 如果找不到就死了.</p><h3 id="C0C-阿克最最易"><a href="#C0C-阿克最最易" class="headerlink" title="C0C 阿克最最易"></a>C0C 阿克最最易</h3><p>ZR题</p><h3 id="C0D-最成功捧杯"><a href="#C0D-最成功捧杯" class="headerlink" title="C0D 最成功捧杯"></a>C0D 最成功捧杯</h3><blockquote><p>给定 $n\times m$ 矩阵, 你在奇数步可以横着任意走, 偶数步可以竖着任意走, 每个位置有颜色 $a_{i, j}$ , 求走 $k$ 步形成的颜色序列个数.</p><p>$n, m\le 10, k\le 600, a_{i, j}\in [1, 9]$</p></blockquote><p>考虑dpofdp, 那么考虑给定一个颜色序列如何dp判断可行, 可以 $f_{i}&#x3D;S$ 表示前 $i$ 位走完可能走到的点是集合 $S$ . 但这个内层状态过大: 可能有一种颜色出现次数很大, 所以考虑做到 $n, m$ 相关: 每一次对于一行&#x2F;一列, 有多个颜色和有一个是一样的, 只要记录 $f_{i}&#x3D;S$ 表示前 $i$ 个走完之后可以走的行&#x2F;列的集合是 $S$ 即可, 此时内层状态数是 $k(2^n+2^m)$ .</p><p>然后考虑dpofdp, 扫掉一维 $i$ 后外层dp的状态是内层的值 $S$ , 于是 $f_{i, S, j}$ 表示颜色序列前 $i$ 个, 走到的集合是 $S$ , 最后一个位置颜色是 $j$ 即可, 预处理转移, dp复杂度是 $(2^n+2^m)k\Sigma$ .</p><h2 id="ZSContest-20221116-on-Vjudge"><a href="#ZSContest-20221116-on-Vjudge" class="headerlink" title="ZSContest 20221116 on Vjudge"></a>ZSContest 20221116 on Vjudge</h2><p>赛时会3个, T4没longlong半天没查出来</p><h3 id="abc259h"><a href="#abc259h" class="headerlink" title="abc259h"></a>abc259h</h3><blockquote><p>给定 $n\times n$ 矩形, 每个位置有值 $a_i$ , 只能往下或往右走, 问有多少起点终点值相同的格路径.</p><p>$n\le 400$</p></blockquote><p>这里用 $n$ 表示题目中的 $n^2$</p><p>考虑两个很显然的暴力:</p><ul><li>枚举颜色 $c$ , $f_{i, j}$ 表示以颜色 $c$ 开头走到 $i, j$ 的方案数dp.</li><li>枚举颜色 $c$ , 枚举 $c$ 中的两个位置, 以这两个位置为起点, 终点的路径是一个简单组合数.</li></ul><p>于是根号分治, 出现次数大于 $\sqrt n$ 的用第一种, 出现次数小于 $\sqrt n$ 的用第二种. 第一部分复杂度显然 $n\sqrt n$ , 第二部分是</p><p>$$<br>\begin{gathered}<br>    \max \sum {a_i}^2\<br>    s. t.<br>    \sum a_i&#x3D;n<br>    \ a_i\le \sqrt n<br>\end{gathered}<br>$$</p><p>这个式子量级是经典的 $n \sqrt n$</p><p>[think] 经典复杂度分析! 在做完SDOI2022D1T1后你又差点忘了.</p><h3 id="abc264h"><a href="#abc264h" class="headerlink" title="abc264h"></a>abc264h</h3><blockquote><p>给定 $T&#x3D;Tree(n)$ , 对每个 $k$ 求只保留编号不超过 $k$ 的点的情况下 $T$ 有多少个导出子图是满二叉树(每个点有两个儿子, 所有叶子深度相同). 保证父亲编号小于儿子.</p><p>$n\le 3\times 10^5$</p></blockquote><p>重点是, 因为是满二叉树, 所以二叉树深度只有 $\log n$ 量级.</p><p>于是直接dp, $f_{i, j}$ 表示点 $i$ 的子树内选深度 $j$ 的二叉树, 那么转移是简单的. 然后因为保证父亲编号小于儿子所以就算不断挂叶子, 因为只有深度在 $\log n$ 以内的节点可能对根的dp值有贡献所以每次暴力往上跳更新就是对的.</p><h3 id="abc255g"><a href="#abc255g" class="headerlink" title="abc255g"></a>abc255g</h3><blockquote><p>$n$ 堆石子的nim游戏, 有 $m$ 个限制, 第 $i$ 个限制 $x_i, y_i$ 表示若一个石子堆剩余石子为 $x_i$ , 你就不能从其中拿走 $y_i$ 个. 问先手必胜&#x2F;必负.</p><p>$n, m\le 2\times 10^5, a_i\le 10^{18}$</p></blockquote><p>公平组合游戏, 只需要考虑求一个石子堆的 SG 值, 最后异或起来判断即可.</p><p>没有限制的时候显然是 $SG(x)&#x3D;x$ , 那么加上限制之后会有若干个特殊点和若干段 $y&#x3D;x+k$ 的一次函数. 没有限制的点的值显然是前面的最大值加1, 而有限制的点可以考虑维护每个 $SG(x)$ 的出现次数, 不断删掉被禁止的 $x$ , 找到最小的删没了的 $SG(x)$ 就是当前的SG值.</p><p>但是直接维护 $SG(x)$ 会爆炸, 但发现只维护特殊点的就行, 其他的位置的次数就是一个默认的 $1$ .</p><h3 id="abc264g"><a href="#abc264g" class="headerlink" title="abc264g"></a>abc264g</h3><blockquote><p>有 $n$ 个字符串, 每个字符串 $t_i$ 长度不超过 $3$ 且有权值 $p_i$ , 一个字符串 $s$ 的总权值为 $\sum_{i&#x3D;1}^n cnt(s, t_i)\times p_i$ , 其中 $cnt(a, b)$ 表示 $b$ 在 $a$ 中出现的次数. 问长度任意的 $s$ 的权值是多少, 若可以无穷大输出 $\texttt{Infinity}$ .</p><p>$n\le 18278, \vert w_i\vert \le 10^9$</p></blockquote><p>第一感觉是很离谱, 尤其是长度不限, 并且不会处理各个 $t$ 之间拼接之后包含的新的 $t$ .</p><p>这个长度3很特点, 发现如果长度2可以直接每个字母建一个点, 然后弄一下边权, 那么现在考虑直接建点 $(a, b)$ 表示当前字母是 $b$ , 上一个字母是 $a$ , 权值就又可以用点之间的边表示了.</p><p>注意起点终点和长度为1, 2的字符串的细节.</p><h2 id="NOIP模拟赛Day1"><a href="#NOIP模拟赛Day1" class="headerlink" title="NOIP模拟赛Day1"></a>NOIP模拟赛Day1</h2><h3 id="A-string"><a href="#A-string" class="headerlink" title="A. string"></a>A. string</h3><blockquote><p>给定 $S_n, T_m$, $q$ 次询问对于 $k$, 最小的 $p$ 满足 $p\cdot S$ 不是 $k\cdot T$ 的子序列. 乘法是重复若干次.</p><p>$n, m\le 5000, k\le 10^14, q\le 3\times 10^5$</p></blockquote><p>处理从 $S$ 每个位置开始跑一个 $T$ 会匹配几个, 到哪.</p><p>然后再拼接这个, 显然最多 $n$ 次出循环, 找到循环次数并处理这 $n$ 次的答案即可 $O(1)$ 回答询问.</p><h3 id="B-path"><a href="#B-path" class="headerlink" title="B. path"></a>B. path</h3><blockquote><p>给定 $Tree(n)$, $q$ 次询问对于 $x, y$ 有多少个路径恰好以 $x\to y$ 的链为交集. 膜 $998244353$.</p><p>$n, q\le 3\times 10^5$</p></blockquote><p>等等, 这不是那个离谱lyh多项式题吗? K Path, 哦, 这是那个题 $k&#x3D;2$ 的弱化.</p><p>那就考虑 $x, y$ 分成祖孙链和其他, 设 $f_u, g_u$ 表示从 $u$ 向子树内&#x2F;外引两条链不交的方案数. 这个随便平方啥的搞一搞就行了.</p><p>最后统计答案就是, 如果 $x$ 是 $y$ 的祖先答案是 $g_xf_y$, 否则是 $f_xf_y$.</p><h3 id="C-triangle"><a href="#C-triangle" class="headerlink" title="C. triangle"></a>C. triangle</h3><blockquote><p>给定 $Tree(n)$, 有边权, 对每个 $x$ 求所有有序对 $(x, y, z)$ 的 $dis(x, y)+dis(y, z)+dis(x, z)\pmod L$ 最小值.</p><p>$n\le 3000$</p></blockquote><p>考虑三个点的虚树形成一个三叉, 那么显然一定要枚举一个三叉的中点.</p><p>注意到, 对于一个三叉, 至少有两个点在中点的子树里, 那么枚举这两个点, 就成了从两个集合各选一个数最大化它们的和膜 $L$. 这个只要直接二分即可. 如果外面有 $x$ 个点, 里面有 $y$ 个点, 复杂度就是 $(x+y)\log(x+y)$, 注意到 $\sum x$ 和 $\sum y$ 都是 $n^2$ 级别的.</p><p>另一个想法是直接枚举 $x$, 然后边分治.</p><h3 id="D-draw"><a href="#D-draw" class="headerlink" title="D. draw"></a>D. draw</h3><blockquote><p><img src="/img/2022-11-22-14-50-33-image.png" alt="picture 1">  </p><p>$n, q\le 3\times 10^5, a_i\le 4$</p></blockquote><p>一个暴力显然是每次从能打的里面拿最大的. 另外断坏成链也是经典套路.</p><p>这种打牌抽牌的一个经典套路是做前缀和描述当前手牌数变化.</p><p>考虑先确定打出的 $1$ 的数量, 显然只有更大的打完了才会用 $1$, 所以此时可以看成 $2, 3, 4$ 的牌都是拿到立刻打, 打够 $p$ 次说明没有 $1$, 中间没有 $2, 3, 4$ 打了的时候才会用 $1$. 这个可以用一个前缀和实现: 把 $1$ 当成 $0$(拿了也不打), 对当前手牌数做前缀和就是对于 $2, 3, 4$, $a_i&#x3D;a_{i-1}+1, 2, 3$, 否则 $a_i&#x3D;a_{i-1}-1$. 那么因为这个数组是可差分的, 找到第一个 $a_i&lt;a_s+k$ 的就说明要打 $1$ 了, 也可以类比着找到所有打 $1$ 的位置. 这么往上弄就好了. 对这个倍增优化一下复杂度就1log.</p><p>另一个问题是要确定当前是否有比自己小的能打, 这个只要直接对着所有数前缀和即可求出一个边界满足在这个边界内总有非0牌可以打.</p><h2 id="KFC-NOIP-2022-20221125wjw模拟赛"><a href="#KFC-NOIP-2022-20221125wjw模拟赛" class="headerlink" title="KFC NOIP 2022(20221125wjw模拟赛)"></a>KFC NOIP 2022(20221125wjw模拟赛)</h2><h3 id="A-move"><a href="#A-move" class="headerlink" title="A. move"></a>A. move</h3><blockquote><p>给定 $2n\times 2n$ 的棋盘, 有 $n^2$ 个棋子在左上角 $n\times n$ 的地方, 要都移动到右下角 $n\times n$ 的地方, 每次可以把一行棋子左右移动&#x2F;一列棋子上下移动, 棋盘上有若干不能放棋子的障碍, 障碍有权值, 求移除最少障碍使得可以移动过去.<br>$n\le 1000$</p></blockquote><p>诈骗题(但被诈骗了), 只要考虑 $(1, 1), (1, n), (n, n), (n, 1)$ 四个位置的棋子要移过去要满足的条件是八个位置(固定的)中的一个没有障碍, 而其他棋子都可以通过这种方式移动走.</p><h3 id="B-path-1"><a href="#B-path-1" class="headerlink" title="B. path"></a>B. path</h3><blockquote><p>给定 $Graph(n, m)$, 边有边权, $q$ 次询问 $u\to v$ 路径上边权序列的前缀与形成的集合的 $\mathrm{mex}$.</p><p>$n, q\le 10^5, m\le 5\times 10^5$</p></blockquote><p>首先因为前缀与, 答案不超过 $2$(包含 $1$ 一定不会包含 $2$), 于是思考判定.</p><p>答案是 $0$ 说明至少有一位全程都是 $1$, 那么对每位单独判保留这位是 $1$ 的边能不能连通, 并查集即可, 条件是至少一位的连通块连通.</p><p>再考虑判定 $1$, 那么如果没有 $1$, 考虑是路径上在到 $0$ 之前一定都要在非末位上有 $1$, 那就是 $u$ 和 $v$ 的连通块之间用一条末位是 $0$ 的边连接即可, 仍然并查集维护连通块标记一下即可. 又因为可以走到0只要出去随便绕一绕总是能到 $0$ 的.</p><h3 id="C-sequence"><a href="#C-sequence" class="headerlink" title="C. sequence"></a>C. sequence</h3><blockquote><p>给定 $a_n$, $q$ 次单点修改或者询问区间最小的 $a_i\mathrm{or} a_j, i\ne j$.</p><p>$n, q\le 10^5$</p></blockquote><p>Source: CF1665E</p><p>结论题.</p><p>[trick] 值域小于 $2^k$ 的数中选两个数 $\mathrm{or}$ 起来最小值出现在前 $k+1$ 个里.</p><p>考虑归纳, 如果第 $k$ 位有 $2$ 个 $0$, 那么一定选 $0$, 剩下的是前 $k-1$ 情况下的最小值. 否则第 $k$ 位最后是 $1$, 只要最小化前 $k-1$ 位, 对应了前 $k-1$ 位的最小值和这一位是 $1$ 的数中的最小值.</p><p>于是直接线段树就是 $\log^2 n$</p><h3 id="D-color"><a href="#D-color" class="headerlink" title="D. color"></a>D. color</h3><blockquote><p>给定 $Tree(n)$, 点有颜色 $c_i$, 求 $\sum_i ((\sum_j s(i, j)) \mathrm{xor} i)$, 其中 $s(i, j)$ 表示从 $i$ 到 $j$ 的颜色数.</p><p>$n\le 10^6$</p></blockquote><h4 id="赛时做法"><a href="#赛时做法" class="headerlink" title="赛时做法"></a>赛时做法</h4><p>考虑一个换根(思路来自 P6556), 那么发现就是加上那些到这个点路径上没有当前颜色的点这样的贡献, 只要对每个颜色求虚树, 然后虚树dp即可, 另外就是可能会有求 $u$ 的一个是 $v$ 的祖先的儿子这样的会有 $\log n$.</p><p>常数写大了, 赛后在loj上看了下是能进1s的.</p><h4 id="std"><a href="#std" class="headerlink" title="std"></a>std</h4><p>实际上不需要虚树, 考虑到当前这个点的路径上没有当前颜色的点形成的连通块只有 $O(n)$ 个, 所以直接求每个连通块大小即可. 可以线性.</p><h4 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h4><p>被wjw对着卡了. 复杂度1log.</p><h2 id="NOIP2022"><a href="#NOIP2022" class="headerlink" title="NOIP2022"></a>NOIP2022</h2><p>输麻, 省队无缘</p><h3 id="A-plant"><a href="#A-plant" class="headerlink" title="A. plant"></a>A. plant</h3><blockquote><p>给定 $n\times m$ 01矩阵, 求有多少个1组成的C形和F形.<br>$n, m\le 1000$</p></blockquote><p>每个位置处理向下向右到哪, 然后简单前缀和&#x2F;二阶前缀和统计.</p><p><strong>多测清空</strong></p><h3 id="B-meow"><a href="#B-meow" class="headerlink" title="B. meow"></a>B. meow</h3><blockquote><p>给定 $n$ 个栈和序列 $a_m\in [1, k]$, 初始一个变量 $p&#x3D;1$, 有两种操作: 1. 选择一个栈压入 $a_p$, 然后 $p\leftarrow p+1$, 如果栈顶两元素相等则同时消去. 2. 选择两个栈底元素相同的栈消去栈底.</p><p>k\le 2n-1, n\le 300, m\le 2\times 10^6</p></blockquote><p>考虑 $k&#x3D;2n-2$ 的情况是容易的, 容易想到 $n-1$ 个栈里每个栈存两种元素, 下一个元素如果是栈顶直接消, 栈底放到空栈消, 不存在则找一个元素个数小于 $2$ 的放进去.</p><p>$k&#x3D;2n-1$ 时, 存在情况 $n-1$ 个栈大小为 $2$, 又出现一个新的元素 $a_x$ 不存在于任意一个栈里, 考虑现在有两种方案, 要么放到一个栈顶, 要么放入空栈.</p><p>我们希望局面始终保持在: 任意一个元素至多出现一次, 那么考虑如果 $a_{x+1}$ 存在于栈底, 只需要放到 $a_{x+1}$ 所在的栈顶然后把栈底消了. 而如果 $a_{x+1}$ 在栈顶则有可能被 $a_x$ 遮住, 并且可能接下来出现 $n-1$ 个元素使得不存在一个栈不会被遮住.</p><p>于是考虑下一个栈底元素 $a_y$, 而 $a_{x+1}\ldots a_{y-1}$ 全位于栈顶. 考虑处理 $a_x, a_y$ 之间元素后的局面: 如果 $a_y$ 所在栈的栈顶元素 $c$ 出现了奇数次, 那么恰好露出 $a_y$, 于是一开始 $a_x$ 进空栈即可. 如果 $c$ 出现偶数次, 那么把 $a_x$ 放到 $c$ 上面, 上面的 $c$ 正好全消了, 再让 $a_y$ 消去栈底即可.</p><p>问题解决.</p><h3 id="C-barrack"><a href="#C-barrack" class="headerlink" title="C. barrack"></a>C. barrack</h3><blockquote><p>给定 $Graph(n, m)$, 保证连通, 求有多少种方案选定一个点集, 再设立若干条关键边, 使得删去任意一条非关键边不会使点集不连通, 膜 $10^9+7$.</p><p>$n\le 5\times 10^5, m\le 10^6$</p></blockquote><p>考虑直接边双, 接下来的问题是给定一棵树, 对每个虚树求有多少种边集可以连通它.</p><p>一个想法是设 $f_u$ 子树内选了点的边连通块与 $u$ 连通, 剩下的边任意的方案数, 问题是边连通块内点随便选时, 有一部分点都没选的情况会在边连通块更小, 但外面随便选的时候重复计算, 为了避免才钦定边连通块是选的点集的虚树.</p><p>那么统计虚树, 设 $f_u$ 表示 $u$ 子树内选, 且点的虚树根为 $u$ 的方案数, 则答案是每个 $u$ 处统计上 $f_u$ 乘 $u$ 子树外的边的随便选的和, 设 $g_{u, 0&#x2F;1}$ 表示去掉虚树根的限制, 根选&#x2F;不选, 转移显然, 最后容斥一下可得到 $f$. 复杂度线性.</p><h3 id="D-match"><a href="#D-match" class="headerlink" title="D. match"></a>D. match</h3><blockquote><p>给定 $a_n$, $b_n$, $q$ 次询问对于给定的 $[l, r]$, $\sum_{l’&lt;r’\in [l, r]} \max_{i\in [l’, r’]} \max_{j\in [l’, r’]} a_ib_j$</p><p>$n, q\le 2. 5\times 10^5$</p></blockquote><p>考虑扫描线, 对于给定的右端点 $r$, 设 $f_i$ 表示以 $i$ 开始的答案区间的答案, 那么询问就是求和, 每次右端点挪动的时候会给每个区间新加一个, 那么再维护两个区间对应最大值位置(从 $r$ 开始向前的前缀 $\max$), 就成了两个数组区间赋值, 以及区间加上他俩对应相乘, 可以线段树, 复杂度 $n\log n$.</p><p>需要维护的矩阵: <img src="/img/2023-08-11-16-35-10-image.png" alt="picture 4">  </p><h2 id="230218qyc-contest"><a href="#230218qyc-contest" class="headerlink" title="230218qyc contest"></a>230218qyc contest</h2><h3 id="A-秋天就要做偷橙子的梦"><a href="#A-秋天就要做偷橙子的梦" class="headerlink" title="A 秋天就要做偷橙子的梦"></a>A 秋天就要做偷橙子的梦</h3><blockquote><p>给定一个数列 $a_n$, 其中除了一个数之外每个都出现了 $k$ 次, 这个数小于 $k$ 次, 求这个数<br>空间限制1mb, $n\le 2\times 10^7, a_i\le 10^9$</p></blockquote><p>有个广为人知题是所有数出现两次, 一个出现一次, 直接异或就做完了.</p><p>那么开始考虑k进制下不进位加, 发现只能扫两遍.</p><p>但实际上搞k进制不进位加是闲的, 直接二进制不进位加起来, 最后mod k就算完了.</p><p>现在复杂度瓶颈是对每一位分别求和, 实际上还可以优化到 $O(n)$ 而不是 $O(n\log v)$</p><p>考虑假设序列是静态的做法, 可以序列分治, 每次合并左右两边的 $\log v$ 个和, 此时合并可以做到 $\log n$, 方法是用 $\log n$ 个数, 其中第 $i$ 个数的第 $j$ 位表示第 $j$ 个和的第 $i$ 位是几, 合并的时候用加法器那一套就行了. 然后每次合并代价是 $\log len$, 所以总复杂度就线性.</p><p>此时变成动态的, 上一个二进制分组即可.</p><h3 id="B-你喜欢OI南桐轻小说吗"><a href="#B-你喜欢OI南桐轻小说吗" class="headerlink" title="B 你喜欢OI南桐轻小说吗?"></a>B 你喜欢OI南桐轻小说吗?</h3><blockquote><p>计算两个序列 $a, b$ 的LPCS Longest Pairing Common Subequence, 也即一个最长的长偶数的序列 $c$, 设它的长度是 $k$, 它要满足对于正整数 $i\leq \frac{k}{2}$ 有 $c_{2i-1}&#x3D;c_{2i}$, 且它同时是 $a, b$ 的子序列. 输出长度.</p><p>$n, m\leq 5000, a_i, b_i\leq 10^4$.</p><p>空间限制 $8mb$</p></blockquote><p>考虑一个朴素dp, $f_{i, j}$ 表示已经选了长 $i$ 的, 其中在 $a$ 中最后一个选的是 $a_j$ 的情况下, $b$ 数组中最后一个最早是谁.</p><p>前缀和优化转移显然, 问题在于转移需要 $O(1)$ 算 $nxt(j, a_i)$ 表示在 $i$ 之后第一个 $a_i$ 的位置, 直接存显然爆了.</p><p>于是常数比较小时间换空间冲了.</p><p>好吧实际上, 你用 $f_{i, j}$ 表示 $a$ 里选了 $i$ 个, $b$ 里选了 $j$ 个的方案数, 此时假设先扫第一维, 就只会从 $(last_a(i), j’)$ 转移来, 其中 $b_{j’}&#x3D;a_i$, 所以复杂度是奇妙的线性.</p><h3 id="C-关于摆烂地交通部长摆烂这档事"><a href="#C-关于摆烂地交通部长摆烂这档事" class="headerlink" title="C 关于摆烂地交通部长摆烂这档事"></a>C 关于摆烂地交通部长摆烂这档事</h3><blockquote><p>给定一张 $DAG(n, m)$, 求有多少个点满足它能到达和能到它的恰好是全部的点.<br>$n\le 5\times 10^5, m\le 10^6$</p></blockquote><p>考虑把DAG从左往右摊开, 可以删掉跨过这个点的边(从这个点左边到右边), 那么发现在剩下的图中满足条件等价于左边的点出度不为0, 右边的点入度不为0.</p><p>于是要维护一个删边情况下每个点的出入度, 注意到按照拓扑序遍历点的时候每个边影响一个区间, 于是差分贡献就能做到线性.</p><h2 id="230318qyc-contest"><a href="#230318qyc-contest" class="headerlink" title="230318qyc contest"></a>230318qyc contest</h2><h3 id="F-Figglypuff-Gym-102341J"><a href="#F-Figglypuff-Gym-102341J" class="headerlink" title="F - Figglypuff Gym - 102341J"></a>F - Figglypuff Gym - 102341J</h3><p>直接猜结论</p><p>但把一个简单代码写复杂了, 太久不写代码</p><h3 id="E-Enteractive-Vertex"><a href="#E-Enteractive-Vertex" class="headerlink" title="E - Enteractive Vertex"></a>E - Enteractive Vertex</h3><p>首先这种东西肯定让你二分, 你一想可以用 $\log n$ 的代价得到特殊点在某个点的哪个子树里, 那么肯定上一个点分治, 目前可以卡到 $2\log n$</p><p>注意到, 如果卡成 $2\log n$ 一定是这个点有一堆特别小的子树, 那么按子树大小排序, 找到前 $k$ 小使得它们大小之和恰好大于一半, 先确定答案是不是在这一半里, 简单分析发现变成了单log</p><h3 id="B-Brammarly-Gym-102331G"><a href="#B-Brammarly-Gym-102331G" class="headerlink" title="B - Brammarly Gym - 102331G"></a>B - Brammarly Gym - 102331G</h3><p>第一眼想建SAM, 多看几眼发现如果走重一定是一个相等的段, 变成了简单组合题.</p><h3 id="D-Dypno-Gym-102341H"><a href="#D-Dypno-Gym-102341H" class="headerlink" title="D - Dypno Gym - 102341H"></a>D - Dypno Gym - 102341H</h3><p>考虑可以用 $\dfrac{3}{2}$ 的代价硬通过一条边, 或者去试探.</p><p>那么对于一个点, 最优策略一定是从能到的点中, 最小的到更大的去试探一个前缀, 当试探后的收益小雨直接冲就不试了.</p><p>那么这个已经可以dp了, 用dij优化, 注意到对于两个点可以根据它们答案最小的后继的答案去比较(放到dij的堆里).</p><h3 id="A-Aevee-Gym-102341E"><a href="#A-Aevee-Gym-102341E" class="headerlink" title="A - Aevee Gym - 102341E"></a>A - Aevee Gym - 102341E</h3><p>考虑容斥, 计算有 $k$ 个不合法长 $l$ 段的方案数, 那么组合数就是每个栈第一个不合法的往上随便拿, 然后连着拿这 $l$ 个, 然后再随便拿. . . , 注意到若有两个都不合法, 则一定要满足这两个颜色在每个栈里都是一个在另一个上面, 于是你设 $f_i$ 表示以 $i$ 颜色结尾的LCIS的贡献(带容斥系数)去dp.</p><p>那么你枚举一个左端点, 开始往右扫右端点, 注意到每次往右延伸一个右端点时, 一个 $i$ 所能转移到的 $j$ 就会减半, 在一次向右扫的过程中, 每个 $i$ 只会转移线性次, 所以复杂度是 $nk\max(n, k)$ 这样的.</p><h2 id="230513qyc-contest"><a href="#230513qyc-contest" class="headerlink" title="230513qyc contest"></a>230513qyc contest</h2><h3 id="CF1696D"><a href="#CF1696D" class="headerlink" title="CF1696D"></a>CF1696D</h3><blockquote><p>给出一个 $1$ 到 $n$ 的排列 $[a_1, a_2, \dots, a_n]$ . 对于 $1\le i &lt; j\le n$ , 记 $\mathrm{mn}(i, j)$ 为 $\min\limits_{k&#x3D;i}^j a_k$ , 记  $\mathrm{mx}(i, j)$ 为 $\max\limits_{k&#x3D;i}^j a_k$ .</p><p>有一张 $n$ 个点的无向图, 点的编号为 $1$ 到 $n$ . 对于每一对整数 $1\le i&lt;j\le n$ , 如果同时满足 $\mathrm{mn}(i, j)&#x3D;a_i$ 且 $\mathrm{mx}(i, j)&#x3D;a_j$ , 或同时满足 $\mathrm{mn}(i, j)&#x3D;a_j$ 和 $\mathrm{mx}(i, j)&#x3D;a_i$ , 那么就在 $i$ 和 $j$ 之间连一条长度为 $1$ 的边.</p><p>询问这张图中从 $1$ 到 $n$ 的最短路的长度. 可以证明 $1$ 和 $n$ 总是连通, 所以最短路总是存在.</p><p>$n\le 5\times 10^5$</p></blockquote><p>考虑你不会往回走.</p><p>考虑对于最大值, 你至少需要一步跨过它, 最小值也是, 于是一种写法是你每次找到最大值最小值, 然后中间一定是从最小值走到最大值, 两边递归.</p><p>贪心的方式是, 直接找到能走到最长段.</p><h3 id="Baekjoon-23416"><a href="#Baekjoon-23416" class="headerlink" title="Baekjoon - 23416"></a>Baekjoon - 23416</h3><blockquote><p>有两个刀片, 分别可以把蛋糕切成相等的 $a, b$ 份, 现在让你切两刀, 最小化最大块最小块极差. $a, b\le 100$</p></blockquote><p>考虑如果两个刀片数量相等答案显然是 $0$.</p><p>那么设 $a&lt;b$, 显然最大值是 $1&#x2F;b$.</p><p>于是你在考虑, 让 $a, b$ 的第一支放在 $0$ 处, 然后找到最大的区间 $[l, r]$, 其中 $l$ 处有 $b$ 刀片, $r$ 处有 $a$ 刀片.</p><h3 id="UOJ310-UNR-2-黎明前的巧克力"><a href="#UOJ310-UNR-2-黎明前的巧克力" class="headerlink" title="UOJ310. [UNR #2]黎明前的巧克力"></a>UOJ310. [UNR #2]黎明前的巧克力</h3><blockquote><p>给定 $n$ 个数, 求有多少种方案选择两个不交的集合, 使它们元素的异或和相等.<br>$n\le 10^6$</p></blockquote><p>等价于求 $\sum_{T\in S} 2^{\vert T\vert}[\mathrm{xor}_i T_i &#x3D; 0]$, 也就是 $\prod_i (1+2x^{a_i})$.</p><p>考虑 $(1+2x^{a_i})$ 的FWT, $1$ 对每个位置贡献 $1$, $a_i$ 对每个位置贡献 $\pm 2$, 位置 $T$ 的符号取决于 $S\cap T$ 的奇偶性. 于是要对所有 $S$ 统计 $\vert T\cap S\vert$ 是偶数. 因为有奇偶性仍然只能用FWT, 考虑做 $\sum_i x^a_i$ 的FWT, 得到的是偶数减奇数, 又因为知道总数就能解出来了.</p><p>然后就知道了结果的FWT, 把它IFWT回去即可.</p><h3 id="Gym-102586E"><a href="#Gym-102586E" class="headerlink" title="Gym - 102586E"></a>Gym - 102586E</h3><p>考虑因为是对 $2$ 取模, 那么考虑双射, 把序列翻转, 不相等的已经配对, 只有前半段和后半段相等的没有配对, 递归下去, 则 $2^k$ 的情况只有全部相等的情况映不上. 那么把 $n$ 按二进制拆成若干段, 每一段内部相等, 长度为 $2^k$.</p><p>然后数位dp即可: $f_{i, j}$ 表示 $S$ 后 $i$ 位, 对上面进位是 $j$, 因为你长度是 $2^k$ 所以就是正好对应加到一位上, 复杂度是 $ak\log s$. TLE了.</p><p>然后对着代码, 猜 $f_{i, j}&#x3D;0$ 的情况很多, 特判掉卡进去了. 正确的做法是改写成bitset优化.</p><p>另一种转化到数位dp的方式是, 设第 $a_i$ 种选了 $c_i$ 个, 方案数就是 $\binom{n}{c_1, c_2, \ldots, c_n} \pmod 2$, 根据卢卡斯定理发现相当于求有多少种方案使得 $c$ 互不相交且或起来上 $n$.</p><h3 id="TopCoder-12832-HugeGraph"><a href="#TopCoder-12832-HugeGraph" class="headerlink" title="TopCoder 12832 HugeGraph"></a>TopCoder 12832 HugeGraph</h3><blockquote><p>有一张 $n$ 个点的巨大图, 由一个集合 $d$ 描述, 如果两个点 $i, j$ 满足 $\vert i-j \vert \in d$, 则在 $i, j$ 间连一条无向边. 求连通块个数.</p></blockquote><p>考虑把 $d$ 排序, 然后你可以把 $d_i, i\ge 2$ 替换成 $d_i-d_1$, 也就是 $i\to i+d_1\to i+d_k$. 前 $d_1$ 个点因为不会被作为 $i+d_1$, 所以不需要连新的 $d_i-d_1$.</p><p>这样进行一次后, 前 $d_1$ 个点只有一条出边, 所以不会影响连通块数, 直接删了, 问题规模变为 $n-d_i$.</p><p>可以把减法换成取模, 就是每次给后面的都膜 $d_1$. 直到仅有一个 $d_i$ 不为 $0$ 或 $n&lt;d_1$</p><h2 id="20230520-GDKOI2023TG-Day1"><a href="#20230520-GDKOI2023TG-Day1" class="headerlink" title="20230520 GDKOI2023TG Day1"></a>20230520 GDKOI2023TG Day1</h2><h3 id="Matrix"><a href="#Matrix" class="headerlink" title="Matrix"></a>Matrix</h3><blockquote><p>给定 $n\times n$ 矩阵 $A, B, C$, 判断是否 $A\times B&#x3D;C \pmod {998244353}$</p><p>$n\le 3000$</p></blockquote><p>考虑一个经典题NOI2013向量内积, 随机一个向量乘 $A, B, C$ 判断是否相等. 这里错误率是 $\dfrac{1}{P}$ 所以一个就够了.</p><h3 id="Qwq"><a href="#Qwq" class="headerlink" title="Qwq"></a>Qwq</h3><blockquote><p>对于 $n, m, q$, 求排列 $p_n$, 使得 $\forall i\le m, p_i&gt;m; \forall i, p_i\ne i$<br>$n, m, q\le 2\times 10^5$</p></blockquote><p>利用两个方向递推式+莫队回答二维询问.</p><p>考虑固定 $n$ 对于 $m$ 求递推式, 此时变化的是 $m$, 二项式反演得到答案为<br>$$<br>\begin{gathered}<br>    \sum_i^{n-2m} (-1)^i \binom{n-2m}{i} (n-m-i)! \<br>    &#x3D;(n-2m)! [z^m] \sum_i^{n-2m} \dfrac{(-1)^i}{i! } \dfrac{(n-m-i)! }{(n-2m-i)! }\<br>    &#x3D;(n-2m)! [z^{n-2m}] e^z*(\sum_i \dfrac{(-1)^i(n-m-i)! }{i! }z^i)<br>\end{gathered}<br>$$</p><p>然后多项式部分是微分有限的, 这表明通过它们的若干阶导数之间存在递推关系, 微分和递推式之间是相互转化的关系. 两个序列做卷积对应多项式相乘, 点积对应递推式相乘. 为了求出相乘后的序列, 考虑 $(AB), (AB)’, (AB)’’\ldots$ 或 $a_nb_n, a_{n+1}b_{n+1}\ldots$, 因为两个分别为 $n, m$ 阶的递推式相乘的到的阶数不超过 $nm$, 所以考虑 $nm$ 个变量, 都把次数&#x2F;下标数降到最低, 必然出现线性相关, 那么把线性相关的部分就可以得到一个递推式.</p><p>$$<br>\begin{gathered}<br>    A&#x3D;e^z, A’&#x3D;A\<br>    b_i&#x3D;b_{i-1}\cdot -\dfrac{1}{i(n-m-i)}<br>    \Rightarrow\<br>    B&#x3D;\sum_i \dfrac{(-1)^i(n-m-i)! }{i! }z^i\<br>    B&#x3D;-(n-m)B’+zB’’, B’’&#x3D;\dfrac{1}{z}B+\dfrac{1}{n-m}B’<br>    \\<br>    (AB)’&#x3D;A(B+B’)\<br>    (AB)’’&#x3D;A(B+2B’+B’’)\<br>    &#x3D;A((1+\dfrac{1}{z})B+(2+\dfrac{1}{n-m})B’)\<br>    &#x3D;(1+\dfrac{1}{z})AB+(2+\dfrac{1}{n-m})(AB)’<br>\end{gathered}<br>$$</p><p>根据这个可以得到沿着 $m$ 的递推式.</p><p>再考虑沿着 $n$ 的方向, $f_{n, m}$ 前 $m$ 个没有限制, 剩下的满足 $p_i\ne i$ 的方案数, 这样答案为 $\binom{n-m}{m}m! f_{n-m, m}$.</p><p>那么 $m&#x3D;0$ 时为错排($D$), 考虑 $m\ne 0$ 时, 考虑第一位如果是否选 $1$, 得到 $f_{n, m}&#x3D;f_{n-1, m-1}+f_{n, m-1}$, 也就是 $F(z)&#x3D;(1+z)^m D(z)$, 也是微分有限的就冲了.</p><h3 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h3><blockquote><p>给定 $Graph(n, m)$, $a_n$, $C$, 求有多少 $b_n$ 满足 $b_i\in[0, a_i]; \forall u\to v, b_u\ne b_v; \mathrm{Xor}_i b_i &#x3D;C$</p><p>膜998244353, $n\le 15, a_i, C\le 10^{18}$</p></blockquote><p>考虑 $m&#x3D;0$, 考虑从高到低第一位使得 $\exists b_i\ne a_i$, 那么以后的部分其他 $i$ 怎么选都可以用这个调对, 枚举这一位即可, 复杂度是 $n\log w$.</p><p>于是考虑容斥, 钦定若干边相等得到若干连通块, 最终方案相当于所有奇数大小的连通块的 $\min a_i$ 拿出来的答案. 而应该乘上 ${-1}^{边数}$. 但是连通块划分方案远多于 $a$ 的集合, 所以考虑把同一集合的一起计算复杂度就是正确的, 也就需要dp出容斥系数.</p><p>先考虑单个连通块的系数, 应该是 $\sum {-1}^{\vert E\vert}$, 其中 $E$ 使得连通块连通. 考虑dp, $f_S$ 先为随便选, 然后枚举 $1$ 所在的连通块 $T$, 减去 $f_T\times 2^{\text{不与T相连的边集}}$, 复杂度 $3^n$.</p><p>然后考虑dp系数和, 设 $f_{S, T}$ 表示当前被包含的点集合为 $S$, 有用的 $a_i$ 集合为 $T$, 因为 $T\subseteq S$, 转移时枚举的集合 $U\cap S&#x3D;\varnothing$, 容易知道复杂度为 $4^n$, 可以通过.</p><h2 id="20230527-GDKOI2023TG-Day2"><a href="#20230527-GDKOI2023TG-Day2" class="headerlink" title="20230527 GDKOI2023TG Day2"></a>20230527 GDKOI2023TG Day2</h2><h3 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h3><blockquote><p>给一棵 $n$ 点的树, $q$ 次询问对于给定的 $x, y, z$, 是否能找到3个点两两之间距离分别是 $x, y, z$.<br>$n, q\le 2\times 10^5$</p></blockquote><p>考虑可以直接求出三个点到这三个点两两路径相交的点的距离, 那么对每个点求出离它最远的三个不同子树的点, 剩下的就是三维偏序.</p><p>todo</p><h2 id="2023-山东省队互唱-Round-1"><a href="#2023-山东省队互唱-Round-1" class="headerlink" title="2023 山东省队互唱 Round 1"></a>2023 山东省队互唱 Round 1</h2><h3 id="给你一颗枪弹"><a href="#给你一颗枪弹" class="headerlink" title="给你一颗枪弹! "></a><a href="https://onlinejudge.u-aizu.ac.jp/problems/1659">给你一颗枪弹! </a></h3><blockquote><p>给定 $k$, $a_n, b_n$, 求有多少种方案把 $a$ 划分成不超过 $k$ 段, 使 $k$ 段归并排序得到 $b$</p></blockquote><p>容易发现如果有解, 所有方案都可以由一个段数最少的划出来, 而这个段数最少的方案就是按照 $b$ 模拟, 如果 $b_i$ 在 $a$ 中前一个元素还没进就一定断开.</p><p>然后要判这个情况下是否有解.</p><p>然后在此基础上考虑什么情况下一个间隔可以断开, 注意到因为有解, 它只用大于本段中前面所有数即可. 于是求出由多少个必须断的, 多少个可以断的, 然后组合数.</p><p>另一种想法是归并不会改变它原来是不是前缀max, 于是所有不是前缀max的位置不能断, 如果这个位置作为前缀max大于前面的则可选, 否则必须断.</p><p>复杂度线性或1log(模拟)</p><h3 id="关山以北-桦树皮纷飞"><a href="#关山以北-桦树皮纷飞" class="headerlink" title="关山以北 桦树皮纷飞"></a>关山以北 桦树皮纷飞</h3><blockquote><p>交互题, 给定 $m$ 和序列 $c_n$, 初始 $n&#x3D;1, c_1&#x3D;0$, 每次可以<code>add(x)</code>使得添加一个数 $c_{n+1}&#x3D;c_n+x$, 或者<code>cmp(x, y)</code>返回 $[c_x&lt;c_y]$<br>log次使用<code>add</code>的复杂度求 $m$.</p></blockquote><p>这个实际上是可以先倍增出大致范围的, 因为如果 $x&lt;m, 2x&gt;m$ 一定有 $2x&lt;2m, 2x-m&lt;x$.</p><p>然后的部分是, 确定大致范围后, 考虑当前二分的数是 $x$, 很难注意到, 设当前位置为 $a, b&#x3D;a+x&#x2F;2, c&#x3D;a+x$, 如果判断 $a, b, c$ 大小关系与 $a, b, c$ 同构则 $x&lt;m$, 否则与 $a, c, b$ 同构是 $x&gt;m$, 原因是考虑:</p><p><img src="/img/2023-06-14-16-58-33-image.png" alt="picture 1">  </p><p>其中蓝线是 $y&#x3D;2x$ 红线是 $y&#x3D;m$, 绿线是 $y&#x3D;x$, 观察 $x&#x3D;m&#x2F;2$ 两边的关系即可.</p><h3 id="浪漫派的诗人"><a href="#浪漫派的诗人" class="headerlink" title="浪漫派的诗人"></a>浪漫派的诗人</h3><p>不会.</p><h2 id="ZSTEST230830"><a href="#ZSTEST230830" class="headerlink" title="ZSTEST230830"></a>ZSTEST230830</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>一眼dp</p><h3 id="B-1"><a href="#B-1" class="headerlink" title="B"></a>B</h3><blockquote><p>形式化地说, 给定 $k$ 行 $n$ 列的正整数矩阵,</p><p>$$<br>   (a_{i, j})_{1 \leq i \leq k, , 1 \leq j \leq n}<br>$$</p><p>有 $q$ 个询问任务, 对于每个询问任务 $[l, r]$, 需要计算以下公式:</p><p>$$<br>\sum_{l \leq x \leq y \leq r} F\left(\max_{i&#x3D;1}^k \left( \min_{j&#x3D;x}^y a_{i, j} \right)\right)<br>$$</p><ul><li>其中 $F(M) &#x3D; A \oplus ( BM + C)$, $A, B, C$ 是三个非负整数的常数, $\oplus$ 表示二进制按位异或.</li></ul><p>$k\le 20, n, q\le 10^5$</p></blockquote><p>如果只有一个序列, 考虑按照从大到小的顺序加点, 并合并两边已经加入的区间, 则每个区间形成的时候恰好是其最小值被插入的时候. 而如果有 $k$ 个序列, 一个区间形成的时候恰好是 $k$ 个序列中这个区间最大的最小值被加入的时刻.</p><p>那就简单题了, 直接数点算贡献, 每次矩形加&#x2F;矩形求和一个2side矩形, 但为了不重复贡献需要把2side矩形拆开并差分成若干3side矩形, 这个过程需要维护右下角阶梯轮廓线. 或者变成矩形覆盖矩形和, 但这个不好差分, 配一个颜色段均摊的话本质相同</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><blockquote><p>一条单向环形铁路上有 $k$ 个城市, 分别标号为 $0, 1, \dots , k-1$. 其中, 第 $i$ 个城市可以乘火车到达第 $(i+1)\bmod k$ 个城市. 城市的个数很少.</p><p>LCR 想要在这些城市中进行为期 $n$ 天的观光. 第 $1$ 天清晨, LCR 从自家坐火车到达 $0$ 号城市出发开始观光. 每天白天, 每个城市都会举行一些特定的活动, 如果第 $t$ 天的白天 LCR 在 $i$ 号城市里, 那么她会获得 $a_{i, t} (0\le i&lt; k, 1\le t\le n)$ 的效用, 效用是一个非负整数. 除了最后一天之外, 每天傍晚, LCR 可以选择留在当前城市, 或者乘火车移动到下一个相邻城市(从城市 $i$ 移动到城市 $(i+1)\bmod k$). 整个观光旅程的总效用为 $n$ 个白天的效用之和.</p><p>LCR 希望她在旅途中恰好坐了特定次数的火车(从家到 $0$ 号城市的一次也算). 因此, 她会询问 $q$ 次, 每次给出一个正整数 $m$, 你需要帮她计算出在恰好坐了 $m$ 次火车的情况下, 观光旅程总效用可能的最大值.</p><p>对于 $100%$ 的数据, $1\le m, q\le n\le 10^5, 2\le k\le 5, k\le n, 0\le a_{i, j}\le 10^9$.</p></blockquote><p>有点厉害, 搬运题解:</p><blockquote><h5 id="算法四"><a href="#算法四" class="headerlink" title="算法四"></a>算法四</h5><p>对于 $q\le 5$ 的情况, 考虑单次询问的做法.</p><p>定义 $F(i)&#x3D;f[n][i]$, 即 $F(i)$ 表示 $i$ 段对应的答案. 可以证明, 对于任意 $0\le j &lt; k$, $G_j(i)&#x3D;F(ik+j)$ 关于 $i$ 是一个凸函数.</p><blockquote><p>证明: 考虑 $i-k$ 段的最优解 $A$, 和 $i+k$ 段的最优解 $B$. 用扫描线从 0 扫描到 $n$, 则一开始扫描线左侧 $A, B$ 各有 $0$ 个划分点(指方案中划分相邻两段的位置). 最后, 扫描线左侧 $A, B$ 各有 $i-k-1, i+k-1$ 个划分点. 定义 $t(i)$ 为 $i$ 左侧 $A$ 中的划分点个数减去 $B$ 中的划分点个数. 则 $t(0)&#x3D;0, t(n)&#x3D;-2k$. 并且 $t(i)-t(i-1)\in {-1, 0, 1}$. 所以, 必定有一个 $0 &lt; p &lt; n$ 满足 $t(p)&#x3D;-k$ 且 $t(p)-t(p-1)&#x3D;-1$.</p></blockquote><blockquote><p>那么构造两个新方案 $A’, B’$, $A’$ 的划分点是 $A$ 在 $(-\infty, p]$ 的划分点加上 $B$ 在 $(p, \infty)$ 的划分点; $B’$ 的划分点是 $B$ 在 $(-\infty, p]$ 的划分点加上 $A$ 在 $(p, \infty)$ 的划分点. 则, $A’, B’$ 各有 $i-1$ 个划分点, 也就都是 $i$ 段的方案. 并且 $A’, B’$ 的权值和等于 $A, B$ 的权值和. (二者包含的数完全一样)</p></blockquote><blockquote><p>所以, $A’, B’$ 一定至少有一个权值不大于 $A, B$ 权值的平均值, 另一个权值不小于 $A, B$ 权值的平均值. 按照凸性的定义, 可以证明对于每个 $j$, $G_j(i)$ 是凸函数.</p></blockquote><p>对于单次询问 $m$, 我们可以二分斜率 $W$, 给每一段额外权值 $W$(可正可负), DP 求出全局最优解. 由于凸性, 每个 $i$ 都存在对应的 $W$ 可以找到其最优解. 因为这里还是要记录段数 $\bmod k$ 的值, 所以每次 DP 时间复杂度为 $O(nk)$. 斜率 $W$ 是一个分母为 $k$(注意, 分母是 $k$ 不是 $1$, 因为这里凸函数相邻点距离是 $k$), 绝对值不超过 $nA$ 的数, 其中 $A$ 是 $a_{i, j}$ 的上界.</p><p>时间复杂度: $O(nqk\log (Ak))$</p><p>预计得分: $30$, 加上之前共 $70$.</p><h5 id="算法五-标准算法"><a href="#算法五-标准算法" class="headerlink" title="算法五(标准算法)"></a>算法五(标准算法)</h5><p>求多个 $m$ 的答案, 我们可以考虑从 $+\infty$ 到 $-\infty$ 枚举斜率 $W$. 这里有 DP 转移 $f[i][j]&#x3D;\max(f[i-1][j]+a[i][j], f[i-1][(j-1)\bmod k]+a[i][j]+W)$. 可以证明, 在 $W$ 减小的过程中, 对于任意一个 $f[i][j]$, 最优决策(取到 $\max$ 的项)只会变化至多一次, 只能从 $f[i-1][(j-1)\bmod k]+a[i][j]+W$ 到 $f[i-1][j]$.</p><blockquote><p>证明: 只需要证明 $W$ 减小时最优决策不需要从 $f[i-1][j]+a[i][j]$ 变回 $f[i-1][(j-1)\bmod k]+a[i][j]+W$. 首先, 整个问题可以建模成最短路. 反证, 假设某个时刻最优决策必须发生改变, 那么一定存在一个 $W’$ 使得 $f[i-1][j]+a[i][j]$ 和 $f[i-1][(j-1)\bmod k]+a[i][j]+W’$ 在这个时刻是相等的, 且在 $W’-\epsilon$ 时后者严格更优. 那么这时后者对应的最优方案的段数(等于 $f[0][0]$ 到 $f[i][j]$ 最短路上 $+W$ 的次数)一定严格小于前者. 所以, 考虑从 $i-1$ 扫描到 $0$, 初始时前者对应方案在扫描线之后的段数比后者对应方案在扫描线之后的段数少 $1$, 但最后却严格多于后者至少 $k$, 所以一定有某个时刻两者在扫描线上相交. 所以一定存在 $0 &lt; p &lt; i-1$ 满足某个 $f[p][. ]$ 到 $f[i][j]$ 有两个段数相同的不同转移(两条 $+W$ 次数相等的不同最短路). 考虑把 $W’-\epsilon$ 的方案的 $f[p][. ]$ 到 $f[i][j]$ 的部分替换成从 $f[i-1][j]+a[i][j]$ 转移的, 这样段数不变. 所以 $W’-\epsilon$ 时一定也存在一个从 $f[i-1][j]+a[i][j]$ 转移的最优方案. 矛盾!</p></blockquote><p>所以, 这 $nk$ 个决策点各只会变化最多一次. 考虑维护这些变化.</p><p>任何时刻, 我们让 $(i, j)$ 向它的最优决策的上一次状态($(i-1, j)$ 或者 $(i-1, (j-1)\bmod k)$)连边. 显然, 这形成一棵有根树(就是最短路径树), 且合法点 $(i, j)$ 的深度一定为 $i$.</p><p>我们用线段树维护最短路径树的区间信息. 首先, 对于每个区间, 为了维护右端点当前的最优解(到根路径长), 需要记录区间右端点的每个点在区间左端点前一层的祖先 $anc(i)$ 以及到这个祖先的路径长度(一个以 $W$ 为自变量的一次函数, 换言之, 当前最短路的段数和效用). 其次, 为了维护 $W$ 减小时下次转移最早的变化, 需要记录 $LCA((i-1, j), (i-1, (j-1)\bmod k))$ 在区间内的所有点 $(i, j)$ 中最小的最短路效用差(段数差一定是 $k$, 所以不需要记录). 以及对于 $LCA((i-1, j), (i-1, (j-1)\bmod k))$ 不在区间内的点 $(i, j)$, 对于每个不同的 $(anc((i-1, j)), anc((i-1, (j-1)\bmod k)))$ 对, 记录最小的最短路效用差(因为段数差是一个定值, 所以不需要记录).</p><p>任何时候, 任何一个区间中不同的 $(anc((i-1, j)), anc((i-1, (j-1)\bmod k)))$ 的对数不会超过 $2k$. 考虑把决策树画在一个高度 $n$, 周长 $k$ 的圆柱面上, 那么区间左端点每个点在区间内的子树对应圆柱面上的一个平面区域. 通过平面图的性质可以证明左端点相邻的面的接缝即平面图边数不超过 $2k$ 即左端点面数的 $2$ 倍.</p><p>这样, 我们用线段树支持单点修改最优决策, 维护扫描线 $W$ 减小时下次最优决策改变位置. 每次从线段树中取出下一个最优决策改变的位置(全局改变需要的 $W$ 的最大值), 然后修改那个位置的决策即可. 初始以及每次修改后需要用全局最右侧每个点到根路径长度更新对应段数的答案.</p><p>一共 $O(nk)$ 次操作, 每次时间复杂度 $O(k\log n)$.</p><p>时间复杂度: $O(nk^2\log n)$</p><p>预计得分: $100$</p></blockquote><p>凸性配合wqs二分得到算法4, 但算法5还是很厉害.</p><p>获得了更简单的做法!</p><p>考虑 $f_{l, r, x, y, t}$ 表示从 $l$ 天到第 $r$ 天, 一开始在城市 $x$ 第 $r+1$ 天在城市 $y$, 一共经过 $k$ 轮的最大收益. 算法四结论有 $F_{l, r, x, y}(t)$ 是凸的, 于是直接分治着合并凸包就行了. 复杂度合并凸包要枚举 $x, y, z$ 以合并 $f_{l, mid, x, y}$ 和 $f_{mid+1, r, y, z}$, 而 $t$ 实际上是 $len&#x2F;k$ 种, 最后和正解一样是 $nk^2\log n$</p><p>有点类似 IOI13 Wombats的dp设法.</p><p>最后还是要想如何发现凸性, 可能本来会猜对 $m$ 有凸性, 然后被不同的城市干爆了, 于是弱化到固定城市后有凸性.</p><p>[trick] 大函数没凸性细分后有凸性</p><h2 id="ZSTEST230831"><a href="#ZSTEST230831" class="headerlink" title="ZSTEST230831"></a>ZSTEST230831</h2><h3 id="A-1"><a href="#A-1" class="headerlink" title="A"></a>A</h3><p>基本就是CF Make It One, 不过范围是 $4\times 10^6$, 用gcd卷积那一套即可. 复杂度应该能到 $v(\log \log v)^2$. 瓶颈是二分答案里面快速幂.</p><h3 id="B-2"><a href="#B-2" class="headerlink" title="B"></a>B</h3><blockquote><p><img src="/img/2023-08-31-17-21-01-image.png" alt="picture 0">  </p><p>$n\le 10^6$</p></blockquote><p>对于每个缝隙, 找到最近的可以切断的位置(这个区间内A和B的值集合相等), 然后连边形成若干个缝隙的环, 每个环上任意断数数即可.</p><p>然后为了判断可以切断需要集合hash.</p><h3 id="C-1"><a href="#C-1" class="headerlink" title="C"></a>C</h3><p>原题是 CF1210G&#x2F;CF1229F</p><blockquote><p><img src="/img/2023-08-31-17-24-57-image.png" alt="picture 1">  </p><p>$n\le 10^6$</p></blockquote><p>赛时写了个网络流.</p><p>正解就是先断环, dp, 设 $f_{i, j}$ 表示前 $i$ 个已经满足, $i$ 向 $i+1$ 传了 $j$ 个, 然后发现 $f_i$ 是关于 $j$ 的凸函数, 上一套 slope trick维护转移, 搭配wqs二分 $n$ 到 $1$ 传了多少.</p><p>转移时发现每次是对 $f_i$ 进行平移, 然后添加一段斜率为 $0$ 的部分, 然后加上函数 $\vert x\vert$, 可以用平衡树以斜率为键实现区间加, 但更好的方法是用对顶堆维护斜率为负的部分和正的部分以及当前位置的值即可.</p><h2 id="ZSTEST230902"><a href="#ZSTEST230902" class="headerlink" title="ZSTEST230902"></a>ZSTEST230902</h2><h3 id="A-2"><a href="#A-2" class="headerlink" title="A"></a>A</h3><p>考虑直接把 $k$ 的答案写出来, $ans_k&#x3D;\sum_i \lceil \dfrac{h_i}{k} \rceil k - h_i$, 那么 $\lceil \dfrac{h_i}{k}\rceil&#x3D;\lfloor \dfrac{h_i-1}{k}\rfloor+1$ 转化成下取整, 那么显然对任意一个 $i$ 都是 $\sqrt V$ 段函数, 总共是 $n\sqrt V$ 段函数, 考虑直接让 $k&#x3D;1$, 用堆维护当前 $k$ 所在的 $n$ 个段的 $n$ 个右端点即可. 复杂度 $n\sqrt V\log n$</p><h3 id="B-3"><a href="#B-3" class="headerlink" title="B"></a>B</h3><p>考虑这是简单扫描线, 每个B获得的元素 $(a, b, c)$ 拆成3个立方体, 最后相当于求立方体体积并, 但注意到每个立方体只有两维有限制, 考虑计算合法数量, 按照 $c$ 扫描线, 那么把所有 $c$ 上没有限制的先画到平面上, 然后剩下的每个矩形相当于限制当 $c\le c_i$ 时 $a\ge a_i$ 或 $b\ge b_i$, 那么可以相当于在刚才的平面上一个矩形查询. 于是最后就是, 在一个平面上2side矩形加矩形和, 再上一个扫描线即可.</p><h3 id="C-2"><a href="#C-2" class="headerlink" title="C"></a>C</h3><p>预处理出每个位置往前第一个和为 $0$ 的矩形, 有一个显然的 $n^2$ dp, 设 $f_{i, j}$ 表示第一行前 $i$ 个和第二行前 $j$ 个的答案, 那么注意到如果 $f_{i, j}, f_{i, k}$ 是分别最小的 $j, k$ 使得 $f_{i, j}&#x3D;f_{i, i}+1, f_{i, k}&#x3D;f_{i, i}+2$, 那么可以只保留 $f_{i, j}$, 考虑如果第一行中 $[i, j]$ 中与一个矩形无交, 那么所有从 $i, k$ 的转移都可以由 $j, j$ 转走, 如果有交, 那么如果原应由 $f_{i, k}\to f_{i’, k}$, 应该存在状态 $f_{i’, j}$, 其中 $i’$ 是最小的满足 $f_{i’, j}&#x3D;f_{j, j}+1$ 的位置, 于是只保留所有的 $f_{i, i}, f_{i, j}, f_{j, i}$ 即可完成转移. 至于要保留哪些, 显然 $f_{i, j}$ 就是 $f_{i, i}$ 往后第一个矩形结尾, 可以预处理.</p><h2 id="潍坊一中-2023-秋提高级友好学校赛前联测-1"><a href="#潍坊一中-2023-秋提高级友好学校赛前联测-1" class="headerlink" title="潍坊一中 2023 秋提高级友好学校赛前联测 1"></a>潍坊一中 2023 秋提高级友好学校赛前联测 1</h2><p>260 RK 16</p><p>DWT RK 1 &#x2F;bx</p><p>T1, T2简单题, T4是CF1119F(不会了菜了)</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><blockquote><p>Mystia 想搭一座跨过河的桥, 来方便她取得食材.</p><p>河是一条无限长的宽度为 $W$ 的直线, 所有在坐标系中符合 $0\le y\le W$ 的点都属于这条河流.</p><p>河面上有 $N$ 个木桩, 附近的杂货店可以买到 $M$ 种可以使用的木头圆盘, 第 $k$ 个木桩的坐标为 $(X_k, Y_k)$. 第 $k$ 种圆盘半径为 $R_k$, 每一块的价格为 $C_k$.</p><p>她可以买任意种任意多的圆盘, 把它们放到河面上. 每一个圆盘的中心都必须为某一个木桩的位置. 而且, 某些圆盘的一部分可以在地面上, 即 $y&lt;0$ 或 $y&gt;W$.</p><p>Mystia 只能在河两岸或圆盘上移动, 两岸即直线 $y&#x3D;0$ 或直线 $y&#x3D;W$, 也可以从一个位置移动到另一个与其相切或相交的圆盘.</p><p>请问她修建一座可以从直线 $y&#x3D;0$ 到直线 $y&#x3D;W$ 走过去的圆盘桥的最小花费是多少?</p><p>复杂度 $n^2\min (m, R)$</p></blockquote><p>首先要做到 $n^2m\log nm$ 是简单的建图题, 直接拆点前后缀优化暴力连边即可.</p><p>考虑不拆点, 设 $f_{i, j}$ 为 $i$ 上盘子种类为 $j$ 情况下 $1$ 到 $i$ 的距离, 那么模拟dij的过程, 记 $g_i&#x3D;\min_j f_{i, j}$, 改为每次选 $g_i$ 最小的点, 用它更新其他所有的 $f_{k, l}$, 更新的时候直接双指针容易做到 $O(m)$, 但是这个最短路看起来是不对的, 考虑证明, 如果松弛顺序有问题, 只可能因为两个桩子 $i$, $j$, 当前 $g_i&lt;g_j$, $i$, $j$ 都在最短路上且 $i$ 比 $j$ 靠后, 但此时绕道走 $j$ 唯一目的只能上让 $i$ 换一个更大的盘子, 那么如果其盘子由 $x$ 换到 $y$, 直接更改 $i$ 的盘子只有 $f_{i, x}-c_x+c_y$, 而j过去至少要更新到 $g_j+c_x$, 于是此时一定不会让 $j$ 去松弛 $i$, 更新顺序就是对的了.</p><p>出题人<code>impossible</code>打成<code>impossib1e</code>, 被刺杀了(没和R取min, 被刺杀了</p><h2 id="信友队CSP-S-2023-复赛模拟赛"><a href="#信友队CSP-S-2023-复赛模拟赛" class="headerlink" title="信友队CSP-S 2023 复赛模拟赛"></a>信友队CSP-S 2023 复赛模拟赛</h2><h3 id="A-3"><a href="#A-3" class="headerlink" title="A"></a>A</h3><blockquote><p>给出 $n\times m$ 的 $01$ 矩阵, 求有多少个正方形满足四个顶点都是 $1$, 正方形可以斜着.</p><p>$n, m\le 500$, 5s</p></blockquote><p>挺见鬼的, 容易想到把斜着的正方形变成证明勾股定理的那个图, 也就是一个小正方形, 四个顶点分别向四个方向延伸相同长度位置都是 $1$. 那么枚举这个小正方形然后bitset即可 $n^4&#x2F;w$, 但是感觉卡的很紧一直不敢写.</p><h3 id="B-4"><a href="#B-4" class="headerlink" title="B"></a>B</h3><blockquote><p>考虑出售一种商品, 有 $m$ 种卖法.</p><p>第 $j$ 种卖法将卖出其中 $a_j$ 个, 收 $b_j$ 的钱.</p><p>对所有 $1\le i &lt; m$, $a_i$ 是 $a_{i+1}$ 的因数; 且保证 $a_1&#x3D;1$.</p><p>假设买恰好 $n$ 个物品最少要花 $f(n)$ 的钱. 你可以同时使用多种买法.</p><p>现在 $q$ 组询问, 每次给定 $n$, 要求出 $\sum\limits_{i&#x3D;0}^{m-1} f(i)$.</p><p>由于答案可能很大, 请对 $2^{64}$ 取模.</p><p>$m, q\le 10^5, n\le 10^{18}$</p></blockquote><p>首先按性价比排序, 性价比不优的都删了, 现在性价比递增, 最多剩 $\log n$ 个. 于是统计每个被用了多少次, 最后相当于要求 $\sum_{i&#x3D;1}^n \dfrac{i}{a_k}$, 等差数列求和即可.</p><h3 id="C-3"><a href="#C-3" class="headerlink" title="C"></a>C</h3><blockquote><p>给定一张 $n$ 个点 $m$ 条边的无向连通图, 点标号 $0\sim n-1$, 其中前 $c$ 个点为关键点.</p><p>每个点有点权 $a_p$, 边有边权 $w_e$. 关键点还额外有一个权值 $b_p$.</p><p>你要选定一个起点, 从起点开始, 中间经过至少 $t$ 个关键点(允许重复经过一个关键点, 但只统计一次), 最后回到起点. 起点可以是关键点, 也可以不是. 可以待在起点不移动, 但那样所统计的关键点仅包括起点本身.</p><p>规定该方案的代价为 $\text{路径长度}+a_{\text{起点}}+\sum\limits_{q\in\text{所有被经过的关键点}} b_q$, 如果一个关键点被多次经过也只统计一次.</p><p>你要对 $t&#x3D;1, 2, 3, \dots, c$ 求出最小代价.</p><p>$c\le 20, n\le 1\times 10^5, m\le 3\times 10^5$</p></blockquote><p>还算比较好想吧. 容易想到先对每个关键点跑一遍dij, 处理出 $d_{i, j, 0&#x2F;1}$ 表示关键点 $i$ 到关键点 $j$, 其中是否有一个点加上了 $a$(作为起点)的最小代价. 同时注意跑最短路时不能用除起点以外的关键点松弛, 否则一条经过某几个关键点的路径会漏算 $b$.</p><p>然后这个 $20$ 显然让你dp, 想到设 $f_{S, i, 0&#x2F;1}$ 表示当前走过的关键点集合为 $S$, 当前在 $i$, 有没有已经选择一个起点, 则每次要么枚举一个点 $k$ 从 $f_{S&#x2F;i, k, 0&#x2F;1}$ 转移过来, 要么由 $f_{S, j, 0&#x2F;1}$ 转移过来, 后面这个需要跑一个最短路. dp的复杂度是 $c^22^c$, 但是要对每个起点跑一遍就爆炸了.</p><p>因为最后让你选一个环, 可以把其中任意一个点当作环的起点, 考虑钦点 $S$ 中编号最小的点为起点, 每次转移的时候不能把起点转移没就行了. 最后复杂度 $c^22^c$</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><blockquote><p>我们称字符串 $A$ 对 $B$ 的相对代价, 为 $A$ 的 Border 中不是 $B$ 的 Border 的字符串的长度之和.</p><p>我们称字符串 $A$ 和 $B$ 的绝对代价, 为 $A$ 对 $B$ 的相对代价和 $B$ 对 $A$ 的相对代价中较大的一个, 记为 $f(A, B)$.</p><p>我们称长度为 $n$ 的字符串 $S$ 的刻板度为其每两个后缀的绝对代价之和, 也即</p><p>$g(S) &#x3D; \sum\limits_{i&#x3D;0}^{n-1}\sum\limits_{j&#x3D;i+1}^{n-1} f(S_{i\sim n-1}, S_{j\sim n-1})$</p><p>现在给你一个长度为 $n$ 的字符串 $S$, 你要对其最长的 $c$ 个后缀子串 $S’$, 求出 $S’$ 的刻板度; 即, 你需要对每个 $0\leq l&lt;c$ 求出</p><p>$h_l(S) &#x3D; g(S_{l\sim n-1}) &#x3D; \sum\limits_{i&#x3D;l}^{n-1}\sum\limits_{j&#x3D;i+1}^{n-1} f(S_{i\sim n-1}, S_{j\sim n-1})$</p><p>由于答案可能很大, 只需输出对 $2^{64}$ 取模的结果.</p></blockquote><p>首先考虑对于同一个字符串的两个后缀, 这个绝对代价是什么. 那么考虑反着跑KMP得到每个后缀的border, 然后 $i$ 向 $border_i$ 连边得到一棵树, 记 $dep_u$ 为根到 $u$ 的链上的字符串总长和, 那么绝对代价就是 $\max dep_a, dep_b -\mathrm{lca}(a, b)$. 感觉这个模型应该很经典但我没做过这种啊()</p><p>那么考虑怎么做 $c&#x3D;1$, 把刚才那个东西分开做, 则一部分要求每个点是多少个点的lca, 可以是 $\sum (siz_u^2-\sum_{v\in son_u} siz_v^2)dep_u&#x3D;\sum siz_u^2(dep_u-dep_{fa})$, 一部分求比这个点 $dep$ 小的有多少个即可.</p><p>那么现在 $c\ne 1$, 考虑从最短的那个后缀开始, 每次在最前面加一个字符, 也就是树上一个叶子, 考虑答案增加了多少. 那么对于刚才分开的两部分, 第二部分是容易的, 直接统计比这个点小的点的个数和比它大的点的 $dep$ 和. 对于第一部分, 这个点让它到根的链上每个点 $siz$ 增加了 $1$, 增加量就是 $\sum (1+2siz_u)(dep_u-dep_{fa})$, 用线段树+静态lct是单log了, 但这很见鬼. 考虑代替方法, 每个点开一个线段树, 其中下标 $i$ 表示加入第 $i$ 个点时的新增贡献, 那么每次把儿子合并, 然后对线段树区间加一次函数, 这就可做了.</p><p>这个失配树的trick居然没见过, 菜了.</p><h2 id="Public-NOIP-Round-6-Div-1-提高"><a href="#Public-NOIP-Round-6-Div-1-提高" class="headerlink" title="Public NOIP Round #6 (Div. 1, 提高)"></a>Public NOIP Round #6 (Div. 1, 提高)</h2><h3 id="A-4"><a href="#A-4" class="headerlink" title="A"></a>A</h3><blockquote><p>给定一个长度为 $n$ 的非负整数序列 $[a_1, \ldots, a_n]$, 求其中某个子序列 $[a_{i_1}, a_{i_2}, \ldots, a_{i_k}]$ $(1\leq i_1&lt;i_2&lt;\cdots&lt;i_k\leq n)$, 使得 $\sum_{j&#x3D;1}^{k-1}(a_{i_j}\text{ and } a_{i_j+1})$ 最大. 其中, $\text{and}$ 是指二进制按位与.</p><p>$n\le 10^6, a_i\le 10^{12}$</p></blockquote><p>容易想到 $n^2$ 的dp, 考虑优化, 注意到看起来多选几个大概率比少选优, 然后发现对于最高位为 $k$ 的所有 $a_i$ 只有最后一个是可能被转移的, 因为不然倒数第二个转移到最后一个, 最后一个转移到当前一定比倒数第二个转移到当前优. 复杂度单 $log$</p><p>看到位运算要想位, 包括最高位, 拆位, 进位条件.</p><h3 id="B-5"><a href="#B-5" class="headerlink" title="B"></a>B</h3><blockquote><p>你有 $n$ 个任务需要完成, 第 $i$ 个任务需要 $t_i$ 天. 但人的寿命有限, 你只剩下 $c$ 天了.</p><p>磨刀不误砍柴工, 你可以花 $1$ 天时间对第 $i$ 个任务进行深入思考, 那么它所需的时间会减少 $d_i$ 天. 特别的, 如果时间被减为零或负数, 这个任务就能被瞬间完成. 但人的灵感有限, 在一次生命里每个任务只能被深入思考一次.</p><p>你可以复活, 每次复活会再给你带来 $c$ 天. 之前的深入思考的结果会一直保留, 不会因复活而消失.</p><p>求出你最少需要复活多少次, 才能在最后一条命把所有任务都完成. 你可以认为在最后一条命之前你并不能做任务, 只能对任务进行思考, 而在最后一条命既可以思考也可以做任务.</p><p>$1\leq T\leq 1000$, $1\leq \sum n\leq 2\times10^5$, $1\leq c\leq 10^9$, $1\leq d_i\leq t_i\leq 10^9$.</p></blockquote><p>二分答案, 现在考虑前面怎么分配思考, 发现对于一个任务来说不断对其思考收益递减, 于是因为凸性这是经典的贪心, 每次选收益最大的即可. 又因为直接做 $c\cdot ans$ 很大, 你应该把每个任务都先缩减到 $2d_i$ 以内, 然后再贪心救行.</p><h3 id="C-4"><a href="#C-4" class="headerlink" title="C"></a>C</h3><blockquote><p>给定一个 $n$ 个点 $m$ 条边的简单无向连通图.</p><p>有 $q$ 次询问, 每次给定两个不同的点 $x$ 和 $y$, 你可以从 $x$ 出发在图上任意游走, 直到走到 $y$ 时结束, 且除了开始和结束以外不允许走到 $x$ 和 $y$. 求出有多少个点 $z$ 使得存在一个游走方案能经过 $z$, 包括 $x$ 和 $y$. 注意你走的路径可以不是简单路径, 唯一的限制是不能重复经过 $x$ 和 $y$.</p><p>$1\leq T\leq 1000$ $1\leq \sum n\leq 2\times10^5$ $1\leq \sum m\leq 5\times10^5$ $1\leq \sum q\leq 5\times10^5$</p></blockquote><p>圆方树!</p><h3 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h3><blockquote><p>给定排列 $a_n$, 希望把他排序, 每次可以把排列分成若干段然后段间reverse, 段内顺序保持不变.<br>$n\le 2\times 10^4$, 次数限制 $90$</p></blockquote><p>好厉害构造, 考虑只有 $01$ 的情况, 按照<code>01|0|10|1|01|0|10|1</code>每次可以把连续段数搞成 $1&#x2F;3$, 然后对值分治, 把大于 $mid$ 的看作 $1$, 其他看作 $0$, 最后复杂度是俩log</p><h2 id="潍坊一中-2023-秋提高级友好学校赛前联测-2"><a href="#潍坊一中-2023-秋提高级友好学校赛前联测-2" class="headerlink" title="潍坊一中 2023 秋提高级友好学校赛前联测 2"></a>潍坊一中 2023 秋提高级友好学校赛前联测 2</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><blockquote><p>给 $n$ 个区间求嵌套最大层数</p></blockquote><p>直接dp, 上个线段树. 但是区间排序没排右端点相等的左端点挂了35&#x2F;fn</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>简单dp</p><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><blockquote><p>乐孤星和 WA90 准备联合参加下一次的 NOB(National Olympiad in Badminton).</p><p>他们想要在一场比赛中击回对手打出的所有球从而赢得比赛, 因为 WA90 非常<strong>强</strong>, 所以可以预先知道对手打出的每一个球的位置, 他们想要计算一下打败对手需要多认真.</p><p>形式化的, 我们将羽毛球场比作一个一维数轴, 不考虑高度的限制. 起初两个人都在数轴的原点, 两个人的移动是独立的, 并且可以互相越过或处于同一位置. 任意时刻, 他们可以以不超过 $V$ 的速度移动或处于静止状态.</p><p>现在他们预测到了对手将能打出 $n$ 次球, 第 $i$ 个球将于时刻 $t_i$ 飞到位置 $x_i$, 也就是说在时刻 $t_i$ 至少有一个人位于 $x_i$ 才能击回第 $i$ 个球. 现在请你求出两个人若想击回所有的球, 速度上限 $V$ 至少是多少.</p><p>对于全部数据, $1 \leq n \leq 10^5$, $1 \leq t \leq 10^9$, $- 10^6 \leq x \leq 10^6$.</p></blockquote><p>简单dp, 但是写飞了TLE 50, 把一个set换成vector过了.</p><p>显然二分答案判定, 那么设 $f_{i, j}$ 表示当一个人处理完第 $i$ 次时, 另一个人最近一次处理的是第 $j$ 次的情况是否可行, 那么显然有</p><p>$$<br>f_{i, j}&#x3D;<br>\begin{cases}<br>    f_{i-1, j}&#x3D;[i-1\to i], if\ j\notin {i, i-1}\<br>    f_{i-1, k}\ \mathrm{and}\ [k\to i], if\ j&#x3D;i-1\<br>    f_{i-1, k}\ \mathrm{and}\ [k\to i]\ \mathrm{and}\ [i-1\to i], if\ j&#x3D;i<br>\end{cases}<br>$$</p><p>其中 $[k\to i]$ 表示</p><p>于是数据结构维护dp即可, 发现要求 $f_{i-1}$ 中是否有一个点可以到达 $i$. 考虑把点 $(t, x)$ 画到平面上, 于是你要求两个斜率固定直线之间的点的数量, 支持删点加点, 上线段树&#x2F;bit即可.</p><p>还可以更快! 其实一开始猜的就是对于某一时刻的 $i$, $j$ 的存在范围是一个区间, 于是用这个dp直接做到 $n\log V$.</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><blockquote><p>Alice 和 Bob 在玩游戏, 他们面前有一个长度为 $n$ 的正整数序列 $a$, 一共有 $q$ 次游戏, 每轮游戏给定 $[l, r]$, Alice 会在 $[l, r]$ 中挑选 $k$ 个数, Bob 会计算这些数的 $\gcd$ 作为自己的得分. Bob 想要知道在 Alice 的所有选择方案中, 他能得到的最大得分是多少. 因为 Alice 比较贪心所以她会选择比较多的数, 因此在此题中 $k\geq (r-l+1)-3$.</p><p>对于全部数据, $1\leq n, q\leq 10^5, \max(1, (r-l+1)-3)\leq k\leq (r-l+1), 1\leq a_i\leq 10^{18}$.</p></blockquote><p>众所周知从一个点开始的区间的gcd只有 $\log V$ 段, 那么直接预处理每个位置开始的 $gcd$ 段, $\log^3 V$ 枚举删的点(一定是段的起点)再乘上 $\log V$ 合并就过了.</p><h2 id="山东省实验中学-2023-秋提高级友好学校赛前联测-3"><a href="#山东省实验中学-2023-秋提高级友好学校赛前联测-3" class="headerlink" title="山东省实验中学 2023 秋提高级友好学校赛前联测 3"></a>山东省实验中学 2023 秋提高级友好学校赛前联测 3</h2><p>A是简单题, B是模版矩阵优化dp</p><h3 id="C-5"><a href="#C-5" class="headerlink" title="C"></a>C</h3><blockquote><p>给定一个长度为 $n$ 的 01 串, 你需要将它划分成若干段, 每一段的长度都不超过 $m$, 且满足以下两种条件之一:</p><ol><li>这个段中全部为 $0$ 或全部为 $1$.</li><li>这个段中 $0, 1$ 数量之差不超过 $k$.</li></ol><p>你需要求出该 01 串合法的划分最少要多少段.</p><p>对于 $100%$ 的数据, 满足 $1 \le n, m, k \le 10^7$</p></blockquote><p>容易想到简单的线段树优化dp做到单log: $f_i$ 表示前 $i$ 个最少分几段, 另外套路的 $s$ 表示把 $0$ 当做 $-1$ 之后的前缀和, 然后就是找 $j\ge i-m, s_j\in [s_i-k, s_i+k]$ 的最小 $f_j$, 于是线段树维护 $j\ge i-m$ 中的部分, 在每个 $v$ 开堆维护所有 $s_j&#x3D;v$ 的 $f_j$, 使得在删掉 $j&lt;i-m$ 的决策时知道改改成啥.</p><p>然后观察性质, 对于任意两个 $i&lt;j, i, j$ 属于同一个堆, $f_i-f_j&#x3D;1$, 于是你只要维护堆里面最大的, 次大的位置和最大值就行了, 替换掉堆.</p><p>然后要替换掉线段树, 发现要在每个位置最多变化 $1$ 的序列上, 每次左右端点各移动 $1$ 的区间求最小值, 且值域 $O(n)$, 于是可以套路的用桶维护最小值个数, 处理左右端点, 而当删除时最小值数量减到 $1$ 时, 最小值 $+1$ 的位置如果是 $0$ 也不需要继续找, 因为一定可以通过全为 $0&#x2F;1$ 转移成 $f_{i-1}+1$ 也就是原来最小值 $+1$ 转移过来.</p><p>[trick] 每个位置变化 $1$, 左右端点每次移动 $1$ 的求区间最小值</p><h3 id="D-2"><a href="#D-2" class="headerlink" title="D"></a>D</h3><blockquote><p>给定一个长度为 $N$ 的序列 $A$. 对于一个子序列, 若任意两个在子序列中<strong>相邻</strong>的元素 $A_x, A_y (x&lt;y)$, 都满足 $A_x &lt; A_y$, 且原序列的&gt; 区间 $[x, y)$ 中不存在严格大于 $A_x$ 的值, 那么我们就说这个子序列是”贪心上升”的.</p><p>定义一个子序列的权值为子序列中所有元素的和, 给定 $Q$ 次询问, 每次询问给定一个区间 $[L, R]$ , 请你求出这个区间中权值最大的贪心上升子序&gt; 列的权值是多少.</p><p>对于所有数据, 保证满足 $0 \le a_i, S \le 10^9, T \in [0, 1]$.</p></blockquote><p>直接找到区间中第一个最大值 $A_x$, 则全局中 $i\in [l, x]$ 开始往后找到的最大子序列长度 $f_i$ 和限制了区间之后找到的只差一个 $f_x-1$, 因为走到 $x$ 之后的剩下都相同了. 而 $i\in [x+1, r]$ 可以找以它结尾的最大长度 $g_i$, 那么它一定起始于 $x$ 之后也就一定在区间里. 于是最后只需要预处理 $f, g$ 和最大值的ST表, 查询的时候就只有RMQ了.</p><p>[think] 使得局部的答案就是全局的答案的子集.</p><h2 id="山东省聊城第一中学-2023-秋提高级友好学校赛前联测-4"><a href="#山东省聊城第一中学-2023-秋提高级友好学校赛前联测-4" class="headerlink" title="山东省聊城第一中学 2023 秋提高级友好学校赛前联测 4"></a>山东省聊城第一中学 2023 秋提高级友好学校赛前联测 4</h2><h3 id="A-5"><a href="#A-5" class="headerlink" title="A."></a>A.</h3><blockquote><p>今年, C 教授举办了一个春令营. 春令营拥有 $n$ 个学生, C 教授在春令营里开设了 $m$ 个技能培训.</p><p>春令营结束前, C 教授想选出一些学生组成兴趣小组进行实地考察.</p><p>第 $i$ 个学生可以用两个数刻画: $a_i, b_i$. 其中 $b_i$ 表示第 $i$ 个学生的能力值; $a_i$ 表示第 $i$ 个学生会的技能, 如果在二进制下 $a_i$ 从低到高数第 $j$ 位&gt; 为 $1$, 说明该学生会第 $j$ 项技能.</p><p>对于两个学生 $x, y$, 如果存在一项技能 $x$ 会但是 $y$ 不会, $x$ 就会认为自己比 $y$ 强.</p><p>为了避免混乱, C 教授组成的小组里面不能有一个人认为自己比组里其他学生都强, 且小组最少要有两个人. 在此基础上, C 教授希望选出的小组能力值 $b_i$ 之和尽量大. 输出能力&gt; 值之和最大值.</p><p>如果无法选出这样一个小组, 输出 $-1$.</p><p>$n\le 7000, m\le 60$</p></blockquote><p>考虑出现过两次以上的 $a$ 的对应元素都可以加上去(他们相互不认为厉害), 对于其他元素 $x$ 不认为自己比 $y$ 强当且仅当 $a_x\subseteq a_y$, 所以其他元素必须被这些相等的元素包含, 把被包含的全部加上即可.</p><h3 id="B-6"><a href="#B-6" class="headerlink" title="B."></a>B.</h3><blockquote><p>求串 $s$ 中形如 $t&#x3D;\texttt{114514}$ 的子序列 $q$ 的个数, 形如指长度相等, 且 $\forall i, j\ [t_i&#x3D;t_j]&#x3D;[q_i&#x3D;q_j]$</p><p>$n\le 10^6, m\le 62$</p></blockquote><p>发现如果我们要先数若干 $t$ 的子串拼起来, 如 $\texttt{114}$ 和 $\texttt{14}$, 那么我们无法保证它们对应的 $\texttt{1, 4}$ 对应相等.</p><p>另一个思路是枚举三种字符的实际值, 复杂度爆炸, 但枚举两种, 每次关于两种字符数量之和的做复杂度是 $nm$ 可以接受, 于是枚举 $\texttt{1}\texttt{4}$ 分别是谁, 数出每个 $\texttt{4}$ 前的 $\texttt{1}$ 和每个 $\texttt{1}$ 后的 $\texttt{4}$ 的个数即可合并答案($\texttt{5}$ 的方案就是 $\texttt{1}$ 和 $\texttt{4}$ 之间与它们不相等的数的个数)</p><h3 id="C-6"><a href="#C-6" class="headerlink" title="C."></a>C.</h3><blockquote><p>给定一个长度为 $n$ 的 0-1 串 $s_0s_1s_2\cdots s_{n-1}$, 你需要通过不超过 $L$ 次操作将其变为目标串 $t_0t_1t_2\cdots t_{n-1}$.</p><p>操作具体如下:</p><ul><li>首先给出一个整数 $0\le k\le L$.<strong>注意并没有要求 $\bm {k\le n}$.</strong></li><li>如果 $k&gt;0$, 接下来 $k$ 次, 第 $i$ 次操作你需要给出一个整数 $p\in[0, n-1]$, 并依次将 $s_{p}, s_{(p+1)\bmod n}, s_{(p+2)\bmod n}, s_{(p+3)\bmod n}, &gt; \cdots, s_{(p+i-1)\bmod n}$(即一个长度为 $i$ 的区间)异或 $1$.</li></ul><p>请你构造一个合法的操作, 或报告不存在可以在 $L$ 次内完成要求的操作方案.</p><p>| $n$ | $L$ | 子任务编号 | 分数 |<br>|: -: |: -: |: -: |: -: |<br>| $\le 5$ | $&#x3D;400$ | $0$ | $15$ |<br>| $\le 9999$ | $&#x3D;5\times 10^5$ | $1$ | $5$ |<br>| $\le 9999$ | $&#x3D;10^4+1$ | $2$ | $15$ |<br>| $\le 9999$ | $&#x3D;9999$ | $3$ | $5$ |<br>| $\le 99999$ | $&#x3D;5\times 10^5$ | $4$ | $5$ |<br>| $\le 99999$ | $&#x3D;2\times 10^5$ | $5$ | $10$ |<br>| $\le 99999$ | $&#x3D;10^5+1$ | $6$ | $10$ |<br>| $\le 99999$ | $&#x3D;10^5$ | $7$ | $20$ |<br>| $\le 99999$ | $&#x3D;99999$ | $8$ | $15$ |</p><p>对于所有数据, $n\le99999, 1\le n\le L \le 5\times 10^5$, $s$ 和 $t$ 仅由 $0$ 和 $1$ 构成.</p></blockquote><p>注意到两次让一位相同并不影响其他位是好做的. 那么我们会做 $L\ge 2c$ 的数据, 其中 $c&#x3D;\sum [s_i\ne t_i]$, 注意到 $L&#x3D;n$ 的范围内 $L$ 一定是奇数, 于是对于 $L&lt;2c$ 的点你可以直接用 $p&#x3D;n$ 的一次整体翻转剩下的直接做.</p><h3 id="D-3"><a href="#D-3" class="headerlink" title="D."></a>D.</h3><blockquote><p>求 $Graph(n, m)$ 用 $k$ 种颜色染色的方案数, 要求一条边相连的两点颜色不同.</p><p>$n\le 10^5, m\le n+3$</p></blockquote><p><img src="/img/2023-11-01-19-02-06-image.png" alt="picture 2">  </p><p>只取其中”点数很多的话”后面的部分即可.</p><h2 id="山东师大附中2023-秋提高级友好学校赛前联测-5"><a href="#山东师大附中2023-秋提高级友好学校赛前联测-5" class="headerlink" title="山东师大附中2023 秋提高级友好学校赛前联测 5"></a>山东师大附中2023 秋提高级友好学校赛前联测 5</h2><h3 id="A-6"><a href="#A-6" class="headerlink" title="A."></a>A.</h3><blockquote><p>给定排列 $p_n$, 每次循环右移 $k$ 位或将其置换一次, 置换指 $p’_{p_i}&#x3D;i$.<br>$n\le 10^5$</p></blockquote><p>考虑置换实际上是交换一个点的值和下标, 那么你记录 $(a, b)$ 表示 $a$ 位置是 $b$, 则循环右移是模意义下加, 置换是交换 $a, b$, 于是可以合并操作了.</p><h3 id="B-7"><a href="#B-7" class="headerlink" title="B."></a>B.</h3><blockquote><p>给定有向图 $Graph(n, m)$, 若 $u$ 可以到达 $v$ 则 $u$ 和 $v$ 不能在同一组, 求整张图最少被划分到几个组.</p></blockquote><p>容易发现它就是让你求最长链状物, 如果没有环是最长链, 有环是缩点后点权为SCC大小后的最长链.</p><h3 id="C-7"><a href="#C-7" class="headerlink" title="C."></a>C.</h3><blockquote><p>现在有 $n$ 个数, 其中第 $i$ 个数等于 $2^{a_i}\times3^{b_i}$.</p><p>对于所有的非空子集, 求出它们的最小公倍数, 并且求和. 求这个和对 $10^9+7$ 取模的结果.</p><p>对于 $100%$ 的数据, 满足 $1\le n\le10^5, 0\le a_i, b_i\le10^9$.</p></blockquote><p>这个题和昨天南外(NOIP2023模拟赛48)T4好像啊.</p><p>考虑设 $f_i$ 表示 $lcm$ 的 $2$ 上指数小于等于 $i$ 的情况下, 所有lcm的 $3$ 的次幂之和, 考虑如何计算 $f_i$, 现在只加入 $2$ 上指数小于 $i$ 的数, 那么若 $3^k$ 有 $c_k$ 个, $s_k&#x3D;\sum_{l&lt;k} c_l$, 答案就是 $\sum_k (2^{c_k}-1)2^{s_k}$, 线段树维护即可.</p><h3 id="D-4"><a href="#D-4" class="headerlink" title="D."></a>D.</h3><blockquote><p>有一个数列 $a_1, a_2, \ldots, a_n$, 它是 $1, 2, \ldots, n$ 的一个排列.</p><p>现在你想对这个数列进行一些变换: 每一次可以选择一对 $i, j$, 满足 $1\le i&lt;j\le n$ 且 $a_i&gt;a_j$, 然后将 $a_i$ 和 $a_j$ 交换.</p><p>问通过若干次(可以 $0$ 次)变换, 能得到多少种不同的排列. 输出答案对 $10^9+7$ 取模的结果.</p><p>$n\le 30$</p></blockquote><p>有点难想?</p><p>如果是 $01$ 序列是会做的, 就要求所有 $1$ 的位置分别比原序列 $1$ 的位置靠右即可. 那么可以把问题转化对每个 $k$, 把大于 $k$ 的当成 $1$, 其他是 $0$, 的情况下均合法的数量. 于是可以dp, 设 $f_S$ 表示当前 $01$ 集合是 $S$ 的方案数, $\vert S\vert$ 就是 $n-k$, 每次从 $S$ 转移到 $S\vert 2^k$ 即可</p><h2 id="威海实验-2023-秋提高级友好学校赛前联测-7"><a href="#威海实验-2023-秋提高级友好学校赛前联测-7" class="headerlink" title="威海实验 2023 秋提高级友好学校赛前联测 7"></a>威海实验 2023 秋提高级友好学校赛前联测 7</h2><h3 id="A-7"><a href="#A-7" class="headerlink" title="A."></a>A.</h3><blockquote><p>有 $n$ 个矿堆</p><p>初始时第 $i$ 个矿堆有 $v_i$ 价值开采, 每次开采价值减少 $w_i$</p><p>即这一次得到的价值是 $v_i$, 下一次 $v_i\to(v_i-w_i)$  .</p><p>求出开采 $k$ 次的开采价值最大值.</p><p>对于全部的数据 $1\le v_i, w_i\le 10^{18}$</p></blockquote><p>和CF1661F, CF1344D一样的trick, 凸的二分优化贪心即可</p><p>见greedy</p><h3 id="B-8"><a href="#B-8" class="headerlink" title="B."></a>B.</h3><blockquote><p>给你一个 $01$ 序列 , 长度为 $n$ .</p><p>每次你可以选择 $1$ 附近距离小于等于 $q$ 的一个 $0$ 并把它改为 $1$ .</p><p>求把整个序列都标记成 $1$ 的操作方案数取模 $10^9+7$ 的结果.</p><p>保证至少存在一种操作方案.</p><p>$n\le 10^6, q\le 100$</p></blockquote><p>考虑一堆 $0$ 被两个 $1$ 夹在中间, 那么更远的 $1$ 都没有用了, 所以答案其实就是每一段连续 $0$ 的答案.</p><p>而这个可以很好地转移啊, 枚举第一个填的 $1$ 的位置即可. 复杂度 $nq$</p><h3 id="C-8"><a href="#C-8" class="headerlink" title="C."></a>C.</h3><blockquote><p>给一棵树, 上面有 $n$ 对点, 每对点上权值, 每次对链包含的点减(包含一个点就给点对减去一次, 包含两个点减两次), 对每个 $i$ 求点对被第一次减成 $0$ 的代价.<br>$n, q\le 2\times 10^5$</p></blockquote><p>问题就是求每个点对结束贡献的时间, 这不是我们的减半警报器吗?</p><p>复杂度 $n\log n\log V$</p><p>可以树上差分, 离线, 转成矩形加(dfn, time)然后以dfn为版本维用主席树维护, 复杂度可以单log啊</p><h3 id="D-5"><a href="#D-5" class="headerlink" title="D."></a>D.</h3><blockquote><p>给定树, 求路径上有多少点对 $a, b$ 满足存在 $k$ 使得 $\lfloor \dfrac{w_a}{k}\rfloor&#x3D;w_b$</p><p>$w$ 互不相同, $n, q, w_i\le 5\times 10^4$</p></blockquote><p>有 $n\sqrt n$ 对满足条件的点, 直接根号平衡复杂度扫描线秒了.</p><p>淀粉质也可以线性空间复杂度带log.</p><p>然后可以搞二次离线莫对之类的东西搞成空间线性的根号log并不依赖互不相同.</p><h2 id="信友队-2023-NOIP-模拟赛"><a href="#信友队-2023-NOIP-模拟赛" class="headerlink" title="信友队 2023 NOIP 模拟赛"></a>信友队 2023 NOIP 模拟赛</h2><h3 id="A-呜"><a href="#A-呜" class="headerlink" title="A. 呜"></a>A. 呜</h3><blockquote><p>给定 $n\times m$ 01矩阵, 求有多少个子矩形满足翻转左上角一个全 $1$ 正方形后是全 $0$ 的, 不能不翻.</p><p>$n, m\le 2000$</p></blockquote><p>你以为这个答案是 $n^4$ 级的, 其实它是 $n^3$ 级的.</p><p>发现如果枚举左上角或者正方形的右下角, 另一边相当于要求子矩形内的全 $0$ 矩形个数, 感觉很见鬼, 但如果枚举右上角, 发现其对应的左上角是唯一的, 于是就做完了. 复杂度 $n^2$ 可能带log.</p><p>[think] 这种对某种性质的结构计数的时候, 你一开始猜的关键位置(中间, 左上角)不一定是关键位置, 想不出来的话就要考虑其他位置. 另外就是01矩阵中的均摊性质, 点对能形成的匹配总个数一定但具体到一个点可能很多, 枚举左上角的时候就看不出对应右端点总和 $n^2$ 这个均摊.</p><h3 id="B-异或"><a href="#B-异或" class="headerlink" title="B. 异或"></a>B. 异或</h3><blockquote><p>给定序列 $a_n$, $q$ 次询问全局异或上 $x$ 后的逆序对个数.</p><p>$n, m\le 10^5$</p></blockquote><p>感觉有一点点像南外题的 NOIP模拟赛44 逆序对</p><p>因为异或你肯定想拆位才能做, 才能看大小关系, 那么可以把每个数的二进制表示看成一个字符串, 大小关系就成了字典序, 而异或就是翻转某些位上的大小关系(让第 $i$ 位 $0&gt;1$), 于是一种计算逆序对的方式是, 计算前 $i$ 位相同的数中, 当前位为 $1$ 的对当前位为 $0$ 的贡献, 这个前 $i$ 位相同很01trie, 于是建出01trie, 把每个数的下标插入到叶子上, 从下往上归并排序就能统计出某个节点的左右儿子之间的逆序对, 发现翻转某一位大小关系只是把一层的贡献从左对右换成右对左, 于是就做完了.</p><h3 id="C-Essence-of-Twilight"><a href="#C-Essence-of-Twilight" class="headerlink" title="C. Essence of Twilight"></a>C. Essence of Twilight</h3><p>LOJ Round6 花火</p><h3 id="D-数表"><a href="#D-数表" class="headerlink" title="D. 数表"></a>D. 数表</h3><blockquote><p>求有多少个值域 $[0, 2^k)$ 的 $2\times n$ 矩阵满足同行同列数不相同, 且 $2n$ 个数的异或和为 $0$.</p><p>$n, k\le 10^6$</p></blockquote><p>考虑每个数最多出现两次, 那么钦定出现两次的数有 $s$ 种, 剩下 $2n-2s$ 个数, 显然这 $s$ 种数的方案数是 $(V-(2n-2s))^{\underline s}$, 而剩下的数异或和仍 $0$ 且互不相同, 这个显然用容斥思想dp, $f_i&#x3D;v^{\underline {i-1}}-(V-i+2)f_{i-2}$, 表示先选前 $i-1$ 个互不相同的, 若最后一个和前面的相同则把它们两个一起删掉会得到 $f_{i-2}$, 它们两个此时又有 $V-(i-2)$ 种选法.</p><p>于是接下来只要求一种方案安排这 $2s$ 个数使得它们没有两个在同一列.</p><p>todo</p><h2 id="The-2nd-Universal-Cup-Stage-11-Nanjing"><a href="#The-2nd-Universal-Cup-Stage-11-Nanjing" class="headerlink" title="The 2nd Universal Cup. Stage 11: Nanjing"></a>The 2nd Universal Cup. Stage 11: Nanjing</h2><p>和zzk和mikefeng VP, 切2, 另外两人都切3, 被带飞了.</p><p>D看到slopetrick但不会写维护函数寄了.</p><h3 id="D-Red-Black-Tree"><a href="#D-Red-Black-Tree" class="headerlink" title="D. Red Black Tree"></a>D. Red Black Tree</h3><blockquote><p>红黑树要求每个点到任意后代叶子节点的路径上, 黑色点的<br>数量都相同. 称该性质为”红黑树性质”.<br>现在给定一棵树, 每个点是红色或黑色, 对于所有 $k \in [1, n]$, 求为了让以节点 $k$ 为根的子树满足红黑树性质, 至少要修改几个点的颜色.</p><p>$n\le 10^5$</p></blockquote><p>我看你是烟火表演弱化版.</p><p>一眼dp设 $f_{u, x}$ 表示 $u$ 到子树内每个叶子经过 $x$ 个黑点的最小代价, 则 $f_{u, x}&#x3D;\min_{i\in [0, 1]} (g(u, i)+\sum_{v\in son(u)}f_{v, x-i}$, 看到累加和 $min+$ 卷积的二维dp就上slopetrick.</p><p>于是两个操作分别是求和和对 $g$ 闵和, $g$ 要么是 $[0, 1]$ 要么是 $[1, 0]$, 都可以看成凸的.</p><p>那么对函数维护差分数组, 则分别是数组相加, 卷的时候要么是把差分数组的正数部分前面加一个 $1$, 要么是差分数组负数部分末尾加一个 $1$, 分差分为正数, 负数和 $0$ 段三段维护即可.</p><h3 id="J-Suffix-Structure"><a href="#J-Suffix-Structure" class="headerlink" title="J. Suffix Structure"></a>J. Suffix Structure</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机化</title>
      <link href="/2022/10/10/random/"/>
      <url>/2022/10/10/random/</url>
      
        <content type="html"><![CDATA[<h1 id="随机化"><a href="#随机化" class="headerlink" title="随机化"></a>随机化</h1><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h3 id="sdfzoj-contest-1-记录"><a href="#sdfzoj-contest-1-记录" class="headerlink" title="[sdfzoj contest #1]记录"></a>[sdfzoj contest #1]记录</h3><blockquote><p>构造一个有向图满足其以1为根的内向生成树个数对 $10^18+3$ 取模为 $k$ .<br>要求构造的有向图点数不超过100, 边数不超过 $3\times 10^5$</p></blockquote><p>首先众所周知的一个DAG的生成树个数是所有节点的入度的乘积. 那么要控制入度, 考虑直接让1到每个节点连一堆边就控制了入度, 所以现在问题是要选若干个数乘积在膜意义下等于 $k$ .</p><p>这个东西我们不会做, 可以智慧. 假设要等于一个数, 那么给2号点随机一个入度, 就直接给 $k$ 乘上一个逆元, 这很好因为你发现这样做把出题人精心构造的 $k$ 变成了近乎随机的. 那么现在你手里由一个随机的 $k$ , 于是接着随机每个节点的入度, 判断此时乘上一堆逆元之后的 $k$ 是否可以由小于某个阈值的质数表示, 如果随到最后还没弄出来就从头再来.</p><p>复杂度算不出来, 但qyc说他写出来之后只跑了1s多一点. 考虑剪枝, 考虑判断一个数是不是可以分解为小于某个数的质数这件事比较费时, 所以仅在它膜常数 $C$ 为0的时候去判断. 这样做相当于把值域缩小到 $\dfrac{1}{C}$ , 就能跑了.</p><p>qyc说比较好的参数是 $5\times 10^4$ , $C&#x3D;360$ </p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>模拟赛被卡hash.</p><p>注意事项:</p><ol><li>ull自然溢出是废物, 只要01串为 $\mathrm{popcount(x)}$ 奇偶性, 无论基数是什么都冲突.</li><li>固定质数 $p$ , 在 $[1, p)$ 中随机基数, 固定基数, 在 $[n, 2n]$ 中随机质数, 出错概率在 $10^{-4}$ 量级</li><li>__int128的确慢的离谱, 使用双模hash代替一个大质数</li></ol><p>EI说哈希常用的两个理论:</p><ul><li>一个是非零向量点乘一个随机向量, 那为0的概率是 $\dfrac{1}{q}$ , $q$ 是域的大小.</li><li>Schwarz–Zippel引理: 对域 $F$ 上一个不恒为0的多项式 $n$ 元 $d$ 次多项式 $P$ , 独立随机 $n$ 个变量 $x_1\ldots x_n$ 使得 $P(x_1, \ldots, x_n)&#x3D;0$ 的概率是 $\dfrac{d}{\vert F\vert}$</li></ul><p>~~但我不知道怎么用. ~~</p><h3 id="Qoj-6504-Flower’s-Land-2"><a href="#Qoj-6504-Flower’s-Land-2" class="headerlink" title="Qoj #6504. Flower’s Land 2"></a>Qoj #6504. Flower’s Land 2</h3><blockquote><p>有 $k$ 种引号, $q$ 次询问区间是否引号匹配, 或者区间把 $i$ 种引号改成 $(i+1)\pmod k$ 种引号.</p><p>$n, q\le 5\times 10^5, k&#x3D;3$</p></blockquote><p>“这是想得到啊”</p><p>对每种引号, 随机一个可逆矩阵, 然后为奇数次出现赋值这个矩阵, 为偶数次赋值它的逆, 然后判断区间乘起来是不是单位矩阵. 因为修改直接维护加一次, 加两次的结果.</p><p>这里不能用多项式乘法, 素数等等, 因为你需要它不交换, 性质尽可能烂.</p><p>然后qyc说sqy说不能用多项式复合, 原因是”不是自由群”? ?</p><h2 id="从这往下的部分是231221南外随机化专题"><a href="#从这往下的部分是231221南外随机化专题" class="headerlink" title="从这往下的部分是231221南外随机化专题"></a>从这往下的部分是231221南外随机化专题</h2><h3 id="P9737-COCI2022-2023-2-Lampice"><a href="#P9737-COCI2022-2023-2-Lampice" class="headerlink" title="P9737 [COCI2022-2023#2] Lampice"></a>P9737 [COCI2022-2023#2] Lampice</h3><blockquote><p>$n\times m$ 平面上 $k$ 种灯, 每种有两盏, 求有多少个矩形满足不存在一对同种灯一盏在矩形内一盏在矩形外.</p><p>$n\le 150, m\le 1000, k\le 200000$</p></blockquote><p>看到这种两个都在等于两个都不在的情况, 考虑异或, 给每种灯一个异或值满足条件当且仅当为 $0$.</p><p>枚举矩形判定即可.</p><h3 id="CF1310D-Tourism"><a href="#CF1310D-Tourism" class="headerlink" title="CF1310D Tourism"></a>CF1310D Tourism</h3><blockquote><p>$N$ 个点的图, 给你图的邻接矩阵, 求从点 $1$ 出发经过  $K$ 条边回到点 $1$, 且路径上没有奇环的最短距离</p><p>$2 \leq  N \leq 80 , 2 \leq K \leq 10$</p></blockquote><p>没有奇环考虑二分图染色, 那么随便染色钦点走的路径相邻两点颜色不同, 那么染对的概率是 $\dfrac{1}{512}$, 算一下发现跑5000遍差不多了.</p><h3 id="HDU6664-Andy-and-Maze"><a href="#HDU6664-Andy-and-Maze" class="headerlink" title="HDU6664 Andy and Maze"></a>HDU6664 Andy and Maze</h3><blockquote><p>给一张图 $Graph(n, m)$, 求经过 $k$ 个点的简单路径的长度最大值</p><p>$n, m\le 10^4, k\le 6$</p></blockquote><p>如果 $n$ 很小可以直接记录点集编号. 因为 $k$ 很小, 考虑给每个点随一个 $1\ldots k$ 的编号要求走过路径编号不重复, 正确率显然是 $\dfrac{k! }{k^k}\approx 0. 98$, 多跑几遍.</p><h3 id="CF364D-Ghd"><a href="#CF364D-Ghd" class="headerlink" title="CF364D Ghd"></a>CF364D Ghd</h3><blockquote><p>定义一个集合的Ghd为 所有大小至少为一半的子集的 $\mathrm{gcd}$ 的最大值.</p><p>给定集合 $a$, 求 $a$ 的Ghd.</p></blockquote><p>和刚才那个类似? 随一个数有一半的概率在最终子集中, 所以随十几次, 每次枚举这个数的因数, 遍历所有的数加到对应因数上, 然后做一遍超集和, 从大到小枚举判定</p><h3 id="CF1728E-Red-Black-Pepper"><a href="#CF1728E-Red-Black-Pepper" class="headerlink" title="CF1728E Red-Black Pepper"></a>CF1728E Red-Black Pepper</h3><blockquote><p>有 $n$ 盘菜, 每盘菜要加入红辣椒或黑辣椒, 其中第 $i$ 盘菜加入红辣椒会增加 $a_i$ 点美味值, 黑辣椒增加 $b_i$ 点. (每盘菜都会且只会加入一份红辣椒或一份黑辣椒, 且不能两种都加)</p><p>现在有 $m$ 个商店, 每个商店 $j$ 有无数包两种辣椒, 一包红辣椒有 $x_j$ 份红辣椒, 一包黑辣椒有 $y_j$ 份黑辣椒(每份辣椒只可以加入一盘菜), 求对于每个商店, 若<strong>只从这个商店买辣椒</strong>得到的最大美味值是多少(买到的辣椒<strong>份数</strong>必须正好等于 $n$, 不能多也不能少, 若无法实现则输出 $-1$).</p><p>$n, m\le 3\times 10^5$</p></blockquote><p>没有懂和随机化有什么关系, 但反正简单题</p><p>设 $n$ 份辣椒中有 $i$ 份为红辣椒的答案为 $f_i$, 可以先全选 $a$ 然后按 $b-a$ 排序加入.</p><p>然后众所周知的结论因为 $x_ja+y_jb&#x3D;n$ 的同余方程中 $a$ 的取值是等差数列, $x_ja$ 也是, 所以就是查等差数列位置最值, 直接根号分治秒了.</p><h3 id="ABC314Ex-Disk-and-Segments"><a href="#ABC314Ex-Disk-and-Segments" class="headerlink" title="[ABC314Ex] Disk and Segments"></a>[ABC314Ex] Disk and Segments</h3><blockquote><p>给定 $n$ 条线段, 求最小的圆使得没有一条线段全部在圆外.<br>$n\le 100$, 误差 $10^{-5}$</p></blockquote><p>退火!</p><h3 id="CF1114E-Arithmetic-Progression"><a href="#CF1114E-Arithmetic-Progression" class="headerlink" title="CF1114E Arithmetic Progression"></a>CF1114E Arithmetic Progression</h3><blockquote><p>交互题, 有一个 ${a_n}$, 保证从小到大排序后是等差数列, 不超过 $60$ 次询问求公差和首项, 每次可以给定 $x$ 问 $a_x$ 或问是否有严格大于 $x$ 的数.</p><p>$n\le 10^6, a_i\le 10^9$</p></blockquote><p>末项可以二分, 任意问两个数, 公差一定是它们差的因数, 期望很少次gcd出公差, 然后就能确定首项.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 随机化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国庆集训</title>
      <link href="/2022/10/03/2022_national_holiday_training/"/>
      <url>/2022/10/03/2022_national_holiday_training/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1-Wyj"><a href="#Day1-Wyj" class="headerlink" title="Day1-Wyj"></a>Day1-Wyj</h1><h2 id="模拟赛"><a href="#模拟赛" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>智障题</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><blockquote><p>给定 $a$ , 计数满足以下条件的排列个数:</p><ul><li>$b_1\lt b_2\gt b_3\lt b_4\ldots$ </li><li>$b_2\lt b_4\lt b_6\ldots$<br>$n\le 5000$</li></ul></blockquote><p>排列上的问题, 基本上只要 $n\ge 20$ 就是顺着值域扫了.</p><p>同时显然偶数位上的性质比奇数位上的好的多. 确定偶数位后, 对每一个奇数位, 它可以被插入在一个后缀里. 此时只看奇数位方案数 $\prod (c_i-i)$ 这样的.</p><p>考虑dp, $f_{i, j}$ 表示值域上前 $i$ 个数, 这 $i$ 个数中有 $j$ 个在偶数位上的方案数. 但这里要提前计算奇数位的费用. 转移就是考虑当前这一位选不选, 选就是 $f_{i-1, j-1}$ , 否则就直接 $f_{i-1, j}$ 再乘上这一个数作为奇数位上的贡献.</p><p>但现在相同数. 只要改一下转移: 枚举是否拿其中一个作为偶数位, 乘上剩下的数作为奇数位的一个下降幂贡献再除掉自己内部顺序.</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><blockquote><p>求选树上点两条不相交链, 最大化两条链各自的异或和的和.<br>$n\le 2\times 10^9, w\le 10^9$ </p></blockquote><p>考虑相当于在子树内找一条最大异或和链, 子树外找一条.</p><p>找到全局最大异或和链, 对于链外的点, 其子树外找的那一条必然是这一条.</p><p>于是把这个最大链求出来作为根, 然后再对内部节点求子树内的链, 此时子树总和是 $O(n)$ . (不需要递归, 只要找直接接在链上的, 显然他们的子孙被包含, 只要插入).</p><p>接下来考虑直接在这条链上的节点, 此时从这条链最深的点往上走, 相当于每次给子树添加几个点, 总增量也是 $O(n)$ 的.</p><p>哦, 这个题有个地理解错了, 其实求最大的和求子树内的都不需要点分治, 因为实际上异或和到根的地方会抵消掉, 所以trie上插入根到所有节点的链的答案就行了.</p><p>点分治是硬加1log</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><blockquote><p>一个 $n$ 个集合组成的序列, $m$ 次操作支持区间插入一个数, 求区间内的集合中的所有数的最大值, 或者对区间内的每一个集合, 删掉<strong>一个</strong>等于这个区间所有数最大值的数.<br>$n, m\le 2\times 10^5$ </p></blockquote><p>第三个删除操作, 相当于强制在线, 毙掉了这类题一个经典扫序列维维护时间维的套路. . .</p><p>考虑线段树套堆+标记永久化. 插入的时候给线段树对应顶层区间的堆插入这个数, 删除的时候因为一共插入 $m\log n$ 个数, 所以我们每次找到一个等于这个数的删掉. 只要暴力递归从树上删除, 但当最大值小于这个数的时候就跳过, 这样做我们只会递归子树内有要删的子树, 用吉老师线段树分叉的分析方法(分析递归链向外分叉数), 复杂度2log.</p><p>对于查询就简单了, 注意标记永久化之后区间查询要算上从根到自己的所有标记.</p><h2 id="讲课"><a href="#讲课" class="headerlink" title="讲课"></a>讲课</h2><h3 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h3><blockquote><p>一个由小写字母组成的长 $n$ 的字符串, Alice和Bob两人分别先后依次操作, 每次操作将字符串的两端其中一个字符移动到自己字符串的开头, 初始时每个人的字符串为空. 最后谁的字符串字典序小谁就赢了. 双方都按照最优操作, 最后谁会赢, 或是平局. $n$ 是偶数, $n \le 2000$ .</p></blockquote><p>一定是前面一段连续相同的然后出现一个不一样的, 并且每一个有向图游戏状态由端点表示即可</p><p>麻, 加到前面, 看错题了.</p><p>但状态设计不变, 转移枚举两个人的决策. 注意是从小到大扩(因为你选的字符是加到最后)</p><p>还有个贪心, 但讲了个啥完全不懂.</p><h3 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h3><blockquote><p>无向图, 边有边权. 有 $k$ 次飞跃的机会, 无视道路, 花费 $(u-v)^2$ 的时间从 $u$ 来到 $v$ . 求从1号点开始的最短路. $n \le 10^5 , m \le 10^5 , k \le 20$ </p></blockquote><p>哦是个智障. 图上转移方向很多, 但编号维方向只有俩.</p><p>于是你就跑最短路, 然后处理跳的这一步的时候枚举编号的两个转移方向单独转(斜率优化). 复杂度 $km\log n$ </p><h3 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h3><blockquote><p>长为 $n$ 的数列 a, 进行如下操作: 选择 $1 \le l \le r \le n$ 和任意数 $x$ , 将 $[l, r]$ 内的所有数字异或 $x$ , 代价 $\left\lceil\dfrac{r-l+1}{2}\right\rceil$ , 注意是向上取整. 求把数列a变成全零的最小代价. $n \le 10^5 , a_i \le 2^{30}$ .</p></blockquote><p>代价向上取整意味着我们只会用长度不大于2的操作</p><p>发现若一个区间异或和为0则可以节省一次. 所以要划分若干个不交区间即可.</p><h3 id="T4-1"><a href="#T4-1" class="headerlink" title="T4"></a>T4</h3><blockquote><p>给定 $n, k\le 2* 10^5$ , 第一次选择一个 $k$ 的倍数, 第二次选择一个 $k+1$ 的倍数, 以此类推, 直到选择数的总和为 $n$ . 对于每一个 $1 \le i \le n$ , 求有多少种方法选择到 $i$ .</p></blockquote><p>比较套路, 暴力做状态数是 $n\sqrt n$ 的.</p><h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><blockquote><p>长为 $n$ 的数列 a, $n \le 250 , \sum a_i \le 250$ , 每次操作让相邻的两个数字一个加一, 另一个减一. 最小操作数使得数列不增.</p></blockquote><p>$f_{i, j, k}$ 表示前 $i$ 个数, 第 $i$ 个数是 $j$ , 并且向右移出了 $k$ 的值.</p><p>重点是我们并不是只用左减右加.</p><h3 id="T6"><a href="#T6" class="headerlink" title="T6"></a>T6</h3><blockquote><p>有一个 $2^n-1$ 个点的完全二叉树, 点有字母, 树的串为前序遍历的字符串. 如果可以将任意点的左右儿子互换, 最多出现多少种不同的树的串? $n \le 18$ </p></blockquote><p>直接做 $f_{u}&#x3D;f_{v}f_{k}(\times 2)$ , 乘不乘取决于左右两边是否同构. 于是判同构即可.</p><h3 id="T7"><a href="#T7" class="headerlink" title="T7"></a>T7</h3><blockquote><p>将长度为 $n$ 的序列 $a$ 分成若干子段, 设子段 $s&#x3D;a_l+a_{l+1}+\ldots+a_r$ 每段的价值定义为: 如果 $s&gt;0$ 价值为 $(r-l+1)$ , 如果 $s&#x3D;0$ 价值为 $0$ , 如果 $s&lt;0$ 价值为 $-(r-l+1)$ . 求序列划分出所有子段总价值的最大值.</p></blockquote><p>暴力就是 $f_i$ 表示前 $i$ 个答案.</p><p>用线段树优化即可.</p><h3 id="T8"><a href="#T8" class="headerlink" title="T8"></a>T8</h3><blockquote><p>构建一棵 $n$ 个点的二叉搜索树, 使得 $\sum_{1 \le i &lt; j \le n}c_{ij}* d_{ij}$ 最小. $d_{ij}$ 表示树上 $i$ 号点和 $j$ 号点的最短路径长度. $n \le 200 , 0 \le c_{ij} \le 10^9$ </p></blockquote><p>是BST所以一个子树对应一个区间. 于是区间dp枚举中间断开当根, 需要费用提前计算</p><h3 id="T9"><a href="#T9" class="headerlink" title="T9"></a>T9</h3><p>模拟赛T2</p><h3 id="T10"><a href="#T10" class="headerlink" title="T10"></a>T10</h3><blockquote><p>长为 $n$ 的两个序列 $a, b$ , 每次操作可以交换 $(a_i, b_i)$ , 求式子的最小值: $\sum_{i&#x3D;1}^{n} \sum_{j&#x3D;i + 1}^{n} (a_i + a_j)^2+\sum_{i&#x3D;1}^{n} \sum_{j&#x3D;i + 1}^{n} (b_i + b_j)^2$ . $n, a_i, b_i\le 100$ .</p></blockquote><p>拆式子, 成了 $\sum_{i, j} a_ia_j&#x3D;\sum_i a_i\times s_i$ , 根据这个设 $f_{i, j}$ 表示前 $i$ 个, $a$ 的前 $i$ 个和位 $j$ 即可.</p><h3 id="T11"><a href="#T11" class="headerlink" title="T11"></a>T11</h3><blockquote><p>长为 $n$ 的序列, 每次操作将一个数加一或减一, 使序列单调不降的最小操作次数. $n \le 5000 , a_i \le 10^9$ </p></blockquote><p>这不是Slope Trick经典例题吗?</p><h3 id="T12"><a href="#T12" class="headerlink" title="T12"></a>T12</h3><blockquote><p>长为 $n$ 的序列 $a$ , 分成 $k$ 段, 每段的价值为不同的数字的个数, 求最大总价值和. $n \le 35000 , k \le 50$ </p></blockquote><p>考虑转化二维数点之后贡献变成什么, 然后考虑这玩意貌似是凸的? ! 是的, 可以二维数点画图, 也可以考虑 $[i-1, j], [i, j+1]$ 变成 $[i-1, j+1], [i, j]$ 相当于把 $i-1$ 移动到 $[i, j+1]$ , 发现如果它在 $i, j$ 中没有贡献则在 $[i, j+1]$ 中一定没有贡献. 所以相交大于等于包含. 于是就是DAG定长最短路直接冲.</p><h3 id="T13"><a href="#T13" class="headerlink" title="T13"></a>T13</h3><blockquote><p>长为 $n$ 的序列 $a$ , 进行 $k$ 次操作. 每次随机选取两个不相同的位置, 交换他们. 求多少概率最后的序列不降. 概率对1000000007取模. $n \le 100 , k \le 10^9 a_i&#x3D; {0, 1}$ .</p></blockquote><p>考虑设 $f_i$ 表示错误位置上的0&#x2F;1的个数为 $i$ 的情况, 你惊讶的发现从 $i$ 到 $i+1$ 或 $i-1$ 的转移只和 $i$ 有关, 于是这个再加上100-1e9这个矩阵乘法数据范围提示组合即可.</p><h3 id="T14"><a href="#T14" class="headerlink" title="T14"></a>T14</h3><blockquote><p>搜索树: 一个点的权值大于左子树的点的权值, 小于右子树的点的权值; 平衡的树: 不存在另外一棵节点大小相同的数, 所有节点的深度和比自己的树小; 有条纹的树: 每个点与左儿子奇偶性不同, 与左儿子奇偶性相同. 求 $n$ 个点的有条纹的平衡的二叉搜索树的个数, 对998244353取模.</p></blockquote><p>结论是只当 $n&#x3D;4, 5, 9, 10, 20, 21. . .$ 时它才是1, 其他是0</p><h3 id="T15"><a href="#T15" class="headerlink" title="T15"></a>T15</h3><blockquote><p>由 $3n-2$ 根火柴横着拼成的 $n$ 个正方形, 对于每个 $i$ 求恰好去掉 $i$ 根火柴后仍然全部联通的方案数. $n \le 3000$ </p></blockquote><p>是不是直接设 $f_{i, j, 0&#x2F;1, 0&#x2F;1}$ 前 $i$ 个, 删了 $j$ 个, 第 $i$ 列的上下是否连通就结束了.</p><h3 id="T16"><a href="#T16" class="headerlink" title="T16"></a>T16</h3><blockquote><p>$n$ 个数的序列, 每个数字值域 $[1, m]$ . 最长上升子序列恰好为3的序列个数有多少? $n \le 1000 , m\le 10$ </p></blockquote><p>$m\le 10$ 提示状压?</p><p>$f_{i, a, b, c}$ 表示前 $i$ 个数, 这 $i$ 个数中长度为1, 2, 3的LIS的最后一个数最少是 $a, b, c$ 即可.</p><p>相当于对着贪心做LIS的那个贪心数组做dp of dp.</p><h1 id="Day2-Qyc"><a href="#Day2-Qyc" class="headerlink" title="Day2-Qyc"></a>Day2-Qyc</h1><h2 id="模拟赛-1"><a href="#模拟赛-1" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="组合数学靠运气"><a href="#组合数学靠运气" class="headerlink" title="组合数学靠运气"></a>组合数学靠运气</h3><blockquote><p><strong>组合</strong>喜欢组合<strong>数学</strong>. 组合认为组合数学中最有趣的部分就是形式语言处理, 或者说串串. 今天她看到一篇关于形式语言的论文, 其中证明了这样一个结论 : 一个长 $l$ 的模式是长 $l$ 的字符串中若干字符之间的等价关系, 如果一个包含 $k$ 个等价类的模式长度至少是 $2^k$ , 那么存在无限长的三个字母的序列, 其中没有子串满足这一模式. 证明的话组合要<strong>靠运气</strong>才能看懂, 但是今天大凶, 所以就不再赘述了.</p><p>选手, 今天组合不关心Entropy Compression, 她只想知道长 $n$ 的无平方串最少有多少个不同的字母, 并且你需要给出构造. 一个串是平方串, 当且仅当它的前一半和后一半相同, 如abcabc或114514114514. 一个串是无平方串, 当且仅当它的子串都不是平方串. $n\leq 10^7$ .</p><p>为了checker写起来方便, 每个字母是一个数, 并且如果你认为最少有 $k$ 个不同的字母, 你构造的串中只能出现 $1, . . . , k$ 这些数.</p><p>输入&#x2F;输出量看起来很大, 但是实际上并没有那么恐怖. 我们测试了一份使用putchar输出的代码, 运行时间在0. 2s以内.</p></blockquote><p>打前几的表发现感觉 $k&#x3D;3$ 可以做到任意大.</p><p>正解是乱搞, 猜测概率上不会出现一个很长的平方串, 只维护100以内的平方串, 就是随机一段拼上去, 然后暴力查是否有100以内的平方串, 有就只删掉组成平方串的一小部分, 不断重复. 可以过 $10^5$</p><p>[trick] 更正的正解是, popcount的奇偶性的差分是无平方串的. 可以当冷知识积累</p><h3 id="图论一顿套模板"><a href="#图论一顿套模板" class="headerlink" title="图论一顿套模板"></a>图论一顿套模板</h3><blockquote><p><strong>图论</strong>现在遇到了一个图论问题. 有一张无向连通图, 没有自环但可能有重边, 保证存在至少一个环经过每条边恰好一次. 图上的点就只是点, 而边有长度 $\mathbf{2}l_i$ . 你有一个体力, 一开始是 $0$ , 每走 $1$ 单位长度会消耗 $1$ . 第 $i$ 条边的正中间有权值为 $w_i$ 的<strong>一顿</strong>, 你经过正中间的瞬间会吃一顿, 获得 $w_i$ 的体力. 现在你要选择一条边的正中间作为起点, 从它出发经过这张图的每条边<strong>恰好</strong>一次, 如果中间你的体力低于 $0$ , 你就需要橘长摸一天的课去救你. 我们不希望这样的事情发生, 所以图论<strong>套</strong>了几个<strong>模板</strong>试图解决这个问题. 但是由于橘长希望这样的事情发生, 图论的模板并不足以解决这个问题, 所以还是要你这个模板大师来秒一秒.</p><p>$n\leq 10^5$ , 多组数据.</p></blockquote><p>跑出任意一条欧拉路, 然后Raney定理. 做完了.</p><h1 id="Day4-Qyc"><a href="#Day4-Qyc" class="headerlink" title="Day4-Qyc"></a>Day4-Qyc</h1><h2 id="模拟赛-2"><a href="#模拟赛-2" class="headerlink" title="模拟赛"></a>模拟赛</h2><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><blockquote><p>给定 $a, b$ , 可以让 $a\times 2, a: &#x3D;a+b, b\times 2, b: &#x3D;a+b$ , 200次以内操作让 $a&#x3D;b$ .<br>$a, b\le 10^9$</p></blockquote><p>考虑 $c&#x3D;\dfrac{a-b}{\gcd (a, b)}$</p><p>用翻倍操作把0补齐, 此时再 $a\times 2$ 相当于 $b&#x2F;2$</p><p>考虑如果 $a&gt;b$ , 就 $a&#x3D;a+b, a&#x2F;&#x3D;2$ , 一直做就行了.</p><h3 id="B"><a href="#B" class="headerlink" title="B"></a>B</h3><blockquote><p>万邦先生的电脑中了<strong>高科技糹乙万恶木馬</strong>, 现在他的诗作都被打乱了. 不过<strong>木馬</strong>的作者只是想找点乐子, 所以<strong>木馬</strong>告诉万邦先生, 它的打乱方式是每次选择两个相邻的长偶数的区间, 然后把它们交换. 万邦先生的诗作可以看成一个整数序列 $a$ . 现在你拿到了打乱后的万邦先生的一首诗 $a^\prime$ 和他尝试复原的一首诗 $a$ , 请你帮他求出他的复原是否有可能正确, 也就是复原的诗是否有可能经<strong>木馬</strong>的打乱变成打乱后的诗. $n\leq 10^5$ , 多组数据.<br>对于 $100 %$ 的数据, $n\leq 10^5, \sum n\leq 5\times 10^5, 1\leq a_i\leq n$ .</p></blockquote><p>首先操作不改变数位置的奇偶性</p><p>然后想到一种策略: 确定了前面的之后每次把后面的一个换到这一个, 类似选择排序吧.</p><p>然后做到最后, 发现剩下3个的时候可能能行可能不能行. 这个跟逆序对有关, 发现操作不改变逆序对奇偶性, 而最后应该剩下一个, 没有重复元素的就做完了.</p><p>如果相同奇偶性内部的有相同元素, 你一定可以钦定一个对应使得可以, 所以此时一定可以.</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>直接贪心, 覆盖1到第一个z前面, 覆盖第二个z到第三个z前面. . . z用完了用 $y$ . . .</p><p>然后现在卫生纸用完了之后, 后面可能不能全覆盖, 此时相当于前面一定确定, 我们要选择一个字典序最大的后缀.</p><p>一个正常的方法是用SA跑</p><p>一个不正常的办法是用OIWiki上的最小表示法的算法.</p><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><blockquote><p><strong>圣诞节后</strong>, 万邦先生和他的 $n-1$ 个朋友们聚会, 他们要玩一个古老的**<em><em>国进口<strong>游戏. 大家坐成一排, 从左往右编号 $1, . . . , n$ . 每个人头上有一个数, 这些数形成一个序列 $a$ , 每个人可以看到别人的数, 但是看不到自己的. 大家都知道两个长 $n-1$ , 下标从 $2$ 开始的序列 $b, c$ , 定义一个序列 $a$ 是</strong>轴心**的, 当且仅当对于每个 $i$ 都有 $a</em>{i+1}\in[a_i+b</em>{i+1}, a_i+c_{i+1}]$ , 而真实的序列 $a$ 必然不是轴心的. 接下来游戏进行若干轮, 每轮大家充分思考, 然后同时分别决定是报出一个必然不在自己头上的数, 还是什么都不做. 假设每个人都绝顶聪明, 不希望报错, 并且希望在尽可能少的轮数报出一个数. 给出 $a, b, c$ , 请你求出第一次有人发言是在第几轮, 可以证明必然有人发言. $n\leq 10^5, \vert a_i\vert, \vert b_i\vert, \vert c_i\vert\leq 10^{11}, b_i\leq c_i$ .<br>对于 $100 %$ 的数据, $n\leq 10^5, \vert a_i\vert, \vert b_i\vert, \vert c_i\vert\leq 10^{11}, b_i\leq c_i$ .</p></blockquote><p>结论是答案是所有轴心序列中到真实序列的最小距离. 距离指位置不同的个数.</p><p>考虑一个简化问题, 每一个人有一个0&#x2F;1, 看不见自己拿的, 那么第一次有人确定自己头上是1的轮数是1的个数. 这个很简单, 和那个蓝眼红眼小岛是一个.</p><p>归纳. 我们假设如果第k轮第一次有人声明, 那么最小距离恰好是k.</p><p>考虑如果最小距离是 $k$ , 那么根据归纳假设前 $k−1$ 轮没有人声明, 此时每个人都知道最小距离至少是 $k$ . 由于每个人都只不知道自己, 每个人看到的部分的最小距离要么至少是 $k$ 要么是 $k−1$ , 那么看到 $k−1$ 的人就知道实际上最小距离应该是 $k$ , 于是他会声明. 如果没有人看到 $k−1$ , 则没有人声明.</p><p>结论完了之后要考虑怎么求这个最小距离. 设 $f_{i}$ 表示前 $i$ 个, 第 $i$ 个和 $a$ 相同, 那么直接转移有序列维, $sumb$ , $sumc$ 三维限制. 此时已经可以做了.</p><p>因为 $b_i&lt;c_i$ , 所以 $sumc-sumb$ 是单调的, 这样可以把下标一维扔掉. 复杂度1log.</p><h2 id="讲课-1"><a href="#讲课-1" class="headerlink" title="讲课"></a>讲课</h2><h3 id="CF1301F"><a href="#CF1301F" class="headerlink" title="CF1301F"></a>CF1301F</h3><blockquote><p>$n\times m$ 的棋盘, 每个点有一个颜色, 颜色一共有 $k$ 种, 你每一步可以走到四连通的点, 或者传送到和当前点颜色相同的任意一个点, 多次查询两个点之间的最短路. $n, m\leq 1000, k\leq 40, q\leq 10^5$ .</p></blockquote><p>$qk^2$ 比较简单, 考虑直接把每个相同颜色做成一个点, 在这个40个点上跑floyd, 那么现在问题是对于一个询问确定从哪两个颜色传送, 于是复杂度是 $nmk+qk^2$ 这样的</p><p>然后实际上我们在一个颜色上传送只会是第一次遇到它, 于是从每一个颜色作为起点跑多源bfs, 状态仍然是 $nm$ 的.</p><p>或者看成给每一个颜色建一个中转点的套路, 从每一个中转点出发跑一遍bfs.</p><h3 id="poi-2003-2004-Bramki"><a href="#poi-2003-2004-Bramki" class="headerlink" title="poi 2003~2004 Bramki"></a>poi 2003~2004 Bramki</h3><blockquote><p>有向图, 每个点点权可能是 $0, 1, \frac{1}{2}$ , 点从 $0$ 开始标号, $0, 1$ 没有出边, 权值总分别是 $0, 1$ . 一个点的点权合法, 当且仅当它的点权是它连向的点的点权中, 去掉 $\frac{1}{2}$ 后的中位数(如果 $0, 1$ 数量相同, 则点权应是 $\frac{1}{2}$ ). 求对于所有合法的点权分配, 每个点的点权是不是唯一的, 如果是的话, 唯一的点权是哪一种. $n, m\leq 10^5$ .</p></blockquote><p>考虑求每个点的最大值最小值</p><p>直接全赋值为0&#x2F;1, 然后找到一个不合法的去调整, 每次找不合法的点调整, 然后再把受影响的点都放到队列里去调整, 因为调整点权的方向是固定的(大到小, 小到大), 复杂度线性.</p><h3 id="xix-open-cup-gp-of-siberia-B-Birthday"><a href="#xix-open-cup-gp-of-siberia-B-Birthday" class="headerlink" title="xix open cup, gp of siberia B. Birthday"></a>xix open cup, gp of siberia B. Birthday</h3><blockquote><p>无向图, 把点集划分成 $k$ 部分然后拼成一个序列, 要求只有相邻两部分或者一部分内部有边. $n\leq 1000, m\leq \frac{n(n-1)}{2}$ .</p></blockquote><p>把一个点放到一边, 把所有和他相连的放到下一层, 把所有和这一层相连且不在上一层的放在下一层. 我们希望bfs树深度尽量大, 所以第一层只有一个点, 这个过程用bitset优化. (深度大了可以直接后面的全塞进一层).</p><h3 id="ptzsc16-D6-C-Counter-manifestation"><a href="#ptzsc16-D6-C-Counter-manifestation" class="headerlink" title="ptzsc16 D6 C. Counter-manifestation"></a>ptzsc16 D6 C. Counter-manifestation</h3><blockquote><p>求有向图所有环的交.<br>$n\le 10^5, m\le 2\times 10^5$</p></blockquote><p>交是一个环或链. 先随便找一个环.</p><p>把环上的点编号 $1\ldots n$ , 若环上点 $i&lt;j$ 在环外有 $i\to j$ , 则环内 $i\to j$ 会不成立. 反过来也一样.</p><p>对于固定的点 $i$ , 第一种只有最大的 $j$ 有用, 第二种只有最小的 $j$ 有用, 然后都记搜去看最大的和最小的.</p><p>复杂度是线性, 虽然qyc现在不知道为何.</p><h3 id="ptzsc16-D9-C-Edge-Coloring"><a href="#ptzsc16-D9-C-Edge-Coloring" class="headerlink" title="ptzsc16 D9 C. Edge Coloring"></a>ptzsc16 D9 C. Edge Coloring</h3><blockquote><p>无向图, 每条边有一个目标颜色, 一开始每条边都没有颜色. 你从任意一个点出发, 在奇数步把边染红, 偶数步染蓝, 如果已经走过则覆盖之前的颜色, 求能否达到目标. $n, m\leq 2000$ .</p></blockquote><p>时间倒流. 此时走到一个边之后它的颜色就不会变了, 这样我们可以在我们已经走过的地方随便走. 然后枚举起点(实际上是终点)dfs就行了.</p><h3 id="hdu多校16-D7-Colosseo"><a href="#hdu多校16-D7-Colosseo" class="headerlink" title="hdu多校16 D7 Colosseo"></a>hdu多校16 D7 Colosseo</h3><blockquote><p>竞赛图, 给一个把点集划分成两部分 $A, B$ 的方案, 保证两部分的导出子图都是无环的. 现在希望把 $B$ 中的点加入 $A$ , 使得 $A$ 仍然是无环的, 求最多加入多少个点. $n\leq 1000$ .</p></blockquote><p>无环相当于一个全序(任意两点可比且满足传递性, 反自反性)</p><p>于是可以把 $A$ , $B$ 分别排序, 此时因为 $B$ 插进去也可比, 所以 $B$ 只能插入到一个固定间隔. 于是一个方案合法当且仅当插进去的 $B$ 的位置正确且有序, 可以dp.</p><p>相当于我们通过全序确定了一个dp的扫描线顺序.</p><h3 id="ptzsc16-D6-B-Colourings"><a href="#ptzsc16-D6-B-Colourings" class="headerlink" title="ptzsc16 D6 B. Colourings"></a>ptzsc16 D6 B. Colourings</h3><blockquote><p>无向图, 给定两个独立集划分 $A, B$ , $A$ 中所有独立集是非平凡的(大小 $&gt;1$ ), 而 $B$ 中的独立集个数设为 $k$ . 找到一个独立集划分, 使得其中所有独立集是非平凡的, 并且独立集个数不超过 $k$ . $n, m\leq 2\times 10^5$ .</p></blockquote><p>把每个点画在平面上, 坐标分别是它在两个独立集划分中属于的独立集的编号. 按任意方向扫描, 如果一行只有一个点就让它和同一列的点组成独立集, 否则让他和同一行的组成.</p><p>因为一列一定不只有一个, 且恰好有 $k$ 行.</p><p>如果这一行只有一个点, 那么这一列一起给他没有问题. 并且我们走一行就能分配一个独立集, 正好 $k$ 个. 所以是可行的.</p><h3 id="xix-open-cup-gp-of-Zhejiang-H-Hamilton-Path"><a href="#xix-open-cup-gp-of-Zhejiang-H-Hamilton-Path" class="headerlink" title="xix open cup gp of Zhejiang H. Hamilton Path"></a>xix open cup gp of Zhejiang H. Hamilton Path</h3><blockquote><p>有向图, 求所有哈密顿链, 设链上点的序列是 $p$ , 满足对于任意 $i&lt; j$ , 存在边 $p_i\rightarrow p_j$ 当<b>且仅当</b> $i+1&#x3D;j$ . . 这样的链可能很多, 你只需要对每一条输出它的某种字符串哈希的值. $n\leq 5\times 10^5, m\leq 10^6$ .</p></blockquote><p>首先限制是哈密顿路中没有向后连的边(后是没有走过的方向)</p><p>然后考虑如果一个点往后走方案不是唯一的(有两条边走向没有走过的)那就不满足条件, 所以已经可以 $nm$ 模拟.</p><p>考虑每一个点开始维护一条链, 那么如果在一个点向后扩展的时候到了另一条链的起点就可以直接接上, 但如果走着走着到了这条链中间的一个点呢?</p><p>此时最后的终点只能是两条链连向这个公共点的点中的一个, 因为其他点走过来都会面临两边的选择.</p><p>最后因为扩展出的每一条链都是答案上的一段, 所以你得到的是唯一的答案或者得到一个环. 如果是个环就复制一份算哈希(并且环外每一条边会让一个区间不合法).</p><h3 id="xix-open-cup-gp-of-Udmurtia-D-Road-Connectivity"><a href="#xix-open-cup-gp-of-Udmurtia-D-Road-Connectivity" class="headerlink" title="xix open cup gp of Udmurtia D. Road Connectivity"></a>xix open cup gp of Udmurtia D. Road Connectivity</h3><blockquote><p>无向图, 有一个初始状态, 每天等概率随机一条边, 把它的存在情况反转, 每次给定 $l, r$ , 求在第 $l$ 天到第 $r$ 天中至少一天整个图连通的概率. $n\leq 5, l, r\leq 10^{15}$ .</p></blockquote><p>暴力是用 $2^{n(n-1)&#x2F;2}$ 种状态矩阵快速幂dp.</p><p>图的标号没有意义! 标号是完全无用的. 所以本质不同的图只有34种. 预处理系数再转移矩阵快速幂.</p><h3 id="xix-open-cup-gp-of-Gomel-F-Six-Words"><a href="#xix-open-cup-gp-of-Gomel-F-Six-Words" class="headerlink" title="xix open cup gp of Gomel F. Six Words"></a>xix open cup gp of Gomel F. Six Words</h3><blockquote><p>无向图, 点有点权, 边有边权. 定义一个图的线图是, 每条边建一个点, 点权是这条边的边权; 如果两条边有公共端点, 则在它们对应的点之间连一条边, 边权是这个点的点权. 求一张图的线图的线图的最小生成树. $n\leq 10^5, m\leq 2\times 10^5$ .</p></blockquote><p>线图是点边互换那个东西, 此时原图一个点变成一个团, 一个边变成一个点, 但此时再考虑线图的线图时发现一个团该变成什么这个问题可以让你混乱.</p><p>考虑反过来看: 线图上一个点代表一个边, 一个边代表一个有公共定点的边对. 于是线图上线图上一个点代表一个有公共顶点点边对, 一个边代表线图上有公共顶点的边对, 是原图上两个有公共边的, 有公共点的边对, 是原图上边的连通三元组. 若三条边有公共点我们叫它一类边, 否则二类边. 且线图线图上的点权是边对公共点的权值, 边权是原图上公共边的权值.</p><p>发现优先连一类边把每个点连成连通块必然不劣. 考虑边集的并的MST(这里MST指MST的边集)等于这些边集分别MST的并的MST. 发现一个二类边不能把一类边从环上顶下去, 所以原图每个点对应的一类边的集合一定可以先自己形成MST.</p><p>然后就是容易的了, 对于原图上同一个点的一类边的集合, 按照其边对两条边的排名为坐标变成平面上一个三角形, 看看我们会怎么连, 显然会连出若干行, 再连一条左下到右上的对角线(这里左下角是(1, 1)).</p><p>这里, 一类边不会被顶掉是因为考虑这个三角形的图, 连接两个边对的链上边权最大值, 是这两个(边对所在行列编号(也就是rk)的min)的max, 发现向外面连的边的边长是(边对所在行列编号(也就是rk)的min), 其中较大的一个就也取max, 所以它只能和链上边权最大值相等, 所以一类最大值不会被顶掉.</p><p>于是此时原图每个点对应线图上一个连通块, 每个边对应一个二类边, 直接Kru即可.</p><p>[trick] 边集的并的MST等于这些边集分别MST的并的MST.</p><h3 id="poi-1999-2000-Skiers-加强版"><a href="#poi-1999-2000-Skiers-加强版" class="headerlink" title="poi 1999~2000 Skiers 加强版"></a>poi 1999~2000 Skiers 加强版</h3><blockquote><p>有向平面图, 有恰好一个源和一个汇, 把它平面嵌入, 满足每条边都从上面连向下面, 然后按照从左往右的顺序给你所有边. 求从源到汇最多能选出多少边不交的路径. $n, m\leq 10^6$ .</p></blockquote><p>贪心走最左边的即可.</p><p>注意这个不交路径是最大流!</p><h3 id="ptzwc22-D3-G-Maximal-Subsequence"><a href="#ptzwc22-D3-G-Maximal-Subsequence" class="headerlink" title="ptzwc22 D3 G. Maximal Subsequence"></a>ptzwc22 D3 G. Maximal Subsequence</h3><blockquote><p>上个题的trick. 序列, 求最少删掉多少数才能使得lis长度减少. $n\leq 10^5$ .</p></blockquote><p>首先这个题好像SDOI还是哪有个经典的网络流: 仿照lis的dp, $f_i$ 设一个点, 若可以转移就连边容量 $inf$ . 每个点拆入点, 出点, 容量为1, 表示删掉. 源点连所有 $f&#x3D;1$ . 然后最小割最大流.</p><p>想象一下这个图, 贪心选字典序最小的一个LIS, 复杂度 $O(n)$ .</p><h3 id="CF1019C-Sergey’s-problem"><a href="#CF1019C-Sergey’s-problem" class="headerlink" title="CF1019C Sergey’s problem"></a>CF1019C Sergey’s problem</h3><blockquote><p>有向图, 求一个独立集, 满足任何一个点可以被集合中的某个点走不超过两步到达(可以走 $0$ 步). $n, m\leq 10^6$ .</p></blockquote><p>在无向图只需要扫一遍, 过程中如果这个点没有被覆盖就选上. 这样所有点都可以被走不超过一步到达.</p><p>但在有向图上, 有可能过程中没有被选上的某些点却连向我们已经选的. 但却不被我们已经选的覆盖.</p><p>但是考虑, 如果有两个点 $u\to v$ , 我们显然不用选 $u$ , 那么我们可能又选了一个 $w\to u$ , 那么我们应该直接把 $u$ 删了就行了.</p><p>因为只有可能后面影响前面, 所以倒着再把被后面覆盖过的点删掉.</p><h3 id="sdoi2019-R2D2A-热闹的聚会与尴尬的聚会"><a href="#sdoi2019-R2D2A-热闹的聚会与尴尬的聚会" class="headerlink" title="sdoi2019 R2D2A 热闹的聚会与尴尬的聚会"></a>sdoi2019 R2D2A 热闹的聚会与尴尬的聚会</h3><blockquote><p>无向图, 你要选 $p, q$ , 构造一个每个点度数至少是 $p$ 的点集, 一个大小是 $q$ 的独立集, 要求 $(p+1)(q+1)&gt;n$ . $n, m\leq 10^6$ .</p></blockquote><p>不停删掉度数最小的点, 可以得到一个最大的, 度数至少是某个数的点集.</p><p>考虑独立集, 直接退火是可行的, 或者按照删掉的顺序贪心选独立集, 每个点最多和后面 $p$ 个点有边, 于是独立集大小至少是 $\dfrac{n}{p+1}$ . 就行了.</p><h3 id="poi2003-2004-Turniej"><a href="#poi2003-2004-Turniej" class="headerlink" title="poi2003~2004 Turniej"></a>poi2003~2004 Turniej</h3><blockquote><p>有一些波特要比赛, 其中某些波特之间的胜负是确定的, 而剩下的都是不确定的. 胜负可能成环. 比赛过程是, 每次选择任意两个还没被淘汰的波特比赛, 输掉的淘汰, 最后一个波特获胜. 求哪些波特有可能获胜. $n, m\leq 10^5$ .</p></blockquote><p>对于一个能赢的 $u$ , 那么若 $v&gt;u$ , 则 $v$ 也能赢.</p><p>然后因为 $u$ 不能干掉 $v$ 一定意味着 $v$ 可以干掉 $u$ 及其走到的所有点, 所以出度(在已知部分)最大的波特必然可能赢.</p><p>然后要找到其他能赢的. 如果不是所有能赢的都到某个有变, 那么这个也能赢, 于是用类似bfs的方法做即可.</p><h3 id="poi2003-2004-Kaglony"><a href="#poi2003-2004-Kaglony" class="headerlink" title="poi2003~2004 Kaglony"></a>poi2003~2004 Kaglony</h3><blockquote><p>定义一张图是好的, 当且仅当它是单点, 或者是两张好图放在一起得到的, 或者是两张好图放在一起, 中间连成完全二分图得到的. 给一张图, 判定它是不是好图. $n, m\leq 10^5$ .</p></blockquote><p>首先一个好图的补图还是好图, 考虑一个好图的补图可以由合成这个补图的过程中的两个操作取反(连完全二分图&lt;-&gt;不连)得到. 所以一个好图的补图也是好图.</p><p>那么考虑对于一个好图, 如果它最后一次由直接放在一起得到, 可以直接把连通块分开. 如果加边的情况, 那么就在补图上把连通块分开.</p><p>算补图的连通块方法是, 维护所有连通块列表, 每次加入一个点枚举这个列表中的连通块进行合并.</p><p>因为每一轮边数减少至少 $n$ 并且 $n$ 轮一定结束所以复杂度是一轮的 $m$ 乘上轮数 $\min n, \dfrac{m}{n}$ , 于是就是 $m\sqrt m$ .</p><h3 id="poi2004-2005-Dziuple"><a href="#poi2004-2005-Dziuple" class="headerlink" title="poi2004~2005 Dziuple"></a>poi2004~2005 Dziuple</h3><blockquote><p>无向图, 平面上有两条从x轴出发平行于y轴的射线, 上面分别有无穷个点, 你要把图上每个点放到射线上一个点, 边变成两点间的线段, 要求没有两条边相交, 求方案数. $n, m\leq 10^6$ .</p></blockquote><p>能嵌入的一定是若干毛毛虫, 然后组合数搞一搞就行了</p><h3 id="ptzsc16-D9-B-Point-Pairs"><a href="#ptzsc16-D9-B-Point-Pairs" class="headerlink" title="ptzsc16 D9 B. Point Pairs"></a>ptzsc16 D9 B. Point Pairs</h3><blockquote><p>平面上有 $2n+1$ 个点, 如果两个点横坐标或者纵坐标相同则连一条边, 求删掉每个点后是否存在完美匹配. $n\leq 10^5$ .</p></blockquote><h3 id="ioi2022-千岛"><a href="#ioi2022-千岛" class="headerlink" title="ioi2022 千岛"></a>ioi2022 千岛</h3><blockquote><p>有向图, 你走过一条边之后, 边的方向会反转. 求一个从 $1$ 出发回到 $1$ , 并且最后图和开始相同的方案. $n\leq 10^5, m\leq 2\times 10^5$ .</p></blockquote><p>首先用手摸出一个只要有两个环就可以了. 然后考虑不断删掉所有没有出度的点, 此时你从1开始向外走, 一定可以走到一个环.</p><p>如果这个环上所有点出度都为1, 显然就寄了. 考虑若有一个不为1, 你会出去走一圈, 走到一个新的环或者直接走进原来那个环, 画图表面两种情况都可以.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性规划</title>
      <link href="/2022/09/21/simplex/"/>
      <url>/2022/09/21/simplex/</url>
      
        <content type="html"><![CDATA[<h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><h2 id="单纯形"><a href="#单纯形" class="headerlink" title="单纯形"></a>单纯形</h2><h3 id="标准型与松弛型"><a href="#标准型与松弛型" class="headerlink" title="标准型与松弛型"></a>标准型与松弛型</h3><p>标准型是</p><p>$$<br>\sum_i a_{i, j}x_j\le b_i\<br>\max \sum_i c_ix_i<br>$$ </p><p>松弛型是</p><p>$$<br>\sum_i a_{i, j}x_j&#x3D;b_i\<br>\max \sum_i c_ix_i<br>$$ </p><p>标准型转化为松弛型, 只要在所有限制左侧一个松弛变量即可. $\sum_i a_{i, j}x_j + x\le b_i$ .</p><p>一般写的单纯型求解的应该是标准型转化成的松弛型, (当然, 也有可能因为UOJ上模板题是输入标准型)</p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>每一条不等式限制限制的是多维空间的一个”半空间”(类比二维空间的半平面), 若干个这个的交应该是一个凸多维几何体.</p><p>而因为目标函数是线性的, 所以必然有一个顶点可以取到最优解. (可以理解一下, 线性函数等值线全部平行, 也就是朝着一个固定的方向函数值最大, 可以沿着等值线平移到一个顶点上). 因为是凸的所以只要贪心的走就能走到最后的最优解.</p><p>单纯形说的是, 选择一组线性无关的变量, 为基变量, 其他变量都可以由基变量表示.</p><p>单纯形实现中, 我们让基变量形式上都是松弛变量(对于每一个基变量, 其只在一个限制中系数为1的出现, 其他限制中系数都为0), 于是任意时刻每个基变量对应一个限制.</p><p>把这样就可以把它们都设成0, 此时基变量的取值也是确定的–它们对应的限制中的常数, 因为其他变量都成0了. 此时对应了凸函数的一个顶点. 于是不断切换基变量就可以到不同的顶点.</p><p>因为最后目标函数最大, 所以我们希望最后所有非基变量在目标函数中的系数都是负的, 这样就可以都设成0了.</p><p>于是算法过程是我们通过不断切换基变量在多维几何体的顶点上游走.</p><h3 id="如何切换基变量-Pivot"><a href="#如何切换基变量-Pivot" class="headerlink" title="如何切换基变量-Pivot"></a>如何切换基变量-Pivot</h3><p>我们每次选择一个非基变量替换已有的一个基变量.</p><p>考虑选择什么非基变量最优, 也就是让哪个变大最优(非基变量取值都是0), 我们要求 $\max$ , 所以贪心选择目标函数中系数最大的.</p><p>然后要替换掉一个基变量, 考虑非基变量最终取值由至少一个限制限制住, 那么就让这个限制的基变量出来换成它(因为最后它的取值就是这个限制的常数)</p><p>那么因为形式上基变量系数只在对应限制上是1其他为0, 于是先给限制整个除一下系数变成1, 然后再用这一限制消去其他所有对应限制中的这个基变量即可.</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>要先找到一个可行解, 再进行.</p><p>考虑如果所有变量都是0不是一个可行解, 那么一定因为至少一个 $b_i&lt;0$ .</p><p>对于一个 $b_i&lt;0$ , 只要在对应限制里找到一个系数为负的变量pivot变成基变量就能让 $b_i&gt;0$ . 如果没有系数为负的, 那么一定无解.</p><h4 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h4><p>每次按照上面写的寻找非基变量和对应限制循环pivot即可. 终止条件是目标函数系数全不正(非基变量当系数不正, 基变量系数按照定义全0)</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>发现, 基变量的取值是对应限制的常数.</p><p>非基变量取值是0.</p><p>答案是目标函数的常数.</p><h3 id="实现-UOJ板子"><a href="#实现-UOJ板子" class="headerlink" title="实现(UOJ板子)"></a>实现(UOJ板子)</h3><blockquote><p>输入一个标准形, 求最大值和变量取值.</p></blockquote><p>看了uoj上的实现, 前 $k$ 快是一个模子的, 然而很费解. 比如读入进来的明明是标准形式却给所有系数取负等.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//uoj卡精度部分</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> float __float128</span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> eps = <span class="number">1e-16</span>, inf = <span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sgn</span><span class="params">(<span class="type">float</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; -eps ? <span class="number">-1</span> : (x &gt; eps ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50</span>;   <span class="comment">//N是n+m</span></span><br><span class="line"><span class="type">float</span> a[N][N];      <span class="comment">//系数矩阵,a[i][j]表示变量id[j]在第i个限制中的系数. a[0][i]表示目标函数, a[0][0]是目标函数常数,a[i][0]是第i个限制的b_i常数</span></span><br><span class="line"><span class="type">int</span> id[N];          <span class="comment">//id[1...n]是系数矩阵第i列对应的变量编号,id[n+1...m]是第i个限制的基变量编号</span></span><br><span class="line"><span class="type">int</span> n, m;           <span class="comment">//变量个数(不包含转化过去的松弛变量)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码理解困难可能主要在于a[...][i]表示的变量是在变的.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把变量id[idx]设为行l当基变量,(用行l消掉其他行对应id[idx]的系数)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pivot</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(id[n + l], id[idx]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> c = a[l][idx];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        a[l][i] /= c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a[...][idx]列要从变量id[idx]的系数变成对应限制l基变量的系数,所以后面还特判j=idx这一列.</span></span><br><span class="line">    <span class="comment">//注意id[n+l]这个基变量本来都系数是00000100000这样的</span></span><br><span class="line">    a[l][idx] = <span class="number">1</span> / c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == l  \vert  \vert  !<span class="built_in">sgn</span>(a[i][idx]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">float</span> x = a[i][idx];</span><br><span class="line">        a[i][idx] = -a[l][idx] * x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (j != idx)</span><br><span class="line">                a[i][j] -= a[l][j] * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找可行解</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++)</span><br><span class="line">        id[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> line = <span class="number">1</span>, var = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找常数最小的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[i][<span class="number">0</span>] &lt; a[line][<span class="number">0</span>])</span><br><span class="line">                line = i;</span><br><span class="line">        <span class="comment">//已经可行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sgn</span>(a[line][<span class="number">0</span>]) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//id[var]&lt;id[i]是和循环i的顺序对应的,不能变,否则会死循环</span></span><br><span class="line">            <span class="comment">//记住是找的是最大的id[var]</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sgn</span>(a[line][i]) &lt; <span class="number">0</span> &amp;&amp; (var == <span class="number">0</span>  \vert  \<span class="built_in">vert</span>  (id[var] &lt; id[i]))) &#123;</span><br><span class="line">                var = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!var)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(line, var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">simplex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> var = <span class="number">1</span>, line = <span class="number">0</span>, temp;</span><br><span class="line">        <span class="type">float</span> lim = inf;</span><br><span class="line">        <span class="comment">//找目标函数中系数最大的非基变量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (a[<span class="number">0</span>][i] &gt; a[<span class="number">0</span>][var]) &#123;</span><br><span class="line">                var = i;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sgn</span>(a[<span class="number">0</span>][var]) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//找变量id[var]最紧的限制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="comment">//这里id[i]&gt;id[line]同样是找最大的,避免死循环,且这个和上面那个保持一致(要么都最大正循环,要么都找最小反着循环)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sgn</span>(a[i][var]) &gt; <span class="number">0</span> &amp;&amp; (temp = <span class="built_in">sgn</span>(a[i][<span class="number">0</span>] / a[i][var] - lim), (temp &lt; <span class="number">0</span>  \vert  \vert  temp == <span class="number">0</span> &amp;&amp; (!line \vert  \vert id[i] &gt; id[line])))) &#123;</span><br><span class="line">                line = i;</span><br><span class="line">                lim=a[i][<span class="number">0</span>]/a[i][var];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!line)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">pivot</span>(line, var);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> in;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cin &gt;&gt; in, a[<span class="number">0</span>][i] = in;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            cin &gt;&gt; in, a[i][j] = in;</span><br><span class="line">        cin &gt;&gt; in, a[i][<span class="number">0</span>] = in;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">init</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Infeasible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">simplex</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Unbounded&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; (<span class="type">long</span> <span class="type">double</span>)-a[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl; <span class="comment">//答案是-a[0][0],因为我们是把a[0][0]放在等式右边了(消元的时候用的...=b_i的b_i消的a[0][0]).</span></span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ans[id[i + n]] = a[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">10</span>) &lt;&lt; (<span class="type">long</span> <span class="type">double</span>)ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h3><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="志愿者招募"><a href="#志愿者招募" class="headerlink" title="志愿者招募"></a>志愿者招募</h3><p>线性规划裸题, 变量是每一类志愿者的个数. 限制是每一天的志愿者都到达所需.</p><p>因为限制的常数(每一天的志愿者需求量)都非负, 可以跳过寻找可行解的初始化过程.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 单纯形 </tag>
            
            <tag> 线性规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I Can&#39;t Be Greedy</title>
      <link href="/2022/09/12/greedy/"/>
      <url>/2022/09/12/greedy/</url>
      
        <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>发现自己贪心跟没学一样, 完全不会.</p><h2 id="贪心-做题笔记"><a href="#贪心-做题笔记" class="headerlink" title="贪心 做题笔记"></a>贪心 做题笔记</h2><p>题库里筛选greedy, 2600, 通过人数降序.</p><h3 id="1400E-Clear-the-Multiset"><a href="#1400E-Clear-the-Multiset" class="headerlink" title="1400E Clear the Multiset"></a>1400E Clear the Multiset</h3><blockquote><p>给定 $1\ldots n$ 每个数的个数 $a$ , 每次给一个区间个数减1或对一个数减去任意, 求清空次数. $n\le 5000, a_i\le 10^9$ </p></blockquote><p>“能大力dp的谁贪心啊” –qyc</p><p>好像给人感觉很经典.</p><p>很能dp, $f_{i, j}$ 表示前 $i$ 个数, 有 $j$ 个区间操作延伸到 $i$ 清空的最小代价. 复杂度 $n^2$ .</p><p>好吧, 贪心就是, 每次大力给全局减掉全局最小值, 然后全局裂开成若干区间, 再递归下去做, 如果这么算出来的答案大于区间长度直接变成区间长度(全用单点)</p><h3 id="1537E2-Erase-and-Extend-Hard-Version"><a href="#1537E2-Erase-and-Extend-Hard-Version" class="headerlink" title="1537E2. Erase and Extend (Hard Version)"></a>1537E2. Erase and Extend (Hard Version)</h3><blockquote><p>给定一个字符串, 可以任意多次删掉末尾字符或者把当前字符串复制一份接在后面, 求能得到的字典序最小的, 长度恰好为 $k$ 的字符串.<br>$n, k\le 5\times 10^5$ </p></blockquote><p>切不动2200了? !</p><p>结论是最优解一定先用删再用复制. 考虑我们一定是先删后复制不劣于先复制后删, 也就是一个前缀反复复制, 做完了.</p><h3 id="1333F-Kate-and-imperfection"><a href="#1333F-Kate-and-imperfection" class="headerlink" title="1333F. Kate and imperfection"></a>1333F. Kate and imperfection</h3><blockquote><p>对所有 $k\in [1\ldots n]$ 求出 ${1\ldots n}$ 的大小为 $k$ 的子集中最小的值, 一个子集的值为这个子集的任选两个不同的数 $a, b$ 的 $\gcd$ 的最大值.<br>$n\le 5\times 10^5$ </p></blockquote><p>$1\ldots n$ 选出互质的 $k$ 个数的做法是什么? 选所有质数.</p><p>那现在允许 $\gcd \le c$ 怎么办? 猜测一定是在之前的基础上加. $c&#x3D;2$ , 发现可以再插入4, $c&#x3D;3$ 则可以插入6, 9, $c&#x3D;4$ 可以插入8, $c&#x3D;5$ 可以插入10, 15, 25, $c&#x3D;6$ 可以插入</p><p>发现一个数会在 $c$ 为自己除以自己最小质因子的时候被插入. 于是结束了.</p><p>证明是, 考虑当前集合中若有 $a\bmod b&#x3D;0, a&gt;b$ , 我们一定删 $a$ 而不是 $b$ . 由此得到一个数在集合的时候自己的所有因数一定在集合里. 于是就是这个结论了.</p><h3 id="1474D-Cleaning"><a href="#1474D-Cleaning" class="headerlink" title="1474D Cleaning"></a>1474D Cleaning</h3><blockquote><p>你有一个长度为 $n$ 的数组 $a$ .<br>现在要进行一些操作将数组的所有元素清除:</p><p>选定两个下标连续的数, 若两个数均不为 $0$ , 则将两个数均减 $1$ .<br>在此之前, 你可以使用一次超能力(可以不使用): 任选两个下标连续的数并交换.</p><p>编写程序, 判断是否可以清空 $a$ 数组.<br>多组询问<br>$T\le 10^4$ , $\sum n\le 2\times 10^5$ </p></blockquote><p>如果不交换是简单的, 从第一个开始考虑容易的出限制是 $a_i\ge c_i&#x3D; \sum a_k\times {(-1)}^{i-k+1}$ , 当 $i&#x3D;n$ 时需要是相等.</p><p>考虑交换两个数 $a_i, a_j, i&lt;j$ 后, 实际上是对所有 $n&gt;j$ 交换了这两个数的符号, 对 $i$ 来说 $c_i$ 符号取反加上 $a_j$ , $a_j$ 减去 $a_i$ 再取反.</p><p>所以我们统计出 $c_i$ , 然后考虑再每个位置交换即可. 如果我来拍上去一棵线段树就是区间加, 单点改, 区间最小值.</p><p>哦你发现不对劲, 后面不是区间加, 因为是给一些位置加上他俩的差, 另一些位置减去.</p><p>如果我不拍线段树, 是不是就是统计一下后缀min之类的结束了啊.</p><p>所以为什么是贪心标签呢?</p><h3 id="CF1092D-Great-Vova-Wall"><a href="#CF1092D-Great-Vova-Wall" class="headerlink" title="CF1092D Great Vova Wall"></a>CF1092D Great Vova Wall</h3><p>合并了</p><h4 id="Version-1"><a href="#Version-1" class="headerlink" title="(Version 1)"></a>(Version 1)</h4><blockquote><p>给定序列 $a$ , 你可以给相邻相等的两个数加1或给任意位置加2, 求是否可以若干次操作后让所有位置相同.<br>$n\le 2\times 10^5, a_i\le 10^9$ </p></blockquote><p>看着很想JOI的俄罗斯方块题? 但这个不能悬空.</p><p>$f_{i, 0&#x2F;1, 0&#x2F;1}$ 表示前 $i-1$ 个为膜 $2$ 余 $0&#x2F;1$ , 其中最后一个膜 $2$ 余 $0&#x2F;1$ 是否可以. 转移是是否在最后一个位置放一个.</p><p>这个做法成功给做Version2给出负效果. . .</p><p>我们已经发现是膜2意义下的, 那么就成了给定01串, 可以翻转相邻两个, 问最后能否弄成一样的.</p><p>这种套路其实是括号序, 我们可以翻转任意偶数长度的段, 那么从左往右扫去匹配高度相等的即可.</p><h3 id="Version-2"><a href="#Version-2" class="headerlink" title="(Version 2)"></a>(Version 2)</h3><blockquote><p>版本1的基础上没有给任意位置加2操作.</p></blockquote><p>向上次一样设状态现在会爆炸了.</p><p>好吧别dp了, 还是看看可爱的贪心吧.</p><p>模仿刚才的栈的做法的话其实只是相当于出栈时这一次的要不低于上一次的. . . 并且要特判 $n$ 为奇数的情况最后一个是否能行.</p><p>哦, 另一个更无脑的做法是从下往上扫描线, 每次碰到一个连续段如果长度为奇数就寄, 否则就加一继续扫. 用set维护连续段是 $n\log n$ .</p><h3 id="CF1428E-Carrots-for-Rabbits"><a href="#CF1428E-Carrots-for-Rabbits" class="headerlink" title="CF1428E Carrots for Rabbits"></a>CF1428E Carrots for Rabbits</h3><blockquote><p>给 $n$ 个胡萝卜, 再 $n-k$ 次选出一个胡萝卜切一刀成俩, 最小化最后所有胡萝卜平方和.</p></blockquote><p>猜测最后所有胡萝卜大小一定是相邻的两个数, 不对. 因为可能让你切不到相邻的两个数.</p><p>但同一段萝卜肯定是切到相邻的两个数吧? 所以我们现在问题是不知道给那些萝卜切几段.</p><p>你随便写写式子, 给一个长 $n$ 萝卜切 $k$ 段连续情况代价是 $\dfrac{n^2}{k}$ 是凸且单减的, 然后发现离散也对, 所以开个堆每次取最大的给他多切一刀再塞回去即可.</p><h3 id="CF1406D-Three-Sequences"><a href="#CF1406D-Three-Sequences" class="headerlink" title="CF1406D Three Sequences"></a>CF1406D Three Sequences</h3><blockquote><p>给一个长 $n$ 序列 $a$ , 区间加, 每次操作后询问, 把 $a$ 拆成 $a_i&#x3D;b_i+c_i$ , 且 $b$ 不增, $c$ 不降, 求最小的 $\max(b_i, c_i)$ .</p></blockquote><p>考虑直接差分, 就是给定序列 $a$ , 构造 $b$ 和 $c$ 使得 $a_i&#x3D;c_i-b_{i+1}$ 且 $b_{i+1}&gt;0, c_i&gt;0$ , 最小化 $\max(\sum b_{i+1}, \sum c_i)$ </p><p>你发现如果 $a_i&gt;0$ , 那么一定让 $c_i&#x3D;a_i$ , 否则 $b_i&#x3D;-a_i$ , 否则会同时增加 $b_i$ 和 $c_i$ .</p><p>转化回来其实就是若 $a_{i+1}&lt;a_i$ , 则 $b_{i+1}&#x3D;b_i+(a_{i+1}-a_i)$ , 否则 $c_{i+1}&#x3D;c_i+(a_{i+1}-a_i)$ </p><p>那么问题就是 $b_1$ 和 $c_1$ 了, 由于加起来是一定的所以直接越近越好. 做完了.</p><h3 id="CF1599J-Bob’s-Beautiful-Array"><a href="#CF1599J-Bob’s-Beautiful-Array" class="headerlink" title="CF1599J Bob’s Beautiful Array"></a>CF1599J Bob’s Beautiful Array</h3><blockquote><p>你有一个长度为 $n$ 的数组 $a$ , 你需要构造一个长度为 $n$ 的数组 $b$ , 使得 $a$ 中每一个元素都能由 $b$ 中两个位置不同的元素相加得到.<br>$n\le 10^5, a_i\le 10^9$ </p></blockquote><p>好神奇</p><p>特判 $n&#x3D;2, n&#x3D;3$ </p><p>如果有一个偶数一定可以: 考虑我们只要构造出 $3$ 个数可以得到 $a$ 中3个数, 剩下的就可以随便弄了, 这是个三元一次方程, 发现我们选的 $a$ 中三个数只要满足都是偶数或一个偶数两个奇数都是有整数解的, 所以就成功了.</p><p>于是考虑全是奇数的情况: 我们考虑如果最终答案 $b_1\ldots b_n$ , 若 $b_i+b_j$ 是 $a$ 中的数就连一条边, 显然它至少得有 $n$ 条边, 那么就有一个环, 环的大小必须是偶数(因为 $a$ 中数都是奇数), 并且这个环的<strong>边</strong>黑白染色后和相等. 所以猜测有解条件是 $A$ 中能选出两个集合 $S, T$ 和相等. 然后再正着去构造证明: 如果有这样两个集合, 我们把它交错的插开推推式子发现一定没问题, 于是剩下的随便弄即可了.</p><p>所以现在要判断是否有两个这样的东西了, 众所周知subset sum指数, 要点在于当 $n\ge 28$ 时, $\binom {28}{14}&gt;14\times 10^6$ , 根据鸽子原理一定有解. 所以只取28个, 折半爆搜即可.</p><p>太脑洞了构造题.</p><h3 id="CF175E-Power-Defence"><a href="#CF175E-Power-Defence" class="headerlink" title="CF175E Power Defence"></a>CF175E Power Defence</h3><blockquote><p>一个塔防游戏: 给定一个无限长的数轴, 一个无限血的敌人要从正无穷走到负无穷. 你的任务是放置三种塔, 包含两种攻击塔和一种寒冰塔, 使得敌人受到的伤害最大.</p><p>其中, 每种塔的攻击半径可能不同, 每种攻击塔的攻击力也可能不同. 而寒冰塔没有攻击力, 它的作用是使范围内敌人的速度减速, 即一段区间若有 $k$ 个寒冰塔覆盖, 敌人速度变为 $\frac{1}{k+1}$ . 同一个位置只能放两个塔.</p><p>敌人初始速度为1格每秒, 攻击塔的伤害值也是以秒计算的.</p><p>三种塔数量总和不超过20.</p></blockquote><p>首先体会一下如果没有一个位置只能放俩的性质, 最好的方案是全部堆到一个点上. 由这个大概可以想到, 最终局面是堆在一起的一排, 长度最大为 $\lceil\dfrac{n}{2}\rceil+1$ (就是中间摆满, 然后两边各伸出一个位置).</p><p>然后发现安排位置好困难, 根本不会, 看题解, 啥? 塔只有20个? &#x2F;qd</p><p>直接枚举冰塔的方案(每个位置放0&#x2F;1&#x2F;2个), 方案是 $3^{\dfrac{n}{2}}$ </p><p>现在有一些空位, 可以求出每个位置放每种塔的伤害.</p><p>此时还不能直接从高往低放. . . 暴力dp它, $f_{i, j, k}$ 表示前 $i$ 个, 放了 $j$ 个第一种攻击塔, $k$ 个第二种攻击塔的伤害, 复杂度是 $3^11\times 20^3$ 有点大.</p><p>我们的问题在于 $j+k\ne i$ 是吧, 想想怎么能让他放满一点, 如果给每个位置按照放第一种攻击塔的收益排序, 前面一段是放满的, 后面一段是不算前面放的情况下的前 $k$ 大.</p><p>那么这样dp, 省掉一维, 然后再枚举前面最长的一段放了多少即可. 用set从后往前扫一遍即可.</p><p>看一眼另一篇题解, 猜完连续的结论后直接模拟退火</p><h3 id="CF935F-Fafa-and-Array"><a href="#CF935F-Fafa-and-Array" class="headerlink" title="CF935F Fafa and Array"></a>CF935F Fafa and Array</h3><blockquote><p>给定一个长 $n$ 序列 $f(A)&#x3D;\sum_{i&#x3D;1}^{n-1} \vert a_{i+1}-a_{i} \vert$ .<br>区间加, 或者给定一个区间和 $x$ , 询问给定区间中给一个数加上 $x$ 后 $f(a)$ 最大是多少. 询问独立.<br>$n, q\le 10^5, a_i\le 10^9$ </p></blockquote><p>数据结构题混到greedy.</p><p>差分. 数组叫 $c$ </p><p>按贡献算, 若 $c_i&gt;0, c_{i+1}&lt;0$ , 贡献显然为 $2x$<br>若 $c_i, c_{i+1}$ 同号, $y$ 为 $\max(-c_i, c_{i+1})$ , 贡献为 $\max(0, x-y)$<br>若 $c_i&lt;0, c_{i+1}&gt;0$ , 贡献是写着很麻烦, 但也是分段一次函数.</p><p>于是你准备离线后按 $x$ 排序, 拍上去一个 $KTT$ .</p><p>然后你冷静一下想一想, 斜率只有 $-2, -1, 0, 1, 2$ 5种. 开线段树分别维护区间最大截距即可. 支持单点修改和区间查询.</p><p>一个不这么<del>野蛮</del>DS的方法是, 考虑其实第一种贡献直接出, 第二种贡献只要求最小的 $y$ , 第三种贡献才不会做. 那么<strong>一个区间内最多有一个第三种情况, 否则必然有一个第一种情况况</strong>. 于是单独维护所有这样下凹的位置即可.</p><h3 id="CF30D-King’s-Problem"><a href="#CF30D-King’s-Problem" class="headerlink" title="CF30D King’s Problem?"></a>CF30D King’s Problem?</h3><blockquote><p>给定 $x$ 轴上 $n$ 个点和轴外一个点, 求从点 $k$ 出发把他们全部走一遍(可以重复走)的最短路径长度. $n\le 10^5$ </p></blockquote><p>考虑如果从轴外那个点出发要么从最左走到最右要么从最右走到最左.</p><p>于是只要考虑在轴内的情况下了. 此时我们的问题是什么时候走那个外面的点不知道. 于是直接枚举什么时候过去的然后 $O(1)$ 算一些距离即可.</p><h3 id="CF758E-Broken-Tree"><a href="#CF758E-Broken-Tree" class="headerlink" title="CF758E Broken Tree"></a>CF758E Broken Tree</h3><blockquote><p>给定一棵有根树树, 每个边有一个重量和一个硬度, 如果一棵树的一条边下面的儿子中的边的重量和大于它的硬度树就寄了, 你可以把一条边的硬度和重量减去一个相同的值, 但必须保证重量为正整数硬度为整数, 求让树不会寄的最大的重量.<br>$n\le 2\times 10^5$ </p></blockquote><p>性质是一棵子树的重量是一个区间, 考虑我们求出最重的那种然后从深度大的开始减是没问题的. 主要在于重量最小的一定是从下往上把所有能减的都减掉得到的重量.</p><p>考虑dp出所有子树的区间, 最小的很显然, 最大的大概是考虑在所有子树都最小的基础上还能增加多少重量.</p><p>这样求的是最后的最大值. 输出方案很烦人, dp时记一下最大&#x2F;最小的时候这条边减去多少以及当前状态比所有子树都最小的基础上增加了多少. 因为一个点的儿子最后的情况一定是若干最小的若干最大的和一个不满的, 这个用来算那个不满的.</p><p>考虑一条边的限制实际上是限制自己的子树重量不超过什么, 那么从深度大的开始调整一定不劣, 每次会让若干点满足限制, todo</p><h3 id="CF1651E-Sum-of-Matchings"><a href="#CF1651E-Sum-of-Matchings" class="headerlink" title="CF1651E Sum of Matchings"></a>CF1651E Sum of Matchings</h3><blockquote><p>给定一个每个点度数都是2的二分图, 左右两侧点分别标号 $[1, n]$ , $[n+1, 2n]$ , 求对于所有 $1\le l\le r\le n&lt;n+1\le L\le R\le 2n$ , $l, r, L, R$ 四元组, 求 $[l, r], [L, R]$ 中的点的导出子图的匹配之和.<br>$n\le 10^5$ </p></blockquote><p>突破点在度数是2上. 所以每个点都恰好在一个环中, 即环互不相交. 每个环互不影响. 此时一个环贡献的匹配数是环长除以2.</p><p>而现在两边各截取出一段, 可能有一些环变成了若干个链, 但发现链也是互不相交的. 分别考虑发现每条链的贡献是长度除以2下取整.</p><p>于是这样一个导出子图都答案是 $(点数-奇数长度链的个数)&#x2F;2$ .</p><p>那么因为 $n$ 很小, 可以直接遍历图的每一个环的每一个区间, $O(1)$ 计算它会被多少区间包含即可.</p><h3 id="CF1661F-Teleporters"><a href="#CF1661F-Teleporters" class="headerlink" title="CF1661F Teleporters"></a>CF1661F Teleporters</h3><blockquote><p>给定数轴上 $n$ 个点和 $m$ , 要再建立若干点, 使得存在一条路径 $a_1\ldots a_n$ 的 $\sum {(a_i-a_{i-1})}^2\le m$ . 求最少再建几个点.<br>$n\le 2\times 10^5, a_i\le 10^9$ </p></blockquote><p>显然可以每一段单独考虑, 在这一段里再建 $k$ 个显然让它平均分布, 因为这个平方让你想着是不是凸的然后发现是的所以一个堆每次把收益最大的拿出来加一就好了. 你以为做完了. 发现可能答案会很大就寄了.</p><p>考虑二分每一段收益减到多少我们就不干了, 就是说我们给一段不断加点知道它再加的收益小于我们二分的常数 $x$ 就不加了, 这样就可以直接根据 $x$ 在每一段再二分加了多少次, 得到一段的解, 然后就做完了. 最后需要处理一些边界条件.</p><h3 id="CF37E-Trial-for-Chief"><a href="#CF37E-Trial-for-Chief" class="headerlink" title="CF37E Trial for Chief"></a>CF37E Trial for Chief</h3><blockquote><p>给一个 $n\times m$ 黑白两色的网格图, 要全染白, 每次把一个连续颜色块反色, 求最少次数. $n, m\le 50$ </p></blockquote><p>idea是不是借鉴于拿着油漆桶在画图上一直点的那种感觉.</p><p>考虑如果你摁着一个点一直点, 这样一层一层下去, 到最后一层就完成了.</p><p>这个东西等价于把相邻两个点同色连边权为0, 不同连1, 然后以这个点跑最短路. 得到的最远的黑点.</p><p>但有没有可能我们不摁着一个点涂色呢? 考虑交换所有操作的顺序使得每个涂色都是在涂色点和第一次点的点连通后再做, 就和一直按着一个做一样了. 一定是可以这么调整的原因在于做这个的时候必然不连通, 会相互影响的讨论一下一定是一样的. 所以我们一定可以摁着一个点涂色.</p><p>于是直接对每个点跑一遍dij或01bfs就结束了.</p><h3 id="CF1599A-Weights"><a href="#CF1599A-Weights" class="headerlink" title="CF1599A Weights"></a>CF1599A Weights</h3><blockquote><p>给定序列 $a_{1\ldots n}$ 和由 $\texttt{LR}$ 组成的长 $n$ 字符串 $S$ , 两个集合 $L, R$ 初始为空, 要求给一个方案使得我们第 $i$ 次选择一个数添加进去后集合 $S_i$ 更大.<br>$n\le 2\times 10^5, a_i\le 10^9$ </p></blockquote><p>我们首先考虑一个比较显然的事情, 如果 $a$ 从小到大排序后轮流往两个集合里放, 那么显然每次都是刚放完的那个集合更大.</p><p>于是考虑在这个基础上, 如果我们删掉最大的一个一定会切换, 而删掉最小的那个不会切换, 且始终保持交错的性质, 于是直接倒着做, 不断删最大或最小的即可.</p><p>[think] 保持性质构造方案; 倒序</p><h3 id="CF1257G-Divisor-Set"><a href="#CF1257G-Divisor-Set" class="headerlink" title="CF1257G Divisor Set"></a>CF1257G Divisor Set</h3><blockquote><p>给定一个 $n$ 个元素多重集, 求最大的子集族使得族内任意两子集没有包含关系. $n\le 2\times 10^5$ </p></blockquote><p>孤陋寡闻, 学到了Sperner定理.</p><p>在不是多重集的情况下, 就是Sperner定理, 内容就是对于 $n$ 个元素集合从中选出最大的彼此无包含关系的子集族中子集的数量为 $\binom{n}{\lfloor \dfrac{n}{2} \rfloor}$ . 构造解只需选出所有大小为 $\lfloor \dfrac{n}{2} \rfloor$ 的子集.</p><p>那么在是多重集的情况下显然会出问题. 考虑其中两个集合 $S\subseteq T$ , 那么因为 $\vert S \vert &#x3D; \vert T \vert$ 所以 $S&#x3D;T$ , 也就是说除了两集合相同的情况否则不会出现包含.</p><p>结论是去掉所有重复的之后就是正确答案, 还是要锻炼猜结论的能力啊.</p><p>如果不知道Sperner定理, 应该通过大小相同的不同集合不会互相包含得出选大小相同的构造, 然后去猜大小为 $\dfrac{n}{2}$ 的最多吧, 这一步可以打个表.</p><p>然后要统计所有大小为 $n$ 且本质不同的子集数, 单选多重集中一个元素的式子是 $1+x^2+x^3\ldots$ , 然后把它们都卷起来就好了. 复杂度 $n\log^2 n$ </p><h3 id="贪心只能过样例"><a href="#贪心只能过样例" class="headerlink" title="贪心只能过样例"></a>贪心只能过样例</h3><blockquote><p>qyc搬的题<br>有两只队伍滚榜, 已知他们封榜前的过题数和罚时, 也知道封榜之后的过的 $n$ 个题和对应罚时, 要求一个滚榜顺序使得第一名变化次数最多.<br>$n\le 10^5, v\le 10^9$ , $v$ 表示除了 $n$ 的其他所有数字.</p></blockquote><p>贪心, 结论是把两只队伍的罚时一个从小到大一个从大到小排序, 然后模拟</p><p>怎么回事呢? 可以考虑这个结论在一开始没有过题和罚时的情况下一次一换的.</p><h3 id="数学上来先打表"><a href="#数学上来先打表" class="headerlink" title="数学上来先打表"></a>数学上来先打表</h3><blockquote><p>有 $n$ 个数列 $a$ , 求数列 $b$ , 使得 $\sum a_ib_i-\max a_ib_i$ 最大. 多测, $n\le 20$ , $\sum n\le 10000$ </p></blockquote><p>看一眼样例, 第一个样例是直接给最大和次大的 $a_i$ 分配 $b_i$ 使得他们 $a_ib_i$ 相等, 后面的没算出来.</p><p>于是直接猜这个, 过了前两个第三个寄了.</p><p>又想一想这个东西是线性规划, 不会写单纯形, 于是一个假单纯形上去TLE30.</p><p>原来是贪心, 如果我们分配的时候最大值 $a_ib_i$ 只有一个, 把它调小一定更好. 于是一定有若干个相同的最大值 $a_ib_i$ .</p><p>然后你发现, 在不止一个最大的 $a_ib_i$ 的情况下, 如果一个 $a_ib_i&lt;a_jb_j$ , 那么把 $b$ 分配到更大的 $a_i$ 一定可以让它更好.</p><p>所以我们最后的样子是有若干个相同的数. 且对应的 $a$ 一定是前若干大.</p><p>那么只要枚举选前几大再解个小方程即可.</p><h3 id="CF1592F-Alice-and-Recoloring"><a href="#CF1592F-Alice-and-Recoloring" class="headerlink" title="CF1592F Alice and Recoloring"></a>CF1592F Alice and Recoloring</h3><p>合并了</p><blockquote><p>给定一个 $n\times m$ 01网格, 你可以进行4个操作, 将其变全0:</p><ol><li>翻转一个包含 $(1, 1)$ 的矩形</li><li>翻转一个包含 $(n, 1)$ 的矩形</li><li>翻转一个包含 $(1, m)$ 的矩形</li><li>翻转一个包含 $(n, m)$ 的矩形<br>求最小代价.<br>$n, m\le 500$ .</li></ol></blockquote><h4 id="F1"><a href="#F1" class="headerlink" title="F1"></a>F1</h4><blockquote><p>四个操作代价分别为 $1, 2, 4, 3$ .</p></blockquote><p>可以证明2, 3操作绝对不会用, 因为可以被替代为两次1操作.</p><p>对于4操作是4次1操作, 所以有可能用到4, 但3次1操作的效果是4的效果再翻转全局, 所以可以认为4操作只会用一次, 如果用两次就可以都替换成3次1操作.</p><p>因为矩形操作比较复杂, 考虑差分. 若原网格为 $a$ , 设 $s_{i, j}&#x3D;a_{i, j} \mathrm{xor} a_{i+1, j}\mathrm{xor}a_{i, j+1}\mathrm{xor}a_{i+1, j+1}$ , 目标状态显然仍是全0, 这样可以使得1操作变成单点修改.</p><p>而对于4操作, 变成4次单点修改, 那么只要枚举4操作操作在哪, 剩下全用1操作即可. 复杂度 $nm$ </p><h4 id="F2"><a href="#F2" class="headerlink" title="F2"></a>F2</h4><blockquote><p>四个操作代价分别为 $1, 3, 4, 2$ .</p></blockquote><p>2, 3操作仍然是来充数的.</p><p>但现在4操作可能被用多次了, 需要再分析:</p><p><strong>1. 设4操作翻转 $x, y, n, m$ , $P(x, y)$ , 则不会对同一行或同一列的 $P$ 都用4操作.</strong></p><p>因为这样4个单点修改中有两个被翻转两次抵消了, 所以实际上只修改了两个, 可以用1操作代替.</p><p><strong>2. 仅当4操作的单点修改中除了点 $(n, m)$ 外3个都是1时会操作</strong></p><p>如果有2个, 翻完还要再搭一次操作1, 那么反而比直接1更糟糕.</p><p>在此基础上我们希望4操作尽可能多, 那么我们算整张网络最多进行多少次, 发现是一个二分图匹配: 每一行列建点, 对于满足要求2的4操作 $P$ 由行向列连边跑网络流即可.</p><p>剩下的每一个用一个1操作即可. 复杂度 $n^2\sqrt n$ </p><h3 id="CF1158D-Winding-polygonal-line"><a href="#CF1158D-Winding-polygonal-line" class="headerlink" title="CF1158D Winding polygonal line"></a>CF1158D Winding polygonal line</h3><blockquote><p>给定平面上 $n$ 个点和 $\texttt{LR}$ 构成的长 $n-2$ 的字符串, 求一条不自交路径经过每一个点一次, 且第 $i+1$ 个点是在 $i-1$ 到 $i$ 的基础上忘 $s_i$ (左或右)的方向拐的.<br>$n\le 2000$ </p></blockquote><p>好厉害构造题.</p><p>任选一个凸包上的点, 如果下一次是 $\texttt{L}$ 那就选当前向右转最后碰到的点, 否则是向左转最后碰到的点, 就对了.</p><p>原因是, 考虑一开始在凸包上, 那么若下一次是在左边, 我们向右转到的点无论到哪个剩下的点都是往左转的且不会自交, 因为当前点到下一个点的连线一定在剩下所有点的一侧.</p><h3 id="CF1380G-Circular-Dungeon"><a href="#CF1380G-Circular-Dungeon" class="headerlink" title="CF1380G Circular Dungeon"></a>CF1380G Circular Dungeon</h3><p>简单题</p><blockquote><p>在游戏中, 有 $n$ 个排列在环上的房间, 第 $i$ 个房间只能到达第 $i+1$ 个房间(特别地, 第 $n$ 个房间只能到达第 $1$ 个房间).</p><p>同时有 $n$ 个宝箱, 第 $i$ 个宝箱的价值是 $c_i$ , 其中恰好有 $k$ 个宝箱是假宝箱, 其余均为真宝箱, 每个房间有且仅放置一个宝箱.</p><p>玩家等概率地从 $n$ 个房间中选取一个房间开始移动, 如果当前房间有真宝箱, 他将获得此宝箱的价值, 否则立刻结束游戏. 最后获得的总收益等于之前收集的宝箱的总价值.</p><p>对于每一个 $k\in[1, n]$ , 你可以决定宝箱的排列顺序和宝箱的真假, 使玩家收益的期望值最小, 请求出最小的期望值 $\pmod {998244353}$ .<br>$n\le 3\times 10^5$ </p></blockquote><p>首先把最大的 $k$ 个变成假的, 显然.</p><p>然后假的把真的分成若干段, 对于每一段显然是递减的.</p><p>然后再考虑一下会发现平均分配好过不平均分配.</p><p>然后再考虑一下发现不仅每一段递减, 实际上递减顺序是, 每一段第一个&gt;每一段第二个. . . , 于是直接顺着放即可.</p><h3 id="CF725E-Too-Much-Money"><a href="#CF725E-Too-Much-Money" class="headerlink" title="CF725E Too Much Money"></a>CF725E Too Much Money</h3><blockquote><p>给定常数 $c$ 和 $n$ 个整数, 每个数只能用一次, 求加到 $c$ 的一个方案. 求法是每次选择不超过 $c$ 的最大的加进去, 那么现在让你再添加任意多个数hack它, 或者判断hack不掉, 最小化添加的数的和.<br>$n, c\le 2\times 10^5$ </p></blockquote><p>首先, 实际上只会添加一个数</p><p>考虑如果添加两个数 $a, b$ , 那么直接添加 $a+b$ 是不劣的.</p><p>然后可以暴力判断每一个, 判断方法是暴力查出能加的下一个, 复杂度上对的就直接考虑和为 $c$ 的数有 $\sqrt c$ 种.</p><h3 id="CF1500C-Matrix-Sorting"><a href="#CF1500C-Matrix-Sorting" class="headerlink" title="CF1500C Matrix Sorting"></a>CF1500C Matrix Sorting</h3><blockquote><p>给定两个 $n\times m$ 的矩阵 $A$ , $B$ , 每次可以选则一列作为关键字把所有行稳定排序, 问是否能通过至多5000次操作把 $A$ 变成 $B$ .<br>$n, m\le 1500$ </p></blockquote><p>排序过程实际是指定了第一关键字第二关键字. . . 这样的.</p><p>添加值为 $A$ 矩阵编号的一行可以让初始矩阵转化成一次排序操作.</p><p>显然如果末状态相邻两行关系是对的则整个数组是对的, 考虑一次操作对末状态的相邻两行的大小关系的影响, 可能是变成对的, 变成错的, 或者没有影响(对应位置相等). 从后往前考虑操作序列, 如果一个位置之后出现过变成对的, 那前面啥都可以, 否则不能出现变成错的.</p><p>于是考虑一个拓扑排序过程, 每个操作建点, 每个相邻两行建点, 若操作可以把两行变成对的就操作连向点, 变成错的点连向操作, 那么一个操作可以选就当且仅当所有入边都被消了, 就是对的了.</p><p>复杂度 $nm$</p><h3 id="CF1700F-Puzzle"><a href="#CF1700F-Puzzle" class="headerlink" title="CF1700F Puzzle"></a>CF1700F Puzzle</h3><blockquote><p>给定两个 $2\times n$ 01矩阵 $a$ , $b$ , 每次交换 $a$ 中相邻两个数, 问让 $a$ 变到 $b$ 的最少步数.<br>$n\le 2\times 10^5$ </p></blockquote><p>先考虑只有一行的情况, 发现我们可以对每一个相邻对的交换次数分别计算, 设 $sa_i$ 为 $a$ 前缀和, $sb$ 同理, 则 $i, i+1$ 两个数会交换 $\vert sa_i-sb_i\vert$ 次.</p><p>那么现在有了第二行前缀和加上一维0&#x2F;1表示行, 考虑如果对于一个位置, $s_{a, 0}&gt;s_{b, 0}, s_{a, 1}&lt;s_{b, 1}$ , 那么显然我们应该换到下面去一个1来省一次, 往上换的同理, 就做完了.</p><p>重点在于这样一种运行到后面我们再考虑一开始是不是换一下这种思想?</p><h3 id="CF1685C-Bring-Balance"><a href="#CF1685C-Bring-Balance" class="headerlink" title="CF1685C Bring Balance"></a>CF1685C Bring Balance</h3><blockquote><p>给定一个括号序列, 每次可以翻转一个区间, 求最少的操作次数使得括号串合法. 保证左右括号数量相等.<br>$n\le 2\times 10^5$ </p></blockquote><p>考虑画出折线图, 那么<strong>一次翻转是把一个区间的折线中心对称</strong>. 要让折线对称后全在x轴上方, 则设最高点值为 $a_p$ , 左右端点为 $a_l, a_r$ , 翻转后显然要求 $a_p\le a_l+a_r$ </p><p>于是用经典套路是只会进行一两次, 发现如果整个序列有一个非常非常高的你可能一次干不掉, 但以这个为端点左右两次一定都没问题所以最多只会进行两次.</p><p>此时怎么构造也显然了.</p><h3 id="CF1373G-Pawns"><a href="#CF1373G-Pawns" class="headerlink" title="CF1373G Pawns"></a>CF1373G Pawns</h3><blockquote><p>$n\times n$ 的棋盘, 第 $k$ 行是特殊行, $(i, j)$ 位置可以走到 $(i-1, j+1), (i, j+1), (i+1, j+1)$ 棋子不能重叠, 要所有棋子都移动到第 $k$ 行, 问最少要再右侧添加多少列.<br>多次询问, 每次切换棋盘上一个位置是否有棋子.<br>$n, q\le 10^5$ </p></blockquote><p>首先你想一想发现棋子 $(i, j)$ 走到第 $k$ 行位置就是 $(k, j+\vert i-k\vert)$ , 于是就成了一个数轴上的问题了.</p><p>不想动脑子, 于是直接 $f_i$ 表示还有几个棋子最后要停到 $i$ 右边去, $f_i&#x3D;f_{i-1}+a_i-1$ , 直接另 $a_i$ 减1, 变成一个模板ddp.</p><p>然后动动脑子, 发现自己是智障这其实是最大后缀和&#x2F;kx</p><h3 id="CF1348F-Phoenix-and-Memory"><a href="#CF1348F-Phoenix-and-Memory" class="headerlink" title="CF1348F Phoenix and Memory"></a>CF1348F Phoenix and Memory</h3><blockquote><p>问是否存在唯一一个 $1 \ldots n$ 的排列 $c$ , 满足 $a_i \leq c_i \leq b_i$<br>$n\le 2\times 10^5$ </p></blockquote><p>简单题?</p><p>考虑从最小的往大考虑, 显然你会选左端点最小的并且此时右端点最小的一定不劣, 然后再往上加一, 反正每次选能选的里面右端点最小的, 就是一个合法方案.</p><p>那么如何判断方案是否唯一呢?</p><p>如果有两个区间一致, 显然有第二小的, 于是考虑互不相同的.</p><p>那么如果方案不唯一, 至少有两个方案, 那么就是说我们过程中有一次, 不选右端点最小的也成, 比如选第二小的, 那么以后最优策略仍然是选最小的, 那么我们下一个数一定选刚才没选的那个, 接下来情况相同, 所以我们交换了两个数, 所以若方案不唯一, 我们最终一定可以交换值域上两个数得到第二个构造.</p><p>于是对于每一个元素, 考虑若交换的会怎样, 就是统计序列中有多少个满足另一个元素在当前这个区间并且当前这个区间包含另一个元素的, 这是个静态三维数点, 2log.</p><p>然后你想一想, 其实可能没必要这么多限制, 假设我们枚举的是大的那个数, 那么另一个数只要满足小于大的并且另一个数的限制右端点不小于当前数, 就只有两维了. 1log.</p><h3 id="CF1584F-Strange-LCS"><a href="#CF1584F-Strange-LCS" class="headerlink" title="CF1584F Strange LCS"></a>CF1584F Strange LCS</h3><blockquote><p>给定 $n$ 个英文字母(大写小写)字符串, 每个字符在每个字符串最多出现2次, 求最长公共子序列. $n\le 10$ .<br>多组询问, $t\le 5$ </p></blockquote><p>考虑每个字符最多出现一次的情况, 此时字符与位置一一对应, $f_i$ 表示字符 $i$ 结尾的答案, 则有 $f_i&#x3D;\max f_j+1$ , 在所有字符串中 $j$ 均出现在 $i$ 前.</p><p>现在每个字符可以出现两次, 当我们仍想这么干的时候不知道 $i$ 哪些在前面哪些在后面, 那就再加一维直接记每个 $i$ 是第一个或第二个. 转移仍是枚举所有出现位置都在字符 $i$ 前的. 这样复杂度是 $4^n\times 52^2$ 之类的.</p><p>你发现, 对于每一个 $s$ , 如果字符 $c$ 两次出现都在 $i$ 前面, 从第二次出现转移一定不劣, 这样我们就只用枚举上一个字符是谁了, 复杂度大概是 $2^n\times 52^2n$ 之类的.</p><h3 id="CF586C-New-Language"><a href="#CF586C-New-Language" class="headerlink" title="CF586C New Language"></a>CF586C New Language</h3><blockquote><p>字符集被分成集合 $V$ 和 $C$ , 给定 $m$ 个限制和一个给定的字符串, 求满足限制, 长度为 $n$ , 字典序大于给定字符串的最小字符串, 每个限制是如果第 $i$ 个位置属于 $A$ , 则第 $j$ 个位置属于 $B$ .<br>$\vert \sigma\vert  \le 26, n \le 200, m \le 4n(n-1)$ .</p></blockquote><p>还能比这个限制更2sat提示的吗, 认准为2sat. 要考虑如何解这东西了, 基本上就是贪心, 从前往后每一位选择可能都最小的. 此时在满足2sat的基础上仍然可能有一种情况是, 如果这个位置选了一个啥, 后面虽然有解但可能不满足字典序要求. 但200的话, 是不是暴力验证就好了啊.</p><h3 id="CF1539F-Strange-Array"><a href="#CF1539F-Strange-Array" class="headerlink" title="CF1539F Strange Array"></a>CF1539F Strange Array</h3><blockquote><p>给定长 $n$ 的数组 $a$ , 对每一个 $a_i$ , 可以选择一个包含它的区间并将区间排序, 设它排序后的位置是 $x$ , 与区间 $[l, r]$ 的中心 $\lceil \dfrac{l+r}{2}\rceil$ 为 $y$ , 则它的奇异值是最大的 $\vert x-y\vert$ .<br>对每个数求出它的奇异值.<br>$n\le 2\times 10^5$ </p></blockquote><p>比较简单?</p><p>先去掉绝对值分正负分别考虑, 现在考虑 $x-y&gt;0$ 的情况:</p><p>排完序后它是第几个取决于小于它的数的个数 $cnt$ , 所以奇异值可以看成 $l+cnt-\lceil \dfrac{l+r}{2}\rceil&#x3D;cnt-\lceil \dfrac{r-l}{2} \rceil$ . 我们要最大化 $cnt$ 减去区间长度.</p><p>于是考虑把小于当前数的设为1, 其他的都设为0, 由于再减去一半的区间长度所以每一个都再减去 $\dfrac{1}{2}$ , 那么变成了 $\dfrac{1}{2}, -\dfrac{1}{2}$ 的序列, 可以都乘2变成正负1的序列.</p><p>于是就是求包含当前节点的最长子段和, 线段树维护一下即可.</p><p>然后因为每个都要求一遍所以要排序后加 $a_i$ , 另外求最大值最小值的时候处理一下等于 $a_i$ 的设成1还是-1即可.</p><p>考虑对一个 $a_i$ , 区间往左一位会让值减 $\dfrac{1}{2}$ ,</p><h3 id="CF1091F-New-Year-and-the-Mallard-Expedition"><a href="#CF1091F-New-Year-and-the-Mallard-Expedition" class="headerlink" title="CF1091F New Year and the Mallard Expedition"></a>CF1091F New Year and the Mallard Expedition</h3><blockquote><p>你要走过 $n$ 块的地, 每一块可以是水, 岩浆, 或土地, 并且长 $l_i$ 个单位长度, 你可以在水上游泳或飞, 在岩浆上飞, 在土地上走或飞, 走一个单位长度用5s, 游泳3s, 飞用1s, 初始时你有0个体力, 走一个或游一个单位长度会加1, 飞一个会减1, 体力显然不能为负, 求走过这 $n$ 段路的最小时间.<br>$n\le 10^5$ </p></blockquote><p>首先在水上游在土地上走在岩浆上飞, 得到一个答案, 此时可能到了一个地方飞不过去要往回走, 我们看如果前面有过水就游着攒(总可以在第一个水攒够再走), 否则就走着攒.</p><p>然后会剩下不少能量, 先让这些能量代替走的, 再代替飞的即可. 但有情况使得有土地但你不能把能量加上去如 $GLWW$ , 若当前能量小于前面的土地长度, 则能加的土地应该是当前能量.</p><p>一些类似费用提前延后计算的技巧吧.</p><h3 id="CF1699E-Three-Days-Grace"><a href="#CF1699E-Three-Days-Grace" class="headerlink" title="CF1699E Three Days Grace"></a>CF1699E Three Days Grace</h3><blockquote><p>给定 $n$ 个元素的可重集 $A$ , 元素在 $[1, m]$ 间, 每次可以把 $x$ 删掉添加 $p, q$ 满足 $pq&#x3D;x$ . 求任意操作后集合的极差的最小值.<br>$n\le 10\times 10^6$<br>$\sum n\le 10^6, \sum m\le 5\times 10^6$ </p></blockquote><p>可以枚举掉一个端点, 比如我们现在求固定最小值的最大值最小.</p><p>那么我们要把所有大于最小值的都拆成不小于最小值的值.</p><p>设 $f_{i, j}$ 表示 $i$ 拆成不小于 $j$ 的最大因子大小, 发现 $f_{i, j}\ne f_{i, j+1}$ 一定说明最小的因子是 $j$ , 由此则 $f_i$ 是只在所有因数上变化, 总变化次数是调和级数的.</p><p>那么如何求得变化后变成啥了呢? 正着转移有点困难考虑从 $j$ 到 $j-1$ , 那么它可以选若干个 $j$ , 所以它的新值就是 $\min f_{i, j}, f_{i&#x2F;j, j}, f_{i&#x2F;j&#x2F;j, j}\ldots$ </p><p>就结束了.</p><h3 id="CF1469F-Power-Sockets"><a href="#CF1469F-Power-Sockets" class="headerlink" title="CF1469F Power Sockets"></a>CF1469F Power Sockets</h3><blockquote><p>给出 $n$ 个链分别长为 $l_1\ldots l_n$ , 和一个只有一个节点的树, 每次可以添加一条边把一个链接到树上并且这条边的两个顶点变黑, 可以进行任意次操作, 最小化操作完后第 $k$ 近的白点到根的距离. 不一定要把所有链都接上.<br>$n\le 2\times 10^5, l_i\le 2\times 10^5, k\le 10^9$ </p></blockquote><p>考虑每次挂链显然一定挑重心挂.</p><p>另外我们一定从长往短挂, 考虑如果先放了短的再放长的, 则最大深度是长链长度一半加一, 但先放短的就只是长链一半, 所以排完序之后依次加入.</p><p>那么如何维护往上挂的这个操作呢? 考虑我们并不关心树的结构, 那么直接开个线段树维护每个深度点的个数支持区间加单点加即可.</p><p>同时因为我们挂点一定是从深度小往深度大的挂, 所以可以用差分实现, 因为我们一定是按顺序的, 所以可以一边累加一边做.</p><h3 id="CF1430F-Realistic-Gameplay"><a href="#CF1430F-Realistic-Gameplay" class="headerlink" title="CF1430F Realistic Gameplay"></a>CF1430F Realistic Gameplay</h3><blockquote><p>有 $n$ 波怪物, 你有一把枪, 枪的弹夹量为 $k$ , 第 $i$ 波怪物数量为 $a_i$ , 在第 $l_i$ 到 $r_i$ 时间出现( $r_i&lt;&#x3D;l_{i+1}$ ), 你可以在任意时刻打出一发子弹击杀一只怪物且不耗费时间, 你必须在 $[l_i, r_i]$ 时间内消灭 $a_i$ 只怪物, 你每次换弹都需要将弹夹(包括里面的子弹)扔掉, 并花费 1 单位的时间, 在尽量保证通关的情况下, 需要的最少的子弹数为多少.<br>$n\le 2000, k\le 10^9$ </p></blockquote><p>看起来似乎很简单啊, 这个 $n\le 2000$ .</p><p>直接dp, $f_{i, j}$ 表示干完前 $i$ 段, 还有 $j$ 个子弹的最小子弹数, 好的 $k\le 10^9$ .</p><p>你体会一下发现 $j$ 可能的取值很少, 因为只根最后一次换弹时间有关, 你也可以直接 $f_{i, j}$ 表示走完前 $i$ 段, 最后一次 $j$ 换弹的最小子弹数之类的.</p><p>然后看一眼题解, 发现这题可以线性, 说的是, 考虑我们一定是再不换弹就死了都时候才换弹. $f_i$ 表示能走完后面的最小子弹数去转移, 最后扫一遍即可.</p><h3 id="CF1572C-Paint"><a href="#CF1572C-Paint" class="headerlink" title="CF1572C Paint"></a>CF1572C Paint</h3><blockquote><p>给定长度为 $n$ 的颜色序列 $a_i$ , 每次可以选择任意一个颜色全部相等的区间染成另一种颜色, 求全都染成一种的最小代价.<br>$\sum n\le 3000$ </p></blockquote><p>这个题和前面那个黑白格子二维染色的有点像, 但颜色多了, 没有一直在一个地方做的性质了.</p><p>注意到一个区间一定可以染色成其右端点的颜色.</p><p>于是区间dp它, $f_{i, j}$ 表示把 $[i, j]$ 染色成 $a_j$ 的最少次数, 那么考虑转移:</p><ul><li>$f_{i, j}&#x3D;\min f_{i+1, j}, f_{i, j-1} + 1$ , 显然的.</li><li>$f_{i, j}&#x3D;\min f_{i, k}+f_{k+1, j}, \ s. t. \ a_k&#x3D;a_j$</li></ul><h3 id="CF1601D-Difficult-Mountain"><a href="#CF1601D-Difficult-Mountain" class="headerlink" title="CF1601D Difficult Mountain"></a>CF1601D Difficult Mountain</h3><blockquote><p>$n$ 个人相约去爬山.<br>山的初始攀登难度为 $d$ .<br>每位登山者有两个属性: 技巧 $s$ 和整洁度 $a$ .</p><p>技巧为 $s$ 的登山者能登上攀登难度为 $p$ 的山当且仅当 $p\le s$ .<br>在一位整洁度为 $a$ 的登山者登上攀登难度为 $p$ 的山后, 山的攀登难度会变为 $\max(p, a)$ .</p><p>请给这些登山者指定一个爬山的先后顺序, 最大化登上山的人数.<br>如果轮到一位登山者时他能登上山, 则他一定会选择登山.<br>$n\le 5\times 10^5, d, s_i, a_i\le 10^9$ </p></blockquote><p>正确做法是直接贪心, 按照 $\max a_i, s_i$ 第一关键字, $s$ 为第二关键字排序就是答案.</p><p>证明它, 当前山高度为 $h$ :</p><ul><li>如果 $\max a_i, s_i&#x3D;s_i$ ,<ul><li>首先一定有 $h\le s_i$ , 因为前面所有人的 $a$ 都不大于 $s_i$ .</li><li>那么我们让这个人上山, 考虑后面一个不能上山的人 $j, s_j&lt; s_i$ <ul><li>如果我们强行让那个人上山, 这个人一定上不了, 并且之后山的高度一定大于当前状况(它排在后面且 $s_j&lt;s_i$ 只能是 $a_j&gt;\max s_i, a_i$ ), 所以一定不优</li></ul></li></ul></li><li>如果 $\max a_i, s_i&#x3D;a_i$ <ul><li>能上山就上山, 如果硬上就是上面那种情况.</li></ul></li></ul><p>思路似乎很不自然啊, 邻项交换?</p><p>考虑相邻两项 $(a_1, s_1), (a_2, s_2)$ </p><p>如果 $a_1&gt;a_2$ 且 $a_1&gt;s_2$ , 肯定让2先上.</p><p>如果 $a_1&gt;a_2$ , $a_1&lt;s_2$ , 也一定让2先上.</p><p>如果 $s_1&gt;a_2$ 且 $s_1&gt;s_2$ , 肯定让2先上.</p><p>. . .</p><p>然后就得到结论了&#x2F;kx</p><h3 id="CF1344D-Resume-Review"><a href="#CF1344D-Resume-Review" class="headerlink" title="CF1344D Résumé Review"></a>CF1344D Résumé Review</h3><p>好像是咱们上面那个 Teleporters 啊. 凸的-二分就做完了.</p><h3 id="CF1641D-Two-Arrays"><a href="#CF1641D-Two-Arrays" class="headerlink" title="CF1641D Two Arrays"></a>CF1641D Two Arrays</h3><blockquote><p>给定 $n$ 个长 $m$ 的序列 $a_i$ , 每个序列有权值 $w$ , 求最小的 $w_i+w_j$ 满足 $a_i, a_j$ 的交集为空.<br>$n\le 10^5, m\le 5$ </p></blockquote><p>这个有点神仙?</p><p>首先可以双指针: 把 $w$ 递增排序, 枚举 $i$ 要找到最小的 $j$ , 发现当 $i$ 右移的时候 $j$ 如果右移一定不如刚才那个, 所以 $j$ 是单调左移的.</p><p>那么现在都问题是我们啥时候应该左移, 那就是如果区间 $[1, j]$ 中有一个集合和当前 $a_i$ 无交. 这也是这个题最妙的地方, 计算</p><p>$$<br>\sum_{t\subseteq T} [t\subseteq S]\cdot (-1)^{ \vert t \vert }<br>$$</p><p>如果等于1则没有重复元素, 否则有. 还挺显然, 考虑 $\sum_i \binom{n}{i}(-1)^i&#x3D;[n&#x3D;0]$ </p><p>这个方法的关键之处在于我们可以判断一个集合与一堆集合是否都有交, 因为我们只要枚举这一个集合的子集, 判断出现次数即可.</p><p>另外一种办法是用bitset莽</p><h3 id="CF356D-Bags-and-Coins"><a href="#CF356D-Bags-and-Coins" class="headerlink" title="CF356D Bags and Coins"></a>CF356D Bags and Coins</h3><blockquote><p>给定长 $n$ 的数组 $a$ 和一个数 $s$ , 构造一个森林, 每个点 $i$ 有非负点权 $c_i$ , 要求点 $i$ 的子树中点权之和恰好为 $a_i$ , 并且所有点权的和为 $s$ .</p><p>输出答案时, 对于每个 $i$ , 先输出 $c_i$ , 再输出 $k_i$ 表示 $i$ 的儿子数量, 然后依次输出 $i$ 的儿子们. 无解输出-1.<br>$n, s\le 70000$ </p></blockquote><p>首先你一眼看出森林的每一棵树应该都是一条链, 就直接构造完了.</p><p>于是现在问题是哪些节点当根, 因为它们的 $a$ 和要等于 $s$ .</p><p>于是要找到若干个数和 $s$ , bitset背包即可.</p><h3 id="CF1292D-Chaotic-V"><a href="#CF1292D-Chaotic-V" class="headerlink" title="CF1292D Chaotic V."></a>CF1292D Chaotic V.</h3><blockquote><p>一棵树, $i$ 的父亲是 $i$ 最大的非自身的因数, 给定 $n$ 个 $k_i!$ , 求树上一点到这 $n$ 个点的距离和最小值.<br>$k_i\le 5000, n\le 10^6$ .</p></blockquote><p>其实只有5000个点做带权重心(重心经典结论), 重点是求出这些点的虚树. 于是要知道:</p><ul><li>dfs序排序<ul><li>我们dfs肯定用先进最小的点的办法. 那么考虑比较两个点的dfs序大小: 一个点从祖先到自己的路上质因子是递增的, 体会一下发现直接按 $k_i$ 排序即可.</li></ul></li><li>lca<ul><li>质因子是从大往小乘的, 所以找到两个点最大的共同质因子, 次数取min, 即它们的lca</li></ul></li></ul><p>于是求虚树就好了.</p><h3 id="CF1672H-Zigu-Zagu"><a href="#CF1672H-Zigu-Zagu" class="headerlink" title="CF1672H Zigu Zagu"></a>CF1672H Zigu Zagu</h3><blockquote><p>给定一个长 $n$ 01串, $q$ 次询问对于一个区间, 若你每次可以删除这个区间的一个01相间子区间(没有00或11), 那么最少要删多少次.<br>$n, q\le 2\times 10^5$ </p></blockquote><p>考虑区间内的00和11个数:</p><p>对于00101010101011这样的, 我们要么一次操作删掉一个11一个00(0010101011-&gt;01), 要么一次删掉一个11或00(00101010100-&gt;00)并且只要同时有00和11, 一定可以选择同时删掉0011(交界处)于是就统计区间00, 11个数, 取个max即可.</p><h3 id="CF578D-LCS-Again"><a href="#CF578D-LCS-Again" class="headerlink" title="CF578D LCS Again"></a>CF578D LCS Again</h3><blockquote><p>给定一个字符串 $S$ , 求有多少个与 $S$ 等长字符串 $T$ , 满足 $\mathrm{LCS}(S, T)&#x3D; \vert S \vert -1$ , 其中 $S, T$ 只包含前 $m$ 个小写字母.<br>$n\le 10^5, m\le 26$ </p></blockquote><p>首先明显转化为 $s$ 删掉一个再增加一个转化成的不同的串个数.</p><p>那么先考虑删掉字符后串相同的情况, 发现两个串相同当且仅当删掉的两个字符及它们中间的字符全部相同.</p><p>那么考虑此时再插入一个字符的方案, 基础情况是除了原位都能插入. 但对于一个相同段, 向其中插入等于这个相同段的东西, 所以贡献是 $m(n-1)-\text{相同元素个数}$ </p><p>但发现删掉 $s_i$ 和 $s_{i+1}$ 的时候有一种情况会重复, 会得到 $s_{[1\ldots i-1]}+s_{i+1}+s_{i}+s_{[i+2\ldots n]}$ 这样的. 于是再减1. 就结束了.</p><p>另一个做法是dpofdp, 直接记录求LCS的一行的状态显然是爆炸的. 考虑对于一个状态 $(i, j)$ , 其 $(i, j)\le \min i, j$ , 所以其能对 $(n, n)$ 有贡献需要 $\min i, j+\min n-i, n-j\ge n-1$ . 化简得到 $\vert i-j \vert \le 1$ , 于是现在 $i$ 行只有 $i, i-1, i+1$ 三个格子有意义.</p><p>那么我们设 $f_{i, j, k, l}$ 表示当前填写到第 $i$ 行, 其中lcsdp数组的 $(i, i-1), (i, i), (i, i+1)$ 分别是几的状态. 状态数 $n^4$ </p><p>再考虑, 因为 $(n, n)&#x3D;n-1$ , 所以对于状态 $(i, j)$ 有 $\min {i, j}\  -1\le (i, j)\le \min i, j$ . 否则后面 $\min n-i, n-j$ 没法把它加到 $n-1$ .</p><p>于是每一位只可能是 $i$ 或 $i-1$ , 用 $0&#x2F;1$ 记录. 时间 $nm$ </p><p>题目很好, 可为啥是贪心呢? </p><h3 id="CF1422E-Minlexes"><a href="#CF1422E-Minlexes" class="headerlink" title="CF1422E Minlexes"></a>CF1422E Minlexes</h3><blockquote><p>给定一个字符串, 每一个后缀, 求可以删去若干个相邻两相同字符的情况下这个后缀最小的字典序. <code>aabb</code>可以到空, 但<code>abba</code>不行, 就是可以一次选若干个不想交的相邻两个删.<br>$\vert S \vert \le 10^5$ </p></blockquote><p>$f_i$ 表示 $i$ 开头的后缀, $f_i&#x3D;\min {s_i+s_i+f_{i+1}}$ 记录开头前几个字符即可.</p><h3 id="CF1658F-Juju-and-Binary-String"><a href="#CF1658F-Juju-and-Binary-String" class="headerlink" title="CF1658F Juju and Binary String"></a>CF1658F Juju and Binary String</h3><blockquote><p>给定一个长 $n$ 01串, 要从中选取若干个不相交子串, 使得:</p><ul><li>所有子串长度加起来为 $m$ </li><li>所有子串拼起来后1的个数占总长的比与原字符串相等.<br>最小化你选的子串个数. 输出方案.</li></ul></blockquote><p>精妙的.</p><p>第一步, 设原串有 $a$ 个0, $b$ 个1, 则给一个1赋权 $a$ , 0赋权 $b$ , 要求就是选的子串权值和为0.</p><p>结论是, 把串头尾相接, 一定有一个长度为 $m$ 的子串权值为0. 考虑若所有 $m$ 的子串权值都大于0, 那么总权值不能等于0. 于是至少有一个长 $m$ 子串权值小于0. 于是这个负的区间不断移动到一个正的区间这个过程中一定会碰到一个恰好等于0的.</p><p>于是就做完了.</p><h3 id="CF578E-Walking"><a href="#CF578E-Walking" class="headerlink" title="CF578E Walking!"></a>CF578E Walking!</h3><blockquote><p>给定长度为 $n$ 的01串 $s$ , 构造一个排列使得 $s_{p_i}\ne s_{p_{i+1}}$ , 最小化排列的逆序对个数, 输出方案. $n\le 10^5$ </p></blockquote><p>相当于选择尽可能少的若干个01交替的子序列.</p><p>于是从左往右扫, 维护当前已有的所有子序列, 看新来的这个是否能添加到其中一个或要新开一个.</p><p>然后有可能添加完之后无法拼到一起, 比如两个分别是 $\texttt{LR}$ , $\texttt{RL}$ 这样的, 我们发现若一个字符串 $\texttt{L}$ 开头 $\texttt{R}$ 结尾叫 $LR$ , 那么最后若有一个 $LR$ , 一个 $RL$ , 那么一定可以把一个的头或尾放到另一个上变成 $LL$ 和 $RR$ , 就可以随便拼了.</p><h3 id="PNR2-Div1-B"><a href="#PNR2-Div1-B" class="headerlink" title="PNR2 Div1 B"></a>PNR2 Div1 B</h3><p>降智题</p><blockquote><p>给一个序列, 你有一个栈, 你要从 $1\ldots n$ 扫这个序列, 如果大于栈顶或栈为空就入栈, 否则可以选择什么都不做或者删掉<strong>一个</strong>把它加进去, 前提是加进去后栈从底到顶依然是单增的. 求处理完之后栈最多剩下多少数.<br>$n\le 5\times 10^5$ </p></blockquote><p>选择的时候一定能加进去就加进去. 因为加进去让栈顶变小并且不改变栈内数的个数.</p><h3 id="CF235E-Number-Challenge"><a href="#CF235E-Number-Challenge" class="headerlink" title="CF235E Number Challenge"></a>CF235E Number Challenge</h3><blockquote><p>给定 $a, b, c$ , 求 $\sum_{i&#x3D;1}^a \sum_{i&#x3D;1}^b \sum_{i&#x3D;1}^c d(ijk) \pmod {2^{30}}$<br>$a, b, c\le 2000$ </p></blockquote><p>这不莫反题吗咋混进来的.<br>就用<br>$$<br>d(ij)&#x3D;\sum_{a \vert i} \sum_{b \vert j} [gcd(a, b)&#x3D;1]<br>$$<br>拓展之后是<br>$$<br>d(ijk)&#x3D;\sum_{a \vert i} \sum_{b \vert j} \sum_{c \vert k} [gcd(a, b, c)&#x3D;1]<br>$$</p><p>然后做就行了.</p><h3 id="Tomik-poezji"><a href="#Tomik-poezji" class="headerlink" title="Tomik poezji"></a><a href="https://szkopul.edu.pl/problemset/problem/Hhip15j-8Ro2dOb_4oB98C-G/site/?key=statement">Tomik poezji</a></h3><blockquote><p>给定一个集合 $S$ 和整数 $s$, 其得分规则是不断从前往后, 若当前 $sum&#x3D;-1\pmod s$, 则把和清空并把得分加一, 最后一次不算, 求排列使得得分最小.<br>$n\le 5\times 10^5$</p></blockquote><p>考虑如果数不重, 那么若当前还剩下至少两个数, 你一定可以选一个让它不是 $s-1$, 所以得分一定是0.</p><p>当有重复的时候, 结论是每次选择当前出现次数最大的数, 如果不对就随便选另一个.</p><p>证明是考虑, 最后剩下的一定是出现次数最大的一个数, 那么设这个数为 $a$, 若其不于 $s$ 互质, 则 $ka$ 始终不等于 $s-1$, 不会出现不对的情况, 否则现在它与 $s$ 互质, 可以把序列中的所有数都乘 $a^{-1}$, 另 $t&#x3D;s\cdot a^{-1}$, 此时原来的 $a$ 变成了 $1$, 而其它的数可以认为全都在 $-(s-2)\ldots -1$ 之间, 那么假设从 $0$ 开始, 按照上面的流程一定是先走 $1$ 走到 $t-1$, 然后往回走一个, 不断重复, 最后等前面的都用完了就只能走 $1$ 跨过若干个 $kt$, 发现因为那些负数的总和一定, 所以最后这个 $kt$ 也是固定且最少的, 因此策略是最优的.</p><h3 id="AT-cf17-final-d-Zabuton"><a href="#AT-cf17-final-d-Zabuton" class="headerlink" title="AT_cf17_final_d Zabuton"></a>AT_cf17_final_d Zabuton</h3><blockquote><p>有 $N$ 个人, 他们按一定顺序排成一队, 依次向砖堆中加砖.<br>对于第 $i$ 个人, 如果此时砖堆中有 $\leq H_i$ 块砖, 他就会往砖堆中<strong>加入 $P_i$ 块砖</strong>, 否则他会<strong>什么也不做</strong>.<br>一开始砖堆中有 $0$ 块砖, 即没有.<br>你可以任意安排这些选手加砖的顺序, 求出<strong>最多</strong>能够让<strong>多少人</strong>往砖堆中加入砖.</p><p>$n\le 5000$</p></blockquote><p>考虑钦点一个无后效性的顺序, 按照 $H_i+P_i$ 排序, 因为这代表着这个人最多能把大小提升到这个值, 如果 $H_i+P_i&lt;H_j+P_j$, 那么如果 $i$ 在 $j$ 后必扔一个, 只有 $i$ 在 $j$ 前可能两个人都能上.</p><p>然后dp. 因为 $V$ 很大, $f_{i, j}$ 表示前 $i$ 个人, 用 $j$ 个人的最小砖数, 复杂度 $n^2$ </p><h3 id="AT-agc027-b-Garbage-Collector"><a href="#AT-agc027-b-Garbage-Collector" class="headerlink" title="AT_agc027_b Garbage Collector"></a>AT_agc027_b Garbage Collector</h3><p>第一眼以为每次扔的应该是一个区间, 但实际不是的. 考虑假设一次扔的垃圾位置序列为 $t_k$, 那么代价是 $t_k+\sum_i^k (2k-2i+1)t_i$, 那么因为越往后系数越小, 把最大的几个垃圾分多次扔才好. 但这个式子也表示了如果我们知道一共扔几次, 只需要从后往前从大到小安排系数即可, 那么就只要枚举扔几次, 设扔的次数为 $m$ 时, 则可以用前缀和处理出 $t_i$ 的区间和, 每次把一段加到贡献里, 单次就成 $O(n&#x2F;m)$ 了, 总复杂度 $n\ln n$ </p><h3 id="CF1891E-Brukhovich-and-Exams"><a href="#CF1891E-Brukhovich-and-Exams" class="headerlink" title="CF1891E Brukhovich and Exams"></a>CF1891E Brukhovich and Exams</h3><blockquote><p>给定序列 $a_n$, 可以把 $k$ 个数变成 $0$, 最小化 $\sum_i [\gcd(a_i, a_{i-1})&#x3D;1]$.</p><p>$n\le 10^5$</p></blockquote><p>直接贪, 找出原序列连续1段和gcd序列的连续1段, 先删gcd连续1段中原序列不是1段的段, 再按原序列1段大小从小到大删, 再删刚才剩下的奇数位置和原序列与1或n相连的段.</p><h3 id="ARC164F-Subtree-Reversi"><a href="#ARC164F-Subtree-Reversi" class="headerlink" title="[ARC164F] Subtree Reversi"></a>[ARC164F] Subtree Reversi</h3><blockquote><p>给出了一个 $N$  个点的树, 以 $1$  为根.</p><ul><li>Alice 是先手持白棋, Bob 是后手持黑棋.</li><li>若 $u$ 无棋子且其儿子都有棋子, 则可以放.</li><li>在 $u$ 放棋子时, 子树内棋子颜色反转($u$ 不变).</li></ul><p>Alice 希望白棋最多, Bob 希望黑棋最多, 双方都采取最优策略, 问白棋数量.</p></blockquote><p>考虑对于一个点其翻转次数固定, 因此可以有一些正点和一些反点, 正点贡献到放棋子的一放, 反点贡献到对方, 而每次放一个点要求它是叶子, 放了之后删掉这个点.</p><p>于是考虑对于当前状态, 能放正叶子肯定不放反的, 于是先把正叶子贡献, 于是现在只有反叶子, 考虑若删掉反叶子后会获得正叶子, 则对手连加两分, 而先后手不变, 因此尽量先选删掉反叶子不会获得正叶子的点.</p><p>于是可以把整棵树划分成若干区域, 每个区域是一个由一个以一个父亲度数大于 $1$ 的反点为根, 有若干红蓝交替的链构成的连通块, 问题变成了选择一个这样的区域把它删掉, 发现直接每次选收益最大的区域就是对的, 而你可以自底向上的划分区域, 于是就做完了, 复杂度单log.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JOI</title>
      <link href="/2022/08/26/joi/"/>
      <url>/2022/08/26/joi/</url>
      
        <content type="html"><![CDATA[<h1 id="JOI刷题笔记"><a href="#JOI刷题笔记" class="headerlink" title="JOI刷题笔记"></a>JOI刷题笔记</h1><p>NOI考完了, 挂分80还有没打完的30遗憾打铁</p><p>另一方面也发现自己观察性质, 思维题, dp方向差很多啊</p><p>看到身边人都刷穿JOI, 板刷CF, 就从这里开始了.</p><p>写这篇博客时hexo爆炸换成了qyc的jekyll, 主要是省心不用配置, 并增加了折叠功能, 就把题目都粘过来提高阅读体验了.</p><h2 id="「JOI-2017-Final」T1-焚风现象"><a href="#「JOI-2017-Final」T1-焚风现象" class="headerlink" title="「JOI 2017 Final」T1 焚风现象"></a>「JOI 2017 Final」T1 焚风现象</h2><blockquote><p>给定序列 $a$ , 构造序列 $b$ :</p><ul><li>若 $a_i&#x3D;a_{i-1}, b_i&#x3D;b_{i-1}$ .</li><li>若 $a_i&gt;a_{i-1}, b_i&#x3D;b_{i-1}-(a_i-a_{i-1})t$ </li><li>若 $a_i&lt;a_{i-1}, b_i&#x3D;b_{i-1}+(a_{i-1}-a_i)s$</li></ul><p>$q$ 次对 $a$ 区间加一个数, 询问 $b_n$ .</p><p>$n, q\le 2\times 10^5$ </p></blockquote><p>一脸差分, 差分后变成单点修改, 那么直接维护 $b$ 的差分就好了, 树状数组单点修改区间求和.</p><h2 id="「-JOI-2017-Final」T2-准高速电车"><a href="#「-JOI-2017-Final」T2-准高速电车" class="headerlink" title="「 JOI 2017 Final」T2 准高速电车"></a>「 JOI 2017 Final」T2 准高速电车</h2><blockquote><p>JOI 铁路公司是 JOI 国唯一的铁路公司.</p><p>在某条铁路沿线共有 N 座车站, 依次编为 $1\ldots N$ 号. 目前, 正在服役的车次按照运行速度可分为两类:<strong>高速电车</strong>(简称快车)与<strong>普通电车</strong>(简称慢车).</p><ul><li>慢车每站都停. 乘慢车时, 对于任意一座车站  $i(1\leqslant i&lt;N)$ , 车站  $i$  到车站  $i+1$  用时均为  $A$ .</li><li>快车只在车站  $S_1, S_2, \ldots, S_M$  停车  $(1&#x3D;S_1&lt;S_2&lt;\cdots&lt;S_M&#x3D;N)$ . 乘快车时, 对于任意一座车站  $i(1\leqslant i&lt;N)$ , 车站  $i$  到车站  $i+1$  用时均为  $B$ .</li></ul><p>JOI 铁路公司现拟开设第三类车次:<strong>准高速电车</strong>(简称准快车). 乘准快车时, 对于任意一座车站  $i(1\leqslant i&lt;N)$ , 车站  $i$  到车站  $i+1$  用时均为  $C$ . 准快车的停站点尚未确定, 但满足以下条件:</p><ul><li>快车在哪些站停车, 准快车就得在哪些站停车.</li><li>准快车必须恰好有  $K$  个停站点.</li></ul><p>JOI 铁路公司希望, 在  $T$  分钟内(<strong>不含换乘时间</strong>), 车站  $1$  可以抵达的车站(不含车站  $1$ )的数量 尽可能多. 但是,<strong>「后经过的车站的编号」必须比「先经过的车站的编号」大</strong>.</p><p>求出在  $T$  分钟内, 可抵达车站的最大数目.</p><p>保证 $A\le C\le B$ </p></blockquote><p>交换着证明一下发现对任意一座车站按高速, 准高速, 慢速顺序一定不劣.</p><p>于是高速列车把数轴分成若干段.</p><p>对于一段, 按照每次从当前能到的最后一个车站往后一个位置建设准快车站一定不劣.</p><p>同时, 每一段是独立的并且每一段是不严格上凸的, 所以每次选增益最大的一段增加一个车站一定不劣.</p><h2 id="「JOI-2017-Final」T3-JOIOI-王国"><a href="#「JOI-2017-Final」T3-JOIOI-王国" class="headerlink" title="「JOI 2017 Final」T3 JOIOI 王国"></a>「JOI 2017 Final」T3 JOIOI 王国</h2><blockquote><p>JOIOI 王国是一个  $H$  行  $W$  列的长方形网格, 每个  $1\times 1$  的子网格都是一个正方形的小<strong>区块</strong>. 为了提高管理效率, 我们决定把整个国家划分成两个省 JOI 和 IOI .</p><p>我们定义, 两个同省的区块<strong>互相连接</strong>, 意为从一个区块出发, 不用穿过任何一个不同省的区块, 就可以移动到另一个区块. 有公共边的区块间可以任意移动. 我们不希望划分得过于复杂, 因此划分方案需满足以下条件:</p><ul><li>区块不能被分割为两半, 一半属 JOI 省, 一半属 IOI 省.</li><li>每个省必须包含至少一个区块, 每个区块也必须属于且只属于其中一个省.</li><li>同省的任意两个小区块互相连接.</li><li>对于每一行&#x2F;列, 如果我们将这一行&#x2F;列单独取出, 这一行&#x2F;列里同省的任意两个区块互相连接. 这一行&#x2F;列内的所有区块可以全部属于一个省.</li></ul><p>现给出所有区块的海拔, 第  $i$  行第  $j$  列的区块的海拔为  $A_{i, j}$ . 设 JOI 省内各区块海拔的极差(最大值减去最小值) 为  $R_{\text{JOI}}$ , IOI 省内各区块海拔的极差为  $R_{\text{IOI}}$ . 在划分后, 省内的交流有望更加活跃. 但如果两个区块的海拔差太大, 两地间的交通会很不方便. 因此, 理想的划分方案是 $ \max(R_{\text{JOI}}, R_{\text{IOI}}) $ 尽可能小.<br>你的任务是求出  $\max(R_{\text{JOI}}, R_{\text{IOI}})$  至少为多大.</p><p>对于所有数据, $2\leqslant H, W\leqslant 2000, A_{i, j}\leqslant 10^9(1\leqslant i\leqslant H, 1\leqslant j\leqslant W)$ </p></blockquote><p>首先看出划分是一个三角形.</p><p>那么考虑全局极差, 答案要么是全局极差, 要么全局最大值最小值分属不同省.</p><p>那么把最大值在的省叫 $A$ , 另一个叫 $B$ .</p><p>求极差时一定是全局最大值最小值和另一个什么东西相减.</p><p>容易想到二分答案.</p><p>那么二分完之后一些点被标记成不能是 $A$ , 求出满足这个情况下 $A$ 最大的情况, 然后看 $B$ 是否满足条件即可.</p><h2 id="「JOI-2017-Final」足球"><a href="#「JOI-2017-Final」足球" class="headerlink" title="「JOI 2017 Final」足球"></a>「JOI 2017 Final」足球</h2><blockquote><p>你是 JOI 联赛中一所声名卓著的足球俱乐部的经理.</p><p>俱乐部有 N 名球员, 编号为  $1\ldots N$ . 球员们每天都刻苦地进行训练, 剑指联赛冠军. 足球场可视为一个底为 $ W$  米, 高  $H$  米的长方形, 底平行于东西方向, 高平行于南北方向. 如果某个点向北走  $i$  米, 再向西走  $j$  米恰好到达球场的西北角, 这个点可用坐标  $(i, j)$  来表示.</p><p>练习结束后, 你要回收练习用的足球. 开始回收时, 所有球员都在足球场上, 球员  $i (1\leqslant i\leqslant N) $ 位于  $(S_i, T_i)$ , 球在球员  $1$  脚下. 你正和球员  $N$  一起站在  $(S_N, T_N)$ , 并准备回收球. 球员们把球传到  $(S_N, T_N)$  时, 你才会回收球.</p><p>你可以指挥球员, 但某些操作会提升球员的<strong>疲劳度</strong>. 一个球员不能同时进行多项操作. 你可以指挥控球的球员进行如下操作:</p><p>-<strong>踢球</strong>. 在东西南北四个方向中任选一个, 并指定一个正整数  $p$ , 该球员将球朝指定方向踢出恰好  $p$  米.<strong>假定球滚动时可以穿过其他球员</strong>. 该球员不会移动, 且自动停止控球, 疲劳度上升  $A\times p+B$ .<br>-<strong>运球</strong>. 在东西南北四个方向中任选一个, 该球员带球, 朝指定方向移动  $1$  米. 该球员仍然控球, 疲劳度上升 $C$ .<br>-<strong>停止控球</strong>. 该球员的疲劳度不改变.</p><p>你可以指挥没有控球的球员进行如下操作:</p><p>-<strong>移动</strong>. 在东西南北四个方向中任选一个, 该球员朝指定方向移动  $1$  米, 疲劳度上升  $C$ .<br>-<strong>控球</strong>. 如果该球员所在的位置恰好有球, 且没有其他球员控球, 该球员才能控球. 该球员的疲劳度不改变.</p><p>球员和球有可能跑出场外, 一个位置上可能有多个球员.<br>一天的训练结束后, 球员们非常疲惫. 你想知道在回收球的过程中, 所有球员的疲劳度之和至少会上升多少.</p><p>对于所有数据, $1\leqslant H, W\leqslant 500, 0\leqslant A, B, C\leqslant 10^9, 2\leqslant N\leqslant 10^5, 0\leqslant S_i\leqslant H, 0\leqslant T_i\leqslant W(1\leqslant i\leqslant N), (S_1, T_1)\neq(S_N, T_N)$ </p></blockquote><p>首先肯定观察策略的性质, 发现球并不一定始终朝着目标走, 可能传球走出奇怪折线之类的.</p><p>真正的性质是每个人只会接球一次, 否则它可以直接带着球走到第二次的位置. 所以每个人接球的位置是固定的–每个位置的球由初始位置最近的人接.</p><p>数据范围不大, 估计是 $HW$ 相关的.</p><p>因为球的路径想不到什么好性质可以联想到试着建图, 那么每个点相邻连边权值为 $C$ , 然后对每一行, 每一列单独建立一排点表示这一行列上踢球, 每个点向这一行上对应点连边权为 $B$ , 然后这一排点之间相邻两个连边权为 $A$ , 最后从这一排回来的位置连离它最近的球员的距离(球员跑过来).</p><p>但我们并没有显式禁止一个人接两次球, 在这个模型下相当于一个人第一次把球踢出去只会又无代价瞬移回原来的位置然后再接第二次, 但发现这样是不优的.</p><p>于是建图最短路就做完了.</p><h2 id="「JOI-2017-Final」绳"><a href="#「JOI-2017-Final」绳" class="headerlink" title="「JOI 2017 Final」绳"></a>「JOI 2017 Final」绳</h2><blockquote><p>JOI 小宝宝正拿着一根绳子玩. 绳子可视为一条长度为  $N$  的左右延伸的线段. 绳子由  $N$  根线连接而成, 每根线的长度为  $1$ , 厚度为  $1$ . 绳子上的线共有  $M$  种颜色, 左数第  $i$  根线 ( $1\leqslant i\leqslant N$ ) 的颜色为  $C_i(1\leqslant C_i\leqslant M)$ .<strong>绳子的左端点</strong>意为左数第  $1$  根线的左端点,<strong>绳子的右端点</strong>意为右数第  $1$  根线的右端点. 显然左数第  $i$  根线  $(1\leqslant i\leqslant N)$  的右端点 到 绳子的左端点 的距离为  $i$ .</p><p>JOI 把绳子的长度缩短了. 具体来说, JOI 反复地进行以下过程, 直到绳长缩短至  $2$ .</p><ul><li>假设此时绳子的长度为  $L$ . 指定一个整数  $j(1\leqslant j&lt;L)$ , 使绳子左数第  $j$  根线成为绳子的左端点(最左的线), 并折叠绳子. 也就是说,<ul><li>如果  $j\leqslant \cfrac{L}{2}$ , 则将左数第  $i$  根线  $(1\leqslant i\leqslant j)$  与左数第  $(2j-i+1)$  根线拧成一股. 此时, 绳子原本的右端点仍是右端点, 绳长变为  $L-j$ .</li><li>如果  $j&gt; \cfrac{L}{2}$ , 则将左数第 i 根线  $(2j-L+1\leqslant i\leqslant j)$  与左数第  $(2j-i+1)$  根线拧成一股. 此时, 绳子原本的左端点变为右端点, 绳长变为  $j$ .</li></ul></li><li>两条线的颜色相同才能拧成一股. 在将两条线拧成一股前, 可以任意改变线的颜色. 将线染成其他颜色所需的费用 等于 线的厚度. 颜色匹配后, 两条线将被拧成一股, 新的一股线的厚度 将为 两条线的厚度之和.</li></ul><p>我们把绳长缩短至  $2$  的绳子称为最终的绳子. JOI 希望使得将绳长缩短至  $2$  所需的费用尽可能小. 对于每种颜色, JOI 都想知道, 在最终的绳子中包含这种颜色的情况下, 将绳长缩短至  $2$  所需的最小费用.</p><p>你的任务是帮 JOI 解决这个问题.</p></blockquote><p>感觉一边折叠一边改颜色好玄学啊.</p><p>考虑一个颜色只会被改一次, 所以每一个颜色其实可以一开始就决定好.</p><p>可以考虑当最终长度为 $1$ 时一定是上来全部染成众数的颜色.</p><p>为2时可能有两个颜色, 我们一开始把他染成若干颜色段.</p><p>那么考虑什么时候一种方案合法, 发现除了第一段和最后一段每一段长度都是偶数, 所以每一段左端点奇偶性相同, 枚举留下的一个颜色和奇偶性, 就能确定当前情况. 即对于当前每一个已有的颜色段把他首尾位置染色成和当前枚举的情况相同的.</p><p>而剩下的颜色一定是这样修改完后的众数.</p><h2 id="「JOI-2016-Final」T1-橙子装箱"><a href="#「JOI-2016-Final」T1-橙子装箱" class="headerlink" title="「JOI 2016 Final」T1 橙子装箱"></a>「JOI 2016 Final」T1 橙子装箱</h2><blockquote><p>JOI 社决定将收获的  $N$  个橙子分装进一些箱子内. 在 JOI 社的工厂中, 橙子排列在输送带上, 依次编号为  $1\ldots N$ . 橙子  $i, (1\leqslant i \leqslant N)$  的大小为  $A_i$ . 由于分拣不方便, 同一个箱子内, 橙子的编号必须连续.<br>一个箱子内最多可以装  $M$  个橙子. 在一个箱子内装一些橙子的成本为  $K + s × (a − b)$ . $K$  是箱子本身的成本, 所有箱子的成本一样. $s$  是该箱子中橙子的数目. $a$  是该箱子中最大橙子的大小, $b$  是该箱子中最小橙子的大小.<br>求包装这  $N$  个橙子所需的最小成本.</p><p>对于所有数据, $1\leqslant N\leqslant 2\times 10^4, 1\leqslant M\leqslant 1000, 0\leqslant K\leqslant 10^9, 1\leqslant A_i\leqslant 10^9(1\leqslant i\leqslant N), M\leqslant N$ </p></blockquote><p>$O(n^2)$ dp冲了.</p><h2 id="「JOI-2016-Final」T2-集邮比赛-2"><a href="#「JOI-2016-Final」T2-集邮比赛-2" class="headerlink" title="「JOI 2016 Final」T2 集邮比赛 2"></a>「JOI 2016 Final」T2 集邮比赛 2</h2><blockquote><p>JOI 商店街有  $N$  家商店, 这些商店从入口到出口依次编为  $1, 2, \ldots, N$  号. 商店街是单向通道, 只能从入口进去, 向出口走.</p><p>为了振兴小镇, 小镇将要举行集邮比赛. 在集邮比赛上, 每家商店都会准备  $\texttt{J, O, I}$  三种邮票中的一种, 在该商店中购物的顾客即可获得一张邮票.<br>在比赛中, 参赛选手从入口进入商业街后, 需要依次进入三家商店. 每位选手在入口处会得知他需要依次进入哪三家商店. 保证这三家商店依次提供邮票  $\texttt{J}$ , 邮票  $\texttt{O}$  和邮票  $\texttt{I}$ . 选手到出口时凭赛时收集的这三张邮票领取购物券.</p><p>这  $N$  家商店已经决定了自己要准备哪种邮票. 不过, 在赛前, 我们决定在商业街上新增一家店铺. 这家店开张的地点可在店铺  $i$  和店铺  $i+1 (1\leqslant i\leqslant N-1)$  之间, 或者是入口与店铺  $1$  之间, 异或是店铺  $N$  与出口之间. 这家新建的店铺也会参赛, 并准备  $\texttt{J, O, I}$  三种邮票中的一种.</p><p>选手获得礼品券的方式越多, 邮票拉力赛就越热烈. 如果两名选手进入的店铺不完全相同(比如三者都不同, 或是两者相同剩下一家不同), 那么这两名选手获得购物劵的方式不同.<br>我们想通过合理安排新店铺的开张地点, 使得选手获得购物券的方式尽可能多. 求在理想安排下, 选手最多有多少种获得购物劵的方式.<br>$N\le 10^5$ </p></blockquote><p>对于一个静态问题计数时, 可以考虑枚举 $\texttt{O}$ , 那么使用这个 $\texttt{O}$ 的方案数就是左边 $\texttt{J}$ 的数量乘右边 $\texttt{I}$ 的数量.</p><p>那么现在要在间隙中添加一个, 考虑是 $\texttt{J}, \texttt{I}$ 的情况, 当添加位置移动一格的时只有当中间的那个是 $\texttt O$ 时才会有影响, 可以直接对这个 $\texttt{O}$ 重新计算贡献.</p><p>如果添加的是 $\texttt O$ , 那么更简单: 直接计算左右数量即可.</p><h2 id="「JOI-2016-Final」T3-铁路票价"><a href="#「JOI-2016-Final」T3-铁路票价" class="headerlink" title="「JOI 2016 Final」T3 铁路票价"></a>「JOI 2016 Final」T3 铁路票价</h2><blockquote><p>给出一个包含  $N$  个点, $M$  条无向边的图, 点的编号为  $1\ldots N$ , 边的编号为  $1\ldots M$ .<br>$i$  号边  $(1\leqslant i\leqslant M)$  连接结点  $U_i$  和  $V_i$ . 开始时, 每条边的长度为  $1$  .<br>接下来有  $Q$  次修改, 第  $j$  次修改  $(1\leqslant j\leqslant Q)$  会将  $R_j$  号边的长度由  $1$  修改为  $2$  . 保证每条边最多只修改一次.<br>每次修改后, 试求: 与原图(未作任何修改的图)相比, 有多少结点到结点  $1$  的最短路变长了.</p><p>对于所有数据, $2\leqslant N\leqslant 10^5, 1\leqslant Q\leqslant M\leqslant 2\times 10^5; 1\leqslant U_i, V_i\leqslant N, U_i ≠ V_i(1\leqslant i\leqslant M); 1\leqslant R_j\leqslant M, R_j ≠ R_k(1\leqslant j&lt;k\leqslant Q)$ , 保证图连通, 无重边.</p></blockquote><p>要点在于<strong>从一点出发所有最短路形成的DAG中从这一点出发的所有走法都是最短路</strong>. 因为所有的边必然都连接距离差 $1$ 的两部分, 感性理解.</p><p>剩下就是简单问题, 直接倒过来加边看从1出发能到几个即可.</p><h2 id="「JOI-2016-Final」T4-领地"><a href="#「JOI-2016-Final」T4-领地" class="headerlink" title="「JOI 2016 Final」T4 领地"></a>「JOI 2016 Final」T4 领地</h2><blockquote><p><strong>有一个平面直角坐标系. JOI 君位于  $(0, 0)$  .<br>JOI 君</strong>每天**都按照一个固定的程序移动一轮. 该程序有  $N$  个步骤, 用一个长度为  $N$  的字符串  $S$  描述. 这个字符串仅由大写字母  $\texttt{E, N, W, S}$  构成.<br>左数第  $i$  个字符  $C_i (1\leqslant i\leqslant N)$  表示 JOI 君会移动到哪里. 如果在执行步骤  $i$  前, JOI 君位于  $(x, y)$ :</p><ul><li>$C_i&#x3D;\texttt{E}$ : JOI 君将移动到  $(x+1, y)$ ;</li><li>$C_i&#x3D;\texttt{N}$ : JOI 君将移动到  $(x, y+1)$ ;</li><li>$C_i&#x3D;\texttt{W}$ : JOI 君将移动到  $(x-1, y)$ ;</li><li>$C_i&#x3D;\texttt{S}$ : JOI 君将移动到  $(x, y-1)$ .</li></ul><p>次日 JOI 君会从他前一天停止的位置开始执行程序.<br>JOI 君会把  $(0, 0)$  以及每个步骤结束后到达的点作标记. 开始时 JOI 君没有标记任何点. $K$  天后, 对于任意整数  $a, b$ , 如果  $(a, b), (a+1, b), (a, b+1), (a+1, b+1)$  这四个点都被标记了一次或以上, 以这四个点为顶点的  $1\times 1$  的正方形就属于 JOI 君的领地.<br>请问  $K$  天后, JOI 君有多少个领地.</p><p>对于所有数据, $1\leqslant N\leqslant 10^5, 1\leqslant K\leqslant 10^9$ .</p></blockquote><p>首先把每天的位移向量记作 $v$ . 也就是说第 $i$ 天他在 $vi$ 的位置</p><p>考虑如果路径全部在 $v$ 框成的矩形内, 也就是说两天之间的不相交, 那么很好, 求一天的然后乘 $k$ 就好.</p><p>然后发现只有一维在 $v$ 框出的区间即可, 即若以 $(0, 0)$ 为起点移动, 只要所有点 $p$ 满足 $p_x\in [0, v_x]$ 就可以.</p><p>核心在于, 我们可以通过调整轮数把这个点移动到这个框里, 就是若 $p_x&#x3D;v_x+1$ 我们就让他变成下一轮的 $p_x&#x3D;1$ .</p><p>于是现在就成了不交的问题了, 只要遍历这一轮的每个点判断以其为一角的格子的其他三个角点出现时间和自己的取交就是这个位置的格子被占有的次数.</p><p>要特判 $v_x&#x3D;v_y&#x3D;0, v_x&#x3D;0\ne v_y$ 等情况哦.</p><h2 id="「JOI-2016-Final」T5-断层"><a href="#「JOI-2016-Final」T5-断层" class="headerlink" title="「JOI 2016 Final」T5 断层"></a>「JOI 2016 Final」T5 断层</h2><blockquote><p>地面是由无限多无限长的地层堆叠成的, 画到平面上, $y&#x3D;0$ 为地面, 现在有 $q$ 变化, 每次给出三个参数 $d, x, l$ 表示画一条穿过 $(x, 0)$ 的, 斜率为 $d\in{1, -1}$ 的直线把地层切开, 之后这条直线上方的地层向上移动 $l$ 层. 求所有变化结束后所有位置 $i\in [1, n]$ 的地层一开始是第几层.</p><p>$n, q\le 2\times 10^5$ </p></blockquote><p>所有地层都是斜着移动的, 十分诡异, 此时要想到<strong>旋转坐标轴</strong>, 将坐标轴顺时针旋转45°后就是每次把一个矩形向右或向下移动.</p><p>第二, 我们维护所有地层的点显然是困难的, 要想办法聚焦一层或一层的点, 光看第一层显然是不行的, 正确做法是倒着做, 每次将地层下降, 那么只用聚焦于最后询问的时候一层都下沉到哪里.</p><p>然后我们惊喜的发现, 实际上将地层下降还带来一个好处: 原来我们上升的时候会改变点的相对顺序, 但下降是不会的.</p><p>于是现在问题变成了, 平面上有若干点, 每次选择一个前缀或后缀(两维前后缀都一样)平移一段, 求最后点的坐标.</p><p>那么你发现此时两维坐标很独立, 开两个树状数组分别维护即可. </p><h2 id="「JOI-2018-Final」T1-寒冬暖炉"><a href="#「JOI-2018-Final」T1-寒冬暖炉" class="headerlink" title="「JOI 2018 Final」T1 寒冬暖炉"></a>「JOI 2018 Final」T1 寒冬暖炉</h2><blockquote><p>JOI 的家里有一个暖炉. JOI 君比较耐寒, 所以他独自在家里时不用开暖炉, 但是有客人的时候就必须要开暖炉了.</p><p>这一天, JOI 有  $N$  个客人, 第  $i$  位客人  $(1\le i\le N)$  到达的时间是时刻  $T_i$ , 并在时刻  $T_i+1$  离开. 不会有多位客人同时到访.</p><p>JOI 可以在任何时刻开启暖炉, 不过在每次开启暖炉的时候会消耗一根火柴. JOI 只有  $K$  根火柴, 所以最多只能开启暖炉  $K$  次. 在这一天伊始, 暖炉是关着的.</p><p>暖炉开着的时候需要燃料. 为了节省燃料, JOI 想最小化暖炉工作的总时间.</p><p>给出 JOI 的客人们到访的时间以及 JOI 拥有的火柴根数, 你需要编写一个程序计算暖炉最少需要工作多长时间.<br>对于所有输入数据, 有 $1 \le N \le 10^5, 1 \le K \le N, 1 \le T_i \le 10^9 (1 \le i \le N), T_i&lt;T_{i+1} (1 \le i \le N-1)$ </p></blockquote><p>看着像wqs二分, 是对的, 不过可以更简单.</p><p>把空闲的位置设为 $1$ , 有客人的地方减去 $-inf$ , 则要在序列上选 $k$ 段使得和最小.</p><p>每次选最小子段和一定不劣吧.</p><p>等价于每次选择没人的最长的一段, 在这里断开一段.</p><p>复杂度1log.</p><h2 id="「JOI-2018-Final」T2-美术展览"><a href="#「JOI-2018-Final」T2-美术展览" class="headerlink" title="「JOI 2018 Final」T2 美术展览"></a>「JOI 2018 Final」T2 美术展览</h2><blockquote><p>JOI 国将举行美术展, 在美术展中将展出来自全国各地的各种美术品.</p><p>现在有  $N$  件候选美术品, 编号为  $1$  至  $N$ . 每件艺术品有描述其尺寸与价值的两个整数, 第  $i$  件艺术品的尺寸为  $A_i$ , 其价值为  $B_i$ .</p><p>美术展至少有一件美术品被选中并展示, 并且举办美术展的展览馆足够大, 所以展出所有的  $N$  件美术品也是可行的. 为了符合 JOI 国人民的审美, 我们想使得参展的美术品之间的尺寸之差不能太大. 并且, 我们想使得参展的美术品价值之和尽量大. 因此, 我们决定按照以下方式选定参展的美术品:</p><p>在参展美术品中, 令  $A_{max}$  为所选美术品中最大的尺寸, $A_{min}$  为所选美术品中最小的尺寸. 令  $S$  为所有参展美术品的总价值之和. 给出候选美术品的数量以及其尺寸与价值, 求  $S-(A_{max}-A_{min})$  的最大值.</p><p>对于所有输入数据, 有 $2 \le N \le 5\times 10^5, 1 \le A_i \le 10^{15} (1 \le i \le N), 1 \le B_i \le 10^9 (1 \le i \le N)$ </p></blockquote><p>首先把 $A$ 排序, 发现选择的一定是一段连续的区间. 因为最大最小值确定后中间的当然全加进来.</p><p>设 $b$ 前缀和数组为 $s$ , 就是 $\max_{i&gt;j} (s_i-s_{j-1})-(a_i-a_j)$ </p><p>于是扫一遍就结束了.</p><h2 id="「JOI-2018-Final」T3-团子制作"><a href="#「JOI-2018-Final」T3-团子制作" class="headerlink" title="「JOI 2018 Final」T3 团子制作"></a>「JOI 2018 Final」T3 团子制作</h2><blockquote><p>你是一个制作团子的师傅, 现在, 你正想用竹签把团子串成一串.</p><p>团子被放置在长为  $N$  行, 宽为  $M$  列的隔开的格子里, 每个格子里都放着一个团子. 每个团子的颜色是红、绿与白中的一种.</p><p>你可以选择三个从左到右, 或者从上到下的连续的格子, 把格子中的团子串成一串, 按照这个顺序, 一串团子串上正好会有三个团子.</p><p>现在, 你希望尽可能多做些颜色按照红绿白顺序的团子串, 并且团子在串上的顺序必须与从格子中取出的顺序相同. 需要注意的是, 同一个团子只能被串在一串团子串上.</p><p>你最多能制作多少串团子串呢?</p><p>给出放置在每个格子上的团子的颜色, 你需要计算最多能制作的团子串的数量. 团子串的颜色必须按照红、绿、白的顺序.<br>$N, M\le 3000$ </p></blockquote><p>肯定考虑中间的那个.</p><p>上来先觉得是不是建图网络流, 然后似乎看起来是二分图, 但 $3000\times 3000$ 咋看都跑不过啊.</p><p>画图发现,<strong>只有同一反对角线的绿色团子才会相互影响!</strong>.</p><p>那么每一个反对角线单独做, dp即可. 是设 $f_{i, 0&#x2F;1&#x2F;2}$ 表示前 $i$ 个, 最后一个是横着, 竖着或不串的答案.</p><h2 id="「JOI-2018-Final」T4-月票购买"><a href="#「JOI-2018-Final」T4-月票购买" class="headerlink" title="「JOI 2018 Final」T4 月票购买"></a>「JOI 2018 Final」T4 月票购买</h2><blockquote><p>JOI 所住的城市有  $N$  个车站, 分别编号为  $1 \dots N$ . 有  $M$  条铁路, 编号为  $1 \dots M$ . 第  $i$  条铁路双向连接车站  $A_i$  与车站  $B_i$ , 乘车费用为  $C_i$ .</p><p>JOI 住在车站  $S$  附近, 而 JOI 所在的 IOI 高中在车站  $T$  附近. 他打算买一张月票往返这两个车站. 当他买这张月票时, 他需要选择一条在车站  $S$  与车站  $T$  之间的乘车费用最小的路径. 有了这张月票, JOI 可以无需额外费用, 双向通过任意所选路径包含的铁路.</p><p>JOI 经常去在车站  $U$  与车站  $V$  附近的书店, 因此他希望能买一张月票使得从车站  $U$  到车站  $V$  的花费最小.</p><p>当他要从车站  $U$  去往车站  $V$  时, 他会选择一条从车站  $U$  到车站  $V$  的路径. 对于路径上的每段铁路, 如果这段铁路在月票指定的路径范围内, 则费用为  $0$ , 否则费用为  $C_i$ . 每段铁路的费用和为 JOI 从车站  $U$  到车站  $V$  的总费用.</p><p>他想要知道, 如果他买月票时选择了一条合适的路线, 从车站  $U$  到车站  $V$  的最小费用是多少.</p><p>你需要编写一个程序计算最小费用.<br>对于所有输入数据, 有 $2 \le N \le 100000, 1 \le M \le 200000, 1 \le C_i \le {10}^9$ .<br>保证 $1 \le S, T, U, V \le N, S \ne T, U \ne V, S \ne U 或 T \ne V, 1 \le A_i &lt; B_i \le N$ , 图中无重边.</p></blockquote><p><strong>两条路径的交是一个区间</strong>, 否则直接把两次相交之间的部分也在买月票的那条路径上跑一定更好.</p><p>这时候想到最短路DAG倒是不困难的, 发现只要统计出 $s\to t$ 最短路DAG上每个点能到的点中离 $v$ 最近的, 这个可以DAG上dp, 那么就结束了. 注意要把 $u$ 和 $v$ 换一换再来一遍.</p><p>还是要多锻炼发现性质.</p><h2 id="「JOI-2018-Final」T5-毒蛇越狱"><a href="#「JOI-2018-Final」T5-毒蛇越狱" class="headerlink" title="「JOI 2018 Final」T5 毒蛇越狱"></a>「JOI 2018 Final」T5 毒蛇越狱</h2><blockquote><p>给出长 $2^L$ 的序列 $v$ 表示每个 $0\ldots 2^L$ 中每个数的权值, $q$ 个询问, 每次给定一个字符串, 第 $i$ 个字符表示限制二进制第 $i$ 位为0, 1或任意, 求满足条件的数的权值和.</p><p>$L\le 20, q\le 10^6$ .</p></blockquote><p>最简单的暴力当然是每次暴力枚举合法的数复杂度 $2^L$ .</p><p>另外这个东西让人联想FMT&#x2F;FWT, 因为不看必须为1就是子集前缀和啊.</p><p>那么有了1之后可以加上一个容斥, 先做FMT求子集前缀和, 那么拿若干前缀和容斥出这个, 那么设 $S$ 的前缀和 $v_S$ , 算的就是 $\sum_{S\subseteq T} v_S\times (-1)^{\vert S\vert-\vert T\vert }$ , 这里 $T$ 是强制为 $1$ 的位的集合.</p><p>折腾完复杂度好像还是 $2^L$ ?</p><p>然而你发现, 设强制位0, 1, 任意的个数为 $a, b, c$ , 实际上第一个是 $2^c$ , 这个是 $2^b$ .</p><p>那么把0和1的角色互换用FWT+容斥就能得到 $2^a$ .</p><p>注意 $a+b+c&#x3D;20$ , 所以现在复杂度就成了 $2^6q&#x3D;64q$ .</p><h2 id="「JOI-Open-2017」T2-推土机"><a href="#「JOI-Open-2017」T2-推土机" class="headerlink" title="「JOI Open 2017」T2 推土机"></a>「JOI Open 2017」T2 推土机</h2><blockquote><p>平面上有  $N$  个点, 点  $i: (1\le i\le N)$  位于  $(X_i, Y_i)$ , 点  $i: (1\le i\le N)$  的权值为非零整数  $W_i$ (可能为负数).<br>在平面上画两条平行线, 所得的总价值为平行线之间(压线也算)所有点的权值之和. 求总价值至多不超过多少.</p><p>$1\le N\le 2000,  \vert X_i \vert , \vert Y_i \vert \le 10^9, 1 \le  \vert W_i \vert \le 10^9(1\le i\le N) . (X_i, Y_i)\ne(X_j, Y_j): (1\le i&lt;j\le N) $ </p></blockquote><p>平行线定角度的话相当于最大子段和啊.</p><p>那么枚举角度, 就是分块旋转扫描线不分块, 就是考虑两个点在线上的投影在转一圈的过程中只会变 $O(1)$ 次, 所以转一圈暴力去交换的复杂度是 $n^2$ 的.</p><p>那么就用线段树维护投影形成的序列的最大字段和, 会 $n^2$ 次交换相邻两个(单点修改), 复杂度 $n^2\log n$ .</p><h2 id="「JOI-Open-2017」T3-高尔夫"><a href="#「JOI-Open-2017」T3-高尔夫" class="headerlink" title="「JOI Open 2017」T3 高尔夫"></a>「JOI Open 2017」T3 高尔夫</h2><blockquote><p>平面的第一象限上有  $N$  个矩形障碍, 矩形的两组对边分别平行于 x 轴和 y 轴. 矩形  $i(1\le i\le N)$  的左下角是  $(A_i, C_i)$ , 右上角是  $(B_i, D_i)$ . 任意两个矩形(包括边界)不相交.<br>JOI 君需要将一个高尔夫球从  $(S, T)$  打到  $(U, V)$ , 保证这两点不同, 保证这两点不在障碍内或障碍的边界上.<br>JOI 君只能朝平行于 x 轴或平行与 y 轴的方向击球(JOI 君可以跟着移动). 球可以经过边界, 但不能进入障碍物内部. 球撞进障碍物后会停下(JOI 君仍然可以朝远离障碍物的方向击球).<br>求最少要击球多少次, 才能将高尔夫球打进  $(U, V)$ .<br>$1\le S, T, U, V\le 10^9, 1\le N\le 10^5, 1\le A_i&lt;B_i\le 10^9, 1\le C_i&lt;D_i\le 10^9, (S, T)\ne (U, V)$ </p></blockquote><p>用你丰富的语文功底体会出, 球可以半路停下来而不是必须撞到障碍. (qyc)</p><p><strong>路径一定要么是矩形边线的延长线, 要么能直接连到起点终点上</strong>.</p><p>于是把所有矩形边线作为点拿出来建图, 发现一条横线可能会连向一个区间的竖线(为什么不是全局? 因为有障碍. )于是用线段树优化建图跑最短路.</p><h2 id="「JOI-2015-Final」T1-铁路旅行"><a href="#「JOI-2015-Final」T1-铁路旅行" class="headerlink" title="「JOI 2015 Final」T1 铁路旅行"></a>「JOI 2015 Final」T1 铁路旅行</h2><p>过于简单.</p><h2 id="「JOI-2015-Final」T2-分蛋糕-2"><a href="#「JOI-2015-Final」T2-分蛋糕-2" class="headerlink" title="「JOI 2015 Final」T2 分蛋糕 2"></a>「JOI 2015 Final」T2 分蛋糕 2</h2><blockquote><p>JOI 君和 IOI 酱是双胞胎兄妹. JOI 君最近闲暇时常常会做甜点. 今天 JOI 君也烤了蛋糕吃, IOI 酱立马嗅到了蛋糕的香气于是跑来想分着吃.<br>蛋糕是圆形的, 从蛋糕中某点开始将蛋糕放射状切为  $N$  块, 按逆时针顺序编号为 1 到  $N$  . 切了之后的第 i 块蛋糕的大小为  $A_i$  . 由于切蛋糕的人刀功很不好, 所以  $A_i$  互不相同.</p><p>JOI 君和 IOI 酱按照以下的方法分这  $N$  块蛋糕:</p><ol><li>首先 JOI 君从这  $N$  块蛋糕中任选一块取走;</li><li>然后, 从 IOI 酱开始, IOI 酱和 JOI 君交替地从剩下的蛋糕中选出一块取走. 不过, 当且仅当一块蛋糕两旁的蛋糕至少有一块已经被选择, 这块蛋糕才能被选择. 如果可供选择的蛋糕有多个, IOI 酱会选择最大的一个, 而 JOI 君可以任选一个.</li></ol><p>JOI 君想让自己所得到的蛋糕大小的合计值最大.</p><p>$N\le 2000$ </p></blockquote><p>选走的蛋糕是环上的一个区间.</p><p>于是考虑序列上区间dp, $f_{i, j, 0&#x2F;1}$ 表示该谁选了并且已经选完区间 $[i, j]$ 的代价, 转移显然.</p><p>然后套路复制两倍就结束了.</p><h2 id="「JOI-2015-Final」T3-JOI-公园"><a href="#「JOI-2015-Final」T3-JOI-公园" class="headerlink" title="「JOI 2015 Final」T3 JOI 公园"></a>「JOI 2015 Final」T3 JOI 公园</h2><blockquote><p>时值 20XX 年, 为了给办奥赛做准备, IOI 国将要修缮 JOI 公园. JOI 公园里有  $N$  个广场, 这些广场从  $1$  到  $N$  编号. 有  $M$  条道路连接各个广场, 这些道路从  $1$  到  $M$  编号. 第  $i(1 \leq i \leq M)$  条道路是一条连接第  $A_i$  和第  $B_i$  个广场的双向边, 长度为  $D_i$  . 任意两个广场间一定有道路(直接或间接)相连.</p><p>修缮计划如下: 首先, 选择一个<strong>自然数</strong>  $X$  , 将和第一个广场距离等于  $X$  或在  $X$  以下的所有广场(含第一个广场)相互之间连结一条地下通道. 广场  $i$  和广场  $j$  的距离指, 从广场  $i$  到广场  $j$  经过的道路长度总和的最小值. 定义  $C$  为一个与修筑地下通道花费有关的量(  $C$  是整数). 修筑所有地下通道的花费为  $C\times X$  .</p><p>接下来, 撤去已经通过地下通道连接的广场之间的道路. 撤去道路的花费不计.</p><p>最后, 将没有被撤去的道路进行修补, 长为  $d$  的道路修补的花费为  $d$  .</p><p>修缮计划实施之前, JOI 公园没有地下通道. 请求出 JOI 公园修缮花费总和的最小值.<br>$N\le 10^5, M\le 2\times 10^5, D_i\le 10^5$ </p></blockquote><p>dij之后我们知道了对于一个 $x$ 会删去总长位多少的边, 那么枚举一下就好了. 枚举要离散化.</p><h2 id="「JOI-2015-Final」T4-舞会"><a href="#「JOI-2015-Final」T4-舞会" class="headerlink" title="「JOI 2015 Final」T4 舞会"></a>「JOI 2015 Final」T4 舞会</h2><blockquote><p>IOI 王国为了庆祝 JOI 公主的生日, 举行了舞会. 预定有  $N$  位贵族要参加舞会.  $N$  是奇数. 将贵族们从  $1$  到  $N$  编号. 每个贵族有一个由整数表示的<strong>舞蹈熟练度</strong> . 贵族  $i(1 \leq i \leq N)$  舞蹈熟练度为  $D_i$ . 舞会中, 含 JOI 公主在内的  $N+1$  人两两一组跳舞. $IOI$ 王国遵循老手帮新手的传统, 按以下方法决定跳舞的分组.</p><ul><li>开始时,  $N$  个贵族排成一列.</li><li>直到队列中只剩下一个贵族为止, 不断进行以下操作.</li><li>调查最前面  $3$  个贵族的舞蹈熟练度.</li><li>这  $3$  个人中舞蹈熟练度最大的贵族称为  $A$  . 如果存在多个人, 从中选出序号最小的称为  $A$  .</li><li>这  $3$  个人中舞蹈熟练度最小的贵族称为  $B$  . 如果存在多个人, 从中选出序号最大的称为  $B$  .</li><li>$A$  和  $B$  离开队列并组成一组.</li><li>这三人中没有被选择的一个人移动到队列最后.</li><li>最后剩下的一个人和 $JOI$ 公主一组.</li></ul><p>从第  $1$  个贵族到第  $M(1 \leq M \leq N-2)$  个贵族的  $M$  个贵族已经决定了自己开始时排在队列的第几个. 剩下的  $N-M$  个贵族的排列方式可以由国王自由决定.</p><p>因为 JOI 公主才刚开始学跳舞, 国王想知道和 JOI 公主组队的贵族的舞蹈熟练度的最大值.</p><h4 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h4><p>给出每个贵族的舞蹈熟练度, 和  $M$  个贵族开始时在队列中的位置. 请编写程序求出和 JOI 公主一组的贵族的舞蹈熟练度的最大值.</p></blockquote><p>哦, 原题, 这个就是二分答案, 求出让每个位置熟练度满足二分店答案至少需要几个人, 这个过程用队列模拟.</p><h2 id="「JOI-2015-Final」T5-城墙"><a href="#「JOI-2015-Final」T5-城墙" class="headerlink" title="「JOI 2015 Final」T5 城墙"></a>「JOI 2015 Final」T5 城墙</h2><blockquote><p>历史学家 JOI 教授对曾经存在过的 IOI 王国进行了研究.</p><p>根据过去的调查, IOI 王国的形状为由  $H$  行, $W$  列的格子组成的长方形. IOI 王国的首都为了防卫外敌入侵而修筑了一座城墙.</p><p>围住 IOI 王国首都的城墙形状如以下叙述: 城墙形状由<strong>城墙的大小</strong>决定. 大小为  $s(s\ge 3)$  的城墙, 指  $s\times s$  的正方形的最外一圈, 也就是除去此正方形中心  $(s-2)\times (s-2)$  的小正方形剩下的区域.</p><p>据调查, 围住首都的城墙的大小在  $L$  或以上. 而且已知 IOI 王国中的一些格子不存在城墙.</p><p>JOI 教授为了进一步研究, 想要知道城墙有多少种可能的情况.</p><h4 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h4><p>给出 IOI 王国的大小, 城墙的大小的最小值, 和一些已知不存在城墙的格子, 请编写程序求出城墙可能的情况数.</p><p>$N, W\le 4000$ </p></blockquote><p>有三个不确定量: 左上角坐标和边长.</p><p>时间内可以枚举两个.</p><p>那么如果枚举边长 $s$ 和左上角横坐标 $x$ , 我们需要求在 $x$ 和 $x+s$ 间有多少条没有障碍的路, 并且还要处理纵向有障碍的情况.</p><p>如果枚举 $x$ 和 $y$ , 那么要求这个点开始的对角线上有多少点 $P(x+a, y+a)$ 能向左, 向上延伸超过 $a$ .</p><p>于是, 求出所有点向左向上延伸的最小值, 记为 $len$ , 然后枚举每一条对角线, 维护所有 $len-i$ , $i$ 表示是对角线上的第几个, 那么就是求若干个区间大于一个数的个数, 离线扫描线BIT即可.</p><h2 id="「JOI-Open-2016」T1-JOIRIS"><a href="#「JOI-Open-2016」T1-JOIRIS" class="headerlink" title="「JOI Open 2016」T1 JOIRIS"></a>「JOI Open 2016」T1 JOIRIS</h2><blockquote><p>JOIRIS 的游戏区域名叫「井」, 是一个宽度为  $N$ , 高度足够大的矩形网格. 位于左数第  $i$  列, 从下往上数第  $j$  列的格子记作  $(i, j)$ . 游戏过程中, 每个格子要不有一个方块, 要不没有方块.<br>开始时, 在第  $i$  列有且仅有  $(i, 1), (i, 2), \dots, (i, A_i)$  有方块.<br>接下来, $10^4$  个  $1×K$  的骨牌一个个下落, 玩家要依次放置骨牌. 每次放置骨牌按照如下方式进行:</p><ul><li>玩家先选择骨牌是横向放置还是纵向放置.</li><li>若选择纵向, 玩家还需再选择一个整数  $x (1 \le x \le N)$ . 一个骨牌会下落到第 x 列最上方方块的上面一行. 若第  $x$  列没有方块, 骨牌会下落到井底.</li><li>若选择横向, 玩家还需再选择一个整数  $x (1 \le x \le N-K+1)$ . 一个骨牌会下落到第  $x$  列至第  $x+K-1$  列最上方方块的上面一行. 若第  $x$  列至第  $x+K-1$  列没有方块, 骨牌会下落到井底.</li><li>每个骨牌停止下落后, 系统将从井底往上逐行检查, 如果有一行格子被方块填满, 该行的所有方块都会消失, 且上方的所有方块向下移动  $1$  格.</li><li>此时检查井中是否有方块, 如果井中没有方块, 游戏结束, 玩家胜利, 否则玩家开始放置下一个骨牌.</li></ul><p>保证开始时最底下一行没有被方块填满. 请判断玩家能否胜利, 如果可能, 则输出一种方案.</p><p>对于所有数据, $2\le N\le 50, 1\le K\le N, 0\le A_i \le 50.$ </p></blockquote><p>设 $b_i&#x3D;\sum_j a_{jK}$ </p><p>那么纵向放置不会改变什么, 而横向放置会让所有 $b_i\to b_i+1$ </p><p>最后的时候前 $n\bmod k$ 个 $b_i$ 相等, 后 $k-n\bmod k$ 个相等. 所以一开始满足这个性质是必要条件.</p><p>同时也是充分的, 通过构造证明:</p><ol><li><p>首先竖着做是不会影响答案的, 所以可以先通过竖着加把他变成单增的.</p></li><li><p>然后胡乱不断放横的使得后 $n-k+1$ 列(留下前 $k-1$ 列)都堆到 $a_n$ 的高度, 前 $k-1$ 列不管成什么样(可能有一些悬空).</p></li><li><p>然后在左边不断放竖的就可以把右边 $n-k$ 都消掉. 此时左边也不会有悬空的了.</p></li><li><p>考虑此时 $b_{n\bmod k+1\ldots k}$ 是相等的, 因为 $b_k&#x3D;a_k&#x3D;0$ , 所以 $a_{n\bmod k+1\ldots k-1}&#x3D;b_{n\bmod k+1\ldots k-1}&#x3D;b_k&#x3D;0$ . 只有前 $n\bmod k$ 列有值了.</p></li><li><p>而另外 $b_{1\ldots n\bmod k}&#x3D;a_{1\ldots n\bmod k}$ , 因为一开始他们是相等的, 且我们做的操作不会改变 $\mod k$ 意义下的值, 所以现在他们 $\bmod k$ 相等, 可以通过放竖条让他们一样高, 最后在右边不断放横条就可以胜利了.</p></li></ol><p>于是也是充分的了.</p><h2 id="「JOI-Open-2016」T2-销售基因链"><a href="#「JOI-Open-2016」T2-销售基因链" class="headerlink" title="「JOI Open 2016」T2 销售基因链"></a>「JOI Open 2016」T2 销售基因链</h2><blockquote><p>基因库中有  $N$  个字符串, 这些字符串仅由 <code>A</code>, <code>G</code>, <code>U</code>, <code>C</code>组成(保证每个字符串都包含四种字母).<br>$M$  组查询, 每组查询包含两个字符串  $P$ , $Q$ , 试求: 基因库中有多少个字符串同时存在前缀  $P$  和后缀  $Q$ .<br>举个例子, <code>GAC</code> 存在前缀 <code>G</code>, <code>GA</code>, <code>GAC</code>, 存在后缀 <code>C</code>, <code>AC</code>, <code>GAC</code>, 那么我们可以说: <code>GAC</code> 同时存在前缀 <code>GA</code> 和后缀 <code>AC</code>.</p><p>$N\le 10^5, \sum  \vert P \vert , \sum  \vert Q \vert$ </p></blockquote><p>按字典序排序后相同前缀的是一个区间, 同理反过来相同后缀的也是一个区间, 那么前后分别排序后每个字符串对应到一个点 $(a, b)$ , $a, b$ 分别为正着和倒着的顺序, 而询问就是矩形点个数. 复杂度 $n\log n$ .</p><p>但还有更牛逼的, 如果建可持久化字典树, 就是询问出现在一个时间段内且在某一子树的字符串个数了, 直接每个子树维护子树内结束标记个数减一减就做完了. 排序用字典树+dfs序, 就可以优化成线性了啊.</p><h2 id="「JOI-Open-2016」T3-摩天大楼"><a href="#「JOI-Open-2016」T3-摩天大楼" class="headerlink" title="「JOI Open 2016」T3 摩天大楼"></a>「JOI Open 2016」T3 摩天大楼</h2><blockquote><p>将互不相同的 $N$ 个整数 $A_1, A_2, \dots, A_N$ 按照一定顺序排列.<br>假设排列为 $f_1, f_2, \dots, f_N$, 要求: $\vert  f_1 − f_2 \vert  +  \vert  f_2 − f_3 \vert  + \dots +  \vert  f_{N−1} − f_N \vert  \le L$.<br>求满足题意的排列的方案数 $\bmod (10^9+7).$<br>$1\le N\le 100, 1\le L\le 1000, 1\le A_i\le 1000$ .</p></blockquote><p>序列上 $dp$ 是不可能的, 你不知道你还有哪些数没插入. 而且数的位置其实不是关键.</p><p>那么在值域顺序dp, 这种dp模型大概是考虑从小到大不断插入数, 行成若干个连续段(一个区间都已经被插入). 这样做的好处是一方面不用记已经插入了哪些数, 一方面一个数的贡献其实只和它前后是否比他大有关, 而不和到底是几有关.</p><p>于是设 $f_{i, j, k, 0&#x2F;1&#x2F;2}$ 表示已经插入了前 $i$ 小的数, 形成了 $j$ 个连续段, 当前贡献是 $k$ , 序列两端点被插入了几个, 转移是枚举是否新创建段, 就是插入一个数 $a$ 时如果两边都已经被插入贡献 $2a$ (比左右俩数都大), 如果一个被插入了贡献 $0$ , 否则贡献 $-2a$ , 复杂度是 $n^3V$ ( $V&#x3D;\max A_i$ ).<br>考虑优化状态, 现在只有 $k$ 这一维看起来不太卡满, 如果我们让 $k$ 单调递增那么这一维实际大小是 $L$ , 但因为可能上去很大再下来所以出问题, 所以这里把一个数的贡献一点一点计算: 对于所有连续段端点我们不再减去 $a$ (一边领居没插入)或 $2a$ (两边都没数), 而是假装每一个连续段左右两边都有数 $i$ , 相当于把这一个数的贡献按值域维分成若干段一段一段的雷佳进答案, 这样就让 $k$ 变成单调的了, 复杂度 $n^2L$ </p><h2 id="「JOI-2014-Final」T1-JOI-徽章"><a href="#「JOI-2014-Final」T1-JOI-徽章" class="headerlink" title="「JOI 2014 Final」T1 JOI 徽章"></a>「JOI 2014 Final」T1 JOI 徽章</h2><p>实际是个模拟暴力</p><h2 id="「JOI-2014-Final」T2-IOI-馒头"><a href="#「JOI-2014-Final」T2-IOI-馒头" class="headerlink" title="「JOI 2014 Final」T2 IOI 馒头"></a>「JOI 2014 Final」T2 IOI 馒头</h2><blockquote><p>有 $M$ 种互不相同的馒头各一个, 第 $i$ 个馒头卖 $P_i$ 元.<br>有 $N$ 个包装盒, 第 $j$ 个包装盒最多能装 $C_j$ 个馒头, 买第 $j$ 个包装盒的花费为 $E_j$ 元. 要求只能将一些馒头放进包装盒中打包出售, 不能零售, 当然也可以不出售某些馒头(卖剩的馒头被出题人吃了, 出题人还吃得津津有味~). 售出一盒馒头得到的利润为盒内所有馒头的价格减去包装盒的价格.</p><p>现在买下(这 $N$ 个包装盒)其中的一些包装盒(也可以不买, 还可以全买), 将馒头打包出售, 求最大可能利润.</p><p>对于全部数据, $1\le M\le 10^4, 1\le N\le 500, 1\le P_i, C_j, E_j\le 10^4$ .</p></blockquote><p>馒头其实可以先不管, 因为若当前能装 $k$ 个我们买的一定是前 $k$ 大.</p><p>所以就设 $f_{i, j}$ 表示考虑前 $i$ 种包装盒, 现在手里有 $j$ 元能买几个馒头. 是个背包.</p><p>很遗憾 $j$ 这一维爆炸了. 但值域这一维很小.</p><p>于是经典的互换他们, 设 $f_{i, j}$ 表示前 $i$ 种包装盒买 $j$ 个馒头的最小代价.</p><h2 id="「JOI-2014-Final」T3-年轮蛋糕"><a href="#「JOI-2014-Final」T3-年轮蛋糕" class="headerlink" title="「JOI 2014 Final」T3 年轮蛋糕"></a>「JOI 2014 Final」T3 年轮蛋糕</h2><blockquote><p>JOI 君马上要和妹妹 JOI 子和 JOI 美一起吃小吃. 今天的小吃是他们三个人都很喜欢的年轮蛋糕.</p><p>年轮蛋糕是像下图一样呈圆筒形的蛋糕. 为了把蛋糕分给三个人, JOI 君必须沿着半径方向切 $3$ 刀, 从而把蛋糕分成三块. 然而, 由于年轮蛋糕硬得像实木一样, 要让刀切进去并不简单. 因此, 这个年轮蛋糕上事先准备了 $N$ 个切口, 而 JOI 君只能在有切口的位置下刀. 切口按顺时针顺序编号为 $1$ 到 $N$, 对于 $1\le i\le N-1$, 第 $i$ 个切口和第 $i+1$ 个切口之间部分的大小是 $A_{i}$. 第 $N$ 个切口和第 $1$ 个切口之间部分的大小是 $A_{N}$.</p><p>妹控的 JOI 君在把蛋糕切成 $3$ 块之后, 自己选走最小的一块吃掉, 把剩下两块分给两个妹妹. 而另一方面, JOI 君太喜欢年轮蛋糕了, 只要能吃到的时候就会想吃很多很多. 试求: JOI 君吃掉的蛋糕的大小至多不超过多少.</p><p>给出切口个数 $N$ 和表示各部分大小的整数 $A_{1}, \cdots , A_{N}$, 请求出把年轮蛋糕切成 $3$ 块之后最小一块大小的最大值.<br>$N\le 10^5, A_i\le 10^9$ </p></blockquote><p>最小值最大, Umnik.</p><p>然后枚举一个切口, 找到剩下两个切口, 显然是随着这个切口移动单调的, 三指针.</p><h2 id="「JOI-2014-Final」T4-飞天鼠"><a href="#「JOI-2014-Final」T4-飞天鼠" class="headerlink" title="「JOI 2014 Final」T4 飞天鼠"></a>「JOI 2014 Final」T4 飞天鼠</h2><blockquote><p>飞天鼠 $JOI$ 君住着的森林里长着编号为 $1$ 到 $N$ 的 $N$ 棵桉树. 第 $i$ 棵树的高度是 $H_{i}$ 米.</p><p>JOI 君能在其中的 $M$ 对桉树之间直接飞行, 在各对树木之间飞行所需的时间是固定的. 当 $JOI$ 君在树木之间飞行的时候, 他离地面的高度会每秒下降 $1$ 米. 也就是说, 如果 $JOI$ 君现在离地高度是 $h$ 米, 在树木之间飞行需要 $t$ 秒, 那么飞行之后的离地高度就会变成 $h-t$ 米. 当 $h-t$ 小于 $0$ 或大于目标树木的高度时则不能飞行.</p><p>JOI 君还能沿着树的侧面上下移动, 使得他的离地高度在 $0$ 到当前所在树木高度的范围内变化. JOI 君每使自己的离地高度增加或减少 $1$ 米都需要 $1$ 秒的时间.</p><p>JOI 君要从 $1$ 号树木上高度为 $X$ 米的位置出发, 到树木 $N$ 的顶端(高度为 $H_{N}$ 米的位置)去. 他想知道为了达成这个目标所需时间的最小值.</p><p>给出各棵树木的高度、JOI 君能直接飞行的树木对和 $JOI$ 君最初所在位置的高度, 请求出到达树木 $N$ 顶端所需时间的最小值.<br>全部的输入数据满足:</p><p>$2\le N\le 100000$<br>$1\le M\le 300000$<br>$1\le H_{i}\le 10^{9}(1\le i\le N)$<br>$1\le T_{j}\le 10^{9}(1\le j\le M)$</p></blockquote><p>看起来是最短路没错, 但状态数是 $NH$ 的.</p><p>考虑我们大概非必要不上升.</p><p>如果我们一直往下走, 走到一个地方爬上来一定会经过0.</p><p>那么再求出每个位置从0高度到终点的距离就好了. 实际上相当于把路程分成从起点一直往下走, 然后从地底爬上来, 然后再走到终点.</p><h2 id="「JOI-2014-Final」T5-裁剪线"><a href="#「JOI-2014-Final」T5-裁剪线" class="headerlink" title="「JOI 2014 Final」T5 裁剪线"></a>「JOI 2014 Final」T5 裁剪线</h2><blockquote><p>给定平面上 $n$ 条<strong>线段</strong>, 求它把平面分成多少块.<br>$n\le 10^5$, 坐标值域 $10^9$.</p></blockquote><p>众所周知欧拉公式 $V-E+F&#x3D;C$, $C$ 为连通块个数.</p><p>于是统计交点个数, 线的个数和连通块数.</p><p>那么统计交点个数连通块个数和线的个数都是简单的, 就是对每一条线段求有多少和他垂直的线和他相交, 二维数点就好了.</p><p>能不能直接维护块数?</p><p>从左往右扫描线, 遍历到竖着的就在并查集里合并一个区间里横着的这些线, 遍历到横着的起点&#x2F;终点就删掉这个区间里的点. 这个好像可以打标记.</p><h2 id="「JOI-2013-Final」T1-彩灯"><a href="#「JOI-2013-Final」T1-彩灯" class="headerlink" title="「JOI 2013 Final」T1 彩灯"></a>「JOI 2013 Final」T1 彩灯</h2><blockquote><p>每年 JOI 高中的文化祭上, 走廊上都会有彩灯装饰. 共有 N 个彩灯, 从走廊的西侧到东侧排成一列. 每个彩灯要么亮要么不亮.</p><p>JOI 高中的仓库里沉睡着一台能够对彩灯进行操作的机器. 对于指定的连续的一段彩灯, 此机器能将这些彩灯中所有亮的变成不亮的, 所有不亮的变成亮的. 但是由于这个机器已经老化了, 所以最多只能使用一次.</p><p>JOI 高中的学生们很喜欢彩灯的交替列(亮的彩灯和不亮的彩灯交替排列的一段连续的彩灯). 他们希望能够在必要时使用一次这个机器, 使得所有彩灯中所含的最长的交替列最长.<br>$N\le 10^5$</p></blockquote><p>套路的, 交替这种的特点是奇偶性全相同, 所以枚举所有亮的灯是奇数还是偶数, 然后就简单.</p><h2 id="「JOI-2013-Final」T2-搭乘-IOI-火车"><a href="#「JOI-2013-Final」T2-搭乘-IOI-火车" class="headerlink" title="「JOI 2013 Final」T2 搭乘 IOI 火车"></a>「JOI 2013 Final」T2 搭乘 IOI 火车</h2><blockquote><p>给定两个序列, 可以在其中各选一个区间, 然后按自己指定的顺序归并起来, 拼成一个形如<code>101010</code>的串(第一个是<code>1</code>, 后面交替), 最大化拼出的长度.<br>串长2000</p></blockquote><p>dp它, $f_{i, j, 0&#x2F;1}$ 表示第一个序列的第 $i$ 个为结尾, 第二个序列的第 $j$ 个为结尾, 所形成的串的最后一个是 $0&#x2F;1$ 的最长长度即可.</p><h2 id="「JOI-2013-Final」-T3-现代豪宅"><a href="#「JOI-2013-Final」-T3-现代豪宅" class="headerlink" title="「JOI 2013 Final」 T3 现代豪宅"></a>「JOI 2013 Final」 T3 现代豪宅</h2><blockquote><p>你在某个很大的豪宅里迷路了. 这个豪宅由东西方向 $M$ 列, 南北方向 $N$ 行的正方形房间组成. 从西面开始第 $x$ 列 $(1 \leq x \leq M)$, 从南面开始第 $y$ 行 $(1 \leq y \leq N)$ 的房间用 $(x, y)$ 表示.</p><p>相邻的两个房间之间都有一扇门. 对于每扇门, 门关上表示不可通行, 门打开表示可以通行. 当门打开时, 从门一边的房间走到另一边的房间需要 $1$ 分钟. 另外, 一些房间中有一个开关, 如果连续 $1$ 分钟按住这个开关, 那么所有关上的门会打开, 所有打开的门会关闭.</p><p>现在, 连接东西两个房间的门全都是关上的, 连接南北两个房间的门全都是打开的. 你现在在房间 $(1, 1)$, 要在最短时间内移动到房间 $(M, N)$.</p><p>任务<br>给出豪宅的大小 $M, N$, 以及存在开关的 $K$ 个房间的位置 $(X_1, Y_1), (X_2, Y_2), \ldots, (X_K, Y_K)$. 开始时, 连接东西两个房间的门全都是关上的, 连接南北的两个房间全都是打开的. 请编写程序求出从房间 $(1, 1)$ 移动到房间 $(M, N)$ 最少需要多少时间. 不过, 当房间 $(M, N)$ 不能到达时, 请输出 $-1$.<br>$N, M\le 10^5, K\le 2\times 10^5$</p></blockquote><p>首先平方做法是好想的, 建两层图分别表示横着有边和竖着有边的情况, 连上边, 然后所有有按钮的点把这两层连起来.</p><p>正解就是忽略掉额外的点而只保留这些会在两张图里切换的特殊点和起点终点, 复杂度 $K\log K$</p><h2 id="「JOI-2013-Final」T4-JOIOI-塔"><a href="#「JOI-2013-Final」T4-JOIOI-塔" class="headerlink" title="「JOI 2013 Final」T4 JOIOI 塔"></a>「JOI 2013 Final」T4 JOIOI 塔</h2><blockquote><p>给定 $\texttt{J}, \texttt{O}, \texttt{I}$ 三个字母组成的字符串 $S$, 从中拿出若干的不交的 $\texttt{JOI}$ 和, $\texttt{IOI}$ <strong>子序列</strong>, 最大化拿的数量总和.<br>不交是指不能选同一个字符两遍, 但 $IIOOII$ 这种是可以取出来两个的, 就是说可以跨越.<br>$\vert S\vert \le 10^6$</p></blockquote><p>tyy讲过这个题, 十分霸气的表示不二分的做法都是假的. . . 然后qyc翻出loj线性老哥.</p><p>难点在于如何处理 $\texttt{I}$, 因为不知道是 $\texttt{IOI}$ 的第一个还是第二个.</p><p>二分数量, 判定时从前往后扫, 并且维护若干个没匹配的串, 扫到 $\texttt{J}$ 就新开一个没匹配的串, 扫到 $\texttt{O}$ 如果能匹配现在没匹配的串就直接匹配, 不然就扔掉, 对于 $\texttt{I}$ 如果当前没匹配的串和已经匹配的总和够答案了就当成末尾的 $\texttt{I}$, 否则当头部的.</p><p>线性做法是, 一定可以是一个前缀的 $\texttt{I}$ 贡献到头部, 一个后缀的贡献到尾部, 预处理前后缀然后枚举分段点即可.</p><h2 id="「JOI-2013-Final」T5-冒泡排序"><a href="#「JOI-2013-Final」T5-冒泡排序" class="headerlink" title="「JOI 2013 Final」T5 冒泡排序"></a>「JOI 2013 Final」T5 冒泡排序</h2><blockquote><p>给出长为 $N$ 的数列 $A$, 对数列 $A$ 中任意两个整数进行一次交换得到数列 $A’$. 请编写程序求出对数列 $A’$ 使用冒泡排序使其升序排列的交换次数的最小值. (请注意: 开始时对数列 $A$ 中整数的交换并不需要交换相邻两个数. )<br>$N\le 10^5, A_i\le 10^9$</p></blockquote><p>先考虑 $A_i$ 互不相同的.</p><p>冒泡排序复杂度等于逆序对个数众所周知.</p><p>交换两个 $i, j$ 位置的数的贡献是满足 $x\in (i, j), A_x\in (A_j, A_i)$ 的 $x$ 个数二倍也众所周知.</p><p>那么这个是二维数点, 用二维前缀和可以得到平方算法.</p><p>考虑如何优化, 发现这是个四维问题, 你要选一个4-side矩形.</p><p>考虑性质, 若 $a&lt;b$ 且 $A_a&gt;A_b$,    显然若交换 $b, c$ 肯定不如交换 $a, c$.</p><p>所以交换 $i&lt;j, A_i&gt;A_j$ 的时候 $i$ 是所有前缀最大值的下标, $j$ 是所有后缀最小值的下标.</p><p>于是 $A_i$ 随 $i$ 单增, 所以原来的 $A_x&lt;A_i$ 是一个前缀, 同理对 $j$ 是一个后缀.</p><p>也就是说 $x&gt;i$ 和 $A_x&lt;A_i$ 合体成了下标上的一个区间, 就是先加后问的矩形加矩形max, 复杂度1log.</p><p>其实 $j$ 关于 $i$ 是有决策单调性的, 可以分治维护决策单调性做到2log, 虽然不知道为何单调? qyc说决策单调性是应该枚举的性质, 很有道理</p><p>同时是loj round #6 C. 花火</p><h2 id="「JOI-2019-Final」T1-勇者比太郎"><a href="#「JOI-2019-Final」T1-勇者比太郎" class="headerlink" title="「JOI 2019 Final」T1 勇者比太郎"></a>「JOI 2019 Final」T1 勇者比太郎</h2><blockquote><p>勇者比太郎正在面对恶魔.</p><p>为了攻击恶魔, 比太郎会在一个 $H \times W$ 的网格上放置三种道具(分别记作 J, O, I)并施放咒语. 网格上往下数第 $i$ 行($1 \le i \le H$), 左往右数第 $j$ 列($1\le j \le W$)的格子坐标记为 $(i, j)$.</p><p>现在, 比太郎在网格的每个格子中放置了三种道具中的一种, 比太郎将施放一个咒语, 其威力取决于三种道具的排列方式. 具体的, 威力大小等于满足以下条件的有序四元组 $(i, j, k, l)$, $(1 \le i &lt; k \le H, 1 \le j &lt; l \le W)$ 的数量.</p><p>条件: $(i, j)$ 位置的格子上的道具为 J, $(i, l)$ 位置上的道具为 O, $(k, j)$ 位置上的道具为 I.</p><p>比太郎想知道他的咒语的威力是多少.</p><p>请写一个程序, 根据三种道具在网格上的排列, 计算出咒语的威力(即满足上述条件的四元组数量).<br>$H, W\le 3000$</p></blockquote><p>大概想象一下这个矩形的样子, 预处理每个 $J$ 上面有多少 $O$, 右边有多少 $I$ 扫一遍乘起来即可.</p><h2 id="「JOI-2019-Final」T2-画展"><a href="#「JOI-2019-Final」T2-画展" class="headerlink" title="「JOI 2019 Final」T2 画展"></a>「JOI 2019 Final」T2 画展</h2><blockquote><p>你将举办一个画展. 在展览中, 你需要将一些画放入一些画框中并摆放成一排.</p><p>展览有 $N$ 幅候选画, 编号从 $1$ 到 $N$. 画 $i ( 1 \le i \le N)$ 具有大小 $S_i$ 和美观度 $V_i$.</p><p>另外, 有 $M$ 个候选画框, 编号从 $1$ 到 $M$. 画框 $j ( 1 \le j \le M)$ 的大小为 $C_j$.</p><p>只有大小不超过 $C_j$ 的画才能放入画框 $j$ 中. 每个画框中最多只能放一幅画. 每幅要展出的画都必须放在一个画框中.</p><p>考虑到美观因素, 展出的画必须满足以下条件:</p><p>对于任意两幅相邻的画, 右边的画框大小不小于左边的画框<br>对于任意两幅相邻的画, 右边的画的美观度不小于左边的画的美观度<br>你需要求出你最多能展出多少幅画.<br>有 $1 \le N, M \le 10^5, 1 \le S_i, V_i, C_j \le 10^9 (1 \le i \le N, 1 \le j \le M)$.</p></blockquote><p>LIS. . . , 和qyc倒在相同的坑里.<strong>无序的</strong></p><p>那么分别从小到大排序, 要求选出若干两边都严格递增的对. 每个画匹配一个后缀的画框.</p><p>一脸贪心的样子, 从小到大的框每个装上能装的美观度最小的.</p><h2 id="「JOI-2019-Final」T3-有趣的家庭菜园-3"><a href="#「JOI-2019-Final」T3-有趣的家庭菜园-3" class="headerlink" title="「JOI 2019 Final」T3 有趣的家庭菜园 3"></a>「JOI 2019 Final」T3 有趣的家庭菜园 3</h2><blockquote><p>家庭菜园专家 JOI 先生在他的家庭菜园中种植了一种叫 Joy 草的植物. 在他的菜园里, 有 $N$ 个花盆自东向西摆放, 编号分别为 $1, \ldots, N$. 每个花盆中有一株 Joy 草.</p><p>春天到了, JOI 先生注意到 Joy 草如他期望地长出了各种颜色的叶子, 但他也发现 Joy 草的生长速度没有他期望的那么快. 他查阅了书籍, 找到了草的以下特点:</p><p>Joy 草有三种品种, 分别会长出红色、绿色和黄色的叶子.</p><p>如果两株同一颜色的 Joy 草紧密相邻, 它们的生长速度就会减慢.</p><p>因此, JOI 先生决定重新摆放花盆, 使得没有两株相邻的 Joy 草颜色相同.</p><p>花盆非常沉重, 因此 JOI 先生每次只能交换相邻的两个花盆. 形式化的说, JOI 先生每次操作可以选择一个 $i (1 \le i &lt; N)$, 然后交换花盆 $i$ 和花盆 $i+1$.</p><p>请编写一个程序, 计算最少的交换次数.<br>$N\le 400$</p></blockquote><p>就是说找一个排列 $a$ 使得任意 $a_i, a_{i+1}$ 颜色不同, 并且最小化逆序对个数.</p><p>直接dp最终排列, $f_{i, j, k, 0&#x2F;1&#x2F;2}$ 表示前 $i$ 个, 有 $j$ 个R, $k$ 个Y, 最后一个是R&#x2F;G&#x2F;Y的最小逆序对个数. 不对.</p><p>那么扫值域吗? 也不对, 看题解.</p><p>啥? 设对了? 哦, 是可以转移的, 我们能根据这个知道当前填的这个应该是原序列中第几个R&#x2F;G&#x2F;Y, 然后提前计算一下费用(插入这个的时候计算上后面的和这个组成的). 结束了.</p><h2 id="「JOI-2019-Final」T4-硬币收藏"><a href="#「JOI-2019-Final」T4-硬币收藏" class="headerlink" title="「JOI 2019 Final」T4 硬币收藏"></a>「JOI 2019 Final」T4 硬币收藏</h2><blockquote><p>平面上有 $2n$ 点, 求最小的代价把它们都移动进 $(1, n)\times (1, 2)$ 的矩形里, 移动的代价为两点的曼哈顿距离, 最后移动完之后要求位置互不相同.<br>$n\le 10^5$</p></blockquote><p>怎么做?</p><p><strong>每个点可以先移动到离矩形最近的点, 一定不劣</strong></p><p>然后在这个矩形内贪心, 从左往右扫, 维护两行各有多少多出来的空位即可. 需要费用提前计算一下吧.</p><p>好像是某个老鼠进洞啊.</p><h2 id="「JOI-2019-Final」T5-独特的城市"><a href="#「JOI-2019-Final」T5-独特的城市" class="headerlink" title="「JOI 2019 Final」T5 独特的城市"></a>「JOI 2019 Final」T5 独特的城市</h2><blockquote><p>给一棵 $n$ 个点的树, 每个点有颜色 $c_i$, 对于每个点求一遍以这个点为根时, 对于所有深度, 若这个深度上只有一个点那么把这个点称为特殊点, 对每个点求所有特殊点的颜色数.<br>$n\le 2\times 10^5$</p></blockquote><p>与 $u$ 形成特殊点的点一定在 $u$ 出发的最长链上.</p><p>那么, 找到任意一条直径, 那么所有点的最长链都可以是到直径的两端点之一.</p><p>于是从两端点开始dfs, 考虑对于当前点 $x$ 有哪些长链上的点不特殊, 发现 $x$ 到根路径上每个点规定了这条链上一个区间不能成为特殊点, 用栈维护到根路径上到所有的特殊点.</p><p>但问题在于进入一个分支的时候可能删掉了一些特殊点, 而这些点在另一个分支是不被删除的.</p><p>容易发现 $u$ 进入 $v$ 时, 被删掉的点是从 $u$ 开始向祖先走, 长度为除了 $v$ 子树外其他子树的最长链的这个区间.</p><p>那么若当前递归进入的不是最长的儿子, 贡献是相同的.</p><p>所以先递归进长儿子统计, 再进其他儿子统计. 这样就不需要复原进入一个儿子后向祖先删除的部分了.</p><p>注意由于每次删掉的是子树内最长链, 所以子树内不会删的比外面删的更多. 但 $u$ 自己不应在 $u$ 处被删且可能被子树干掉, 所以每次递归儿子要判断如果当前栈顶不是 $u$ 把 $u$ 塞进去.</p><p>复杂度是每个点被塞进去度数+1次, 所以线性.</p><p>网上资料都说是长链剖分, 但感觉并没怎么用长链的性质. 本质还是换根dp.</p><h2 id="「JOI-Open-2019」T1-三级跳"><a href="#「JOI-Open-2019」T1-三级跳" class="headerlink" title="「JOI Open 2019」T1 三级跳"></a>「JOI Open 2019」T1 三级跳</h2><blockquote><p>有一条很长的路, 被划分为 $N$ 段并从 $1$ 到 $N$ 编号. 每一段都一个坚固程度, 第 $i$ 段路的坚固程度为 $A_i$.</p><p>JOI 君是一位有天赋的体育明星. 他将在这条路上进行三级跳. 一次三级跳包含三次连续的跳跃动作. 设 $a, b, c$ 为 JOI 君进行三级跳时三个起跳点的所在段, 那么需要满足以下条件:</p><p>$a&lt;b&lt;c$. 即: 起跳点所在段需要严格递增;<br>$b-a\le c-b$. 即: 第一次的跳跃距离应该不大于第二次的跳跃距离.<br>JOI 君将进行 $Q$ 次三级跳. 第 $j$ 次三级跳的所有起跳点所在段编号都在 $L_j$ 到 $R_j$ 范围内. 换句话说, 必须保证 $L_j\le a&lt;b&lt;c\le R_j$.</p><p>JOI 君想在更坚固的段上起跳. 对于每次三级跳, JOI 君想知道起跳点的最大坚固程度之和.</p><p>写一个程序, 在给定路的段数和每次三级跳的信息的情况下, 计算对于每次三级跳, 起跳点的最大坚固程度之和.<br>对于所有数据, $3\le N\le 5\times 10^5, 1\le Q\le 5\times 10^5, 1\le A_i\le 10^9, 1\le L_j\lt L_j+2\le R_j\le N$.</p></blockquote><p>构造支配对,但是固定$i,k$根本想不到支配性质.</p><p>需要固定$i,j$,对于任意 $(i, j, k)$ 作为答案, $i, j$ 换成区间 $[i, j]$ 的最大值和次大值一定不劣, 因为前半段是可以任意短的.</p><p>考虑每个次大直, 一个次大值只会对应2个最大值(左右各一个), 于是一共只有 $O(n)$ 个!</p><p>就开扫描线吧, 当经过对 $(a, b)$ 的 $2b-a$(最小的 $c$)时把它插入进去, 每次就是全局取max和区间最小值了.</p><h2 id="「JOI-Open-2019」T2-汇款"><a href="#「JOI-Open-2019」T2-汇款" class="headerlink" title="「JOI Open 2019」T2 汇款"></a>「JOI Open 2019」T2 汇款</h2><blockquote><p>JOI 王国的河狸湖边有 $N$ 座房子, 按逆时针方向给房子从 $1$ 到 $N$ 编号.</p><p>站在湖所在的位置看, 每一座房子可以给它左边相邻的房子汇款, 即: 对于房子 $i\ (1\le i\le N-1)$, 它左边的房子是房子 $i+1$, 对于房子 $N$, 它左边的房子为房子 $1$. 然而, 汇一笔款的手续费等于汇款金额. 汇款金额必须是一个整数. 当你汇款的时候, 你必须交手续费, 所以汇款钱数和手续费之和不能超出房子里的钱数.</p><p>目前, 房子 $i\ (1\le i\le N)$ 里有 $A_i$ 元. 另一方面, 从收税的角度来看, 我们希望房子 $i$ 里的钱数等于 $B_i$. 因此你希望利用汇款系统使得房间 $i$ 里钱数等于 $B_i$ 元. 你不能通过除给别的房子汇款和交手续费之外的方式花掉钱.</p><p>给定每座房子目前有的钱数和期望钱数, 写一个程序判断能否使得每间房子都达到期望的钱数.<br>对于全部数据, $1\le N\le 10^6, 0\le A_i, B_i\le 10^9$.</p></blockquote><p>震惊, 万万没想到是模拟题! 不敢相信啊.</p><p>每个房子最多汇款 $\log A_i$ 次, 于是考虑进行 $\log A_i$ 轮, 即直接看 $A_i$ 是大于还是小于目标状态然后去汇1, 弄完不对就不可能了.</p><h2 id="「JOI-Open-2019」T3-病毒实验"><a href="#「JOI-Open-2019」T3-病毒实验" class="headerlink" title="「JOI Open 2019」T3 病毒实验"></a>「JOI Open 2019」T3 病毒实验</h2><blockquote><p>你知道「净是一些鬼畜发明公司」(Just Odd Inventions Co. , Ltd. )吗? 这家公司就是发明一些鬼畜玩意的. 现在我们就叫它 JOI 公司.</p><p>JOI 公司开发了一种新型病毒——「JOI 病毒」. JOI 公司想要通过用 JOI 病毒感染 IOI 岛上的居民的方式做一次病毒实验.</p><p>IOI 岛是一个矩形, 从东向西有 $R-1$ 条互相平行的街道, 从北向南有 $C-1$ 条互相平行的街道. 它们把岛划分为 $RC$ 个区域. 每个区域只住着一个居民, 我们称住在从北数第 $i$ 区域, 从西数第 $j$ 个区域的居民为居民 $(i, j)$.</p><p>在 IOI 岛上, 一天共有 $M$ 个时间段. 我们称第 $k$ 个时间段为时段 $k$. 风总是从东西南北四个方向吹来, 风向取决于时段. 如果时段相同, 则风向相同, 与日期无关.</p><p>每个居民都有一个抵抗力. 居民 $(i, j)$ 的抵抗力用一个非负整数 $U_{i, j}$ 表示.</p><p>如果 $U_{i, j}&#x3D;0$, 表示居民 $(i, j)$ 的抵抗力很高, 并且这位居民不会感染 JOI 病毒;<br>如果 $U_{i, j}&gt;0$, 表示居民 $(i, j)$ 可能会感染 JOI 病毒. 如果以下情况持续了 $U_{i, j}$ 个时段, 这位居民就将在下一个时段感染 JOI 病毒:<br>住在风吹来方向且与这位居民相邻的居民感染了 JOI 病毒.<br>注意一天最后一个时段和下一天第一个时段是连续的.<br>为了完成实验, 我们想要至少感染一位居民, 但是我们不想感染太多的居民. 在初始的时候, 我们选择一位居民作为第一个被感染的人, 然后使他感染 JOI 病毒. 我们不能感染抵抗力为 $0$ 的居民.</p><p>给定每一个时段的风向, 写一个程序计算在 $10^{100}$ 天之后至少会有多少居民被感染, 和达到这个最小值选择初始感染者的方案数.<br>对于全部数据, $1\le M\le 10^5, 1\le R, C\le 800, 0\le U_{i, j}\le 10^5$, 保证 $D$ 字符串长度为 $M$ 并且只包含 $N, S, W, E$ 四种字符, 并且保证至少有一个 $U_{i, j}\ge 1\ (1\le i\le R, 1\le j\le C)$.</p></blockquote><p>读错成简单题了&#x2F;qd 病毒的风可以来自不同方向但时间上连续, 所以毙掉了先建图再直接tarjanSCC的做法.</p><p>首先如果A感染后B也感染, 那直接感染B一定不劣.</p><p>所以我们选的是最小的出度为0的SCC, 但很遗憾我们不知道图的结构.</p><p>但我们仍然可以模拟: 对于一个点可以处理它周围四个点的16种情况下是否会感染, 然后枚举人bfs就可以做到 $n^2c^2$.</p><p>但其实我们只想知道关系而不是直接bfs答案, 没必要每次都到底吧?</p><p>考虑如果A可以到B, 那么所有到A的都一定不优于B了吧.</p><p>于是我们维护若干集合, 每个集合维护一个最优点, 每次从最优点出发遍历, 若遍历到其他集合的元素就合并上去.</p><p>写成别如卡就是 $RC\log RC$ 了</p><p>最后得到若干无法拓展的集合, 那么每个集合从最优点出发求一下是 $RC$ 的, 这个大小同时是这个集合的感染人数和感染方案.</p><h2 id="「JOI-2020-Final」T1-只不过是长的领带"><a href="#「JOI-2020-Final」T1-只不过是长的领带" class="headerlink" title="「JOI 2020 Final」T1 只不过是长的领带"></a>「JOI 2020 Final」T1 只不过是长的领带</h2><blockquote><p>你知道 Just Odd Inventions 公司吗? 这个公司的业务是「只不过是奇妙的发明 &#x2F; Just Odd Inventions」. 这里简称为 JOI 公司.<br>JOI 公司的最新发明是「只不过是长的领带」. 共有 $N+1$ 条领带, 并以 $1, \ldots, N+1$ 编号.<br>第 $i$ 种领带的长度为 $A_i$, 其中 $1 \le i \le N+1$.</p><p>公司聚集了他们的员工, 并准备举办一场试戴派对.<br>参加该聚会的员工共有 $N$ 个, 且第 $j$ 个员工一开始戴着长度为 $B_j$ 的领带, 其中 $1 \le j \le N$.<br>派对的流程如下:</p><p>JOI 公司的 CEO 首先选出一条领带, 它将不会在接下来的派对中使用.<br>然后, 每个员工从其余领带中选择一条, 且需保证没有两个员工选择了同一条领带.<br>最终, 每个员工取下一开始戴着的领带, 并试戴他 &#x2F; 她选择的领带.<br>若某个员工一开始戴着的领带长度为 $b$ 而最后试戴的领带长度为 $a$, 则他 &#x2F; 她会产生 $\max{a - b, 0}$ 个单位的奇怪感.<br>整场派对的奇怪度定义为所有员工中最大的奇怪感.</p><p>由此, 我们定义 $C_k$ 为当 CEO 选择第 $k$ 条领带时, 整场派对最后可能的最小奇怪度.</p><p>请你对于给定的 $A_1, A_2, \ldots, A_{N+1}$ 和 $B_1, B_2, \ldots, B_N 求出 C_1, C_2, \ldots, C_{N+1}$.<br>对于所有测试数据 $1 \le N \le 2 \times 10^5, 1 \le A_i \le 10^9, 1 \le B_j \le 10^9\ (1 \le i \le N+1, 1 \le j \le N)$.</p></blockquote><p>发现自己是智障: 简单贪心发现如果匹配连出交叉一定不如换一下不交叉, 于是两个分别排序一一对应就是对的. 因为要删一个你要处理排完序后 $i$ 对应 $i$ 和 $i$ 对应 $i+1$ 的情况然后随便做.</p><h2 id="「JOI-2020-Final」T2-JJOOII-2"><a href="#「JOI-2020-Final」T2-JJOOII-2" class="headerlink" title="「JOI 2020 Final」T2 JJOOII 2"></a>「JOI 2020 Final」T2 JJOOII 2</h2><blockquote><p>比太郎收到了一个长度为 $N$ 的字符串 $S$ 作为他的生日礼物, 且这个字符串仅由 $\texttt{J}, \texttt{O}, \texttt{I}$ 组成.</p><p>对于所有正整数 $K$, 若一个字符串仅由 $K$ 个连续的 $\texttt J$, $K$ 个连续的 $\texttt O$ 和 $K$ 个连续的 $\texttt I$ 顺次连接而成, 则我们称这个字符串为 $K$ 级JOI-串.<br>例如, $\texttt{JJOOII}$ 就是一个 2 级 JOI-串.</p><p>比太郎热衷于构造 $K$ 级 JOI-串, 于是他打算通过以任意顺序使用以下三个操作任意次来将字符串 $S$ 构造为一个 $K$ 级 JOI-串:</p><ol><li>删除 $S$ 的开头字符.</li><li>删除 $S$ 的结尾字符.</li><li>删除 $S$ 的一个非开头且非结尾的字符.<br>由于操作 $3$ 十分耗时, 比太郎想要尽可能少地使用操作 $3$.<br>请对于给定的长度为 $N$ 的字符串 $S$ 和一个正整数 $K$, 输出将其构造为 $K$ 级JOI-串所需要的最少的操作 $3$ 的次数.<br>若无解, 请输出 $-1$.</li></ol><p>$3 \le N \le 2 \times 10^5, 1 \le K \le \frac N3$, S 是一个仅有 $\texttt J, \texttt O, \texttt I$ 组成的字符串.</p></blockquote><p>枚举一下开头位置, 预处理一下每个位置往后多少有 $K$ 个 $\texttt{J}&#x2F;\texttt{O}&#x2F;\texttt{I}$, 结束.</p><h2 id="「JOI-2020-Final」T3-集邮比赛-3"><a href="#「JOI-2020-Final」T3-集邮比赛-3" class="headerlink" title="「JOI 2020 Final」T3 集邮比赛 3"></a>「JOI 2020 Final」T3 集邮比赛 3</h2><blockquote><p>JOI 君生活的 IOI 国有一个著名的湖泊, 今天一场集邮大会在湖边举行.</p><p>绕湖一圈总共有 $N$ 种邮票可以收集, 编号分别为 $1\ldots N$, 收集点绕湖顺时针排列. 湖的周长为 $L$, 第 $i$ 张邮票 $(1\le i\le N)$ 的收集点在距离出发点顺时针走 $X_i$ 米的位置.</p><p>参赛者在比赛开始的时候要站在出发点的位置, 当大会开始时, 参赛者可以绕湖顺时针或者逆时针移动, 参赛者能够得到第 $i$ 张邮票 $(1\le i\le N)$ 当且仅当他到达收集点的时间在比赛开始时的 $T_i$ 秒以内(含).</p><p>JOI 君也是集邮大会的参与者. 他的移动速度是每秒钟 $1$ 米, 你可以认为只有移动才会消耗时间.</p><p>请你计算他最多能收集到多少种邮票.<br>对于 $100%$ 的数据, 保证 $1\le N\le 200, 2\le L\le 10^9, 1\le X_i &lt; L, X_i &lt; X_{i+1}, 0\le T_i \le 10^9$.</p></blockquote><p>走到的一定是一个区间经典.</p><p>$f_{i, j, 0&#x2F;1, t}$ 表示 $i-j$ 这一区间, 当前在 $i&#x2F;j$, 时间 $t$ 拿到的最多邮票, $t$ 这一维原地爆炸, 于是直接替换 $t$ 和答案维做完了.</p><h2 id="「JOI-2020-Final」T4-奥运公交"><a href="#「JOI-2020-Final」T4-奥运公交" class="headerlink" title="「JOI 2020 Final」T4 奥运公交"></a>「JOI 2020 Final」T4 奥运公交</h2><blockquote><p>给一个 $n$ 点 $m$ 边有向图, 边有 $c$ 和 $d$ 两个属性表示这条边的代价和把这条边方向颠倒的代价, 求翻转至多一条边的情况下 $1\to n$ 最小代价.<br>$n\le 200, m\le 5\times 10^4$</p></blockquote><p>$n\le 200$, 复杂度居然不是 $n^3$.</p><p>考虑枚举翻转的是边 $u\to v$, 那么贡献似乎很好算, 就 $\min(dis(1, n), dis(1, v)+dis(v, u)+dis(u, n))$ 这样.</p><p>但问题是我们翻转一条边可能导致原最短路消失. 考虑最短路必经边只有 $n$ 条(最短路树的树边才有可能)所以这些边直接重跑暴力即可.</p><h2 id="「JOI-2020-Final」T5-火灾"><a href="#「JOI-2020-Final」T5-火灾" class="headerlink" title="「JOI 2020 Final」T5 火灾"></a>「JOI 2020 Final」T5 火灾</h2><blockquote><p>给一个长 $n$ 序列 $a$ 在0时刻的状态 $a_1\ldots a_n$, 每一时刻 $a_i&#x3D;\max{a_i, a_{i-1}}$(同时进行的), $q$ 次询问 $t$ 时刻区间和.<br>$n, q\le 2\times 10^5$</p></blockquote><p>这个题是lxl在一轮省集搬的题的弱化版啊! 把树上的操作去了就行了.</p><p>具体的, 考虑所有由值相等的连续段, 每一时刻它左右端点都有可能右移, 取决于左右两个连续段与它的大小关系. 并且由若干时刻连续段会消失. 因为要求和用平衡树维护. 这个技巧是不是很经典啊?</p><p>开题解. 为啥大家不需要平衡树也不维护连续段</p><p>大致是分析了一个数的移动是平面(时间-下标)上的一个平行四边形, 在平面上做平行四边形加横线求和.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
            <tag> JOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022SDSC</title>
      <link href="/2022/08/01/2022_sdsc/"/>
      <url>/2022/08/01/2022_sdsc/</url>
      
        <content type="html"><![CDATA[<h1 id="夏令营游寄"><a href="#夏令营游寄" class="headerlink" title="夏令营游寄"></a>夏令营游寄</h1><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><h3 id="比赛题"><a href="#比赛题" class="headerlink" title="比赛题"></a>比赛题</h3><h4 id="T1-P7163"><a href="#T1-P7163" class="headerlink" title="T1 P7163"></a>T1 P7163</h4><blockquote><p>给一个树, 每个点有一个灯, 可能为开或关, 每经过一个点会把灯的状态翻转, 不能停留, 任选起点, 求最短路径把所有灯打开. $n\le 10^5$ </p></blockquote><p>尝试构造发现方案不唯一而十分复杂, 考虑dp.</p><p>由于起点为自选, 想到换根dp, 发现换根过程很困难, 考虑把换根的信息也放进状态里, 最后设 $f_{u, 0&#x2F;1, 0&#x2F;1&#x2F;2}$ 表示节点 $u$ 的子树内, $u$ 的状态为开或关, 子树内有几个路径端点的情况下让子树内全亮的最短路程, 转移时:</p><ul><li>路径拼接时可能会重复走某个点</li><li>若走出时发现某个 $v$ 并没有被关闭, 那么就在走到 $v$ 后再走回 $v$ 再走回 $u$ , 会把 $u\to v$ 走两遍.</li></ul><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><blockquote><p>3d空间内有 $n$ 个块, 每个块都是一个长方体, 第 $i$ 块对角 $(x, y, z)$ 坐标分别为 $(i, 0, 0)$ , $(i+1, a_i, b_i)$ , 要求在这些<strong>块内</strong>的空间内找到一个最大的长方体</p><p><img src="/img/2022-07-16-15-44-26-image.png"> $n\le 2\times 10^5, a_i, b_i\le 10^6$ </p></blockquote><p>考虑按 $x$ 分治它, 现在分为两半, 我们选择的长方体左右端点到中间的距离分别为 $l, r$ . 讨论 $a$ , $b$ 最后被哪里限制住, 也就是 $a$ , $b$ 的最小值在哪里取到, 考虑若两者在同一侧取到, 则显然另一边越长越好, $l$ 向左移动的过程 $r$ 显然单调右移, 可以双指针扫出来. 另一种情况为两个限制在两边, 设 $maxa$ 在左边而 $maxb$ 在右边, 另一种情况同理, 则贡献为 $(r-l+1)\cdot maxa\cdot maxb$ , 固定 $r$ , 则 $maxb\cdot (r-l+1)$ 可以看做关于 $l$ 的一次函数, 所以我们扫一遍处理出所有右侧对应的一次函数, 再扫一遍左边对每个放在李超树求最大值即可.</p><p>此时复杂度为 $n\log^3 n$ , 考虑取最值的一次函数形成凸壳, 就可以线段树维护凸壳做. 复杂度不变, 但注意到当我们 $l$ 单调递增的时候直线是单调左移的就解决了.</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><blockquote><p>给定长 $n$ 的序列 ${a_i}$ , 代表一棵点数 $\dfrac{(n+1)(n+2)}{2}$ 的树, 其中第 $i$ 层有 $i$ 个节点, 第 $a_i$ 个节点有2个儿子, 其他节点均只有一个儿子, 再按层标号形成的树.</p><p><img src="/img/2022-07-16-15-45-26-image.png"></p><p>如图为序列{1, 2, 6}.</p><p>$q$ 次询问两个点 $x, y$ 的 lca.</p><p>$n\le 2\times 10^5$ </p></blockquote><p>考虑这个树的性质, 感觉主要有两个, 一个是总分支数是 $n$ , 另一个是深度是 $n$ .</p><p>可以看成每个点 $a_i$ 引出一个新的分支, 而其他的都是垂直向下的, 发现我们只要能找出一个点在哪个分支就可以算 lca, 因为总分支数是没问题的, 同时可以把所有分支连成一棵树.</p><p>我们找父亲, 儿子是简单的, 就是减去和加上层数, 同时注意对于层 $i$ 所有大于 $a_i$ 的点再找儿子时还要再加一, 这使得我们跨多层找父亲儿子十分困难.</p><p>于是利用深度为 $n$ 的性质, 发现我们可以把这个树看成一开始只有根节点1, 每次 $a_i$ 分裂出来一个的结构, 所以用一个可持久化线段树就能维护每一层的形态(插入一个点而已), 但插入一个点后面点的编号怎么变啥的处理复杂, 所以反过来, 最后一层的形态是确定的, 只要从后往前每次删一个点过程容易维护. 而且每个点对应的分支就是这一层时它这个点对应的叶子(由哪个叶子演变而来)的编号.</p><p>于是就做完了.</p><p>考场上想到做法然而只剩半小时.</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="比赛题-1"><a href="#比赛题-1" class="headerlink" title="比赛题"></a>比赛题</h3><h4 id="T1-Block"><a href="#T1-Block" class="headerlink" title="T1 Block"></a>T1 Block</h4><blockquote><p>给定长度为 $n$ 的序列和 $m$ 个询问, 以B为大小分块后, 若一个询问端点在同一块代价为区间长度, 否则为不算两端点中间的块数加上两端点到各自块端点的距离, 就像分块一样.<br>$n\le 10^6$ . 提示: 相信自己.</p></blockquote><p>提示让ljc坚信这是个 $\sqrt n$ 的卡常题. 这题方法很多.</p><h5 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h5><p>首先容易想到一个简单的数论分块做法, 是过不了的, 就是你写出式子后询问 $(l, r)$ 对块大 $B$ 的贡献会化成</p><p>$$<br>\begin{aligned}<br>&amp;\lfloor\dfrac{r-1}{B}\rfloor-\lfloor\dfrac{l-1}{B}\rfloor+(B-l+B\cdot \lfloor\dfrac{l-1}{B}\rfloor)+(r-B\cdot \lfloor\dfrac{r-1}{B}\rfloor)<br>\end{aligned}<br>$$ </p><p>之类的, 然后拆拆式子, 最后注意要单独给 $l, r$ 在同一块的减去 $B$ . 于是能得到一个绝妙的TLE做法.</p><p>wmy神仙对着这个搞出了一个转调和级数的做法, 然而我现在还不会. todo</p><h5 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h5><p>首先经典调和级数结论告诉我们不同的块个数为 $O(n\log n)$ , 那么考虑对每一块求所有询问对它的贡献. 发现我们只要对两端点都在块内, 都在块外, 一内一外进行讨论就可以把一个询问拆成11个3side静态二维矩形数点问题获得大常数TLE, 令人望而生畏, 但真的有人写了3种不同扫描线的做法啊! . (至于是不是分和数论分块一样多? )</p><p>然而有一种更简单的做法, 考虑对每一个块长的答案先加上所有询问区间长度总和, 如果它跨过一块, 就再给贡献减去 $B-1$ . 那么我们只要统计两端点一外一内的即可. 一个树状数组即可.</p><h4 id="T2-sbt"><a href="#T2-sbt" class="headerlink" title="T2 sbt"></a>T2 sbt</h4><blockquote><p>给一个长 $n$ 的序列和常数 $k$ , 有 $q$ 次单点修改, 要求在未修改时和每次修改后求出对于序列中所有长度为 $k$ 的滑动窗口中最大值与不严格次大值的和最大为多少.<br>$n\le 10^6$ , $n\le 10^5$ .</p></blockquote><p>首先你考虑维护滑动窗口没前途的话我们可以套路的枚举每个数是最大值或次大值, 那么此时答案就是它前后 $k$ 个不算自己的最大值和次大值之和, 再考虑有了单点修改后, 如果把数改大只要直接再对修改后的值求一下, 但改小不会做, 于是套路的上一个线段树分治, 看起来2log冲不过去, 但实际上因为修改了的数只有 $q$ 个, 也就是说剩下的数都直接放到了根节点上了, 于是复杂度其实是 $q\log n\log q+n\log n$ .</p><h4 id="T3-ntt"><a href="#T3-ntt" class="headerlink" title="T3 ntt"></a>T3 ntt</h4><p>见鬼数学题todo.</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="比赛题-2"><a href="#比赛题-2" class="headerlink" title="比赛题"></a>比赛题</h3><h3 id="讲课"><a href="#讲课" class="headerlink" title="讲课"></a>讲课</h3><h4 id="LOJ2764-JOIOI塔"><a href="#LOJ2764-JOIOI塔" class="headerlink" title="LOJ2764 JOIOI塔"></a>LOJ2764 JOIOI塔</h4><blockquote><p>给定一个字符串由J, O, I组成, 求能找出多少个不相交的’IOI’, ‘JOI’子序列. $n\le 10^6$ </p></blockquote><p>二分答案, 贪心过程中如果碰到J或O就贪心的往已经有的接, 如果已经有的接不上就直接扔, 然后碰到I看当前的子序列个数够不够二分的答案, 不够就作为IOI的I, 否则作为后面的I接上去.</p><p>虽说tyy说不二分的都是假的, 但qyc似乎确实从loj上找到了线性的解法啊?</p><h4 id="LOJ3666-沙堡-2"><a href="#LOJ3666-沙堡-2" class="headerlink" title="LOJ3666 沙堡 2"></a>LOJ3666 沙堡 2</h4><blockquote><p>给定 $W\times H$ 网格, 每个格子高度为 $A_{i, j}$ , 高度互不相同, 每次只能走到不高于当前格子的相邻格子, 问恰好覆盖一个子矩形的方案数.<br>$H\cdot W\le 5\times 10^4$ </p></blockquote><p>由于高度互不相同, 显然对于一个子矩形, 恰好覆盖它的方案是唯一的. 而能不能成等价于把其中的数排序后相邻两项在图上相邻.</p><p>设与当前格子相邻的权值比当前格子大的最小的为后继, 比它小的最大的为它的前驱, 若两个相邻的格子相互为前驱后继, 那么由前驱向其后继连有向边, 此时如果一个矩形能成当且仅当至多一个格子出度为0, 预处理相邻两个格子间是否右边, 注意这里在子矩形边界上的要单独处理.</p><p>然后考虑dp, 如果确定了矩阵的上下位置, 那么可以设 $f_{i, 0&#x2F;1, 0&#x2F;1, 0&#x2F;1}$ 表示到 $i$ 列, 第 $i$ , $i-1$ , $i+1$ 列选不选的方案数, 转移可以枚举下一列选还是不选.</p><p>因为 $H\cdot W\le 5\times 10^4$ , 所以短的一边一定少于 $\sqrt n$ , 所以只要我们把 $H$ 搞成短边就可以直接做了.</p><h4 id="UOJ578-校验码"><a href="#UOJ578-校验码" class="headerlink" title="UOJ578 校验码"></a>UOJ578 校验码</h4><h4 id="UOJ280-题目难度提升"><a href="#UOJ280-题目难度提升" class="headerlink" title="UOJ280 题目难度提升"></a>UOJ280 题目难度提升</h4><blockquote><p>给定数列, 求一个顺序, 使得每次按顺序加入一个数后数列中位数不降, 要求字典序最大的方案. 这里偶数个的中位数为中间两个取平均 $n\le 10^5$ </p></blockquote><p>为了让中位数不降, 我们要加一个大的一个小的这样, 所以在未加入的数里至少要有一半的比中位数小, 那么考虑:</p><ul><li>我们一开始加的必然是全局最小值.</li><li>如果当前加入了偶数个, 那么接下来加的数一定要比当前中位数小. 也就是当前最小值.</li><li>如果加入了奇数个, 那么只要满足接下来的数和中位数取平均后比原来的大, 可以二分出来.</li></ul><p>注意我们这个过程, 因为一开始是全局最小值, 再归纳的看这个过程, 发现每次小于中位数的其实只有一个也就是当前最小值.</p><h4 id="cf16-final-J-Neue-Spiel"><a href="#cf16-final-J-Neue-Spiel" class="headerlink" title="cf16-final J Neue Spiel"></a>cf16-final J Neue Spiel</h4><blockquote><p>小 T 有一张 $n\times n$ 的棋盘和很多硬币. 他想把硬币都放到棋盘上, 使得每个格子上恰好有一枚硬币.<br>每次操作, 小 T 会将一枚硬币放在这些在棋盘外面且与某个格子相邻的位置, 之后按照往棋盘内的方向推硬币, 直到该枚硬币恰好位于格子内为止. 若格子上已经有另外一枚硬币, 则那枚硬币也会被往里推一个格子. 如果有硬币被推出棋盘外则视为失败.<br>小 T 对每个棋盘外面的位置 $U_i, D_i, L_i, R_i$ 都分别写上了一个非负整数 $U_i, D_i, L_i, R_i$ , 表示在这个位置进行操作的次数. 但在写完数之后, 小 T 发现他并不能很快找出一组合法的方案, 你能帮他找到吗?<br>无解输出 NO.<br>$1\le n \le 300$ .</p></blockquote><p>考虑这个挤的过程等价于我们找到第一个不空的位置放上. 那么我们可以先考虑每个硬币是从哪个边界上过来的再去构造方案. 那么每个硬币从哪来的这件事可以简单网络流经典算法, 而安排顺序则比较困难, 每个硬币放的时候要求在它到它的边缘间的所有硬币都已经放上了, 那么如果 $D_i&#x3D;R_i&#x3D;0$ 我们可以随便拓扑排序之类的.</p><p>但一般情况下, 这种依赖关系会成环, 但如果我们找到这样一个环, 只要把每个环上的硬币对应的边缘换成依赖环上后继(下一个)对应的边缘, 转一下就能把它消掉. 如图, 箭头为从哪条边过来.</p><p><img src="/img/2022-07-18-21-34-18-image.png"></p><p>考虑如何扫环, $n^2$ 个点和边上找环大概是 $n^4$ 之类的, 这里有一种更好的方式: 我们从某个硬币开始dfs, 如果遍历了它所有依赖仍然没有环那就把处理完这个点了, 否则我们就在找到环后立刻把环消了, 这样的好处时我们花费的总代价是 $n^2+\sum len$ , $len$ 为环长, 而 $\sum len\le n^3$ , 于是就解决了.</p><h4 id="UOJ431-time-map"><a href="#UOJ431-time-map" class="headerlink" title="UOJ431 time map"></a>UOJ431 time map</h4><blockquote><p>给一棵广义线段树, 它维护长 $n$ 的序列 $a$ . 节点 $i$ 的值 $val_i$ 为其所管辖的区间与, 支持:</p><ul><li>区间与 $x$ </li><li>区间或 $x$ </li><li>区间异或 $x$ </li><li>询问从 $l, r$ 开始走, 若 $popcount(val_i)&amp;1$ 则走左儿子否则走右儿子, 走到的这条链的权值和.<br>$n\le 10^6, v\le 10^5$</li></ul></blockquote><p>首先由于区间与的性质, 从任何一个节点出发走都只有 $\log v$ 种不同的取值, 启示我们利用这个性质, 每次走的时候走一条链, 且走的方向是相同的, 那如果我们建一棵正常线段树维护区间与就可以二分倍增找到一段, 而区间与, 或, 异或可以打标记, 标记维护子树所有点都被 $((x \mathrm{and} a) \mathrm{or} b) \mathrm{xor} c$ 的 $a, b, c$ 即可. 由于要二分 $\log$ 次, 每次判定时要 $\log$ 查询区间与所以复杂度 $n\log^3 n$ .</p><p>然后考虑由于每次走一条链的过程中有一个端点是不动的, 可以先在线段树上二分到与不变的区间, 之后在链上倍增就是 $O(1)$ 的了, 复杂度 $n\log ^2 n$ .</p><h4 id="UOJ425-strings"><a href="#UOJ425-strings" class="headerlink" title="UOJ425 strings"></a>UOJ425 strings</h4><blockquote><p>给定长 $n$ 的 $q$ 个模式串, 每个位置可以是01? , 表示匹配0, 1或者任意字符, 现在求有多少长 $n$ 的字符串可以至少匹配其中的一个.<br>$n\le 30, q\le 100$ </p></blockquote><p>大力暴力, 发现我们至少枚举前26位都爆炸不了. 于是先枚举前24位, 对每场考试预处理一个bitset表示后6位为 $x$ 是否可行, 那么只要直接把前面匹配的字符串对应的bitset并起来, 把对应的bitset并起来求popcount即可. 复杂度 $O(2^(n-6)\dfrac{q}{w})$ .</p><p>接着优化, 现在的问题是每次枚举后要对所有考试分别check, 我们维护一个bitset表示当前还有哪些考试是对的, 那么填01时可以直接与上一个什么东西, 接下来要根据这个bitset判断后6位, 方法是每 $\log$ 个分块, 处理每块内的所有可能方案对应的或即可.</p><h4 id="UOJ327-去月球"><a href="#UOJ327-去月球" class="headerlink" title="UOJ327 去月球"></a>UOJ327 去月球</h4><blockquote><p>给定一个长 $n$ 序列, 每次询问对于区间 $[l, r]$ 中的数, 若每次可以删除相邻相等的两个数, 最多删多少次.<br>$n\le 10^5, m\le 2\times 10^6$ . 强制在线.</p></blockquote><p>这玩意居然可差分? !</p><p>$[l, r]$ 的答案为 $reverse([1, l-1])*[1, r]-(l-1)$ , 这里乘法指串接起来的答案, 因为把前面那段反过来后就自己和自己消掉了.</p><p>而这个等价于问两个前缀的lcp, 于是插到trie上去求lca, 建立trie很简单因为每次相对于上一次插入的地方只可能回到父亲或走到一个儿子.</p><p>最后在trie上lca, 复杂度是1log或线性.</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="比赛题-3"><a href="#比赛题-3" class="headerlink" title="比赛题"></a>比赛题</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><blockquote><p>给定 $n$ 个点 $(x, y)$ , 距离为曼哈顿距离, 求平面最大生成树.<br>$n\le 2\times 10^6$ . $\vert x_i \vert , \vert y_i \vert \le 10^8$ .</p></blockquote><p>首先因为是最大生成树, 而对于所有点, 其最远点一定是四个点中的一个, 直接做不好考虑的话可以考虑转化成切比雪夫距离, 那么离每个点最远的就是最上面最下面最左边最右边的四个点中的一个, 如果有多个同为最大任选一个是不劣的, 于是有一种构造方法是每个点只和这四个点连边, 这四个点间两两连边跑 Kruskal.</p><p>然而还是较难通过, 考虑Brovka, 看起来仍然是 $n\log n$ , 但实际上如果写了发现其实只会跑两轮, 因为每个点都向那四个点连边, 所以一轮过后其实只剩最多两个连通块.</p><h4 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h4><p>首先看出是dp, b序列可以看成大小限制, 根据大小关系就可以建出一棵大根笛卡尔树, 这里一定是一棵树在于:</p><ul><li>保证有解的偏序关系不可能成环.</li><li>对于一条偏序链, 有用的其实是那个最长路, 所以有用的边是以每个点结尾的最长路. 只保留这些边就是树了.</li></ul><p>于是在这棵树上dp, 设 $f_{i, j}$ 表示 $i$ 子树根节点为 $j$ 的方案数. 利用前缀和复杂度为 $O(nm)$ </p><p>此外, 注意到答案是关于 $m$ 的 $O(n)$ 次多项式, 所以再拉插可以做到 $n^2$ .</p><h4 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h4><p>考虑建出整个字符串的后缀自动机, 那么考虑成为重要节点的标准, 在建出后缀树后:</p><ul><li>必然是后缀自动机某节点代表的最长的, 显然.</li><li>存在两个以上非空child的一定重要, 因为它child就是包含它的, 每个child出现至少一次所以它的出现次数一定多余自己两个child</li><li>只有一个非空child, 只有当它是全局的后缀时才重要, 否则它的出现次数等于孩子的出现次数, 就不变.</li><li>没有child, 一定重要, 因为显然只有整个字符串没有child.</li></ul><p>我们每次加入一个字符就重判一遍就有了 $n^2$ .</p><p>如果数据随机, 那么只要长度超过 $O(\log n)$ , 大概率只会出现一次, 会直接被全串干掉, 所以只维护出现次数超过一次的 $O(n)$ .</p><p>对于第一种情况, 我们发现每个节点只会从不重要变成重要一次, 可以直接开个变量维护, 也就是在设置其link的时候顺便看父亲.</p><p>接下来考虑正解, 考虑维护parent tree的结构, 考虑新加节点的时候:</p><ul><li>我们新建了一个叶子</li><li>可能会在clone过程中, 在一个点和它父亲间插入一个新点</li><li>反转儿子状态(儿子数 $0\to 1, 1\to 2$ )</li><li>查询一个节点到根的路径上1的个数</li></ul><p>可以LCT简单解决.</p><p>然而LCT跑1e6很困难, 考虑树的形态只有clone时才会变化, 且是把子树深度加1, 看能不能用常数更小的数据结构干, 我们将所有操作反过来做, 这样的好处是我们不需要加点, 而删点只要把这里的点设为0即可, 这样是单点修改区间查询的树剖, 发现我们只在乎从整串跳parent跳到根这条链, 于是就做完了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOI系列题目</title>
      <link href="/2022/07/30/noi_problems/"/>
      <url>/2022/07/30/noi_problems/</url>
      
        <content type="html"><![CDATA[<h1 id="NOI系列刷题"><a href="#NOI系列刷题" class="headerlink" title="NOI系列刷题"></a>NOI系列刷题</h1><h3 id="P7738-NOI2021-量子通信-乱搞"><a href="#P7738-NOI2021-量子通信-乱搞" class="headerlink" title="P7738 [NOI2021] 量子通信 [乱搞]"></a>P7738 [NOI2021] 量子通信 [乱搞]</h3><blockquote><p>给定一个 $n$ 个单词的字典, 每个单词为长256的01串, $q$ 次询问一个串是否可以由字典中的串翻转 $k$ 位得到.<br>$n\le 4\times 10^5, q\le 1. 2\times 10^5, k\le 15$ ,<strong>字典是随机生成的</strong>.</p></blockquote><p>没看输入格式的时候没有意识到字典是随机生成的, 想了些字典树上dp之类的东西. 没想到其实是个乱搞题.</p><p><strong>如果把每个单词每16位一组分成16组, 那么翻转15位的情况下至少有一组是相同的</strong>. 所以对于询问的串直接枚举是哪一位相同, 字典里这一位恰好相同的只有 $\dfrac{n}{65536}$ 个, 于是复杂度就是 $\dfrac{nq}{256}$ .</p><p>最后的问题就是如何快速找到字典里确定了某一组所有单词, 用vector存即可. 不要智障的打算插入到set&#x2F;map&#x2F;有序数组里就不会TLE.</p><h3 id="P7737-NOI2021-庆典-图论-tarjan-虚树-拓扑排序"><a href="#P7737-NOI2021-庆典-图论-tarjan-虚树-拓扑排序" class="headerlink" title="P7737 [NOI2021] 庆典 [图论] [tarjan] [虚树] [拓扑排序]"></a>P7737 [NOI2021] 庆典 [图论] [tarjan] [虚树] [拓扑排序]</h3><blockquote><p>给定一张 $n$ 点 $m$ 边有向图, 记 $a\Rightarrow b$ 表示 $a$ 可以走到 $b$ , 那么若有 $x\Rightarrow z, y\Rightarrow z$ 则一定有 $x\Rightarrow y$ 或 $y\Rightarrow x$ .<br>有 $q$ 次询问, 每次额外添加 $k$ 条边, 询问从 $s$ 到 $t$ 的路径<strong>可以</strong>经过多少点. 询问间独立. 新添加的边可以不满足原图的限制.<br>可以经过指有一条从 $s$ 到 $t$ 的路径经过这个点.<br>$n, q\le 3\times 10^5, m\le 6\times 10^5, k\le 2$ . 保证在把有向图视为无向图后图连通.</p></blockquote><p>有一个简单暴力, 一个点能出现在路径上当且仅当它能到达终点且反图上能到起点. 所以就在正图和反图分别处理每个点能到哪些点, 每次暴力判就好了. 复杂度 $O(nm)$ </p><p>首先发现缩点是不影响答案的, 先缩SCC, 图变成了DAG.</p><p>考虑能不能想办法把DAG搞成树, 发现因为原图的限制, 若有边 $x\to z, y\to z, x\to y$ 我们可以删掉边 $x\to z$ . 也就是说, 每个点的入边可以只留一条, 于是就成了一棵树. 具体的, DAG上应该只保留拓扑序最晚的即可.</p><p>如果 $k&#x3D;0$ , 那么求的就是一条链上的SCC大小的和. 但现在我们的树上又多了两条边, 产生了114514种分类讨论, 于是有另一种做法: 把两条边的端点以及询问的起点终点这6个点建一棵虚树, 再连上新加的两条边, 在这个小的DAG上跑一开始那个暴力, 复杂度 $n\log n$ , 瓶颈在于求lca和虚树.</p><p>200+行代码预警</p><h3 id="P1224-NOI2013-向量内积"><a href="#P1224-NOI2013-向量内积" class="headerlink" title="P1224 [NOI2013] 向量内积"></a>P1224 [NOI2013] 向量内积</h3><blockquote><p>给定 $n$ 个 $d$ 维向量, $q$ 次询问找出两个向量点积为 $k$ 的倍数, 或者判断无解.</p><p>$k\in {2, 3}$ , 复杂度 $nd^2$ </p></blockquote><p>首先 $k$ 只有两个想到分类讨论:</p><h4 id="若-k-x3D-2"><a href="#若-k-x3D-2" class="headerlink" title="若 $k&#x3D;2$ :"></a>若 $k&#x3D;2$ :</h4><p>重点是<strong>结合律可以改变矩阵的运算代价</strong>.</p><p>把 $n$ 个向量排成矩阵 $A$ , 则无解当且仅当 $AA^T$ 所有位置都为 $1\pmod 2$ </p><p>然而直接 $AA^T$ 复杂度是 $n^3$ 爆炸, 考虑不精准判断, 这里的奇妙之处在于拿一个 $1\times n$ 向量 $R$ 乘上它们: 若 $RAA^T$ 中有一个位置不等于原来 $R$ 的和则对应 $AA^T$ 中的一列中有一个 $1$ , 在其中判断即可. 而且 $RAA^T&#x3D;(RA)A^T$ , 复杂度 $nd$ </p><h4 id="若-k-x3D-3"><a href="#若-k-x3D-3" class="headerlink" title="若 $k&#x3D;3$ :"></a>若 $k&#x3D;3$ :</h4><p>有了 $k&#x3D;2$ 后考虑膜3意义下每个数都平方后就又成了01矩阵, 设 $B&#x3D;AA^T$ , 则要得到 $B_{i, j}^2r_i&#x3D;B_{i, j}r_i B^T_{j, i}$ . 所以把 $r$ 变成只有一个对角的 $n\times n$ 矩阵 $R$ , 则 $BRB^T$ 的对角线就是所有 $B^2_{i, j}r_i$ 了.</p><p>然后因为这三个都是 $n\times n$ 的不能直接乘, 而是要变成 $AA^TRAA^T&#x3D;(A(A^T(RA)))A^T$ , 并且最后一次矩阵乘的时候只计算对角线, 复杂度 $nd^2$ .</p><p>为了保证正确率可以多随几次, 就通过本题了.</p><h3 id="P6772-NOI2020-美食家"><a href="#P6772-NOI2020-美食家" class="headerlink" title="P6772 [NOI2020] 美食家"></a>P6772 [NOI2020] 美食家</h3><blockquote><p>精灵王国共有 $n$ 座城市, 城市从 $1$ 到 $n$ 编号, 其中城市 $i$ 的美食能为小 W 提供 $c_i$ 的愉悦值. 精灵王国的城市通过 $m$ 条<strong>单向道路</strong>连接, 道路从 $1$ 到 $m$ 编号, 其中道路 $i$ 的起点为城市 $u_i$ , 终点为城市 $v_i$ , 沿它通行需要花费 $w_i$ 天. 也就是说, 若小 W 在第 $d$ 天从城市 $u_i$ 沿道路 $i$ 通行, 那么他会在第 $d + w_i$ 天到达城市 $v_i$ .</p><p>小 W 计划在精灵王国进行一场为期 $T$ 天的旅行, 更具体地: 他会在第 $0$ 天从城市 $1$ 出发, 经过 $T$ 天的旅行, 最终在<strong>恰好第 $T$ 天</strong>回到城市 $1$ 结束旅行. 由于小 W 是一位美食家, 每当他到达一座城市时(包括第 $0$ 天和第 $T$ 天的城市 $1$ ), 他都会品尝该城市的美食并获得其所提供的愉悦值, 若小 W 多次到达同一座城市, 他将<strong>获得多次愉悦值</strong>. 注意旅行途中小 W<strong>不能在任何城市停留</strong>, 即当他到达一座城市且还未结束旅行时, 他当天必须立即从该城市出发前往其他城市.</p><p>此外, 精灵王国会在<strong>不同</strong>的时间举办 $k$ 次美食节. 具体来说, 第 $i$ 次美食节将于第 $t_i$ 天在城市 $x_i$ 举办, 若小 W 第 $t_i$ 天时恰好在城市 $x_i$ , 那么他在品尝城市 $x_i$ 的美食时会<strong>额外得到</strong> $y_i$ 的愉悦值. 现在小 W 想请作为精灵王国接待使者的你帮他算出, 他在旅行中能获得的愉悦值之和的<strong>最大值</strong>.</p><p>对于所有测试点, $1 \leq n \leq 50$ , $n \leq m \leq 501$ , $0 \leq k \leq 200$ , $1 \leq t_i \leq T \leq 10^9$ , $1 \leq w_i \leq 5$ , $1 \leq c_i \leq 52501$ , $1 \leq u_i, v_i, x_i \leq n$ , $1 \leq y_i \leq 10^9$ .</p></blockquote><p>在这图上走是随便走的, 使得大部分处理路径的科技不能用, 而看看数据范围想到邻接矩阵自乘的trick.</p><p>但这张图上是点权而不是点权, 朴素的把点权转移到入边上再特判起点.</p><p>但我们不是求路径条数, 定义矩阵乘法为外 $\max$ 内加.</p><p>但边有通过时间, 拆边复杂度很高. 于是把一个点拆成5个用, 不能共用一共5个点是因为要区分从哪里走进来的.</p><p>对于美食节在相邻两次之间用矩阵快速幂即可.</p><p>复杂度看起来过不了实际能过.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LJC讲dp</title>
      <link href="/2022/07/08/note_of_ljcclass/"/>
      <url>/2022/07/08/note_of_ljcclass/</url>
      
        <content type="html"><![CDATA[<h1 id="LJC讲dp"><a href="#LJC讲dp" class="headerlink" title="LJC讲dp"></a>LJC讲dp</h1><h2 id="sdfzoj-contest2-但当我用上了换行"><a href="#sdfzoj-contest2-但当我用上了换行" class="headerlink" title="sdfzoj contest2 但当我用上了换行"></a>sdfzoj contest2 但当我用上了换行</h2><blockquote><p> 给 $n$ 个长 $T$ 模式串, 含能匹配任何一个字符的通配符, 求有多少个字符串 $S$ 能匹配其中恰好 $k$ 个模式串. $n\le15, \vert T \vert \le50$ </p></blockquote><p>首先考虑了一个容斥做法, 算能匹配每一个模式串子集的方案数再容斥就结束了.</p><p>不过还有个DP, 如果设 $f_{i, S}$ 表示考虑前 $i$ 位能匹配集合 $S$ 的方案数, 转移就是枚举这一位填谁, 然后根据这个算能满足哪些模式串, 复杂度应该是 $O(26\times2^n  \vert S \vert n)$ , 但是很容易发现卡不满, 据说实际上跑的飞快.</p><p>感觉这个dp做法的对所有串同时考虑的想法还挺不错?</p><h2 id="sdfzoj-contest0-T1"><a href="#sdfzoj-contest0-T1" class="headerlink" title="sdfzoj contest0 T1"></a>sdfzoj contest0 T1</h2><blockquote><p>给一个数列 $A$ , 若一个位置为 $-1$ 表示你可以随便填, 求最长上升子序列长度. $n\le 10^6$ </p></blockquote><p>先给每个位置减去它的下标, 就可以是求最长不降子序列了, 考虑此时我们可以任意在两个元素间插入一个-1, 所以直接不带-1求最长不降子序列然后加上-1的个数. 这是对的吗?</p><p>然而是不对的, 这个每个位置减下标的结论只对整个序列才管用, 正确的做法是每个位置减去前面的-1的个数, 因为必然存在一个最优解使用了所有-1, 那么我们就强制不能把-1挤掉, 也就是选数的时候相邻两数之差大于等于之间-1个数, 这么做就过了.        </p><h2 id="P7961-NOIP2021-数列"><a href="#P7961-NOIP2021-数列" class="headerlink" title="P7961 [NOIP2021] 数列"></a>P7961 [NOIP2021] 数列</h2><blockquote><p>给定整数 $n, m, k$ 和一个长度为 $m+1$ 的正整数数组 $v0, v1, …, vm$ .</p><p>对于一个长度为 $n$ , 下标从 $1$ 开始且每个元素均不超过 $m$ 的非负整数序列 ${ai}$ , 我们定义它的权值为 $va1 \times va2 \times ⋯ \times van$ .</p><p>当这样的序列 ${a_i}$ 满足整数 $S&#x3D;2^{a_1}+2^{a_2}+⋯+2^{a_n}$ 的二进制表示中 1 的个数不超过 $k$ 时, 我们认为 ${a_i}$ 是一个合法序列.</p><p>计算所有合法序列 ${a_i}$ 的权值和对 $998244353$ 取模的结果.</p></blockquote><p>由于是二进制使得我们倾向于按二进制从低位向高位选, 也就相当于我们把 $a$ 按值域顺序考虑, 那么可以把题目做一个转化, 变成我们有长 $m$ 的序列中选长 $n$ 的下标序列, 那么考虑设 $f_{i, j, x, y}$ 表示已经考虑到二进制的第 $i$ 位, 已经选了 $j$ 个, 二进制下前面有 $x$ 个1, 同时这一位上积累的进位是 $y$ , 这里 $y$ 不一定是1, 也可能积累了一堆, 总之是留着后面进位的. 那么转移就是我们枚举选的最后一个:</p><p>$$<br>f_{i, j, k, l}\times \binom {m-j}{o}\times v_i^o\to f_{i-1, j-o, k+l\mathrm{and}1, o+\frac{l}{2}}<br>$$ </p><p>就做完了</p><h2 id="spoj19-sdfzoj-contest-2-我仿佛"><a href="#spoj19-sdfzoj-contest-2-我仿佛" class="headerlink" title="spoj19. [sdfzoj contest #2]我仿佛"></a>spoj19. [sdfzoj contest #2]我仿佛</h2><blockquote><p>给 $m$ 个区间, 让每个区间里有切仅有一个关键点, 最大化关键点个数.</p></blockquote><p>序列上这类选点问题常常设 $f_i$ 表示强制选 $i$ 的情况下的答案, 那么考虑 $f_i$ 可以从哪里转移过来, 当前到 $i$ 的情况下, 一个区间 $[l, r]$ 共有3类:</p><ul><li><p>不包含 $i$ 且在右边, 显然不用管</p></li><li><p>包含 $i$ , 那么转移过来的位置显然要满足 $j&lt;l$ </p></li><li><p>不包含 $i$ 且在左边, 要求满足 $j\ge l$ ,</p></li></ul><p>对于第二个限制, 要求覆盖每个位置的区间的最左的左端点, 可以线段树区间取min解决.</p><p>对于第三个限制, 要求右端点小于 $i$ 的左端点最大值, 把它按 $r$ 排序, 每次加入小于 $i$ 的, 扫着维护就行了.</p><h2 id="P7962-NOIP2021-方差"><a href="#P7962-NOIP2021-方差" class="headerlink" title="P7962 [NOIP2021] 方差"></a>P7962 [NOIP2021] 方差</h2><blockquote><p>给一个序列, 你可以进行任意多次让 $a_i&#x3D;a_{i+1}+a_{i-1}-a_i$ , 最小化数组方差.</p><p>$n\le 400, a_i\le 600$ 或 $n\le 10^4, a_i\le 50$ </p></blockquote><p>首先这个操作相当于交换相邻两项差分, 那么也就是我们可以任意重排差分数组.</p><p>经过一番玄学发现方差数组是单谷的. 感性理解就是平均值一定是值域中间的, 那么你希望更多的数接近平均值, 所以就中间小两边大. 那么从小到大加入方差时就是选择每次加到头上或尾巴上.</p><p>众所周知</p><p>$$<br>n^2s^2&#x3D;<br>n\sum a_i^2-(\sum a_i)^2<br>$$ </p><p>我们很难直接维护这个两项相减的东西, 所以把一个记录到状态里, 设 $f_{i, j}$ 表示加入前 $i$ 个差分而和为 $j$ 的情况, 再设 $s_i&#x3D;\sum_j^i d_j$ 为这一项的大小, 此时有两种转移:</p><ul><li><p>新数加到前面: $f_{i-1, j}+2xd_i+id_i^2\to f_{i, j+i\times d_i}$ </p></li><li><p>新数加到后面 $f_{i-1, j}+s_i^2\to f_{i, j+s_i}$</p></li></ul><p>然后现在得到一个 $n^2a$ 的解法, 考虑 $n$ 很大时序列中很多都是0, 因为序列是不降的所以0一定在中间, 那么只要把0都跳过去就成了 $na^2$ .</p><h2 id="P2569-SCOI2010-股票交易"><a href="#P2569-SCOI2010-股票交易" class="headerlink" title="P2569 [SCOI2010]股票交易"></a>P2569 [SCOI2010]股票交易</h2><blockquote><p>最近 $\text{lxhgww}$ 又迷上了投资股票, 通过一段时间的观察和学习, 他总结出了股票行情的一些规律.</p><p>通过一段时间的观察, $\text{lxhgww}$ 预测到了未来 $T$ 天内某只股票的走势, 第 $i$ 天的股票买入价为每股 $AP_i$ , 第 $i$ 天的股票卖出价为每股 $BP_i$ (数据保证对于每个 $i$ , 都有 $AP_i \geq BP_i$ ), 但是每天不能无限制地交易, 于是股票交易所规定第 $i$ 天的一次买入至多只能购买 $AS_i$ 股, 一次卖出至多只能卖出 $BS_i$ 股.</p><p>另外, 股票交易所还制定了两个规定. 为了避免大家疯狂交易, 股票交易所规定在两次交易(某一天的买入或者卖出均算是一次交易)之间, 至少要间隔 $W$ 天, 也就是说如果在第 $i$ 天发生了交易, 那么从第 $i+1$ 天到第 $i+W$ 天, 均不能发生交易. 同时, 为了避免垄断, 股票交易所还规定在任何时间, 一个人的手里的股票数不能超过 $\text{MaxP}$ .</p><p>在第 $1$ 天之前, $\text{lxhgww}$ 手里有一大笔钱(可以认为钱的数目无限), 但是没有任何股票, 当然, $T$ 天以后, $\text{lxhgww}$ 想要赚到最多的钱, 聪明的程序员们, 你们能帮助他吗?</p><p>对于 $100%$ 的数据, $0\leq W&lt;T\leq 2000, 1\leq\text{MaxP}\leq2000$ </p><p>对于所有的数据, $1\leq BP_i\leq AP_i\leq 1000, 1\leq AS_i, BS_i\leq\text{MaxP}$ </p></blockquote><p>容易想到设 $f_{i, j}$ 表示到第 $i$ 天有 $j$ 股时最大收益. 转移:</p><ul><li><p>从这一天第一次买入这么多: $f_{i, j}&#x3D;-AP_i\times j$ </p></li><li><p>这一天什么也没干: $f_{i, j}&#x3D;f_{i-1, j}$ </p></li><li><p>买进了一些 $f_{i, j}&#x3D;f_{i-w-1, j-k}-k\times AP_i\ s. t. \ 0&lt;k\le \min(j, AS_i)$ </p></li><li><p>买出了一些 $f_{i, j}&#x3D;f_{i-w-1, j+k}+k\times BP_i\ s. t. \ 0&lt;k\le min(BS_i, MaxP-j)$</p></li></ul><p>由于有第二个的转移所以我们可以只从 $i-w-1$ 天转移过来而不用再枚举哪一天.</p><p>然后这样复杂度三次方, 可以通过单调队列优化成二次方.</p><h2 id="P8352-SDOI-x2F-SXOI2022-小-N-的独立集"><a href="#P8352-SDOI-x2F-SXOI2022-小-N-的独立集" class="headerlink" title="P8352 [SDOI&#x2F;SXOI2022] 小 N 的独立集"></a>P8352 [SDOI&#x2F;SXOI2022] 小 N 的独立集</h2><blockquote><p>给一棵树, 对每个 $v\in [0, nk]$ 计数 $n$ 个点每个点点权在 $[1, k]$ 之间的最大独立集为 $v$ 的方案数.</p><p>$n\le 1000, k\le 5$ </p></blockquote><p>由于一个广为人知的求最大独立集的dp, 让我们想到设 $f_{u, i, j}$ 表示对于 $u$ 的子树, 选了的最大独立集为 $i$ , 不选为 $j$ 的方案数.</p><p>直接数状态数的话 $i, j\le nk$ , 总状态数是 $n^3k^4$ 的, 但是可以分析 $j\le i\le j+k$ </p><ul><li><p>$i\le j+k$ 是因为根本不会有这个样的合法状况, 如果不选 $u$ 的时候最大为 $j$ 那么加上 $u$ 一定不会增加超过 $k$ .</p></li><li><p>$i\ge j$ 是因为若 $i&lt; j$ 那么最大独立集一定和 $i$ 没关系, 因为不选的限制显然是弱于选的限制的, 那么可以把所有这些压到一起处理.</p></li></ul><p>状态数成 $n^2k^2$ 了</p><p>然后再有个优化, 直接转移的话式子显然是</p><p>$$<br>f_{v, x, y}f_{u, i, j}\to f_{u, i+y, j+\max(x, y)}<br>$$ </p><p>复杂度 $n^4k^4$ , 但实际上我们的 $j, y$ 可以只枚举到 $k$ 倍对应子树大小, 看起来这个优化是玄学的, 但实际上可以分析: 记 $u$ 子树大小为 $siz_u$ , 此时我们合并一个子树到 $u$ 的复杂度为 $siz_v\times(siz_u-siz_v)\times k^2$ , 相当于一个点在 $v$ 内, 一个点在 $v$ 外的点对数量, 所以我们的复杂度可以类比过来, 考虑我们以后就再也不会枚举到 $u$ 子树内两个点的点对了, 那么每个点对只在他们的 lca 处被计算了一次, 点对个数是 $n^2$ 的, 所以总复杂度是 $n^2k^2$ 的啊.</p><p>然后就过了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> dp </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数数</title>
      <link href="/2022/07/02/count/"/>
      <url>/2022/07/02/count/</url>
      
        <content type="html"><![CDATA[<h1 id="数数题"><a href="#数数题" class="headerlink" title="数数题"></a>数数题</h1><p>会把计数相关问题放在这里.</p><p>一做数数发现现在已经不会做蓝题了.</p><h2 id="1-Appleblue17"><a href="#1-Appleblue17" class="headerlink" title="1. Appleblue17"></a>1. Appleblue17</h2><p>这一部分是appleblue17的cf和其他数数选做里的前几个.</p><h3 id="CF1515E-Phoenix-and-Computers"><a href="#CF1515E-Phoenix-and-Computers" class="headerlink" title="CF1515E Phoenix and Computers"></a>CF1515E Phoenix and Computers</h3><blockquote><p>有 $n$ 台电脑排成一排, 每次可以手动打开一台没被打开的, 同时若一台电脑左右的电脑都被打开, 那么它会自动打开. 求把所有电脑打开的方案数. $n\le 400$ </p></blockquote><p>发现自动打开的电脑两边一定是手动打开的, 即它们不可能相邻, 所以其实是若干段手动打开的, 段段之间夹着一个自动打开的.</p><p>手动打开一个连续区间的方案数是 $2^{len-1}$ , 原因是我们每次只能像左边和右边拓展, 那么设第一个打开的是第 $k$ 个, 方案就是在剩下 $len-1$ 步中选 $k-1$ 步是向左拓展的, 所以方案数是</p><p>$$<br>\sum_{k&#x3D;1}^{len} \binom{len-1}{k-1}&#x3D;2^{n-1}<br>$$ </p><p>那么把一个自动打开的和紧跟着的一段手动打开的作为一段, 设 $f_i$ 表示前 $i$ 个的方案, 则加上一个新段的方案数时除了乘上这一段的方案, 还要再在总步数里选若干步是新的这段的方案, 那么我们要知道总步数, 所以还要记录总步数或者之前分了几段, 增加一维, 设 $f_{i, j}$ 表示前 $i$ 个分了 $j$ 段, 转移就是</p><p>$$<br>f_{i, j}&#x3D;f_{k-1, j-1}\times \binom {i-j+1}{i-k}\times 2^{i-k+1}\<br>f_{-1, 0}&#x3D;1<br>$$ </p><p>要把0当成一个自动开启的电脑留出来, 所以边界就成了-1, 实际实现可以所有下标一起加一</p><h3 id="P6944-x2F-LOJ3405-ICPC2018-WF-Gem-Island"><a href="#P6944-x2F-LOJ3405-ICPC2018-WF-Gem-Island" class="headerlink" title="P6944&#x2F;LOJ3405 [ICPC2018 WF]Gem Island"></a>P6944&#x2F;LOJ3405 [ICPC2018 WF]Gem Island</h3><blockquote><p>有 $n$ 个人每个人有一个宝石, 每天会随机一个宝石分裂成两个, 求 $d$ 天后拥有宝石前 $r$ 多的人所拥有的宝石数之和的期望, 不膜. $n, d\le 500$ </p></blockquote><p>设序列 $A$ , $a_i$ 表示 $d$ 天后第 $i$ 个人拥有的宝石数, 试着算算它出现的概率.</p><p>$$<br>\begin{aligned}<br>\text{A的方案数}&amp;&#x3D;\dfrac {d! }{\prod_i (a_i-1)! }\times \prod(a_i-1)! \<br>&amp;&#x3D;d!<br>\end{aligned}<br>$$ </p><p>解释一下这个式子:</p><ul><li><p>乘号左边的部分是我们确定下来每一天是给哪个人加的, 这个过程相当于对于一个天数构成的排列对一个排列我们让前 $1-a_1$ 个给第一个人, 接下来 $a_2$ 个给第二个人. . . 再除掉这么每一组分组后组内相对顺序.</p></li><li><p>乘号右边的部分是把每天由谁得这个关于人的方案数再变成关于宝石的方案数, 考虑一个人第 $i$ 次收获宝石的方案数是 $i-1$ , 那么这个人 $i$ 得到宝石的方案数就是 $(a_i-1)!$ 再乘起来.</p></li></ul><p>于是发现每个 $A$ 的概率是相同的, 那么接下来就是算对于所有的 $A$ 它们的前 $r$ 大之和, 先考虑如何求 $A$ 的方案数, 此时可以先减去每个人一开始有的那个宝石方便计算:</p><p>这时有一种十分奇妙的状态设计, 考虑由于我们不关心 $a_i$ 的顺序, 所以我们假定它是递减的, 我们把宝石排成一个矩阵, 第 $i$ 列表示第 $i$ 个人的情况, 像这个样:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">****</span><br><span class="line">******</span><br><span class="line">*********</span><br><span class="line">*********</span><br><span class="line">***********</span><br><span class="line">***********</span><br></pre></td></tr></table></figure><p>这个图对应的 $A$ 是 $6, 6, 6, 6, 5, 5, 4, 4, 4, 2, 2$ </p><p>横着关于人递推是困难的, 于是把它竖着递推, 由于此时向上递推时更高的顶大小一定小于更低的所以我们要知道顶的大小, 由于最后要求 $\sum a_i&#x3D;d$ 所以要记录和, 于是设 $f_{i, j}$ 表示一共有 $j$ 个宝石, 其中有顶有 $i$ 个的方案数, 那么转移就是枚举上一层的大小, 即</p><p>$$<br>\begin{aligned}<br>f_{i, j}&amp;&#x3D;\sum f_{k, j-i}\times\binom{k}{i}\<br>f_{n, 0}&amp;&#x3D;1<br>\end{aligned}<br>$$ </p><p>可以类比这个列出和的, 设顶大小为 $i$ , 共 $j$ 个的所有情况前 $r$ 大和的和为 $g_{i, j}$ , 则有转移:</p><p>$$<br>\begin{aligned}<br>g_{i, j}&amp;&#x3D;\sum (g_{k, j-k}+f_{k, j-k}*min(r, i))*\binom{k}{i}\<br>g_{n, 0}&amp;&#x3D;0<br>\end{aligned}<br>$$ </p><p>然后dp就行了, 这个题不膜, 要直接带着long double从头算到尾.</p><h3 id="CF1630E-Expected-Components"><a href="#CF1630E-Expected-Components" class="headerlink" title="CF1630E Expected Components"></a>CF1630E Expected Components</h3><p>收录到<a href="https://fireinicecode.github.io/2022/07/01/polya/">polya定理初学</a>中</p><h3 id="ARC132E-Paw"><a href="#ARC132E-Paw" class="headerlink" title="ARC132E Paw"></a>ARC132E Paw</h3><blockquote><p>给定字符串 $s$ 包含 $\texttt{&lt; &gt; . }$ 三种, 表示向左的足迹, 向右的足迹和洞. 你每次会随机一个洞钻出来, 把洞填平, 然后随机左右两个方向走到下一个洞或走出字符串, 并把沿途所有位置都覆盖为你走的方向的足迹(沿途不包括你停止的那个洞). 直到没有洞. 求最后局面向左足迹的期望个数.<br>$\vert s\vert \le 10^5$</p></blockquote><p>这种题要考虑形成局面的性质.</p><p>发现我们最后的局面一定是 $\texttt{&lt;&lt;\ldots&lt;&lt;. &#x3D;&#x3D;\ldots&#x3D;&#x3D;. &gt;&gt;\ldots&gt;&gt;}$ , 且 $\texttt{&#x3D;}$ 两边两个洞中间没有洞, 这里 $&#x3D;$ 表示未走过的地方. 因为考虑不会出现 $\texttt{&gt;&gt;&lt;&lt;}$ 的情况是因为停止需要一个洞, 而由这个洞出发的时候要么覆盖顺延右边的 $\texttt{&lt;}$ 的要么顺延左边的, 一定会把这个局面填掉. 不会出现 $\texttt{&lt;&lt;&gt;&gt;}$ 因为这个点在出发一个之后就没了不能出发一个相反的, 所以局面只能是相邻两个洞向外发出的足迹.</p><p>那么枚举相邻两个洞, 考虑形成这个局面的概率, 发现左右是独立的, 以向右部分为例, 若 $f_i$ 表示向右形成前 $i$ 个的全局概率(所有方案中右边是对的的概率), 则有 $f_i&#x3D;f_{i-1}\times (1-\dfrac{1}{2n})$ , 意思是只有选到 $i$ 这个位置并且向左走不行. 发现直接把左右两边对应概率乘起来即可因为两边都是全局的概率且互不影响.</p><h3 id="CF1621G-Weighted-Increasing-Subsequences"><a href="#CF1621G-Weighted-Increasing-Subsequences" class="headerlink" title="CF1621G Weighted Increasing Subsequences"></a>CF1621G Weighted Increasing Subsequences</h3><blockquote><p>给定 $a_n$ , 对于 $a$ 的所有上升子序列 $a_{i_1}\ldots a_{i_k}$ , 其权值为 $a_{i_j}&lt;a_x\And x&gt;k$ 的 $j$ 个数, 对所有上升子序列求和.<br>$n\le 2\times 10^5$</p></blockquote><p><strong>钦定每个上升子序列 $a_{i_1}\ldots a_{i_k}$ 被最后一个大于a_{i_k}的 $x$ 贡献</strong>.</p><p>于是枚举 $x$ , 考虑计算贡献.</p><p>那么 $a_x$ 与 $a_j$ 行成的贡献是在 $[1, x)$ 中的上升子序列个数(这里是于拆贡献成 $x$ 与上升子序列中每一个小于它的数对的个数).</p><p>这个就是以 $i$ 结尾的, 乘上以 $i$ 开头但没有接到 $x$ 的个数. 因为 $x$ 是最后一个大于 $a_k$ 的, 所以<strong>没有接到 $x$ 后面的子序列</strong>, 于是后面这个等于以 $i$ 开头的个数减去以 $i$ 开头, $x$ 结尾的个数.</p><p>考虑直接把这些数都拿出来跑一遍dp, 那么这两个都可以1log算. 注意到设 $y$ 为大于 $x$ 的最大的 $y$ , 则 $a_x\in [a_y, a_z)$ , 并且 $y$ 恰好是下一个 $x$ ( $x$ 就是后缀 $\max$ , $y$ 恰好是下一个后缀 $\max$ ), 所以每个 $x$ 只会被拿出来算一遍. 就结束了.</p><p>[think] 钦点的东西可能也需要枚举, 第一个, 最后一个, 最大的这样的.</p><h3 id="XXI-OpenCup-Grand-Prix-of-SPb-J-Justice-For-Everyone"><a href="#XXI-OpenCup-Grand-Prix-of-SPb-J-Justice-For-Everyone" class="headerlink" title="XXI OpenCup Grand Prix of SPb J Justice For Everyone"></a>XXI OpenCup Grand Prix of SPb J Justice For Everyone</h3><blockquote><p>给定 ${a_n}$, 每次可以选定 $i\ne j$ 使得 $a_i: &#x3D; a_i+1, a_j: &#x3D; a_j+1$, 求有多少种方式最后得到 ${b_n}$, 且过程中 $\forall p\ne q, a_p\ne a_q$</p><p>$n\le 30, a_i, b_i\le 200$</p></blockquote><p>好厉害的题.</p><p>首先考虑如果没有限制, 那么设 $d_i&#x3D;b_i-a_i, s&#x3D;\dfrac{1}{2}\sum d_i$, 设出 $n$ 元生成函数, 答案可以写成</p><p>$$<br>\begin{gathered}<br>Ans&#x3D;[x_i^{d_i}]\ (\sum_{i, j}x_ix_j)^{s}\<br>&#x3D;[x_i^{d_i}]\dfrac{1}{2^s}((\sum x_i)^2-(\sum x_i^2))^{s}    \<br>&#x3D;2^{-s}[x_i^{d_i}]\sum_j\binom{s}{j}(-1)^j(\sum x_i)^{2s-2j}(\sum x_i^2)^{j}\<br>&#x3D;2^{-s}\sum_j\binom{s}{j}(-1)^j\sum_{\sum_k e_k&#x3D;j} \binom{2s-2j}{d_1-2e_1, d_2-2e_2\ldots d_n-2e_n}\binom{j}{e_1, e_2\ldots e_n}\</p><p>\because \binom{n}{a_1, a_2\ldots a_n}&#x3D;\dfrac{n! }{\prod (a_i! )(n-\sum a_i)! }\<br>\therefore ANS&#x3D;2^{-s}\sum_j\binom{s}{j}(-1)^j\sum_{\sum_k e_k&#x3D;j} \dfrac{(2s-2j)! j! }{\prod_i(e_i! (d_i-2e_i)! )}\<br>let\ F_d(z)&#x3D;\sum_{2j&lt;d}\dfrac{z^j}{j! (d-2j)! }\<br>\therefore ANS&#x3D;2^{-s}\sum_j\binom{s}{j}(-1)^j\sum_{\sum_k e_k&#x3D;j} (2s-2j)! j! [z^j]\prod F_{d_i}(z)\<br>let A(j)&#x3D;2^{-s}\binom{s}{j}(-1)^j\sum_{\sum_k e_k&#x3D;j} (2s-2j)! j!<br>\end{gathered}<br>$$</p><p>这是没有限制的情况, 当有限制的时候, 考虑若存在两个位置相同, 则以后可以把它们的值互换, 最后终点互换, 所以存在相两个数在某时刻相同的方案构成双射, 类似LGV引理求互不相交路径的证明, 发现答案可以是 $\sum_ (-1)^pH(a_i\to b_{p_i})$, 而这个就是 $\sum_(-1)^p\sum_j A(j)[z^j] \prod_i F_{b_{p_i}-a_i}(z)$, 这里可以把 $A$ 和提取系数提到最外面, 里面就是若干多项式构成的矩阵的行列式的形式, 于是设矩阵 $M, M_{i, j}&#x3D;F_{b_j-a_i}(z)$, 求行列式提取系数再带入刚才 $Ans$ 中的部分就是答案了.</p><p>然后直接乘多项式可能不很好, 不如先用点值算再插回来.</p><h3 id="PtzWinter2022-Day3-C-Inversions"><a href="#PtzWinter2022-Day3-C-Inversions" class="headerlink" title="PtzWinter2022 Day3 C Inversions"></a>PtzWinter2022 Day3 C Inversions</h3><blockquote><p>求所有长 $n$ 的排列的逆序对数的 $k$ 次方之和, $n\le 10^{18}, k\le 1000$</p></blockquote><p>组合意义可以认为是排列中的所有逆序对选出 $k$ 对可以重的方案数, 或者说选出 $k$ 对位置每对都是逆序对的方案数之和, 那么可以看出答案是 $2k$ 次多项式.</p><p>有 $k$ 个逆序对的排列生成函数怎么写? 设 $F_t(x)&#x3D;\sum_{i&#x3D;0}^t x^i$, 那么 $k$ 个逆序对的方案数是 $g_k&#x3D;[x^k]G(x), G(x)&#x3D;\prod_{i&#x3D;0}^{n-1}F_t(x)$, 而题目要求 $\sum_{i}i^kg_i$, 遇到高次常见方法转下降幂</p><p>$$<br>\begin{gathered}<br>Ans&#x3D;\sum_{i}i^kg_i\<br>&#x3D;\sum_{i}\sum_j i^{\underline{j}}{k\brace j}g_i\<br>&#x3D;\sum_{j&#x3D;0}^k {k\brace j}\sum_i g_ii^{\underline j}<br>&#x3D;\sum_{j&#x3D;0}^k {k\brace j}\sum_i G^{(j)}(1)<br>\end{gathered}<br>$$</p><p>$G&#x3D;\prod F$, 考虑 $F_t^{(j)}(1)&#x3D;\sum_{i&#x3D;0}^{t} i^{\underline j}&#x3D;\dfrac{t^{\underline{j+1}}}{j+1}$, 而 $(AB)^{(n)}&#x3D;\sum_{i&#x3D;0}^n \binom{n}{i}A^{(i)}B^{(n-i)}$, 对应了EGF的卷积, 所以把 $F_t(j)(1)$ 的值写成EGF卷起来即可, 复杂度 $k^2\log k$</p><p>[trick] 普通幂转下降幂之后的累加形式可以用求导带值简化.</p><h3 id="CF1641E-Special-Positions"><a href="#CF1641E-Special-Positions" class="headerlink" title="CF1641E Special Positions"></a>CF1641E Special Positions</h3><blockquote><p>给定长度为 $n$ 的数组 $a$, 长度为 $m$ 的数组 $p$, 其中 $1 \le p_i \le n$ , 而且 $\forall j, p_i \not &#x3D; p_j$.</p><p>在 $p$ 中等概率选定一个非空集合, 求 $\sum_{i &#x3D; 1} ^ n a_i \times \vert i - p_j\vert$ 期望 其中 $p_j$ 是选定集合中 $\vert i - p_j\vert$ 最小的 $p$.</p><p>$m \le n \le 10^5, a_i \le 998244352, 1 \le p_i \le n, p_i$ 两两不同.</p></blockquote><p>期望线性性, 考虑 $a_i\vert i-j\vert$ 的概率, 考虑 $i&lt;j$ 情况, 那么设 $s_i$ 表示小于 $i$ 的 $p$ 的个数, $b_i$ 表示 $i$ 是否是 $p$ 中的数, 则概率是 $2^{-(s_{j}-s_{2i-j})}a_ib_j(j-i)$, 设 $v_i&#x3D;2^{s_i}$, 变成 $j\dfrac{v_{2i-j}}{v_{s_j}}a_ib_t-i\dfrac{v_{2i-j}}{v_{s_j}}a_ib_t$ 两边各自可以看出卷积的形式, 然后因为有 $i&lt;j$ 的限制所有分治NTT即可.</p><h3 id="P8114-Cnoi2021-六边形战士"><a href="#P8114-Cnoi2021-六边形战士" class="headerlink" title="P8114 [Cnoi2021]六边形战士"></a>P8114 [Cnoi2021]六边形战士</h3><blockquote><p>求边长为 $a, b, c$ 的六边形平面图二分图完美匹配数量.</p><p>$a, b, c\le 10^6$</p></blockquote><p>是个很经典的题, 把所有非匹配边割断会把匹配边分开:</p><p><img src="/img/2023-12-21-11-46-53-image.png" alt="picture 0">   </p><p>然后瞪大眼睛瞪出3d感, 发现一个匹配和一个立方体堆叠双射, 则只要求长 $a$ 宽 $b$ 高 $c$ 的长方体内的堆叠数, 要求所有面都能漏出来, 然后观察一列立方体最高的轮廓形成的轨迹, 可以对应成从 $1, 1$ 出发每次向右或向下走走到 $(a+1, b+1)$ 的 $c$ 条路径, 且没有两条路径相互穿过的方案数, 那么把第 $i$ 条路径的起点终点都平移 $(i, i)$, 就成了互不相交路径, 就可以LGV引理了, 现在答案成了<br>$det(M), M_{i, j}&#x3D;\binom{a+b}{a+i-j}$</p><p>然后它写成了一个巨大的矩阵化简&#x2F;jk&#x2F;jk&#x2F;jk, 流程就是组合数的阶乘提出来, 然后凑成题目中的公式.</p><p>最后是线性的.</p><h3 id="P4566-CTSC2018-青蕈领主"><a href="#P4566-CTSC2018-青蕈领主" class="headerlink" title="P4566 [CTSC2018] 青蕈领主"></a>P4566 [CTSC2018] 青蕈领主</h3><blockquote><p>有一个长度为 $n$ 的排列 $a_n$, 给定对每个 $i$, 最大的 $l_i$ 使得 $[i-l_i+1, i]$ 是连续的, 定义连续为排序后是一段公差为 $1$ 的等差数列, 求可能的 $a$ 数量. $n\le 5\times 10^4$.</p></blockquote><p>好强.</p><p>首先发现 $[i-l_i+1, i]$ 的区间一定不交, 否则一定可以更长, 那么区间包含关系可以形成树状结构, 对一个节点来说其子节点可以再看成一个单个的数去计数, 所以设点 $u$ 有 $son_u$ 个儿子, 答案就是 $\prod_u f_{son_u}$, 而 $f_n$ 表示 $n+1$ 个数构成排列且除了整个排列外没有长度大于 $1$ 的连续段, $f_0&#x3D;0$.</p><p>那么 $f$ 是一个极小的定义, 考虑设其OGF为 $F(x)$, $G(x)&#x3D;\sum_{i&#x3D;1} i! x^i$ 为全排列, 根据刚才的分析, 考虑一个排列建出树之后根节点的分解, 大小为 $1$ 的排列分解不了, 就有了</p><p>$$<br>\begin{gathered}<br>    G(x)&#x3D;xF(G(x))+x\<br>    F(G(x))&#x3D;\frac{G(x)-x}{x}\<br>    let\ H(G(x))&#x3D;x\<br>    \therefore F(x)&#x3D;\frac{x}{H(x)}-1<br>\end{gathered}<br>$$</p><p>问题变为求 $H$, 因为不是只求一项所以拉反不好用了. 发现 $G$ 是微分有限的, 于是凑系数并带入 $H$:</p><p>$$<br>\begin{gathered}<br>G(x)&#x3D;\sum_{i&#x3D;1} i! x^i\<br>G’(x)&#x3D;\sum_{i&#x3D;1} i\cdot i! x^{i-1}\<br>(x-1)G(x)+x^2G’(x)+x&#x3D;0\<br>(H(x)-1)x+H^2(x)G’(H(x))+H(x)&#x3D;0\<br>\because G(H(x))&#x3D;x\<br>\therefore G’(H(x))H’(x)&#x3D;1\<br>\therefore (H(x)-1)x+\frac{H^2(x)}{H’(x)}+H(x)&#x3D;0\<br>xH(x)H’(x)-xH’(x)+H^2(x)+H(x)H’(x)&#x3D;0\<br>nh_n&#x3D;\sum_{i&#x3D;0}^{n-2}(i+1)h_{i+1}h_{n-1-i}+\sum_{i&#x3D;1}^{n-1}h_ih_{n-i}+\sum_{i&#x3D;0}^{n-1}(i+1)h_{i+1}h_{n-i}\<br>-g_1h_n&#x3D;\sum_{i&#x3D;1}^{n-1}(i+1)r_ir_{n-i}+\sum_{i&#x3D;2}^{n-1}ir_ir_{n+1-i}\<br>\because F(G)&#x3D;x<br>\therefore [x]F(G)&#x3D;f_1g_1&#x3D;g_1&#x3D;[x]x&#x3D;1<br>\end{gathered}<br>$$</p><p>卷积形式, 分治NTT, 复杂度 $n\log^2 n$.</p><p>[think] 对微分有限的东西求复合逆, 就微分列出微分方程, 再带入得到关于复合逆的微分方程, 再转递推式上FFT</p><p>补充一下, 写的时候会让人感到疑惑在于 $G, F, H$ 都是没常数的, 于是不能求逆, 但是你最后求的是 $\dfrac{x}{H}&#x3D;\dfrac{1}{\frac{H}{x}}$ 就没问题了.</p><h3 id="P8354-SDOI-x2F-SXOI2022-多边形"><a href="#P8354-SDOI-x2F-SXOI2022-多边形" class="headerlink" title="P8354 [SDOI&#x2F;SXOI2022] 多边形"></a>P8354 [SDOI&#x2F;SXOI2022] 多边形</h3><blockquote><p>$n$ 条边的凸多边形每条边上又额外有 $a_i-1$ 个顶点, 求三角剖分数, 要求一条边上的两个顶点不能连线, 边中间上可以有顶点不连线.</p><p>$\sum a_i\le 5\times 10^5$</p></blockquote><p>和普通的卡特兰数相比就是后面的两个限制.</p><p>对于一条边上可以有不连的只要选出点数就行了, 现在先假设所有点都要被选, 问题是同一条边的不能连线, 不容易发现若存在同一边连线必然存在恰好跨过一个点的边, 于是对这样的边容斥, 而钦点这样的相当于直接删掉中间的点.</p><p>终止假设, 于是对于删掉中间点, 删掉不选的点的最终局面的一条线段, 其贡献系数应该为 $1-(c-1)$($c$ 为跨过的段数), 其中第一个 $1$ 是正常贡献, 后面 $c-1$ 是枚举它跨过了中间的一个点. 设 $a_i$ 原题目多边形上一条边的段数, 则一条边上选 $k$ 条边的容斥系数最后就是</p><p>$$<br><a href="%5Csum_%7Bc=1%7D(2-c)x%5Ec">x^{a_i}</a>^k&#x3D;<a href="%5Cdfrac%7B-2x%5E2+x%7D%7B(1-x)%5E2%7D">x^{a_i}</a>^k<br>$$</p><p>要对所有 $k$ 算这个东西, 也就是设</p><p>$$<br>F(x, z)&#x3D;\dfrac{1}{1-z\frac{-2x^2+x}{(1-x)^2}}&#x3D;\dfrac{(1-x)^2}{(2z+1)x-(z+2)x+1}<br>$$</p><p>有一个很粗暴的方法了, 求 $[x^{a_i}]F$, 看成关于 $x$ 的多项式, 就是线性递推那类的东西, 复杂度是 $T(n)&#x3D;2T(n&#x2F;2)+O(n)$, 则 $T(a_i)&#x3D;a_i\log a_i$ 是可以过的, 然后对 $y$ 的多项式你应该带着点值算以卡常.</p><p>可以考虑拉反, 设 $G(x)&#x3D;\dfrac{-2x^2+x}{(1-x)^2}$, $G(R)&#x3D;x$, 则有</p><p>$$<br>[x^n]G^k&#x3D;[x^{n-1}]\dfrac{1}{n}kx^{k-1}(\dfrac{x}{R})^n&#x3D;\dfrac{k}{n}<a href="%5Cdfrac%7Bx%7D%7BR%7D">x^{n-k}</a>^n<br>$$</p><p>我们把多项式的指数统一了! 现在只要知道 $(\dfrac{x}{R})^n$ 是啥, 设 $H&#x3D;\dfrac{x}{R}$, 则因为</p><p>$$<br>G&#x3D;\dfrac{-2x^2+x}{(1-x)^2}\<br>x&#x3D;\dfrac{-2R^2+R}{(1-R)^2}<br>$$</p><p>$R$ 是微分有限的, 所以 $H&#x3D;\dfrac{x}{R}$ 也是微分有限的, $H^n$ 也是微分有限的, 你可以得到一个线性的递推式.</p><h3 id="ARC132F-Takahashi-The-Strongest"><a href="#ARC132F-Takahashi-The-Strongest" class="headerlink" title="[ARC132F] Takahashi The Strongest"></a>[ARC132F] Takahashi The Strongest</h3><blockquote><p>小 $A, B, C$ 在玩石头剪刀布, 分别用 $R, S, P$ 表示. 小 $A$ 有 $n$ 个策略, 小 $B$ 有 $m$ 个策略, 一个策略是一个长度为 $k$ 的包含 $R, S, P$ 的字符串, 表示每一局会固定出什么. 对于小 $C$ 的一种策略, 如果在中途某一次小 $C$ 是绝对赢家, 那么小 $C$ 会开心. 对于小 $C$ 每种可能的策略, 求出有多少种 $A, B$ 的组合策略(一共有 $nm$ 种组合)使得小 $C$ 会开心.</p><ul><li>$1\leq k\leq 12, 1\leq n, m\leq 3^k$</li></ul></blockquote><p>即存在某一轮 $A, B$ 相同且恰好比 $C$ 少 $1$, 考虑定义 $4$ 进制类FWT的卷积使得对于每一位<br>$$<br>x\otimes y&#x3D;\begin{cases}<br>    x\ if\ x&#x3D;y, \<br>    3\ if\ x&#x3D;y<br>\end{cases}<br>$$<br>用和FWT相同的方法构造矩阵, 即设 $j$ 对 $i$ 的贡献为 $c(i, j)$ 要求 $c(i, j)c(i, k)&#x3D;c(i, j\otimes k)$, 则是要解 $c_i\in {-1, 1, 0}, c_3&#x3D;c_0c_1&#x3D;c_0c_2&#x3D;c_1c_2$, 大概拿出来有 $[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]$ 的解(全 $0$ 没有逆), 有矩阵</p><p>$$<br>\begin{bmatrix}<br> 1 &amp; 0 &amp; 0 &amp; 1\<br> 0 &amp; 1 &amp; 0 &amp; 1\<br> 0 &amp; 0 &amp; 1 &amp; 1\<br> 0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$$</p><p>实际上是做前缀和, 认为 $0, 1, 2\subset 3$. 显然有逆, 可以卷积. 求出 $A$, $B$ 策略卷起来的序列 $f_T$, 再把策略平移一位, 变成对每个 $S$(三进制)的 $\sum_{T\cap S\ne \varnothing}f_T$. 改成求 $\sum_{T\cup S&#x3D;\varnothing}f_T$,</p><h2 id="2-luogu某题单"><a href="#2-luogu某题单" class="headerlink" title="2. luogu某题单"></a>2. luogu某题单</h2><p>然后做不动了appleblue太强悍. 随便找点, 下面是luogu上的一个题单</p><h3 id="CF1657E-Star-Mst"><a href="#CF1657E-Star-Mst" class="headerlink" title="CF1657E Star Mst"></a>CF1657E Star Mst</h3><blockquote><p>求 $n$ 个点的无向完全图有多少个满足最小生成树的权值和等于所有和点1相连的边的权值和, 每条边边权为 $[1, v]$ , $n, v \le 250$ </p></blockquote><p>qyc场切</p><p>[trick] 这个条件首先等价于以1为根的菊花是它的最小生成树, 再考虑Kruskal的过程, 又等价于对于每个点, 1都是离它最近的点之一.</p><p>考虑对于一条 $u\to v, u, v\ne 1$ 的边, 在我们不知道 $1\to u$ 和 $1\to v$ 前是无法确定的, 所以要明确一个确定边权的顺序, 发现如果从小到大确定边权那么所有新的满足 $1\to u, 1\to v$ 已经确定的 $u\to v$ 的边权都只依赖于我们新加的边权而不依赖于旧的, 根据这个, 设 $f_{i, j}$ 表示加入了边权在 $[1, i]$ 的边, 一共有 $j$ 个连到 $1$ 上, 当转移时, 我们考虑新加入的这些边确定了哪些:</p><p>$$<br>f_{i, j}&#x3D;f_{i-1, k}\times (v-i+1)^{\binom{j}{2}-\binom{k}{2}}\times \binom{j}{k}<br>$$ </p><p>推转移式子的时候别忘了最后那个组合数.</p><p>注意指数上那个二项式系数不是对 $P$ 取模, 但其实也没事因为它们根本到不了要取模的大小.</p><p>然后你就做完了.</p><h3 id="P5664-CSP-S2019-Emiya-家今天的饭"><a href="#P5664-CSP-S2019-Emiya-家今天的饭" class="headerlink" title="P5664 [CSP-S2019] Emiya 家今天的饭"></a>P5664 [CSP-S2019] Emiya 家今天的饭</h3><blockquote><p>给一个 $n$ 行 $m$ 列的矩阵 $A$ , 每个格子有个数表示选这个格子的方案数, 可以选任意多个格子, 要求每行只能选一个, 且若一共选了 $k$ 个数, 则不能有一列选超过 $\lfloor\dfrac{k}{2}\rfloor$ 个数. $n \le 100, m\le 1000$ </p></blockquote><p>这题首先看起来很dp, 发现这个每列个数不超过一半很难计算, 而又因为只可能有一列选的个数超过一半, 所以可以容斥, 枚举是哪一列超过了一半.</p><p>于是现在钦定第 $r$ 列超过一半计算方案数, 很容易想到设 $f_{i, j, k}$ 表示考虑这一列的前 $i$ 个数, 选了 $j$ 个第 $r$ 列的和其他 $k$ 个不在第 $r$ 列的. 这里记 $s_i&#x3D;\sum_j A_{i, j}$ , 则转移为:</p><p>$$<br>f_{i, j, k}&#x3D;f_{i-1, j-1, k}\times a_{r, i}+f_{i-1, j, k-1}\times (s_i-a_{r, i})<br>$$ </p><p>但这样做算上枚举每一列的话复杂度是 $O(mn^3)$ 的, 无法通过, 发现我们之所以记录 $j$ 和 $k$ 是因为判断最后是否要这个值, 即是否在这一列里选了超过一半, 那么其实我们只要知道 $j-k$ 就行, 所以考虑设 $f_{i, j}$ 表示考虑这一列的前 $i$ 个数, 在这一列的比外面的多 $j$ 的方案数, 发现转移是简单的, 复杂度就成了 $O(mn^2)$ </p><p>启发一种优化状态设计的方法.</p><h3 id="P3214-HNOI2011-卡农"><a href="#P3214-HNOI2011-卡农" class="headerlink" title="P3214 [HNOI2011] 卡农"></a>P3214 [HNOI2011] 卡农</h3><blockquote><p>有 $m$ 个音, 要求选出无序的 $n$ 个互不相同的音的集合, 满足所有音都出现了偶数次. 对 $10^8+7$ 取模.</p><p>$n, m\le 10^6$ </p></blockquote><p>首先 $10^8+7$ 居然也是质数, 长见识.</p><p>首先这个的无序没有任何用处, 有序的除以 $n!$ 就行.</p><p>由于是偶数次, 让人想到异或, 所以转化为:</p><p>在 $[1, 2^m -1]$ 个数中选 $n$ 个互不相同的数满足异或和为0.</p><p>设选前 $i$ 个数的答案为 $f_i$ , 如果我们先随便放 $[1, i-1]$ , 最后在 $i$ 的位置放一个数 $x&#x3D;a_1\mathrm{xor}a2. . . \mathrm{xor}a_{i-1}$ 就满足了条件, 这样的方案数是 $A^{i-1}_{2^m-1}$ 但却多算了以下两种情况:</p><ul><li><p>$x&#x3D;0$ , 说明前 $i-1$ 个已经异或起来是0了, 多算了 $f_{i-1}$ 个方案.</p></li><li><p>$x$ 在前面出现过, 那么把那个出现过的也删去, 剩下的还有 $f_{i-2}$ 个方案, 此时 $x$ 有 $2^m-1 -(i-2)$ 种可能(与前面的其他数互不相同), 同时与其相同的那个数的下标有 $i-1$ 种, 一共多算了 $(2^m-1-(i-2))(i-1)f_{i-2}$ 个方案.</p></li></ul><p>最后注意</p><p>$$<br>A^k_n\bmod P&#x3D;A^k_{n\bmod P} \bmod P<br>$$ </p><p>可以简单归纳法证明.</p><h3 id="P2606-ZJOI2010-排列计数"><a href="#P2606-ZJOI2010-排列计数" class="headerlink" title="P2606 [ZJOI2010]排列计数"></a>P2606 [ZJOI2010]排列计数</h3><blockquote><p>求有多少个长为 $n$ 的排列满足 $p_{i}&gt;p_{\frac{i}{2}}$ . $n \le 10^6$ </p></blockquote><p>容易想到若 $i$ 向 $\dfrac{i}{2}$ 连边会得到一棵完全二叉树, 而此时根一定是当前最小值, 左右子树则是互不干扰的, 形成一个递归结构, 于是我们考虑dp.</p><p>设 $f_i$ 表示长度为 $i$ 的排列的答案, 也就是节点数为 $i$ 的树的答案, 同时设 $lson_i, rson_i$ 表示它左右子树的大小, 则有:</p><p>$$<br>f_{i}&#x3D;\binom i {lson_i}\times f_{lson_i}\times f_{rson_i}<br>$$ </p><p>然后做完了.</p><h3 id="P6453-SP3734-PERIODNI-Periodni"><a href="#P6453-SP3734-PERIODNI-Periodni" class="headerlink" title="P6453 SP3734 PERIODNI - Periodni"></a>P6453 SP3734 PERIODNI - Periodni</h3><blockquote><p>给定一个 $n$ 列直方图(底部对齐的若干矩形)网格, 每列高度各不相同, 现在要在其中摆放 $k$ 个车, 要求车相互无法攻击. 求摆放方案数.<br>$n, k\le 500$ .</p></blockquote><p>看到这个直方图想到给定直方图求最大矩形那个题的笛卡尔树做法, 我们把笛卡尔树建出来dp, 考虑以序列下标为二叉查找树的关键字, 以矩形高度建小根笛卡尔树, 因为每一列高度各不相同所以, 所以相当于把直方图横向分隔成若干层, 如图:</p><p><img src="/img/2022-10-15-16-23-30-image.png" alt="picture 2"></p><p>那么接下来只要考虑如何在这棵树上dp, 容易想到设 $f_{u, i}$ 表示 $u$ 的子树内放了 $i$ 个车的方案数, 若 $v$ 为 $u$ 的儿子, 发现仅仅在自己这里选择 $j$ 个的方案数就是 $\binom{w}{j}\binom{h}{j}j!$ , 然后按这个转移即可.</p><h3 id="P3244-HNOI2015-落忆枫音"><a href="#P3244-HNOI2015-落忆枫音" class="headerlink" title="P3244 [HNOI2015]落忆枫音"></a>P3244 [HNOI2015]落忆枫音</h3><blockquote><p>给定 $n$ 个点 $m$ 条边的DAG, 在此基础上再添加一条 $x\to y$ 的边, 求此时以1为根的不同的生成树个数. $n\le 10^5$ </p></blockquote><p>在DAG上这个东西时好求的, 只要把每个点的入度乘起来即可, 意思是给每个点选一个父亲. 但现在又多了一条边, 可能形成至多一个环, 那么只要减去恰好选了这个环的方案, 相当于我们只确定了环上点的父亲, 所以方案数就是不在环上的所有点的入度的乘积, 两者相减即可.</p><h3 id="P6672-清华集训2016-你的生命已如风中残烛"><a href="#P6672-清华集训2016-你的生命已如风中残烛" class="headerlink" title="P6672 [清华集训2016] 你的生命已如风中残烛"></a>P6672 [清华集训2016] 你的生命已如风中残烛</h3><blockquote><p>$m$ 张牌的牌堆,<strong>牌是区分的</strong>, 同时 $n$ 张牌还有属性 $w$ 表示可以打出后能再摸几张, 求有多少种牌堆的排列使得你一轮可以把所有牌都摸没. 保证 $\sum w&#x3D;m$ .</p></blockquote><p>首先可以把没有属性 $w$ 的牌看成 $w&#x3D;0$ .</p><p>考虑摸没的条件, 摸完前 $k$ 张牌的手牌数为 $1+\sum_{i&#x3D;1}^k w_i - k$ , 所以要求对于任意 $k$ 这个式子为正, 于是可以给每个 $w_i$ 先减去1. 变成保证 $\sum_i w_i&#x3D;0$ , 要求所有前缀和都非负的个数.</p><p>有一个Raney引理: 对任意和为1的整数排列, 其所有循环平移形成的排列中, 有且仅有一个满足任意前缀和为正.</p><p>这个证明很简单, 看成折线图后就是只有从折线图的最低点出发的情况满足条件. 如果有多个相同的最低点则只能选最后一个, 所以只有一个出发点满足条件.</p><p>但这个问题没有和圆排列的直接一一对应的关系, 原因是当出现多个最低点时可以选择任意一个.</p><p>可能会想到在开头处添加一个1转化过去, 会发现我们在原始问题上添加1可能导致去掉这个1后两种方案本质相同. 因为第一个位置的数不一定是1.</p><p>但如果在最后添加一个-1就没有问题, 因为假设仍有多个最低点只能选第一个, 否则我们会跨过这个-1来到第一个最低点, 那么第一个最低点的位置就会比当前的更低. 于是我们又建立起了一一对应的关系.</p><p>接下来计算答案就简单了. 要注意这里 $w$ 相等的卡牌是区分的, 所以不用Polya而可以直接圆排列计数, $m+1$ 个卡牌的圆排列一共有 $\dfrac{(m+1)! }{m+1}&#x3D;m!$ 个, 同时由于我们添加的-1和其他-1是不区分的, 所以除掉-1个数 $m-n+1$ , 答案为 $\dfrac{m! }{m-n+1}$ .</p><h2 id="3-CF板刷"><a href="#3-CF板刷" class="headerlink" title="3. CF板刷"></a>3. CF板刷</h2><p>CF选择标签combination板刷</p><h3 id="CF1730E-Maximums-and-Minimums"><a href="#CF1730E-Maximums-and-Minimums" class="headerlink" title="CF1730E Maximums and Minimums"></a>CF1730E Maximums and Minimums</h3><blockquote><p>给定序列 $a$ , 求区间中最大值是最小值的倍数的区间个数.<br>$n\le 5\times 10^5, a_i\le 10^6$ </p></blockquote><p>$10^6$ 以内因数个数不到300. 于是算法复杂度有可能是 $nd$ 的. (不然应该出到 $10^9$ )吧.</p><p>枚举最大值和对应因数, 我们能做到 $nd\log n$ . 这个部分还很套路: 就是考虑能做最大值的区间, 对应最小值能做最小值的区间. . . $\log n$ 出现在对于每一个最大值找出左边&#x2F;右边第一个最小值的位置.</p><p>但是问题是, 怎么去 $\log n$ 呢? 好, 打开jiangly代码,<strong>lower_bound</strong>, 嗯, 结束了. 原来是 $nd\log n$ .</p><p>哦去 $\log$ 是简单的, 考虑我们相当于 $nd$ 次询问一个数左边等于另一个数的位置. 那么假设最大值枚举的时候从左往右, 就只需要对于每一个值维护它最后一次的位置即可.</p><p>另一个做法是分治, 扫左端点得到左边最大最小, 那么钦定左边贡献最大, 然后枚举约数好像复杂度一样.</p><h3 id="CF1728G-Illumination"><a href="#CF1728G-Illumination" class="headerlink" title="CF1728G Illumination"></a>CF1728G Illumination</h3><blockquote><p>给定一条长 $d$ 数轴上的 $n$ 个灯和 $m$ 个点的位置序列 $l, p$ , 灯 $i$ 可以照亮 $[l_i-w_i, l_i+w_i]$ 范围内的点, 其中 $w_i$ 是 $[0, d]$ 的整数.<br>$q$ 次询问, 每次询问在已有 $n$ 个灯的基础上添加一个新灯后 $w$ 的方案数使得每一个点都能被照亮.<br>$n\le 2\times 10^5, m\le 16, q\le 5\times 10^5, d\le 3\times 10^5$ .</p></blockquote><p>先考虑一次询问怎么做, 能dp吗?</p><p>$f_{i, j}$ 表示前 $i$ 个灯照亮前 $j$ 个点, 发现可以转移. 那么直接转移写成矩阵, 预处理前缀积和后缀积就行了. 复杂度是 $nm^3+qm^3$ </p><p>另一个做法是考虑容斥, 枚举点集 $S$ , 确定它们都被覆盖是困难的, 但要求 $S$ 内的点都不被覆盖只要让相邻两个属于 $S$ 的点之间的灯照不到这两个端点即可. 相当于直接限制每个灯的最大值. 那么预处理数组 $f_{l, r}$ 表示 $[l, r]$ 中的灯照不到点 $l$ 和 $r$ 即可.</p><p>现在有了多组询问, 枚举新加的点照亮的范围, 并预处理照亮这个范围外的点的方案. 注意范围外的点这一点集一定是前缀和后缀, 所以点集只有 $m^2$ 个.</p><h3 id="CF1671F-Permutation-Counting"><a href="#CF1671F-Permutation-Counting" class="headerlink" title="CF1671F Permutation Counting"></a>CF1671F Permutation Counting</h3><blockquote><p>求逆序对数为 $k$ , 下降数为 $x$ 的长 $n$ 的排列数量.<br>$n\le 998244352, k, x\le 11$<br>下降数是 $\sum [a_i&gt;a_{i+1}]$ </p></blockquote><p>牛逼题.</p><p>观察性质拆贡献, 把满足 $i&lt;\max_{j\le i} a_j$ 的连续的一段称为一段, 那么发现段间没有贡献.</p><p>对于每一段, 考虑其内部排列, 一段长度最多是 $12$ 否则逆序对数就会超过 $11$ , 于是就先考虑内部排列, 设 $f_{s, j, k}$ 表示 $s$ 集合已经选了, 有 $j$ 个逆序对, $k$ 个下降的一段的个数, 枚举下一个填几即可转移. 就能 $2^12\times 11^2\times 12$ 的dp它了.</p><p>接下来考虑, 一个长度是 $2$ 的段会产生 $1$ 个逆序对, 所以我们最多拼 $11$ 个段, 于是设 $g_{i, j, k, l}$ 表示拼了 $i$ 个段, 这 $i$ 个段一共 $j$ 个数, 有 $k$ 个逆序对, $l$ 个下降的方案数, 转移是类似背包的dp.</p><p>最后算答案的时候, 我们累加所有 $k, l$ 是题目要求的那些状态值, 那么对于除了这些长为 $2$ 的段之外的那些长为1的段, 每一个数都是唯一确定的, 于是直接用隔板法再乘一个组合数即可.</p><p>很厉害啊</p><p>更好想的感觉是另一个: 猜测固定 $i, j$ 后答案是关于 $n$ 的, 次数不超过 $11$ 的多项式, dp打出 $11\times 11\times 11$ 的表, 然后拉格朗日差值.</p><h3 id="CF383E-Vowels"><a href="#CF383E-Vowels" class="headerlink" title="CF383E Vowels"></a>CF383E Vowels</h3><blockquote><p>给出 $n$ 个长度为 $3$ 的由 $\texttt{a}\ldots\texttt{z}$ 组成的单词, 一个单词是正确的当且仅当其包含至少一个元音字母. 这里的元音字母是 $\texttt{a}\ldots\texttt{x}$ 的一个子集. 对于所有元音字母集合, 求这 $n$ 个单词中正确单词的数量平方的异或和.<br>$n\le 10^4$ </p></blockquote><p>一个单词是错误的当且仅当这个单词与元音字母集合不交, 等价于它的补集是元音字母集合超集, 于是补集之后做超集和就能得到数量.</p><p>但问题是这样是 $10^7$ 的, 且没有利用单词长度为3的特性.</p><p>看题解, “注意到4s, 所以 $O({\vert\sigma\vert}2^{\vert\sigma\vert})$ 完全能过. “这样啊.</p><h3 id="CF1603F-October-18-2017"><a href="#CF1603F-October-18-2017" class="headerlink" title="CF1603F October 18, 2017"></a>CF1603F October 18, 2017</h3><blockquote><p>给出 $n, k, x$ , 求长 $n$ , 每一项在 $[0, 2^k)$ , 且任意子序列异或和不为 $x$ 的序列个数. $n\le 10^9, k\le 10^7, \sum k\le 5\times 10^7, x&lt; 2^20$ </p></blockquote><p>$x&#x3D;0$ 是特殊的, 其他是相同的.</p><p>当 $x&#x3D;0$ 时, 相当于选出若干个线性无关向量. 方案数为 $\prod 2^k-2^{i}$ , 就是每一次选前面不能表示的. 复杂度 $O(k)$ </p><p>当 $x\ne 0$ 时, 每个数的情况相同, 所以求对于一个序列其能表示的数的个数求和后再除以数的总数就是答案. 而一个数列能表示的数的个数就是, 若把这个数列中所有数视作向量弄成一个矩阵后矩阵的秩为 $r$ , 个数就是 $2^r$ . 于是只要求长 $n$ 的序列秩为 $1\ldots n$ 的分别是多少即可.</p><p>考虑dp这个东西, 设 $f_{i, r}$ 表示前 $i$ 行, 秩为 $r$ 的方案数. 有</p><p>$$<br>f_{i, r}&#x3D;f_{i-1, r}\times 2^{r}+f_{i-1, r-1}\times (2^k-2^{r-1})<br>$$</p><p>复杂度 $nk$ </p><p>用生成函数求, 写成生成函数, 我们可以先选出一组基, 方案数是 $\prod_i (2^k-2^i)$ , 然后再把其他的数添加进去, 第 $i$ 个数后添加方案数是 $2^i$ . 后面这个生成函数是<br>$$<br>\prod \dfrac{1}{1-2^ix}<br>$$<br>而<br>$$<br>\dfrac{1}{\prod ^n_{i&#x3D;0}(1-q^ix)}&#x3D;\sum_{i&gt;&#x3D;0}x^i{i+n\brack n}_q<br>$$<br>所以后面这个生成函数 $n-r$ 项系数就是 ${n\brack n-r}_q$ </p><p>于是就做完了.</p><p>qanalogy&#x3D;不可做</p><h3 id="CF1295F-Good-Contest"><a href="#CF1295F-Good-Contest" class="headerlink" title="CF1295F Good Contest"></a>CF1295F Good Contest</h3><blockquote><p>求长 $n$ 序列 $a$ 单调不增的概率, 其中 $a_i$ 在 $[l_i, r_i]$ 中等概率随机.<br>$n\le 50, l_i, r_i\le 998244353$ </p></blockquote><p>$f_{i, j}$ 表示前 $i$ 个单调不增以 $j$ 结尾的方案数, 则</p><p>$$<br>f_{i, j}&#x3D;(\sum_{k\ge j} f_{i-1, k})<br>$$</p><p>但值域很大, 会寄.</p><p>$f_i$ 是 $f_{i-1}$ 做后缀和再截取一个区间, 有什么好办法?</p><p>离散化成若干值域区间! 变成 $a_i$ 在第 $j$ 个值域区间, 那么此时转移要考虑一个区间内转移到当前区间内的情况, 发现根本不会做.</p><p>考虑不枚举 $j$ 转而枚举 $i$ , 即从 $f_{k}{j+1}$ 转移过来, 这样只要算从最后一段里选一个不降的序列即可. 而从长 $l$ 的值域段选长 $a$ 的不降序列只要组合数 $\binom {l+a-1}{a-1}$ 即可.</p><p>另一个方法, 容易想到直接维护分段函数, 那么需要对分段函数求前缀和, 是容易的.</p><h3 id="CF1523E-Crypto-Lights"><a href="#CF1523E-Crypto-Lights" class="headerlink" title="CF1523E Crypto Lights"></a>CF1523E Crypto Lights</h3><blockquote><p>有 $n$ 个台灯初始时都是暗的, 每次等概率随机一个暗台灯将其点亮, 若点亮后存在一个长度为 $k$ 的连续段有大于一个台灯被点亮则立刻停止, 求期望点亮多少台灯. 答案对 $10^9+7$ 取模.<br>$n, k\le 12^5$ </p></blockquote><p>考虑算开启 $i$ 个后能继续的概率.</p><p>那么这个就是从这 $n$ 个灯中选 $i$ 个灯相隔 $k$ 以上的概率. 这个考虑选 $i$ 个相隔 $k$ 以上的灯可以看作选 $i$ 个灯亮, 再在其中插入剩下的灯. 那么方案数就是 $\binom {n-i+(i-1)(k-1)+i}{i}\times i!$ . 就结束了.</p><h3 id="CF1495D-BFS-Trees"><a href="#CF1495D-BFS-Trees" class="headerlink" title="CF1495D BFS Trees"></a>CF1495D BFS Trees</h3><blockquote><p>给定一张图, 以 $s$ 为根的生成树是厉害的指 $s$ 到任意一点的树上距离等于实际距离. 求有多少个生成树同时是以 $x$ 为根厉害的也是以 $y$ 为根厉害的. 对所有 $(x, y)$ 求答案.<br>$n\le 400, m\le 600$ </p></blockquote><p>考虑如果 $x\to y$ 有两条及以上最短路, 那么一定不行.</p><p>找到这一条后, 这一条链一定原封不动照搬到这棵树上. 对于剩下的点, $u$ 的父亲可以为 $f$ 当且仅当 $dis(u, x)&#x3D;dis(x, f)+1, dis(u, y)&#x3D;dis(y, f)+1$ .</p><p>然后统计每个点可以的父亲个数, 直接乘起来就结束了.</p><h3 id="CF1264D-Beautiful-Bracket-Sequence"><a href="#CF1264D-Beautiful-Bracket-Sequence" class="headerlink" title="CF1264D Beautiful Bracket Sequence"></a>CF1264D Beautiful Bracket Sequence</h3><blockquote><p>给定一个含 $\texttt{? }$ 的括号序列. 定义一个括号序列的权值为删除一些字符使其成为合法的匹配括号串后, 括号匹配的最深深度. 求把 $\texttt{? }$ 替换成括号的所有方案中, 括号序列的权值之和.</p></blockquote><h4 id="Version1"><a href="#Version1" class="headerlink" title="Version1"></a>Version1</h4><blockquote><p>$n\le 2000$ </p></blockquote><p>[trick] 一个括号序列有唯一的位置使得左边的左括号个数等于右边的右括号个数.</p><p>这个位置显然就是最大的匹配位置, 于是可以枚举深度最大的匹配之间的空隙(如果有多个, 算在第一个空隙). 设左边有 $l$ 个左括号, 右边有 $r$ 个右括号, 左边有 $x$ 个问号, 右边有 $y$ 个. 那么方案数就是</p><p>$$<br>\sum_{i&#x3D;0}^{x} (l+i)\times \binom xi \binom {y}{l+i-r}<br>$$</p><p>含义是枚举左边有多少个问号是左括号, 那么 $l+i$ 是深度, $\binom xi$ 是从左边挑出 $i$ 个, $l+i-r$ 是右边需要这么多括号定为右括号. 是我们钦定它是第一个深度最大的空隙并且右边确定了对应数量的右括号, 所以左边所有左括号都是可以贡献给这个空隙的. 所以这是正确的. 复杂度 $O(n^2)$ </p><h4 id="Version2"><a href="#Version2" class="headerlink" title="Version2"></a>Version2</h4><blockquote><p>$n\le 10^6$ </p></blockquote><p>考虑化简这个式子:</p><p>$$<br>\begin{aligned}<br>     &amp;  \sum_{i&#x3D;0}^{x} (l+i)\times \binom xi \binom {y}{l+i-r}\<br>    &#x3D;&amp;  l\sum_{i&#x3D;0}^{x}  \binom xi \binom {y}{l+i-r} +<br>        \sum_{i&#x3D;0}^{x} i\binom xi \binom {y}{l+i-r}\<br>    &#x3D;&amp;  l\sum_{i&#x3D;0}^{x} \binom xi \binom {y}{l+i-r} +<br>        x\sum_{i&#x3D;0}^{x} \binom {x-1}{i-1} \binom {y}{l+i-r}\<br>    &#x3D;&amp; l\sum_{i&#x3D;0}^{x} \binom {x}{x-i}\binom {y}{l+i-r}+x\sum_{i&#x3D;0}^{x} \binom{x-1}{x-i}\binom {y}{l+i-r}\<br>    &#x3D;&amp;l\binom{x+y}{x+l-r}+x\binom{x+y-1}{x+l-r}<br>\end{aligned}<br>$$</p><p>拿这个做即可.</p><p>第二部分知道范德蒙德卷积应该是简单的. 主要是第一部分枚举一个关键(最大值)的位置后计算组合数这个方法比较巧妙.</p><h3 id="CF1437F-Emotional-Fishermen"><a href="#CF1437F-Emotional-Fishermen" class="headerlink" title="CF1437F Emotional Fishermen"></a>CF1437F Emotional Fishermen</h3><blockquote><p>给定长 $n$ 的序列 $a$ , 求 $a$ 重新排列后, 对于每一个位置 $a_i$ 和 $x&#x3D;\max_{j\in[1, i-1]} a_j$ , 满足 $x\ge 2a_i$ 或 $a_i\ge 2x$<br>膜998244353. $n\le 5000$ </p></blockquote><p>考虑用 $a_i\ge 2x$ 的把序列分成若干段, 每一个段内 $2a_i\le x$ , 每一个数可以作为划分点, 或放在第一个大于自己二倍的划分点之后. 排序后用这个dp. 设 $f_i$ 表示最大值是 $a_i$ 的方案数(加入小于 $\dfrac{a_i}{2}$ 的所有数), 此时排列中被加入的数目设为 $len_i$ .</p><p>$$<br>f_i&#x3D;\sum f_j \times A^{len_i-len_j-1}_{n-len_j-2}<br>$$</p><p>$f_i$ 位置是 $a_j$ 后第一个没被放的位置(否则空出来一个位置没有东西可以放), 它的位置是确定的. 而在值域 $(\dfrac{a_j}{2}, \dfrac{a_i}{2}]$ 中的这些数可以再这一次被加入. 并且可以在自己后面任意放(不能在前面, 前面已经没空位了). 于是就是这个样子了. 复杂度 $n^2$ .</p><p>仍然是费用提前计算的思想(不过把费用改成方案数). 我们应该有意识枚举所有可能都状态设法和转移方向. 并且dp排列的时候由于其每个值只能出现一次基本都是从值域入手把值域分成若干段去计算.</p><h3 id="CF1237F-Balanced-Domino-Placements"><a href="#CF1237F-Balanced-Domino-Placements" class="headerlink" title="CF1237F Balanced Domino Placements"></a>CF1237F Balanced Domino Placements</h3><blockquote><p>给定一个 $n\times m$ 的棋盘, 上面放了 $k$ 个 $1\times 2$ 的骨牌, 要再任意放骨牌, 要求同一行, 同一列只有最多有一个骨牌, 求方案数.<br>$n, m\le 3600, k\le 2400$ </p></blockquote><p>行和列是隐晦的独立的.</p><p>看起来似乎行和列会互相影响. 但实际上可以看作, 若选择 $x$ 个横放和 $y$ 个竖放, 就是要选择 $x+2y$ 行, 其中有 $y$ 对两两相邻. 对列也一样. 那么确定这个选择的方案之后剩下就是两两配对了. 所以预处理 $f_{x, y}, g_{x, y}$ 分别表示在确定横竖个数之后选行列的方案数, 答案就是</p><p>$$<br>\sum f_{x, y}g_{x, y}x! y!<br>$$</p><p>注意这里不是 $(x+y)!$ , 因为 $2y$ 个相邻行和只能和 $y$ 列匹配, $2x$ 个相邻列和 $x$ 行匹配, 两组匹配是独立的.</p><p>最后就是处理 $f, g$ 的问题了. 以 $f$ 为例, 对于每一个能选的行当连续段且确定 $x, y$ 后方案数很好确定. 那么这么背包上去只能做到三次方.</p><p>我们不需要同时考虑 $x$ 和 $y$ , 可以先确定选 $y$ 个行对当方案数, 再在剩下的里面选单独行是直接组合数. 而第一个就dp就好了. 前 $i$ 行选 $j$ 对的方案这样的. 就做完了.</p><p>dwt钦定是简单题</p><p><img src="/img/2022-10-14-19-17-47-image.png" alt="dwt"></p><h3 id="CF1185G-Playlist-for-Polycarp"><a href="#CF1185G-Playlist-for-Polycarp" class="headerlink" title="CF1185G Playlist for Polycarp"></a>CF1185G Playlist for Polycarp</h3><blockquote><p>有 $n$ 首歌, 每一首长 $t_i$ , 类型为 $g_i$ , 求选择一些歌并排列的方案使得任意两个相邻 $g_i$ 不同且总时长恰好为 $T$ .<br>$g_i\le 3$ </p></blockquote><h4 id="Version1-1"><a href="#Version1-1" class="headerlink" title="Version1"></a>Version1</h4><blockquote><p>$n\le 15, T\le 225, t_i\le 15$ </p></blockquote><p>直接状压dp. $f_{s, i}$ 表示 $s$ 已经被选了, 最后一个选的第 $i$ 首.</p><h4 id="Version2-1"><a href="#Version2-1" class="headerlink" title="Version2"></a>Version2</h4><blockquote><p>$n\le 50, T\le 2500, t_i\le 50$ </p></blockquote><p>不能直接状压dp了, 需要组合数学靠运气.</p><p>我们可以直接处理满足编号限制的dp: $f_{i, j, k, 0&#x2F;1&#x2F;2}$ 表示 $i$ 个第一种, $j$ 个第二种, $k$ 个第三种, 最后一个是哪一种的方案数. 暴力转移.</p><p>那么接下来就要考虑一个合法集合使得满足时间限制. 看看数据很小可以直接枚举 $i, j, k$ , 那么就要知道此时等于时间的方案数. 这是一个subset sum, 不过有三个集合. 所以就使劲背包就好了.</p><h3 id="CF1558D-Top-Notch-Insertions"><a href="#CF1558D-Top-Notch-Insertions" class="headerlink" title="CF1558D Top-Notch Insertions"></a>CF1558D Top-Notch Insertions</h3><blockquote><p>对于一个长度为 $n$ 的序列 $a$  做插入排序, 即依次考虑 $a_2, \cdots, a_n$ 每个元素:</p><ul><li><p>如果 $a_i \ge a_{i - 1}$ , 即前缀依然保持不下降, 不做操作.</p></li><li><p>否则, 找到最靠前的位置 $p$ , 使得 $a_i &lt; a_p$ , 然后将 $a_i$ 插入到 $a_p$  前面, 并重新标号序列. 记这次插入为 $(i, p)$ .</p></li></ul><p>接下来给定 $m$ 个二元组 $(x_i, y_i)$ , 求有多少个长度为 $n$ 的序列 $a$ , 满足 $\forall i, a_i \in [1, n] \cap \mathbb N$ 且做插入排序恰好按照给出的元组进行给定的 $m$ 次插入.</p><p>输出序列的数量对 $998244353$ 取模的结果.</p></blockquote><p>根据若干个插入条件, 可以唯一确定原序列相对顺序. (就是这些插入相当于对原序列做了一个置换重排, 根据这个可以获得 $a$ 的排序.</p><p>但此时拿到的 $a$ 并不是一个不降的要求(我们会得到若干 $&gt;$ 和若干 $\ge$ 串起来的关系), (可以理解一下这个关系蕴含了能获得的全部信息), 我们需要知道其中有几个是大于几个是大于等于. 一个数前面是小于当且仅当是另一个数直接插入到自己前面, 于是用平衡树维护序列即可.</p><p>平衡树不断插入有些麻烦, 反过来变成删除即可.</p><h3 id="CF1536F-Omkar-and-Akmar"><a href="#CF1536F-Omkar-and-Akmar" class="headerlink" title="CF1536F Omkar and Akmar"></a>CF1536F Omkar and Akmar</h3><blockquote><p>两个人在一个长度为 $n$ 的环上放黑白棋, 每个人在一个空格子里放一个颜色不能与相邻棋子相同的棋子, 问如果两人都采用最优策略, 可能的游戏过程有多少种.<br>$n\le 10^6$ </p></blockquote><p>手玩几组发现后手好像总会赢.</p><p>结论是:<strong>后手只要走, 无论怎么走都赢</strong>. 因为最后一定是若干个黑白交替连续段中间夹着单个空格, 且空格两边颜色一定不同. 所以总棋子数一定是偶数. 所以这俩人实际上是随便走, 然后后手能赢.</p><p>于是就可以直接计数最后的局面再乘一个排列.</p><p>最后的排列数也很好算, 枚举空格个数, 方案数就是</p><p>$$<br>2n\sum_i \binom{n-i}{i} (n-i-1)!<br>$$</p><p>阶乘减一是因为前面方案数实际上是 $\dfrac{\binom{n-i}{i}}{n-i}$ , 因为插板插完是个环.</p><h3 id="CF1111D-Destroy-the-Colony"><a href="#CF1111D-Destroy-the-Colony" class="headerlink" title="CF1111D Destroy the Colony"></a>CF1111D Destroy the Colony</h3><p>什么鬼题面</p><blockquote><p>给一个字符串 $s$ , $q$ 次询问对于两个字符 $x, y$ , 任意重排 $s$, 有多少种方法可以使得每一种字符都只出现在 $s$ 的前一半或后一半, 并且 $x, y$ 处于同一边.<br>$\vert s \vert \le 10^5, \vert \Sigma \vert \le 52, q\le 10^5$ </p></blockquote><p>首先 $q\le 10^5$ 是在诈骗, 一共只有 ${ \vert \sigma \vert }^2$ 种询问.</p><p>设 $n&#x3D;\dfrac{ \vert s \vert }{2}$ </p><p>考虑没有限制的话, 就是要我们从中选若干个数和为 $n$ 求方案数, 这个方案数乘上 ${(m! )}^2$ 再除掉 $\prod cnt_i!$ 就是没限制的答案. 有限制的时候就用从背包里删物品的做法删了再加进去一个他俩算作同一种的即可.</p><h3 id="CF1466G-Song-of-the-Sirens"><a href="#CF1466G-Song-of-the-Sirens" class="headerlink" title="CF1466G Song of the Sirens"></a>CF1466G Song of the Sirens</h3><blockquote><p>给定字符串 $s_0, t$ , 满足 $s_{i+1}&#x3D;s_it_is_i$ . 多次询问, 每次询问字符串 $w$ 在指定的 $s_k$ 中的出现次数. 答案对 $10^9+7$ 取模.<br>$n, q\le 10^5$ </p></blockquote><p>考虑 $s_i$ 对询问的贡献是跨过 $t_i$ 的出现次数, 长度是 $2\vert w\vert +1$ , 用kmp, hash可以做到 $k\vert w\vert$ 回答单次询问.</p><p>那么考虑, 对于 $i, j$ , 如果 $\vert s_i\vert &gt;\vert w\vert, \vert s_j\vert &gt;\vert w\vert, t_i&#x3D;t_j$ , 它们的贡献应该相同.</p><p>而由于每次 $s$ 长度翻一倍, 只用 $\log w$ 次就超过了, 那么复杂度就是 $\min{\log w, k} \vert w\vert$ . 结束了.</p><h3 id="CF1400G-Mercenaries"><a href="#CF1400G-Mercenaries" class="headerlink" title="CF1400G Mercenaries"></a>CF1400G Mercenaries</h3><blockquote><p>有 $n$ 个人和 $m$ 对敌对关系, 每一个人有一个条件区间 $[l_i, r_i]$ .</p><p>现在要在这 $n$ 个人中选<strong>若干个人</strong>. 定义一个合法的选择 ${S}$ , 当且仅当对于 ${S}$ 中的所有人 $i$ , $l_i\le  \vert S \vert  \le r_i$ , 且 ${S}$ 中所有人互不敌对.</p><p>求有多少种合法的选择, 答案对 $998244353$ 取模.</p><p>$1\le n\le 3\times 10^5$ , $0\le m\le \min{20, \frac{n(n-1)}{2}}$ , $1\le l_i\le r_i\le n$ .</p></blockquote><p>考虑如果 $m&#x3D;0$ , 直接枚举选的人数就做完了.</p><p>考虑容斥, 于是要求满足不限制集合 $s$ , 那么就是强制选若干点的方案数.</p><p>那么若原来我们枚举人数 $x$ 的时候方案数是 $\binom{n}{x}$ , 现在强制选了 $cnt$ 个点, 方案数就是 $\binom{n-cnt}{x-cnt}$ </p><p>要对所有这个求和会寄, 但因为这个 $cnt$ 最大到 $2m$ , 所以可以直接一遍处理所有 $cnt$ , 再一遍容斥枚举点集 $O(1)$ 算, 复杂度就是 $nm+2^m$ .</p><h3 id="CF285E-Positions-in-Permutations"><a href="#CF285E-Positions-in-Permutations" class="headerlink" title="CF285E Positions in Permutations"></a>CF285E Positions in Permutations</h3><blockquote><p>称一个 $1\sim n$ 的排列的完美数为有多少个 $i$ 满足 $\vert P_i-i \vert &#x3D;1$ .<br>求有多少个长度为 $n$ 的完美数恰好为 $m$ 的排列. 答案对 $10^9+7$ 取模.</p><p> $1 \le n \le 1000, 0 \le m \le n$ .</p></blockquote><p>二项式反演. $f(n)$ 表示完美数至少为 $k$ 的方案数, $g(n)$ 表示恰好为 $k$ 的, 于是有 $f(n)&#x3D;\sum_i \binom{i}{n} g(i)$ , 反演后 $g(n)&#x3D;\sum_i {(-1)}^{n-i}\binom{i}{n} f(i)$ .</p><p>现在转而求钦定 $k$ 个完美位的方案数. 考虑dp. $f_{i, j, 0&#x2F;1, 0&#x2F;1}$ 表示值域上前 $i$ 个选了 $j$ 个, 且 $i, i+1$ 是否作为完美位, 复杂度 $n^2$ 然后乘上一个阶乘就上上文的 $f(n)$ , 反演掉即可.</p><h3 id="CF1530F-Bingo"><a href="#CF1530F-Bingo" class="headerlink" title="CF1530F Bingo"></a>CF1530F Bingo</h3><blockquote><ul><li><p>给定一个 $n\times n$ 的表格, 表格中的每个元素有 $p_{i, j}$ 的概率为 $1$ , 否则为 $0$ .</p></li><li><p>求至少有一行或一列或一条对角线全为 $1$ 的概率. 对角线指主对角线或副对角线.</p></li><li><p>$n\le 21$</p></li></ul></blockquote><p>对角线看做特殊的列.</p><p>考虑容斥, 复杂度 $n\times 2^{2n+2}$ , 是不行的.</p><p>考虑只容斥列, 对于行带着容斥系数dp. 那么钦定一些列选不选之后, 这一行的系数就是没有被强制选的部分的概率的乘积, 设为 $p$ , 注意因为带着系数, 多选这一行之后应该乘 $-1$ , 两个加起来就行了.</p><h3 id="CF1486F-Pairs-of-Paths"><a href="#CF1486F-Pairs-of-Paths" class="headerlink" title="CF1486F Pairs of Paths"></a>CF1486F Pairs of Paths</h3><blockquote><p>给定一棵树和树上若干条路径, 求有多少个对 $i\ne j$ 满足路径 $i$ 和路径 $j$ 有且仅有一个公共点.</p><p>$n\le 3\times 10^5$ </p></blockquote><p>一开始糊了个强力做法, 假了, 不会.</p><p>考虑两个路径的交点一定是两个路径的lca中深的那一个.</p><p>考虑如果两个lca相同, 问题是简单的: 统计lca相同, 且路径经过的子树不同, 只要容斥算相同的就行了.</p><p>不同的做法感觉很鬼, 说的是LCA从小到大排序, 每次给小于当前lca的lca点的子树加1. , 查的时候查一下, 以lca为根的子树和减去序列两段点子树和.</p><p>另一个做法是离谱的点边容斥.</p><h3 id="CF140E-New-Year-Garland"><a href="#CF140E-New-Year-Garland" class="headerlink" title="CF140E New Year Garland"></a>CF140E New Year Garland</h3><blockquote><p>现在小 $A$ 手上有 $m$ 种小球, 他要用这些小球装饰一棵圣诞树.</p><p>这是一棵神奇的圣诞树, 一共有 $n$ 层, 每层由 $l_i$ 个小球组成.</p><p>对于每一层内部, 相邻的小球的都不相同.</p><p>同时, 外部来看, 相邻的两层的小球集合不相同.</p><p>现在小 $A$ 想要知道一共有多少种合法装饰方案, 答案对 $p$ 取模.</p><p>数据范围: ( $1\le n, m\le 10^6, 2\le p\le 10^9, 1\le l_i\le 5000, \sum\limits^n_{i&#x3D;1}l_i\le 10^7$ )</p></blockquote><p>考虑对于一层的计数方案, 只取决于这一层能用的颜色数和这层的球总数. 数量是 $m\times (m-1)^{c-1}$ , $c$ 为能用的数量.<br>那么差分完了就是恰好用 $c$ 种的, 设这个为 $g(l, c)$ </p><p>那就直接 $f_{i, j}$ 表示前 $i$ 层, 最后一层用了 $j$ 个颜色, 就行了吧.</p><p>$$<br>f_{i, j} &#x3D; (\sum f_{i-1, k}) \times {m}^{\underline{j}}\times g(l_i, j) - f_{i-1, j}\times j! \times g(l_i, j)<br>$$</p><p>然后发现我是智障, $g(l, c)$ 不能用至多的差分得到, 关系是一个二项式反演, 这个 $g$ 还是直接递推比较好. 式子是 $g(i, j)&#x3D;g(i-1, j-1)+g(i-1, j)\times (j-1)$ </p><h3 id="P5204-USACO19JAN-Train-Tracking-2-P"><a href="#P5204-USACO19JAN-Train-Tracking-2-P" class="headerlink" title="P5204 [USACO19JAN] Train Tracking 2 P"></a>P5204 [USACO19JAN] Train Tracking 2 P</h3><blockquote><p>给出长 $n$ 的序列的每个区间 $[i, i+k-1]$ 的最小值, 求值域不超过 $10^9$ 的原序列 $a$ 的方案数, 膜 $10^9+7$ .<br>$n, k\le 10^5, a\le 10^9$ </p></blockquote><p>考虑假设所有 $c$ 都是相同的, 怎么做? 相当于每 $k$ 个就要选一个 $c$ . 然后我们设可以选的数总数是 $x+1$ (多了个 $c$ )</p><p>暴力dp就是 $f_{i, j}$ 表示前 $i$ 个, 且没选 $c$ 已经有 $j$ 个. 转移 $f_{i, j}&#x3D;f_{i-1, j-1}\times x, f_{i, 0}&#x3D;\sum f_{i-1, j}$ , 可以直接记录一下上移多少位和全局乘法标记. 就是通过数据结构优化dp做.</p><p>题解区一个老哥用等差数列写了一把, 惊叹于他的脑回路, 但还是应该积累一下这个方法, 就是对一维状态的dp可以用类似数列的方法做.</p><p>最后, 实际上可以法法塔, 是1log的.</p><p>当然重点是接下来的, 考虑 $c$ 分成若干段, 对于每个连续段, 考虑 $c_i&#x3D;\ldots&#x3D;c_j$ , 那么现在有 $c_{i-1}&gt;c_i$ , 就有:</p><p>$\min {a_i\ldots a_{i+k-1}}&#x3D;c_i&lt;c_{i-1}&#x3D;\min {a_{i-1}\ldots a_{i+k-2}}$ </p><p>于是有 $a_{i+k-1}&#x3D;c_i$ 确定下来了, 那么它前面的都可以随便选, 直接归到上一个连续段考虑即可. 后面相同的同理. 这样处理之后每一段是独立的, 最后直接乘起来就是答案. 如果一段空了那么显然不用管它们.</p><h3 id="P3643-APIO2016-划艇"><a href="#P3643-APIO2016-划艇" class="headerlink" title="P3643 [APIO2016] 划艇"></a>P3643 [APIO2016] 划艇</h3><blockquote><p>计数长 $n$ 的序列 $a$ , 满足要求</p><ul><li>若 $a_i\ne 0, a_i\in [l_i, r_i]$ </li><li>若 $a_i\ne 0, a_i\ge a_{i-1}$<br>$n\le 500, a_i\le b_i\le 10^9$</li></ul></blockquote><p>和上面CF1295F Good Contest类似吧.</p><p>仍然离散化区间, 设 $f_{i, j}$ 表示前 $i$ 个, 最后一个是 $j$ 区间的方案数, 然后不从 $i$ 转移而从 $j$ 转移, 就结束了.</p><h3 id="CF367E-Sereja-and-Intervals"><a href="#CF367E-Sereja-and-Intervals" class="headerlink" title="CF367E Sereja and Intervals"></a>CF367E Sereja and Intervals</h3><blockquote><p>有 $n$ 个区间, 你需要为每个区间分配左右端点, 端点属于 $[1, m]\cap \mathbb{N}$ . 你需要保证区间两两互不包含且至少存在一个区间的左端点等于 $x$ , 输出方案数对 $10^9+7$ 取模的结果, 区间有标号. $nm\leqslant 10^5$ , $1\leqslant x\leqslant m$ .</p></blockquote><p>还可以吧.</p><p>考虑很显然的因为不互相包含, 所以按 $l$ 排序之后 $r$ 递增.</p><p>于是方案数是左右端点分别的方案再给一个阶乘(标号).</p><p>然后这个可以直接dp. 就直接设 $f_{i, j, k}$ 前 $i$ 个有 $j$ 个左端点 $k$ 个右端点. 复杂度就 $nm^2$ </p><h3 id="P6189-跑步"><a href="#P6189-跑步" class="headerlink" title="P6189 跑步"></a>P6189 跑步</h3><blockquote><p>划分数. $n\le 10^5$ , 对 $p\le 2^{30}$ 取模.</p></blockquote><p>多项式? ? ?</p><p>居然是根号分治. 设 $B&#x3D;\sqrt n$ </p><p>完全背包前 $B$ 个数的方案, 记结果 $g_{i}$ 表示凑 $i$ 的方案数.</p><p>dp出只有大于 $B$ 的数凑成的方案, 然后卷起来.</p><h3 id="CF1651E-Sum-of-Matchings"><a href="#CF1651E-Sum-of-Matchings" class="headerlink" title="CF1651E Sum of Matchings"></a>CF1651E Sum of Matchings</h3><p>收录在greedy里</p><h3 id="CF1613F-Tree-Coloring"><a href="#CF1613F-Tree-Coloring" class="headerlink" title="CF1613F Tree Coloring"></a>CF1613F Tree Coloring</h3><blockquote><p>给一棵有根树, 求排列 $c$ 的方案数使得 $\forall u, \ c_{fa}-1\ne c_u$ .</p><p>膜998244353, $n\le 250000$</p></blockquote><p>原来是多项式题.</p><p>考虑钦定 $i$ 个点不合法, 直接容斥就是 $i$ 为偶数的方案减去奇数的.</p><p>二项式反演也一样. 考虑钦定 $i$ 个点不合法的方案数是 $f(i)$ , 恰好 $i$ 个点不合法的方案数 $g(i)$ , $f(i)&#x3D;\sum \binom{i}{j}g(j)$ , 这个是因为 $i$ 个点不合法的方案是等价的, 于是反演得 $g(0)&#x3D;\sum f(i)\times (-1)^i$ , 可以扩展到其它恰好其它 $i$ 个不对的.</p><p>那么考虑如何求 $f_i$ . 我们只需要知道从这里面选 $i$ 个不合法的方案数, 因为剩下的可以随便排, 问题就变成了钦定 $i$ 个点不合法的方案数.</p><p>考虑点 $u$ 有 $k$ 个儿子, 则在其中钦定一个不合法点的方案数是 $k$ , 钦定其中没有的方案数是1, 所以把 $1+kx$ 卷起来就行了. 分治ntt可以做 $n\log^2 n$ .</p><h3 id="CF1580B-Mathematics-Curriculum"><a href="#CF1580B-Mathematics-Curriculum" class="headerlink" title="CF1580B Mathematics Curriculum"></a>CF1580B Mathematics Curriculum</h3><blockquote><p>求有多少排列长度为 $n$ , 恰有 $k$ 个数满足所有包含这个数的区间中, 不同的最大值有恰好 $m$ 个.</p><p>$n\le 100, m, k\le n, p\le 10^9$</p></blockquote><p>[trick] 对于一个数来说, 其包含这个数的区间的不同最大值个数恰好是这个数向前向后的前缀min个数之和. 而这个等价于笛卡尔树(大根)上的层数, 所以就是计数笛卡尔树上 $m$ 层恰好有 $k$ 个元素的方案数.</p><p>考虑dp笛卡尔树的结构, 设 $f_{i, j, k}$ 表示 $i$ 个点的笛卡尔树, 深度为 $j$ 的有 $k$ 个的方案数即可.</p><h3 id="CF1278F-Cards"><a href="#CF1278F-Cards" class="headerlink" title="CF1278F Cards"></a>CF1278F Cards</h3><blockquote><p>有 $m$ 张牌, 其中一张是王牌, $n$ 次洗牌后查看第一张牌, 看见王牌的次数 $x$ . 认为洗牌时 $m!$ 排列概率均等. 求 $x^k$ 的期望.<br>$n, m\le 998244353, k\le 5000$</p></blockquote><p>直接推式子.</p><p>$$<br>\begin{aligned}<br>&amp;\sum_i i^k\binom {n}{i}{(\dfrac{1}{m})}^i{(\dfrac{m-1}{m})}^{n-i} \<br>&#x3D;&amp;\dfrac{1}{m^n}\sum_i i^k{(m-1)}^{n-i}\binom{n}{i}\<br>&#x3D;&amp;\dfrac{1}{m^n}\sum_i {(m-1)}^{n-i}\binom{n}{i}\sum_j {k\brace j}i^{\underline{j}}\<br>&#x3D;&amp;\dfrac{1}{m^n}\sum_j{k\brace j}\sum_i{(m-1)}^{n-i}\binom{n}{i}i^{\underline{j}}\<br>\<br>&amp;\binom{n}{i}i^{\underline{j}}&#x3D;[i\ge j]\dfrac{n^{\underline{i}}}{i^{\underline{i}}}i^{\underline{j}}&#x3D;\dfrac{n^{\underline{j}}{(n-j)}^{\underline{i-j}}}{(i-j)! }&#x3D;n^{\underline{j}}\binom{n-j}{i-j}\<br>\<br>&amp;\sum_i {(m-1)^{n-i}}\binom {n}{i}i^{\underline{j}}\<br>&#x3D;&amp;n^{\underline{j}}\sum_i \binom{n-j}{i-j}{(m-1)^{n-i}}\<br>&#x3D;&amp;n^{\underline{j}}\sum_i \binom{n-j}{n-i}{(m-1)^{n-i}}\<br>&#x3D;&amp;n^{\underline{j}}{(m+1-1)}^{n-j}\<br>&#x3D;&amp;n^{\underline{j}}m^{n-j}\<br>\<br>&amp;\dfrac{1}{m^n}\sum_j{k\brace j}\sum_i{(m-1)}^{n-i}\binom{n}{i}i^{\underline{j}}\<br>&#x3D;&amp;\dfrac{1}{m^n}\sum_j{k\brace j}n^{\underline{j}}m^{n-j}<br>\end{aligned}<br>$$</p><p>可以枚举 $j$ 直接做了.</p><p>告诉我们要相信式子的力量.</p><h3 id="CF1153F-Serval-and-Bonus-Problem"><a href="#CF1153F-Serval-and-Bonus-Problem" class="headerlink" title="CF1153F Serval and Bonus Problem"></a>CF1153F Serval and Bonus Problem</h3><blockquote><p>给定长为 $l$ 的数轴, 有 $n$ 个在 $[0, l)$ 间随机的区间, 求被被至少 $k$ 个区间覆盖的期望长度.</p><p>$k, n\le 2000, l\le 10^9$ , 膜998244353.</p></blockquote><p>首先实际上 $l$ 是没用的, 按 $l&#x3D;1$ 的算直接乘上就行了.</p><p>考虑位置 $x$ 被覆盖一次的概率是 $2x(1-x)$   </p><p>$$<br>f(x)&#x3D;\sum_{i\in[k, n]} \binom{n}{i}(2x(1-x))^{i} (1-2x(1-x))^{n-i}<br>$$</p><p>对这个求积分就是答案.</p><p>这个是关于 $x$ 的多项式, 如果直接暴力是 $n^3$ 的.</p><p>中间部分是卷积, 可以 $ntt$ 做成 $n^2\log n$ .</p><p>考虑算点值再插值回去, 最后再求积分也是可行的, 那么 $O(n^2)$ 算 $n$ 个点值就行了.</p><p>好厉害啊.</p><h3 id="CF814E-An-unavoidable-detour-for-home"><a href="#CF814E-An-unavoidable-detour-for-home" class="headerlink" title="CF814E An unavoidable detour for home"></a>CF814E An unavoidable detour for home</h3><blockquote><p>$n$ 个点, 每个点有度数 $d_i$ , 构造无向图满足点 $1$ 到点 $i$ 的最短路唯一且比到 $i-1$ 的长. 求方案数.<br>$n\le 50, 2\le d_i\le 3$</p></blockquote><p>想想以1为根的最短路树. 那么图是这个的基础上连若干同深度的边得到的.</p><p>然后dp计数. 设 $f_{i, j}$ 表示后 $i$ 个节点, 最后一层有 $j$ 个的方案数.<strong>从下往上dp</strong>.</p><p>这里不记点的度数, 因为从下往上dp保证每个点都还有一个度留给往上的. 每个点的儿子数量不确定但父亲数量确定是从下往上的原因.</p><p>那么相邻两层之间的边, 一层内的边都分别预处理即可.</p><p>反正还是很不会数数啊.</p><p>[think] 想不到原因的话, 感觉还是枚举dp方向吧.</p><h3 id="CF382E-Ksenia-and-Combinatorics"><a href="#CF382E-Ksenia-and-Combinatorics" class="headerlink" title="CF382E Ksenia and Combinatorics"></a>CF382E Ksenia and Combinatorics</h3><blockquote><p>求有多少个以 $1$ 为根的 $n$ 节点二叉树最大匹配为 $k$ , 树相同判定为每个节点的相连节点相同.</p><p>膜 $10^9+7$</p></blockquote><p>第一反应是, 很像SDOI2022D2T1吧</p><p>所以还是类似dp of dp的思路, 但注意树的最大匹配是不需要dp的, 实际上做法是直接贪心, 从叶子开始匹配, 那么这里就设 $f_{u, i, 0&#x2F;1}$ 表示 $u$ 节点内有 $i$ 个匹配, 其中 $u$ 自身是否被匹配即可.</p><p>注意因为判定是树同构所以钦定左儿子小于右儿子, 大小相同除以2. 并且转移的时候要带编号.</p><h3 id="CF235E-Number-Challenge"><a href="#CF235E-Number-Challenge" class="headerlink" title="CF235E Number Challenge"></a>CF235E Number Challenge</h3><p>一个莫反题有贪心和组合数学标签上让人问号的.</p><p>收录在greedy中.</p><h3 id="CF1548C-The-Three-Little-Pigs"><a href="#CF1548C-The-Three-Little-Pigs" class="headerlink" title="CF1548C The Three Little Pigs"></a>CF1548C The Three Little Pigs</h3><blockquote><p>$q$ 次给定 $x$ , 询问 $\sum_{i&#x3D;1}^n \binom{3i}{x}\pmod {10^9+7}$ .</p><p>$n\le 10^6, q\le 2\times 10^5, x\le 3n$</p></blockquote><p>考虑那一定是对着这一堆 $x$ 一起算. 但这个式子关于 $x$ 不是多项式.</p><p>但还是简单的, $\binom{3i}{x}&#x3D;[z^x] (z+1)^{3i}$ , 那么直接求和然后暴力求即可求出对所有 $x$ 的答案.</p><h3 id="CF840C-On-the-Bench"><a href="#CF840C-On-the-Bench" class="headerlink" title="CF840C On the Bench"></a>CF840C On the Bench</h3><blockquote><p>给定序列 $a_n$ , 求排列个数使得相邻两个的乘积不为完全平方数. 膜 $10^9+7$ .<br>$n\le 300, V\le 10^9$</p></blockquote><p>考虑直接给所有数除掉自己的平方因子, 就成了求相邻两数不同的排列个数.</p><p>考虑把所有类的数一一插进去, 假设现在已有的排列长 $m$ , 要再插进 $k$ 个相同值, 方案数显然是 $\binom{m+1}{k}k!$ . 就结束了吧</p><p>哦暴露了垃圾的数数水平, 这个显然是错的啊原因是有可能出现现在有若干个位置相邻但以后被插入了东西.</p><p>那就再加一维, 逐个数字dp直接记 $f_{i, j, k}$ 表示前 $i$ 类数, 并且当前有 $j$ 个相邻的数之间需要被插入新的数, 其中有 $k$ 个是等于 $i$ 的, dp就行了. 复杂度是 $n^3$ 的. 这个dp转移比较像那种连续段dp.</p><p>有个更厉害点的做法, 考虑仍然容斥, 那么钦定 $i$ 对彼此相邻的方案数记为 $f_i$ , 那么显然答案就是 $\sum f_i\times  (-1)^i$ , 而 $f_i$ 可以由各个颜色的直接卷积合并. 复杂度 $n^2$ .</p><h3 id="CF997C-Sky-Full-of-Stars"><a href="#CF997C-Sky-Full-of-Stars" class="headerlink" title="CF997C Sky Full of Stars"></a>CF997C Sky Full of Stars</h3><blockquote><p>给定 $n\times n$ 的正方形网格, 用三种颜色染色, 求没有一行或一列颜色相同的方案数. 膜998244353.</p><p>$n\le 10^6$</p></blockquote><p>看到这种直接考虑容斥反演类技术. 于是钦定选了 $i$ 行 $j$ 列颜色相同方案数是 $f(i, j)$ , 没有相同的方案数就是</p><p>$$<br>\sum_i \sum_j f(i, j)\binom{n}{i}\binom{n}{j}\times (-1)^{i+j}<br>$$</p><p>(高维容斥反演时系数是各维度之积, 也可以分部理解)</p><p>考虑 $f$ 是十分容易计算的:</p><p>$$<br>f(i, j)&#x3D;<br>\begin{cases}<br>  3^{(n-i)(n-j)+1}, \ ij\ne 0\<br>  3^{i+j}3^{n(n-i-j)}\ ij&#x3D;0<br>\end{cases}<br>$$</p><p>发现 $ij&#x3D;0$ 的情况可以直接单独计算(此时只有一个变量, 直接暴力求). 考虑 $ij\ne 0$ 的情况:</p><p>$$<br>\begin{aligned}<br>    &amp;\sum_i \sum_j \binom{n}{i}\binom{n}{j}\times (-1)^{i+j}\times 3^{(n-i)(n-j)+1}\<br>    &#x3D;&amp;\sum_i \sum_j \binom{n}{i}\binom{n}{j}\times (-1)^{i+j}\times 3^{ij}3^{ni}3^{nj}3^{n^2+1}\<br>    &#x3D;&amp;3^{n^2+1}\sum_i (-1)^i \binom{n}{i}3^{ni} \sum_j \binom{n}{j}(-1)^j\times 3^{nj}\times 3^{ij}<br>\end{aligned}<br>$$</p><p>$ij$ 不会处理了. 大多数组合恒等式这里不行因为这个次幂很难看, 考虑少数有正常幂的二项式定理</p><p>$$<br>\begin{aligned}<br>    &amp;3^{n^2+1}\sum_i (-1)^i \binom{n}{i}3^{ni} \sum_j \binom{n}{j}(-1)^j\times 3^{nj}\times 3^{ij}\<br>    &#x3D;&amp;3^{n^2+1}\sum_i (-1)^i \binom{n}{i}3^{ni} \sum_j \binom{n}{j}(-1\times 3^{n+i})^j\<br>    &#x3D;&amp;3^{n^2+1}\sum_i (-1)^i \binom{n}{i}3^{ni} (-1\times 3^{n+i}+1)^n<br>\end{aligned}<br>$$</p><p>就结束了.</p><h3 id="CF1327F-AND-Segments"><a href="#CF1327F-AND-Segments" class="headerlink" title="CF1327F AND Segments"></a>CF1327F AND Segments</h3><blockquote><p>给定 $n, k, m$ 以及 $m$ 个限制 $(l_1, r_1, x_1)\ldots (l_m, r_m, x_m)$</p><p>求每个数都在 $[0, 2^k]$ 中, 且 $\forall i, a_{l_i}\mathrm{and} a_{l_i+1}\mathrm{and}\ldots a_{r_i}&#x3D;x$ , 且长度为 $n$ 的序列个数</p><p>$n, m\le 5\times 10^5, k\le 30$</p><p>膜998244353</p></blockquote><p>考虑每一位是相同的. 问题变成了, 指定一段全是1或者其中至少有一个0, 求方案数.</p><p>那直接用全1段把它们拆成若干段, 每段就只有限制至少有一个0的方案了.</p><p>可以设 $f_i$ 表示前 $i$ 个且第 $i$ 个为0的方案数, 则 $f_i$ 是一个区间的和, 前缀和优化即可.</p><h3 id="CF1174E-Ehab-and-the-Expected-GCD-Problem"><a href="#CF1174E-Ehab-and-the-Expected-GCD-Problem" class="headerlink" title="CF1174E Ehab and the Expected GCD Problem"></a>CF1174E Ehab and the Expected GCD Problem</h3><blockquote><p>关于排列 $p_n$ , 设 $g_i$ 表示 $\gcd {a_1, a_2, \ldots, a_i}$ , $g_i$ 的数量为 $f(p)$ , $f$ 的最大值为 $f_{max}$ , 求有多少个排列 $p$ 满足 $f(p)&#x3D;f_{max}$<br>$n\le 10^6$</p></blockquote><p>考虑 $f$ 的最大值, 显然一种构造是从头开始2的幂下降一定能达到最大. 于是最大值已知.</p><p>那么也能顺便得到结论: 不会有 $5$ 及以上的下降(下降指前缀 $\gcd$ 除以了 $5$ ), 不会有两个 $3$ 的下降, 因为都可以调整为数量更多的 $2$ 下降.</p><p>于是直接dp, $f_{i, j, k}$ 表示前 $i$ 个, 其中当前gcd为 $2^i3^j$ 的方案数, 从序列维转移.</p><p>dp排列值域扫多了都要忘了能序列了.</p><h3 id="CF1367F-Flying-Sort"><a href="#CF1367F-Flying-Sort" class="headerlink" title="CF1367F Flying Sort"></a>CF1367F Flying Sort</h3><blockquote><p>给定 $n$ 个正整数构成的序列, 每次可以将序列中的任意一项放到最前面或最后面, 求最少操作次数让序列不降.</p></blockquote><h4 id="Easy-Version"><a href="#Easy-Version" class="headerlink" title="Easy Version"></a>Easy Version</h4><blockquote><p>保证每个数互不相同, $n\le 3000$</p></blockquote><p>每个数最多操作一次. 显然.</p><p>那么找到可以保留的最多的数. 并且因为中间不能插进数, 所以就是保留最长的相差为1的上升的子序列. 设 $f_i$ 表示前 $i$ 个以 $i$ 结尾的答案, 那么 $f_{a_i}&#x3D;f_{a_i-1}+1$</p><h4 id="Hard-Version"><a href="#Hard-Version" class="headerlink" title="Hard Version"></a>Hard Version</h4><blockquote><p>可以有相等的数, $n\le 2\times 10^5$</p></blockquote><p>首先你觉得这个就是直接把上面的dp搬过来, 加上可以相等.</p><p>但实际上区别在于, 中间可能要取完, 比如排列<code>1 1 2 2 3 3 2</code>中, 我们不能选<code>1 1 2 2 3 3</code>因为这样<code>2</code>是插不进来的.</p><p>所以就是分三种情况: 都等于一个值, 两段不一定取完, 三段, 其中中间段必须取完这三种, dp即可.</p><h3 id="CF510D-Fox-And-Jumping"><a href="#CF510D-Fox-And-Jumping" class="headerlink" title="CF510D Fox And Jumping"></a>CF510D Fox And Jumping</h3><blockquote><p>给出 $n$ 张卡片, 分别有 $l_i$ 和 $c_i$ . 在一条无限长的纸带上, 你可以选择花 $c_i$ 的钱来购买卡片 $i$ , 从此以后可以向左或向右跳 $l_i$ 个单位. 问你至少花多少元钱才能够跳到纸带上全部位置. 若不行, 输出 $-1$ .</p><p>$n\le 300, l_i\le 10^9$</p></blockquote><p>能从0到1等价于能完成任务. 考虑若干数凑出1等价于它们 $\gcd$ 为1, 直接冲用map记状态就行.</p><h3 id="BZOJ3864-Hero-meet-devil"><a href="#BZOJ3864-Hero-meet-devil" class="headerlink" title="BZOJ3864 Hero meet devil"></a>BZOJ3864 Hero meet devil</h3><blockquote><p>给定 $s$ , 求有多少长 $m$ 的串 $t$ 满足 $lcs(t, s)&#x3D;i$ , 对所有 $i$ 输出答案.</p><p>$\vert s\vert \le 15, m\le 1000$</p></blockquote><p>内层dp显然是求lcs的dp $f_{i, j}$ 表示 $s$ 前 $i$ 个和 $t$ 前 $j$ 个那个, 是众所周知的, 关键是如何压缩状态.</p><p>发现做到 $2^{\vert s\vert}m$ 左右可能正好? 考虑我们显然扫描 $j$ , 维护所有 $f_{i}$ , 和LCS Again那题一样有个经典结论 $f_{i, j}-f_{i, j-1}\le 1$ 所以可以差分压成二进制就做完了.</p><h3 id="CF1043F-Make-It-One"><a href="#CF1043F-Make-It-One" class="headerlink" title="CF1043F Make It One"></a>CF1043F Make It One</h3><blockquote><p>给定序列 $a_n$ , 求选最少的数使得它们gcd为1.</p><p>$n, a_i\le 3\times 10^5$</p></blockquote><p>考虑 $3\times 10^5$ 内的数的最多不同质因数个数有 $6$ 个.</p><p>那么答案最大是不是不超过 $6$ 呢.</p><p>发现实际上界是7, 构造出来应该是 $2, 3, 5, 7, 11, 13, 17$ 分别删去一个数得到的集合.</p><p>qyc给出强力做法: 直接gcd卷积, 若答案为 $k$ , 则卷恰好 $k$ 次的时候 $f_1\ne 0$ .</p><p>复杂度是 $n\log n$ 或 $n \log^2 \log n$</p><h3 id="CF1792F1-Graph-Coloring-easy-version"><a href="#CF1792F1-Graph-Coloring-easy-version" class="headerlink" title="CF1792F1 Graph Coloring (easy version)"></a>CF1792F1 Graph Coloring (easy version)</h3><blockquote><p>给定 $n$ 个点的完全图, 求有多少个红蓝染色方案, 使得对任意一个点集 $S$, 满足其导出子图仅看红色边是连通的, 或满足仅看蓝色边上连通的, 但不同时满足两个限制.</p><p>$n\le 5000$</p></blockquote><p>行</p><p>[trick] 一个图和它的补图中至少有一个是连通的.</p><p>对于原图中不连通的两个联通块, 其中一个的点 $x$ 必然和另一个的所有点相连, 所以这个连通块在补图中是连通的, 剩下部分显然.</p><p>整张图必然是蓝&#x2F;红连通的, 假设是红连通, 蓝不连通.</p><p>那么考虑计数策略之一, 看所有和 $1$ 蓝连通的点组成的块, 组成了一个规模更小的问题, 而剩下的点和这个块之间全是红边, 剩下的点是另一个规模更小的问题, 可以 $n^2$ dp出来.</p><p>$$<br>f_n&#x3D;\sum_{x&lt;n} \binom{n}{x} f_x \cdot (f_{n-x}\cdot (2-[x&#x3D;n-1]))<br>$$</p><p>$n-x$ 的部分可能是蓝连通的也可能是红连通的, 但当只有一个点的时候就只有一种了.</p><h3 id="CF1781F-Bracket-Insertion"><a href="#CF1781F-Bracket-Insertion" class="headerlink" title="CF1781F Bracket Insertion"></a>CF1781F Bracket Insertion</h3><blockquote><p>进行 $n$ 次操作, 设当前序列为 $s$(初始为空), 每次从 $s$ 中随机选一个空位(若长度为 $k$, 有 $k+1$ 个空位), 以 $p$ 概率插入<code>()</code>或以 $1-p$ 概率插入<code>)(</code>, 求最后得到合法序列的概率.</p><p>膜 $998244353$.<br>$n\le 500$.</p></blockquote><p>考虑把插入的包含关系建树, 设<code>()</code>是 $1$, <code>)(</code>是 $-1$, 看起来要求任意根开始的路径和非负.</p><p>那考虑dp, 设 $f_{i, j}$ 表示 $i$ 个点, 节点到当前根的和最小为 $j$ 的方案数dp应该就行.</p><p>todo;</p><h3 id="CF1750F-Majority"><a href="#CF1750F-Majority" class="headerlink" title="CF1750F Majority"></a>CF1750F Majority</h3><blockquote><p>求有多少个01串 $s$, 满足允许任意次把一个1个数大于等于0个数, 且两端点是 $1$ 的区间变成全1的操作下, 变成全1串.<br>对 $m$ 取模.<br>$n\le 5000, m\le 10^9$.</p></blockquote><p>看起来是让你dp的, 并且我们显然应该对着操作完了不能操作了的串dp.</p><p>容易发现操作完了的串是0, 1连续段交替, 且0的长度大于两边1的长度, 当然两头必须是1.</p><p>于是设 $f_{i, j}$ 表示长度为 $i$, 操作完最后一个1段长 $j$ 的方案数, 你发现 $f_{i, j}, j&lt;i$ 的转移方式是能写的, 考虑去掉结尾 $j$ 个 $1$, 再枚举去掉 $k$ 个 $0$, 再枚举剩下的最后长 $l$ 个 $1$ 即可. 而 $f_{i, i}$ 十分遗憾的等于自身</p><p>于是 $f_{i, i}$ 的用 $2^{i-2}-\sum f_{i, j}$ 表示了.</p><p>用一些前缀和优化做到 $n^2$.</p><h3 id="CF1617E-Christmas-Chocolates"><a href="#CF1617E-Christmas-Chocolates" class="headerlink" title="CF1617E Christmas Chocolates"></a>CF1617E Christmas Chocolates</h3><blockquote><p>你有一个长度为 $n$ 的数组 $a_1, a_2, \dots, a_n$, 一开始数组中的所有元素都<strong>互不相同</strong>.<br>你可以选择两个数组中的元素 $a_x, a_y$, 然后执行若干次操作, 每次操作你可以选择一个非负整数 $k$, 然后将 $a_x$ 替换为 $2^k-a_x$. 如果在某次操作之后 $a_x&#x3D;a_y$, 那么不再执行操作. 任意时刻, $a_i$ 不能为负数.</p><p>你是一个很聪明的人, 所以在选择一对 $(x, y)$ 之后你知道如何用最少的操作次数使得 $a_x&#x3D;a_y$. 但是你并不满足于此, 你现在还想知道使得最少操作次数最大的 $(x, y)$. 请求出 $x, y$ 和这个最大的最少操作次数 $m$.</p><p>数据范围:</p><ul><li>$2\leqslant n\leqslant 2\times 10^5$.</li><li>$0\leqslant a_i\leqslant 10^9$.</li></ul></blockquote><p>考虑一个数经过操作形成一棵树(对于一个树, 只有最小的 $k$ 变成的数小于自己). 于是路径是唯一的, 要求最长路.</p><p>求虚树需要求lca, dfn, 完全不会啊.</p><p>停, 一个点的深度是 $\log v$ 的, 那么根据直径性质就直接求最远的点, 再求最远的点就做完了.</p><h3 id="CF1574F-Occurrences"><a href="#CF1574F-Occurrences" class="headerlink" title="CF1574F Occurrences"></a>CF1574F Occurrences</h3><blockquote><p>有 $n$ 个值域在 $[1, k]$ 的数列 $A_1, A_2, \cdots, A_n$, 要求构造一个长为 $m$ 的值域在 $[1, k]$ 的序列 $a$, 满足对于所有数列 $A_i$, $A_i$ 在序列 $a$ 中的出现次数大于等于其任意一个非空子段在 $a$ 中的出现次数.<br>求不同的 $a$ 的数量, 答案 $\bmod 998244353$.<br><strong>数据范围</strong>: $1\le n, m, k\le 3\times 10^5, \sum c_i\le 3\times 10^5$.</p></blockquote><p>考虑限制的意思是, 如果 $a$ 中的一个数出现了, 那么 $a$ 必须按顺序完整出现一遍.</p><p>于是对于 $i, j$, $A_{i, j}\to A_{i, j+1}$ 连边, 要求每次可以选择一个入度为 $0$ 的点走一条链拼出整个串.</p><p>那后面这个问题背包求方案数啊.</p><h3 id="CF1542E-Abnormal-Permutation-Pairs"><a href="#CF1542E-Abnormal-Permutation-Pairs" class="headerlink" title="CF1542E Abnormal Permutation Pairs"></a>CF1542E Abnormal Permutation Pairs</h3><blockquote><p>给定 $n, m$, 求有多少对长度为 $n$ 的排列 $p, q$, 满足以下条件.</p><ul><li>$p$ 的字典序小于 $q$</li><li>$p$ 的逆序对个数大于 $q$.</li></ul><p>答案对 $m$ 取模.</p><p>$1\le n\le 500, 1\le m\leq 10^9$,<strong>不保证</strong> $m$ 为素数.</p></blockquote><p>容易想到枚举前面相同的前缀长度, 也容易想到笛卡尔树dp排列.</p><p>那么注意到, 枚举一个相同的长 $l$ 前缀后, 只要看后面的逆序对数就能比较.</p><p>于是dp后面的, $f_{i, j, 0&#x2F;1&#x2F;2}$ 表示从小到大插入 $i$ 个数, 目前两个排列逆序对个数的差为 $j$, 第一个数现在是 $p&#x2F;q&#x2F;$ 一样大的方案数. 如果枚举插入位置复杂度是 $n^5$ 的吧.</p><p>然后考虑从 $f_{i, j}$ 转移到 $f_{i+1, j+k}$ 时, $k$ 是插入的两个数的位置的下标的差, 于是就是乘一个 $n-\vert k\vert+C$ 的系数.</p><p>那么用一些奇妙的二阶差分就能区间加等差数列了吧, 或者把 $k$ 拆成 $(j+k)-j$ 后在两边分别贡献.</p><p>复杂度 $n^3$.</p><p>Froggy的”显然生成函数是”, 就是直接考虑每次插入一个 $i$ 时的贡献, 则插入到一个序列相当于把原答案卷上 $\sum_{j&#x3D;0}^{i-1} x^j$, 再插入就是又卷 $\sum_{j&#x3D;0}^{i-1} x^{-j}$, 把这两个乘起来化简即可.</p><h3 id="CF1511F-Chainword"><a href="#CF1511F-Chainword" class="headerlink" title="CF1511F Chainword"></a>CF1511F Chainword</h3><blockquote><p>给出一个 $n$ 个词的字典 $S_1, S_2, \dots , S_n$, 求由长度均为 m 的字符串<br>S 和划分 $P, Q$ 组成的三元组 $(S, P, Q)$ 数量, 满足:</p><ul><li>对于 $P$ 中划分的每一段 $[l, r]$, 均满足 $S[l, r]$ 在字典中.</li><li>对于 $Q$ 中划分的每一段 $[l, r]$, 均满足 $S[l, r]$ 在字典中.</li></ul><p>答案对 $998244353$ 取模.<br>$n\le 8, m\le 10^9$</p></blockquote><p>先考虑 $O(mC)$ 的东西, 那么dp过程中看起来我们需要记录最后几位的是啥, 但实际上显然只关心匹配情况, 所以就是都插到字典树里, $f_{i, j, k}$ 记录一共长 $i$, 当前 $P$ 在字典树的 $j$, $Q$ 在字典树的 $k$.</p><p>然后显然和 $i$ 没啥关系, 就矩阵快速幂.</p><p>8个字符串, 每个有5个字符, 最大有 $40$ 个节点, 复杂度爆炸了.</p><p>观察性质, $j, k$ 都是当前填好的后缀, 所以他俩一个是另一个的后缀.</p><p>于是现在状态数减少到 $5<em>8</em>8&#x3D;320$, 过了.</p><p>[trick] 同一个字符串的两个后缀必有一个是另一个后缀</p><h3 id="CF1487G-String-Counting"><a href="#CF1487G-String-Counting" class="headerlink" title="CF1487G String Counting"></a>CF1487G String Counting</h3><blockquote><p>你有 $26$ 个不同的字符, 第 $i$ 个字符有 $c_i$ 个($\frac{n}{3} &lt; c_i \leq n$).</p><p>你希望用这些字符, 构造出一个长度为 $n$ 的字符串(每个字符在字符串中出现的个数不超过 $c_i$), 使得这个字符串上不存在长度为奇数且大于 $1$  的回文串. 求出方案数对 $998244353$ 取模的结果.</p><p>$n\le 400$, 10s, 1G</p></blockquote><p>注意到 $\frac{n}{3}&lt;c_i\le n$ 的意思是, 你只能有两个字符超出限制.</p><p>那么先不考虑字符数限制的话, 考虑添加一个字符 $c$ 时只要求它不能和上上次添加的相同即可, 是随便做.</p><p>那么容斥, 钦点两个字符次数过多, 于是 $f_{i, j, k, 0&#x2F;1&#x2F;2, 0&#x2F;1&#x2F;2}$ 表示添加 $i$ 个字符, 如果 $a, b$ 的次数分别是 $j, k$, 最后两个位置是 $a&#x2F;b&#x2F;$ 其他的情况下的答案. 仍然可以转移.</p><h3 id="CF1540C1-x2F-2-Converging-Array"><a href="#CF1540C1-x2F-2-Converging-Array" class="headerlink" title="CF1540C1&#x2F;2 Converging Array"></a>CF1540C1&#x2F;2 Converging Array</h3><blockquote><p>这是这道题的困难版, 与简单版唯一不同是 $1 \le q \le 10^5$</p><p>现在有长度为 $n$ 的数组 $a$ 和长度为 $n - 1$ 的数组 $b$, 进行无穷次如下过程直至 $a$ 数组值收敛</p><ol><li>选择一个数字 $i$</li><li>同时使 $a_i &#x3D; min(a_i, \frac{a_i + a_{i + 1} - b_i}{2}), \ a_{i + 1} &#x3D; max(a_{i + 1}, \frac{a_i + a_{i + 1} + b_i}{2})$ (没有取整)</li></ol><p>定义 $F(a, b)$ 为操作完成后 $a_1$ 的值</p><p>现在你知道数组 $b$ 和 长度为 $n$ 的数组 $c$, 保证 $\forall i \in [1, n], \ 0 \le a_i \le c_i$</p><p>有 $q$ 组询问, 每次问使 $F(a, b) \ge x$ 的数组 $a$ 有多少个</p><p>答案对 $1\ 000\ 000\ 007$ 取模</p></blockquote><p>考虑简单版($q&#x3D;1$).</p><p>考虑操作就是, 对于 $a_i, a_{i+1}$, 如果 $a_{i+1}&lt;a_i+b_i$ 就把它们两个以平均值为中心差调整到 $b_i$</p><p>考虑现在的限制, 因为一个前缀的和随操作是不增的, 再通过分析收敛后, $a_i\ge x+\sum_j b_j$, 容易得出前缀和 $s_i\ge ix+\sum b_j$.</p><p>问题来到充分性, 考虑如果一开始 $a_1&gt;x$, 那么要让它调整到小于 $x$ 必须让 $a_2&lt;x+b_i$, 以此类推.</p><p>那么 $q&#x3D;1$ 是简单背包, 可以优化到 $n^3$</p><p>那么注意到通过分析 $a_1, a_n$ 的取值范围, 得出不同的 $x$ 只有 $200$ 种(剩下都不可能), 就过了.</p><h2 id="4-2021sdpttday3"><a href="#4-2021sdpttday3" class="headerlink" title="4. 2021sdpttday3"></a>4. 2021sdpttday3</h2><h3 id="AGC028B"><a href="#AGC028B" class="headerlink" title="AGC028B"></a>AGC028B</h3><blockquote><p>现在有 $N$ 条线段排成一行, 其中第 $i$ 条线段的长度为 $A_i$. 现在要按照一个顺序删除所有线段, 以下定义其代价:</p><ul><li>相邻的没有被删除的线段会连在一起.</li><li>删除连起来的一些线段中的任意一条线段, 花费的代价为这些线段的总长.</li><li>一个删除顺序的代价, 就是每条线段的删除代价总和.<br>对于所有 $1, 2, \cdots, N$ 的排列 $p_1, p_2, \cdots, p_N$, 求依次删除 $p_1, p_2, \cdots, p_N$ 的代价之和. 答案对 $10^9+7$ 取模.<br>$N\leq 10^5, 1\leq A_i\leq 10^9, 2s, 1GB$.</li></ul></blockquote><p>考虑一条线段的贡献, 也就是其在删除时间的笛卡尔树上深度, 只要考虑一个点是它祖先的概率, $i$ 是 $j$ 的祖先要求 $i$ 被删的时候区间 $[i, j]$ 保留, 就是 $\dfrac{1}{\vert i-j\vert +1}$, 累加起来就是祖先概率, 就会做了.</p><h3 id="CF605E-Intergalaxy-Trips"><a href="#CF605E-Intergalaxy-Trips" class="headerlink" title="CF605E Intergalaxy Trips"></a>CF605E Intergalaxy Trips</h3><blockquote><p>给定一张 $n$ 个点的图, 目标是花费最小的天数从 $1$ 到 $n$.<br>每一天, 都有 $p_{ij}$ 的概率存在边 $\langle i, j\rangle$, 花费恰好 $1$ 天.<br>每天可以选定一条存在的边出发, 也可以选择留在原地不动(即 $p_{i, i}&#x3D;1$).<br>求最优策略下的期望天数.<br>$n\leq 1000, 2s, 256MB$.</p></blockquote><p>$f_u&#x3D;p_{u, v}f_v+(1-p_{u, v})f_u$</p><h2 id="1-其他"><a href="#1-其他" class="headerlink" title="-1. 其他"></a>-1. 其他</h2><h3 id="Nowcoder某题"><a href="#Nowcoder某题" class="headerlink" title="Nowcoder某题"></a><a href="https://ac.nowcoder.com/acm/contest/42819/E">Nowcoder某题</a></h3><blockquote><p>$n$ 行 $2n$ 列的网格图, 每行每列最多有两个棋子, 求本质不同方案数.</p><p>本质相同定义为可以通过交换若干行列得到相同的方案.</p><p>$n\le 10^5$ , 膜998244353</p></blockquote><p>汪娟介绍的</p><p>考虑这是一个经典网络流模型, 可以把一个方案对应到一个二分图上(建行点列点, 有棋子则连对应行列).</p><p>于是变成计数无标号二分图个数, 并且<strong>每个点度数不超过2</strong>, 一边 $n$ 个点一边 $2n$ 个点.</p><p>发现因为度数限制, $n$ 个点这边怎么选 $2n$ 个点都够用, 所以可以只考虑左边的大小, 视右边大小为无限.</p><p>那么度数限制为 $2$ 的二分图只有链和环两种. 那么就是计数若干个链和环且左边为 $n$ 个点.</p><p>然后在仅考虑左边点的情况, 它们的区别仅在于左边至少一个点(左边点少的链, 左右数量相等的链, 环)或者至少两个点(左边数量多一个的链), 所以写成生成函数就是 $\prod_{i&#x3D;1} \dfrac{1}{1-x^k} * \prod_{i&#x3D;2} \dfrac{1}{1-x^k}$</p><p>一个简单做法是分治ntt或ln+exp.</p><p>常数小做法是五边形数四次方乘 $1-x$ . 复杂度 $n\log n$ .</p><h3 id="CF930E-Coins-Exhibition"><a href="#CF930E-Coins-Exhibition" class="headerlink" title="CF930E Coins Exhibition"></a>CF930E Coins Exhibition</h3><blockquote><p>有 $k(1 \leq k \leq 10^9)$ 个硬币, 每个硬币有正面朝上和反面朝上两种状态.</p><p>现有 $n+m(0 \leq n, m \leq 10^5)$ 个限制条件, 每个限制条件形如 $(l_i, r_i)(1 \leq l_i \leq r_i \leq k)$ . 前 $n$ 个限制条件限制区间 $[l_i, r_i]$ 内至少有一个硬币正面朝上, 后 $m$ 个限制条件限制区间 $[l_i, r_i]$ 内至少有一个硬币反面朝上.</p><p>问共有多少种摆放硬币的方案使得所有限制条件都被满足. 答案对 $10^9+7$ 取模.</p></blockquote><p>考虑dp, $k$ 这么大肯定要离散化, 不过先想一个关于 $k$ 线性的东西, 考虑限制是在说一个什么, 序列上数数自然设 $f_{i, 0&#x2F;1}$ 表示前 $i$ 个最后一个是 $0&#x2F;1$ 的方案, 那么想到钦点从最近的0&#x2F;1转移, 于是发现一个限制 $[l, r]$ 中至少一个0等价于对于大于等于 $r$ 的位置其找0的时候需要在 $l$ 之后, 那么前缀和优化就线性了. 最后上一个划艇的套路: 离散化区间即可.</p><p>我天, 不会写dp了.</p><h3 id="P5492-PKUWC2018-随机算法"><a href="#P5492-PKUWC2018-随机算法" class="headerlink" title="P5492 [PKUWC2018]随机算法"></a>P5492 [PKUWC2018]随机算法</h3><blockquote><p>我们知道, 求任意图的最大独立集是一类NP完全问题, 目前还没有准确的多项式算法, 但是有许多多项式复杂度的近似算法.</p><p>例如, 小 C 常用的一种算法是:</p><ol><li><p>对于一个 $n$ 个点的无向图, 先等概率随机一个 $1\ldots n$ 的排列 $p[1\ldots n]$.</p></li><li><p>维护答案集合 $S$ , 一开始 $S$ 为空集, 之后按照 $i&#x3D;1\ldots n$ 的顺序, 检查 ${p[i]}\cup S$ 是否是一个独立集, 如果是的话就令 $S&#x3D;{p[i]}\cup S$.</p></li><li><p>最后得到一个独立集 $S$ 作为答案.</p></li></ol><p>小 C 现在想知道, 对于给定的一张图, 这个算法的正确率, 输出答案对 $998244353$ 取模.</p></blockquote><p>考虑枚举排列就是每次选一个点, 一个自然的状态是设 $f_S$ 表示当前已经加入了 $S$ 内的点, 答案是对的的概率. 再设 $siz_S$ 表示 $S$ 点集的最大独立集.</p><p>那么 $siz$ 转移显然, 主要考虑 $f$ 的转移.</p><p>一开始考虑枚举 $u$, 若 $siz_{S&#x2F;u}+check(u, S&#x2F;u)&#x3D;siz_S$ 则转移过来, 但这个是不对的, $u$ 的相邻点可能贡献了 $S&#x2F;u$ 的 $siz$, 不如删掉这些相邻点从 $f_T$ 转移过来.</p><h3 id="P4705-玩游戏"><a href="#P4705-玩游戏" class="headerlink" title="P4705 玩游戏"></a>P4705 玩游戏</h3><blockquote><p>给定 $a_n, b_n$, 对每个 $k$ 求 $\dfrac{1}{nm} \sum_i \sum_j (a_i+b_j)^k$</p><p>$n, m, k\le 10^5$</p></blockquote><p>$$<br>\begin{gathered}<br>    \sum_i \sum_j (a_i+b_j)^k\<br>    &#x3D;\sum_i \sum_j \sum_l \binom{k}{l}{a_i}^l{b_j}^{k-l}\<br>    &#x3D;k! \sum_l \dfrac{1}{l! (k-l)! } (\sum_i {a_i}^l) (\sum_j {b_j}^{k-l})<br>\end{gathered}<br>$$</p><p>可以看出卷积, 问题变成如何求 $c_k&#x3D;\sum_i {a_i}^k$, 注意到</p><p>$$<br>    \sum_k \dfrac{ {a_i}^k\cdot z^k}{k}&#x3D;-\ln(1-a_iz)<br>$$</p><p>于是</p><p>$$<br>C(z)&#x3D;\sum_i -\ln(1-a_iz)&#x3D;-\ln \prod_i (1-a_iz)<br>$$</p><p>分治FFT算里面的即可.</p><h3 id="校内模拟Circle"><a href="#校内模拟Circle" class="headerlink" title="校内模拟Circle"></a>校内模拟Circle</h3><blockquote><p>ehzeux 给了你一个圆, 圆上均等地放着 $2n$ 个点, 其中 35 已经帮你在 $k$ 对点之间连好了线段, 你需要从中选择剩下 $n-k$<br>对点随意连线段 (每个点只连一条线段), 并求出所有连边方案中联通块的个数总和. 两点联通当且仅当两点在同一<br>条线段上或两点所属于的线段相交. 答案对 $10^9+7$ 取模.</p><p>$n\le 300$</p></blockquote><p>考虑看起来是dp</p><p>但是区间dp试一试发现进行不下去, 连出去的根本做不到</p><p>考虑设 $f_{i, j}$ 表示 $i, j$ 是一个连通块内编号最小和最大的点, $[i, j]$ 中的点都已经经过配对, 此时的方案数.</p><p>那么这个连通块出现的次数就是上面那个再乘上剩下的点乱连的方案数.</p><p>于是问题来到如何算 $f$, 考虑先在 $[i, j]$ 中乱连, 显然不会连出去, 但与 $i$ 相连的连通块最大值不一定是 $j$, 考虑枚举最大值 $a$, 那么此时分成了两部分, 分别是 $f_{i, a}$ 中的部分加上 $[a+1, j]$ 乱连, 用这个容斥即可.</p><h3 id="P5401-CTS2019-珍珠"><a href="#P5401-CTS2019-珍珠" class="headerlink" title="P5401 [CTS2019] 珍珠"></a>P5401 [CTS2019] 珍珠</h3><blockquote><p>有 $n$ 个在范围 $[1, D]$ 内的整数均匀随机变量.</p><p>求至少能选出 $m$ 个瓶子, 使得存在一种方案, 选择一些变量, 并把选出来的每一个变量放到一个瓶子中, 满足每个瓶子都恰好装两个值相同的变量的概率.</p><p>请输出概率乘上 $D^n$ 后对 $998244353$ 取模的值. 取模部分说明可参考第一题.<br>$D\le 10^5$</p></blockquote><p>考虑</p><p>$$<br>\sum_i \dfrac{cnt_i}{2} \ge m\<br>\leftrightarrow \sum_i (cnt_i \bmod 2) \le 2m-n<br>$$</p><p>钦点 $k$ 个数出现奇数次, 奇数的一个数的EGF是 $\dfrac{e^x-e^{-x}}{2}$, 所以总式子是</p><p>$$<br>\binom{D}{k} n! (\dfrac{e^x-e^{-x}}{2})^k e^{D-k}\<br>\binom{D}{k} \dfrac{n! }{2^k} \sum_i \binom{k}{i} (-1)^{k-j} e^{D-2k+2j}x<br>$$</p><p>因为 $[x^n]e^ax&#x3D;\dfrac{a^n}{n! }$, 所以再带进去, 就有了卷积的形式.</p><p>然后卷积优化二项式反演.</p><h3 id="P3978-TJOI2015-概率论"><a href="#P3978-TJOI2015-概率论" class="headerlink" title="P3978 [TJOI2015]概率论"></a>P3978 [TJOI2015]概率论</h3><blockquote><p>对于一棵随机生成的 $n$ 个结点的有根二叉树(所有互相不同构的形态等概率出现), 它的叶子节点数的期望是多少呢?<br>$n\le 10^9$</p></blockquote><p>~~发现答案是 $n-1$ 个点的二叉树个数乘 $n$ ~~</p><p>证明就是, 一个 $n$ 个点的树假设有 $k$ 个叶子, 去掉每一个都得到一个 $n-1$ 个点的树. 考虑每个 $n-1$ 的被算了多少次, 相当于能在多少点底下挂一个叶子, 显然是 $n$, 于是就做完了.</p><p>另外EI的拉反很厉害.</p><h3 id="P7364-有标号二分图计数"><a href="#P7364-有标号二分图计数" class="headerlink" title="P7364 有标号二分图计数"></a>P7364 有标号二分图计数</h3><blockquote><p>$n$ 个点的二分图, $n\le 10^5$</p></blockquote><p>考虑第一反应是枚举左半边, 然后枚举连边:<br>$$<br>f_n&#x3D;\sum_i \binom{n}{i}2^{i(n-i)}\<br>\sum_i \dfrac{n! }{i! (n-i)! }2^2\cdot 2^{n-i}<br>$$</p><p>这个可以随便卷卷算.</p><p>但注意到这个不完全正确: 对于有 $x$ 个连通块的二分图, 因为你这么二染色, 会有 $2^x$ 种.</p><p>那么设刚才求的这个生成函数是 $F$, 连通二分图的为 $H$, 答案为 $G$.</p><p>容易发现 $e^{2H}&#x3D;F$ 和 $e^H&#x3D;G$, 于是实际上就对 $F$ 开根.</p><h3 id="ABC290F-Maximum-Diameter"><a href="#ABC290F-Maximum-Diameter" class="headerlink" title="[ABC290F] Maximum Diameter"></a>[ABC290F] Maximum Diameter</h3><blockquote><p>对于一个长度为 $n$ 的正整数序列 $X&#x3D;(X_1, X_2, \cdots, X_n)$, 定义 $f(X)$ 为:</p><ul><li>对于所有节点数量为 $n$, 且点 $i$ 的度数恰好为 $X_i$ 的树, 其直径的最大值. 如不存在, 则值为 $0$.</li></ul><p>你需要对于所有长度为 $n$ 的正整数序列 $X$ 计算 $f(X)$ 的和, 可以证明其为有限值. 答案对 $998244353$ 取模.</p><p>$T$ 组数据. $1\le T\le2\times10^5$, $2\le n\le10^6$.</p></blockquote><p>看到杜赢做这个题.</p><p>考虑对于某个整数序列, 让直径最长一定是串一条链, 然后把多出来的一度点直接挂在链上的点.</p><p>因此对于 $a_n$, 答案是 $\sum_i [a_i&gt;1]$</p><p>考虑枚举一个一度点的个数 $k$, 答案是</p><p>$$<br>\sum_k (n-k+1)\binom{n}{k}\binom{n-2}{n-k-1}<br>$$</p><p>然后用范德蒙德卷积就可以化简完了.</p><h3 id="P4709-信息传递"><a href="#P4709-信息传递" class="headerlink" title="P4709 信息传递"></a>P4709 信息传递</h3><blockquote><p>给定置换<br>$$<br>f &#x3D; \begin{pmatrix} 1 &amp; 2 &amp; . . . &amp; n \\ a_1 &amp; a_2 &amp; . . . &amp; a_n \end{pmatrix}<br>$$<br>求有多少个置换 $g$ , 满足<br>$$<br>g ^ n &#x3D; f<br>$$<br>答案对 $998244353$ 取模.</p><p>$n \le {10} ^ 5$.</p></blockquote><p>考虑拆环, 对于单个环考虑, 对于一个数 $i$, 乘上一个数就相当于在环上走一步 $i\to p_i\to p_{p_i}\ldots$.</p><p>那么, 若走 $x$ 步, 环长为 $l$, 环会变成 $gcd(x, l)$ 个小环, 按照膜 $gcd(x, l)$ 分类</p><p>于是你可以对着 $f$, 考虑有 $a$ 个环能拼成 $g$ 中的一个环, 条件是长度均为 $k$, 满足 $gcd(ak, n)&#x3D;a$.</p><p>然后显然每个长度的环互不影响, 就能做了, 对于所有长度为 $k$ 的环, 设 $f_i$ 表示使用 $i$ 个的方案数, 钦定用 $a$ 个环拼起来时以第一个环第一个数为首, 又因为每个环地位相等, 所以用 $\binom{i-1}{a-1}$</p><p>$$<br>f_i&#x3D;\sum_a [gcd(ak, n)&#x3D;a]\binom{i-1}{a-1}f_{i-a} k^{a-1}k!<br>$$</p><h3 id="SDOI2017-序列计数"><a href="#SDOI2017-序列计数" class="headerlink" title="[SDOI2017]序列计数"></a>[SDOI2017]序列计数</h3><blockquote><p>Alice 想要得到一个长度为 $n$ 的序列, 序列中的数都是不超过 $m$ 的正整数, 而且这 $n$ 个数的和是 $p$ 的倍数.</p><p>Alice 还希望, 这 $n$ 个数中, 至少有一个数是质数.</p><p>Alice 想知道, 有多少个序列满足她的要求.</p><p>$1\leq n \leq 10^9, 1\leq m \leq 2\times 10^7, 1\leq p\leq 100$.</p></blockquote><p>观察数据范围, 考虑 $f_{i, j, 0&#x2F;1}$ 表示前 $i$ 个数, 和膜 $p$ 余 $j$, 是否选了质数的方案数.</p><p>看到至少一个, 想到全都不是, 发现全都不是的只要做的时候只考虑非素数求就行了, 所以去掉 $0&#x2F;1$ 维.</p><p>那么矩阵快速幂优化上面那个即可. 容易发现转移固定.</p><h3 id="P6694-强迫症"><a href="#P6694-强迫症" class="headerlink" title="P6694 强迫症"></a>P6694 强迫症</h3><blockquote><p>给定圆上 $n$ 个点, 有点权 $a_i$, 将它连成一张图, 使得边不在非端点处相交, 边 $u\to v$ 的权值为 $a_u\cdot a_v$, 求期望权值和.</p><p>$n\le 10^5$</p></blockquote><p>考虑方案数是好求的: 设 $n$ 个点方案数为 $f_n$, 钦定一号点连向编号最小的边为 $1\to i$, 则 $f_n&#x3D;f_{n-1}+\dfrac{1}{2}\sum_i f_{i-1}\cdot f_{n-i}$, 直接卷.</p><p>那么考虑一条边 $u\to v, u&lt;v$ 的贡献是 $a_u a_v f_{v-u+1}f_{n-(v-u+1)}&#x2F;4$(除4是除必须选 $u\to v$).</p><p>还需要进一步优化, 注意到两个 $f$ 可以合成一个 $h_{v-u+1}$, 然后它和 $a_u$ 可以先卷出一个关于 $v$ 的东西, 就能行了.</p><h3 id="P5363-SDOI2019-移动金币"><a href="#P5363-SDOI2019-移动金币" class="headerlink" title="P5363 [SDOI2019]移动金币"></a>P5363 [SDOI2019]移动金币</h3><blockquote><p>Alice和Bob将要进行如下的一场游戏. 二人轮流操作, 且Alice先行.<br>当轮到一个玩家的时候, 他可以选择一枚金币, 并将其向左移动任意多格, 且至少移动一格.<br>金币不能被移出棋盘, 也不能越过其它金币.</p><p>一个 $1\times n$ 的棋盘上最初摆放有 $m$ 枚金币. 其中每一枚金币占据了一个独立的格子, 任意一个格子内最多只有一枚金币.</p><p>如果轮到一个玩家的时候他已经无法做出任何有效操作了(显然这个时候 $m$ 枚金币恰好落在最左侧的 $m$ 个格子中), 则被判定为输家. 已经知道Alice和Bob都是极致聪明的人, 他们在任何局面下总能做出最优的操作. 那么有多少初始状态能保证Alice必胜呢?</p><p>$m\le 50, n\le 150000$</p></blockquote><p>发现不会判定.</p><p>学到了一个叫阶梯博弈的东西.</p><p>[trick] 说的是考虑有 $n$ 堆石子, 每次可以把第 $i$ 堆的移动到第 $i-1$ 堆, (规则为把第 $i$ 堆移动到左边任意一堆的同理), 那么实际上相当于一个仅考虑奇数堆的普通NIM游戏. 具体可以考虑, 如果对方移动一个偶数堆到奇数堆, 你立刻把它再往下移动到偶数堆, 这个操作一定可以进行且对奇数堆情况没有改变且不导致先后手变化, 相当于没干, 所以只要考虑一次把一个奇数堆移动没了就行了.</p><p>于是这个题, 把两个金币之间的距离当做石子堆, 问的就是有多少个序列 $a_m$, $\sum a_m&lt;n$, 且 $\mathrm{xor}_{i&#x3D;2k+1}{a_i\ne 0}$</p><p>这个东西同时要求 和 与 异或和, 看起来不是二进制多项式可以解决的.</p><p>考虑逐位考虑, 考虑只考虑奇数位上的数, 每位有偶数个 $1$, 层层之间无关, 对于每一层, 枚举选几个 $1$ 方案数得到一个 $a_i$ 表示和为 $i$ 的方案数, 卷起来就是总方案数.</p><p>最后再卷上偶数位上的方案数即可.</p><p>哦, 发现模数上智障的 $10^9+9$.</p><p>注意到奇数堆每一层最多选 $m&#x2F;2$ 个盘子, 所以暴力卷复杂度是 $nm\log n$. 最后卷偶数堆的时候求的是后缀和, 也可以做到线性.</p><h3 id="P3228-HNOI2013-数列"><a href="#P3228-HNOI2013-数列" class="headerlink" title="P3228 [HNOI2013]数列"></a>P3228 [HNOI2013]数列</h3><blockquote><p>求有多少个序列 $a_k$ 满足 $a_i-a_{i-1}\in [1, m], a_k\le n$<br>保证 $m(k-1)&lt;n$<br>$n, k, m\le 10^9$.</p></blockquote><p>显然式子是</p><p>$$<br>\sum_{i}^{n-1} (n-i) <a href="%5Cdfrac%7Bx-x%5E%7Bm+1%7D%7D%7B1-x%7D">x^i</a>^{k-1}<br>$$</p><p>关键在于 $m(k-1)&lt;n$, 说明把多项式所有项都提取了.</p><p>那么问题变得清新: 多项式代入 $x&#x3D;1$ 就是系数和, 而对于 $x^i\to ix^i$ 只需要求个导代入(展开带)</p><p>那么就是 $nm^{k-1}-(k-1)m^{k-2}\cdot m(1+m)&#x2F;2$</p><h3 id="CF960G-Bandit-Blues"><a href="#CF960G-Bandit-Blues" class="headerlink" title="CF960G Bandit Blues"></a>CF960G Bandit Blues</h3><blockquote><p>给你三个正整数 $n$, $a$, $b$, 定义 $A$ 为一个排列中是前缀最大值的数的个数, 定义 $B$ 为一个排列中是后缀最大值的数的个数, 求长度为 $n$ 的排列中满足 $A &#x3D; a$ 且 $B &#x3D; b$ 的排列个数. $n \le 10^5$, 答案对 $998244353$ 取模.</p></blockquote><p>当设 $f_{i, a, b}$ 表示 $i$ 个数, $a$ 个前缀max, $b$ 个后缀max时, 会有</p><p>$$<br>f_{n, a, b}&#x3D;\sum_{i&#x3D;1}^n f_{i-1, a-1, any} f_{n-i, any, b-1} \binom{n-1}{i-1}<br>$$</p><p>于是你的状态就只有两维, 设 $f_{i, j}$ 表示 $i$ 个数, $j$ 个前缀max即可.</p><p>又注意到, 考虑往后追加一个数这个数的排名, 易得 $f_{i, j}&#x3D;f_{i-1, j-1}+(i-1)f_{i-1, j}$, 这是第一类斯特林数.</p><p>此时暴力应该是把两个求两个斯特林列然后卷起来. 为了好看</p><p>考虑组合意义, 它就是你从 $n-1$ 个数选 $i-1$ 个排成 $a-1$ 个环, 剩下的排成 $b-1$ 个环. 等价于从 $n-1$ 个数排成 $a+b-2$ 个环, 再从这里面选出 $a-1$ 个环.</p><p>所以 $f_{n, a, b}&#x3D;{n-1 \brack a+b-2}\binom{a+b-2}{a-1}$</p><h3 id="P6144-USACO20FEB-Help-Yourself-P"><a href="#P6144-USACO20FEB-Help-Yourself-P" class="headerlink" title="P6144 [USACO20FEB]Help Yourself P"></a>P6144 [USACO20FEB]Help Yourself P</h3><blockquote><p>计算给定线段集(大小为 $n$)的所有子集并的连通块数目的 $k$ 次方的和对 $10^9+7$ 取模.</p><p>变量范围:</p><ul><li>$1 \leq n \leq 10^5$</li><li>$2 \leq k \leq 10$</li><li>$1 \leq l_i \lt r_i \leq 2n$, 且任意两个端点都不在同一位置上.</li></ul></blockquote><p>处理次幂的常见套路是组合意义和生成函数?</p><p>生成函数的话, 注意到 $e^{x+y}&#x3D;e^xe^y$, 但 $\dfrac{1}{1-x-y}$ 不怎么好, 所以用EGF.</p><p>于是 $f_i$ 表示线段集合最右端在 $i$ 上的方案数EGF, 考虑插入线段 $[l, r]$ 后带来的影响:</p><ul><li>对于 $i&lt;r$, $f_i$ 没有影响</li><li>对于 $f_r$:<ul><li>$f_i, i&lt;l$ 部分多了一条不交线段, $f_r : &#x3D; f_r + e^x(\sum f_i)$</li><li>$f_i, i\in[l, r]$ 部分相交的连通块数不变: $f_r : &#x3D; f_r+\sum f_i$</li></ul></li><li></li><li>对于 $i\ge [l, r]$, 不知道右边的左端点, 但如果按照 $l$ 从小到大考虑线段, 就一定所有情况都相交(且包含), 选不选没关系, 所以 $f_i: &#x3D;2f_i$</li></ul><p>要求区间多项式和, 区间多项式乘2, 单点修改, 可以上个线段树. 而乘法暴力卷积就行了. 复杂度是 $nk^2+nk\log n$</p><h3 id="P7483-50-年后的我们"><a href="#P7483-50-年后的我们" class="headerlink" title="P7483 50 年后的我们"></a>P7483 50 年后的我们</h3><blockquote><p>给出了 $n$ 个点, 每个点有一个权值 $c_i$ 和坐标值 $d_i$.</p><p>另外还有 $m$ 条线段, 第 $i$ 条线段的两个端点分别为 $l_i$ 和 $r_i$, 表示该线段覆盖了从 $l_i$ 到 $r_i$ 之间的所有点, 线段 $i$ 有 $p_i$ 几率被选中.</p><p>定义权值给出为所有点中, 至少被一条选中的线段覆盖的点的权值之和的 $k$ 次幂. $0^0&#x3D;1$</p><p>求出权值的期望膜 $998244353$</p><p>$1\leq n\leq 400, 0\leq k\leq 400, 1\leq m\leq 10^5, 1\leq d_i\leq 10^9, 1\leq l_i\leq r_i\leq 10^9, 0\leq c_i, p_i&lt;998244353$.</p></blockquote><p>类比上一题处理次幂.</p><p>设 $f_i$ 表示 $i$ 为右端点的EGF. 插入一条线段 $[l, r]$ 时:</p><ul><li>$i&lt;r$: $f_i: &#x3D;(1-p)f_i$</li><li>$r$: $f_r: &#x3D;(f_r+p\sum_{i\in [l, r)} f_i)\cdot e^{\sum c_i}$($[l, r]$ 中的 $f$ 转移过来再卷上所有被包含的点)</li><li>$i&gt;r$: 无影响</li></ul><p>要区间乘一个东西, 区间多项式和, 还有暴力卷积, 复杂度是 $nk^2+nk\log n$ 吧</p><h3 id="「SiR-1」Bracket"><a href="#「SiR-1」Bracket" class="headerlink" title="「SiR-1」Bracket"></a>「SiR-1」Bracket</h3><blockquote><p>给定仅有<code>(</code>, <code>)</code>的括号序列 $s_n$, 求 $\sum_{l&lt;r} f(S_{l, r})$, 其中 $f(S)$ 表示, 可以进行任意循环移位 和 任意添加一个左或右括号 的情况下使得 $S$ 是匹配括号串的最小次数. $n\le 2\times 10^7$</p></blockquote><p>对于固定的 $S$ 考虑 $f$ 如何求.</p><p>首先括号个数肯定要对, 调完之后此时前缀和就是 $0$ 了, 容易想到Raney定理说你最多只会进行一次循环移位.</p><p>再考虑什么时候需要循环移位, 仍然考虑前缀和折线, 众所周知加括号一定加在最前或最后, 设前缀和数组为 $a$, 那么发现加完括号不用再操作当且仅当: $\forall i, a_i\ge 0$ 或 $a_n&#x3D;\min_i a_i$, 画画图还是很显然的.</p><p>那么开始数数, 先不考虑循环移位, 那就是数 $\sum_{l<r>} \vert a_r-a_{l-1} \vert$, 这个可以直接拆贡献: 对于一个 $a_{r}$, 考虑前面有多少个 $a_i$ 大于它即可, $a_{l-1}$ 部分同理.</p><p>然后数不用再操作的个数, 两个条件同时满足当且仅当已经是合法序列, 那么这个是好数的, 接下来对于同一个 $l$, 可以直接二分出满足 $a_i\ge 0$ 条件的区间, 对于同一个 $r$ 可以直接二分出自己作为最小值的区间, 总复杂度1log.</p><p>单调栈可以线性啊, 拉了.</p><h3 id="群友题"><a href="#群友题" class="headerlink" title="群友题"></a>群友题</h3><blockquote><p>对于序列 $a_n$, 求有序对 $(i, j, k)$ 个数满足 $i&lt;j&lt;k, 2a_j&#x3D;a_i+a_k$. $n, a_i\le 10^5$</p></blockquote><p>对序列分块, 枚举 $j$, 其中 $i, k$ 与 $j$ 在同一块的直接用桶处理掉, 不在同一块的考虑fft即可.</p><h3 id="P2012-拯救世界2"><a href="#P2012-拯救世界2" class="headerlink" title="P2012 拯救世界2"></a>P2012 拯救世界2</h3><blockquote><p>求有多少个长 $n$ 序列满足 $\texttt{a, b, c, d}$ 出现任意次, $\texttt{e, f, g, h}$ 出现奇数次, $\texttt{i, j, k, l}$ 出现偶数次.<br>$n\le 2^63$, 多次询问</p></blockquote><p>以前只知道egf:</p><ul><li>$\texttt{a, b, c, d}$: $e^x$</li><li>$\texttt{e, f, g, h}$: $\dfrac{1}{2}(e^x+e^{-x})$</li><li>$\texttt{i, j, k, l}$: $\dfrac{1}{2}(e^x-e^{-x})$<br>全都卷起来提取系数即可.</li></ul><p>另一种做法是直接矩阵乘法优化dp, 设 $f_{i, j}$ 表示前 $i$ 位, 后 $8$ 种字符中有 $j$ 种出现奇数次, 用矩阵乘法优化dp.</p><h3 id="AGC008E-Next-or-Nextnext"><a href="#AGC008E-Next-or-Nextnext" class="headerlink" title="[AGC008E] Next or Nextnext"></a>[AGC008E] Next or Nextnext</h3><blockquote><p>给定正整数 $n$ 和一个长度为 $n$ 的序列 $a$, 问有多少长度为 $n$ 的排列 $p$, 满足对于任意 $i$ 有 $p_i&#x3D;a_i$ 或 $p_{p_i}&#x3D;a_i$.</p><p>答案对 $10^9+7$ 取模.</p><p>$n \leq 10^5$.</p></blockquote><p>见到排列还有这个 $p_{p_i}$ 直接拆环考虑. 一开始读错题以为 $a$ 也是排列, 那显然 $p$ 中的环在 $a$ 中也是一个环, 对于单独一个环, 方案数是 $1+(n\bmod 2)$, 两个大小相同的环可以合并, 方案变为 $len$. 这个数起来就, 对每个大小的环分别考虑, 相当于算从 $n$ 个中选 $k$ 个匹配的方案数, 可以简单组合数.</p><p>然后要考虑 $a$ 组成的图中的基环树, 也是好做的, 容易发现一个基环树无法和环合并, 树上每个点除了环边最多有一个入度, 看起来像是把一堆链的链头串起来. 那么因为无法合并每个基环树单独做, 对于一个基环树上的一个点 $i$ 在环外有长为 $l$ 的链, 如果 $i$ 在环上往前走 $l$ 个点都没挂链方案数是 $1$, 如果往前 $l+1$ 个都没挂链方案数是 $2$, 否则是 $0$, 于是就做完了.</p><h3 id="ARC134F-Flipping-Coins"><a href="#ARC134F-Flipping-Coins" class="headerlink" title="ARC134F Flipping Coins"></a>ARC134F Flipping Coins</h3><blockquote><p>给定一排 $n$ 枚硬币, 初始时所有硬币正面向上.</p><p>Snuke 会等概率地选择一个长度为 $n$ 的排列 $p &#x3D; (p_1, p_2, \dots, p_n)$, 并执行 $n$ 次操作. 第 $i$ 次操作会执行如下步骤:</p><ul><li>若第 $i$ 枚硬币是反面朝上的, 什么也不做.</li><li>若第 $i$ 枚硬币是正面朝上的, 翻转它, 并翻转第 $p_i$ 枚硬币.</li></ul><p>给定 $w$. 设 $n$ 次操作完后正面朝上的硬币数为 $k$, 则这排列的贡献即为 $w^k$.</p><p>你需要求出这贡献的期望值乘 $n!$ 后在模 $998244353$ 意义下的值. 容易证明这值定是整数.</p><p>$1\le n\le 2\times 10^5, \ 1\le w &lt; 998244353$.</p></blockquote><p>考虑排列拆成若干个环独立, 那么可以算一个环的答案然后 exp. 再考虑对于一个环可以分成若干个递增段, 则硬币 $i$ 当且仅当一个递增段最后一位 $p_j&#x3D;i$ 且递增段长度为奇数才会是正面.</p><p>于是一个递增段的贡献关于长度的生成函数可以写成 $F(x)&#x3D;\sum_{i&#x3D;0} w^{i\bmod 2}\dfrac{x^i}{i! }$. 但是环的EGF并不是 $G(x)&#x3D;\sum_{i&#x3D;1} \dfrac{F^i}{i}&#x3D;\ln 1-F$ 因为不满足连续段极长的限制, 也就是实际上的一个连续段由多个卷起来的连续段贡献了.</p><p>考虑容斥, 对于每个长 $i$ 的连续段给系数 $c_i$, 则一个方案的容斥系数是 $\prod c_i$, 总答案是 $\sum \prod_{i\in S} c_i$, 这里 $S$ 是遍历不加限制的拼的方案. 如果一个段实际上的值是 $a_i$, 那么总的答案 $\sum \prod_{i\in T} a_i$, 这里 $T$ 是有极长限制的拼法的情况, 那么若对于一段 $a_i$ 是所有拼出它的系数的和 $a_i&#x3D;\sum c_j$, $\sum \prod_{i\in T}a_i$ 就真的等于 $\sum \prod_i (\sum c_j)$ 了. 所以只要满足一段的容斥系数是对的, 也就是这一段的真实权值 $a_n&#x3D;\sum_{S_k\ s. t. \ \sum_i s_i&#x3D;n} \prod_i c_{S_i}$, 其中 $S$ 是每一种拼出长 $k$ 连续段的方案数. 翻译成生成函数, 设 $H(x)&#x3D;\sum_{i&#x3D;0} w^{i\bmod 2}x^i$, 则 $\dfrac{1}{1-C(x)}&#x3D;H(x), \therefore\ C(x)&#x3D;1-\dfrac{1}{H(x)}$.</p><p>刚才得到的 $C$ 是 $c_i$ 的OGF, 换成EGF $C_e&#x3D;\sum_i c_i\dfrac{x^i}{i! }$ 就可以带到刚才 $G$ 的错误式子里得到答案了, $Ans&#x3D;\exp G(x)&#x3D;\exp (\ln (1-C’))&#x3D;1-C’&#x3D;(\dfrac{1}{H(x)})_e$. (用 $F_e$ 表示 $F$ 对应的EGF).</p><p>最后你只要求逆再求逆.</p><h3 id="LOJ6728-U群把妹王-TopCoder13444"><a href="#LOJ6728-U群把妹王-TopCoder13444" class="headerlink" title="LOJ6728 U群把妹王 TopCoder13444"></a>LOJ6728 U群把妹王 TopCoder13444</h3><blockquote><p>有 $n \times m$ 个格子, 每个格进行染色, 可以选择 $k$ 种颜色之一. 对于集合 $S, T$, 你需要计数有多少种格子的染色方案, 满足:</p><ul><li>对于每一行的图案拿出来, 和它相同的图案总共有 $r$ 行 (含自身), 则 $r \in S$.</li><li>对于每一列的图案拿出来, 和它相同的图案总共有 $c$ 列 (含自身), 则 $c \in T$.</li></ul><p>答案对 $P &#x3D; 998244353$ 取模.<br>为了让这道题看起来代码比较健康, 保证 $1 \in S \cap T$.</p><p>TopCoder是这个的 $S&#x3D;T&#x3D;{1}$ 情况</p></blockquote><p>虽然先看的这个题, 但感觉上面的ARC134F里对这个容斥说的更清楚.</p><p>首先弱化版是斯特林数反演题, 考虑如果只要求列互不相同方案数是 $f(n)&#x3D;{(k^n)}^{\underline{m}}$, 而 $g(n)$ 表示在此基础上要求行互不相同, 那么有 $f(n)&#x3D;\sum_i {n\brace i}g(i)$, 于是直接反演得到 $g$ 即可.</p><p>强化版考虑更强的容斥, 对于一维问题每种颜色出现次数必须在 $S$ 中, 不考虑限制, 方案数是 $k^n$, $k^n$ 意味着有些相同, 把相同的元素组成的集合再放到一起组成集合 $L&#x3D;{S_1\ldots S_l}$, 其中每个 $S$ 表示一个颜色相同的集合, 那么最后答案应该是 $\sum_L c(L)k^{\vert L\vert}$, 现在因为限制是对 $\vert S_i\vert$ 的, 我们希望 $c(L)&#x3D;\prod_i d(\vert S_i\vert)$, 这样一来取 $k&#x3D;1$ 就有</p><p>$$<br>ans(n)&#x3D;[x^n]1+\sum_{i\in S} x^i&#x3D;\sum_L c(L)&#x3D;n! [x^n]\exp(\sum_i \dfrac{d(i)x^i}{i! })<br>$$</p><p>所以 $d$ 的egf就是 $\ln 1+F$, 其中 $F&#x3D;\sum_{i\in S}x^i$.</p><p>那么二维情况下, 容斥系数可以直接相乘, 让 $f_i$ 表示 $\vert L\vert$ 为 $i$ 的方案的容斥系数之和, $g$ 为另一维的, 发现答案为 $\sum_i \sum_j f_ig_ik^{ij}$, 而 $k^{ij}&#x3D;k^{\binom{i+j}{2}-\binom{i}{2}-\binom{j}{2}}$, 于是只要卷一下, 所以问题来到求 $f$.</p><p>而又由定义, $f_i&#x3D;n! [x^n] \dfrac{\ln^i (1+F)}{i! }$, 新建一个元 $u$, 则 $f$ 是 $[x^n] \exp(u\ln(1+F))$ 这个复合函数求某项系数可以拉反:</p><p>$$<br>[x^n]\exp(u\ln(1+F))&#x3D;\dfrac{1}{n}[x^{n-1}]ue^{ux}(\dfrac{x}{G(x)})^n<br>$$</p><p>这里 $G$ 是 $\ln(1+F)$ 的复合逆, 可以牛迭. , 复杂度 $\vert S\vert n\log n$</p><h3 id="P3349-ZJOI2016-小星星"><a href="#P3349-ZJOI2016-小星星" class="headerlink" title="P3349 ZJOI2016 小星星"></a>P3349 ZJOI2016 小星星</h3><blockquote><p>给定一张无向图和一棵树, 求有多少种点集到点集的双射使得若两点在树上有边则图上对应的两点也有边.<br>$n\le 17$</p></blockquote><p>考虑dp, 从树的结构出发肯定比图好, 设 $f_{u, i, S}$ 表示 $x$ 映射到 $i$, 子树中的点映射过去组成的集合是 $S$ 的方案数. 转移显然, 复杂度 $n^33^n$ 或子集卷积后 $n^42^n$ 爆炸.</p><p>考虑 容斥掉排列限制的trick(见南外省选集训&gt;ICPC模拟赛2&gt;F. Non-Puzzle: The Lost Array), 然后就可以不记录 $S$, 复杂度是 $n^32^n$ </p><h3 id="AGC041F-Histogram-Rooks"><a href="#AGC041F-Histogram-Rooks" class="headerlink" title="[AGC041F] Histogram Rooks"></a>[AGC041F] Histogram Rooks</h3><blockquote><p>给一个底端对其, 第 $i$ 列有 $h_i$ 个格子的网格, 求有多少种填车的方案使得每个位置都能被至少一个车攻击到.<br>$h_i\le n\le 400$</p></blockquote><p>容斥, 钦定选了 $c$ 个不能被覆盖的格子, 则容斥系数是 $(-1)^c$, 但这样没法走了, 考虑钦定存在未被覆盖格子的列的集合 $S$, 容斥系数还是 $(-1)^{\text{未覆盖格子数}}$, 那么现在一个长 $l$ 的行连续段如果经过 $k$ 个 $S$ 中的列, 要么这 $k$ 个位置都不是钦定的, 贡献 $2^{l-k}$, 否则枚举这 $k$ 个位置中有 $i$ 个被钦定, 则贡献 $\sum_{i&#x3D;1}^k \binom{k}{i}(-1)^i&#x3D;-[p&gt;0]$.</p><p>但这样不能保证一开始说的 $S$ 中的列都至少有一个格子被覆盖, 但注意到现在的限制对象从格子变成了列, 问题已经得到简化, 再容斥, 设集合 $T$ 中的列中不能有被选的, 容斥系数是 $(-1)^{\vert T\vert}$, 那么仍然考虑刚才长 $l$ 的段, 经过 $k$ 个 $S$ 中元素其中有 $j$ 个 $T$ 中的没有被钦定不能覆盖的格子, 那么贡献就变成了 $2^{l-k}$ 和 $-[k&gt;j]$(为什么不是 $2^{l-k+p}$? 发现第一类贡献其实不会算错, 要消去的是第二类的错误贡献)</p><p>然后考虑dp, 前面那个网格很容易让人想搞笛卡尔树dp, 设 $f_{u, i, 0&#x2F;1}$ 表示当前在笛卡尔树上的 $u$ 点, $u$ 经过了 $i$ 个 $S$ 中的格子, 以及 $k$ 是否等于 $j$(如果某个点开始 $k&gt;j$, 则其祖先必然 $k&gt;j$, 所以只要记这个信息就够了). 复杂度是树形背包的 $n^2$.</p><h3 id="P5405-CTS2019-氪金手游"><a href="#P5405-CTS2019-氪金手游" class="headerlink" title="P5405 [CTS2019] 氪金手游"></a>P5405 [CTS2019] 氪金手游</h3><blockquote><p>题意概要: 给定 $n$ 个点, 点 $w_i$ 分别有 $p_{i, 1}$, $p_{i, 2}$, $p_{i, 3}$ 的概率取 $\frac{1}{2&#x2F;3}$.</p><p>**在确定了所有的 $w_i$ 后再开始游戏:**不断抽点, 点 $i$ 被抽中的概率为 $\frac{\sum w_j}{\sum w_j}, j&#x3D;1 \text{ to } n$, 直到所有点都被抽中过.</p><p>给定 $n-1$ 个二元组 $(u, v)$ 表示第一次抽中 $u$ 的时间需要比第一次抽中 $v$ 的时间早, 且若将这 $n-1$ 个二元组中的两个元素连无向边, 则这张图是一棵树.</p><p>问满足所有二元组限制的概率. $n\le 1000$</p></blockquote><p>第一眼以为树一定是外向, 也就是限定了拓扑序, 那么根节点一定是子树中的点中第一个被选的, 忽略子树外的点是概率没有影响, 那么设 $f_{u, i}$ 表示子树 $u$ 内部权值和为 $i$ 的概率即可吧.</p><p>然后发现有些边方向不对, 那就容斥掉, 钦点一条反向边不考虑&#x2F;一定违反, 带着系数dp即可.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> dp </tag>
            
            <tag> 生成函数 </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>polya定理初学</title>
      <link href="/2022/07/01/polya/"/>
      <url>/2022/07/01/polya/</url>
      
        <content type="html"><![CDATA[<h1 id="置换群论学习"><a href="#置换群论学习" class="headerlink" title="置换群论学习"></a>置换群论学习</h1><ul><li>我们要解决的问题是, 给定一个对象集合 $A$ , 一个颜色集合 $B$ 和一组针对映射的变换 $G$ , 求有多少种映射(将对象集合映射到颜色集合)的方案是本质不同的, 这里两种映射本质不同指不能通过变换把一个变成另一个.</li></ul><p>简单理解就是对对象染色, 如果可以通过翻转旋转之类的操作变化到的算一种, 求有多少种染色方案. 要求这个变换操作关于他们的复合构成一个群, 称为置换群, 变换称为置换.</p><h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定:"></a>符号约定:</h2><ul><li><p>$F(A, G)$ 表示对 $A$ 染色, 在 $G$ 的情况下的本质不同方案数</p></li><li><p>$G(c)$ 表示应用到 $C$ 上不改变的置换组成的集合</p></li><li><p>$C(f)$ 表示 $f$ 作用上去不改变的方案组成的集合</p></li><li><p>$S(c)$ 表示和 $c$ 本质相同的染色方案组成的集合</p></li><li><p>方案 $c$ 经过置换 $f$ 得到的东西为 $c<em>f$ , 先进行 $f$ , 再进行 $g$ (就是复合 $f$ 和 $g$ )的置换为 $h&#x3D;f</em>g$</p></li></ul><h2 id="Burnside引理"><a href="#Burnside引理" class="headerlink" title="Burnside引理"></a>Burnside引理</h2><h3 id="引理0"><a href="#引理0" class="headerlink" title="引理0"></a>引理0</h3><p>$G(c)$ 是群</p><p>照着定义显然成立</p><h3 id="引理1"><a href="#引理1" class="headerlink" title="引理1"></a>引理1</h3><p>$$<br>\sum \vert G(c) \vert &#x3D;\sum  \vert C(f) \vert<br>$$ </p><p>显然成立, 因为两边都是满足 $f$ 对 $c$ 没用的有序对 $(f, c)$ 的个数</p><h3 id="引理2"><a href="#引理2" class="headerlink" title="引理2"></a>引理2</h3><p>作用在方案 $c$ 上与 $f$ 效果一样的置换 $g$ 数量为 $G(c)$ .</p><p>$$<br>f<em>c&#x3D;g</em>c\<br>f^{-1}<em>g</em>c&#x3D;c\<br>h*c&#x3D;c<br>$$ </p><p>这里因为构成群, 可以保证 $f^{-1}$ 和 $f^{-1}*g$ 一定存在, 同时对于一个 $f$ 满足 $g$ 和 $h$ 一一对应, 所以成立</p><h3 id="引理3"><a href="#引理3" class="headerlink" title="引理3"></a>引理3</h3><p>$$<br> \vert S(c) \vert &#x3D;\frac { \vert G \vert }{ \vert G(c) \vert }, \vert G(c) \vert &#x3D;\frac { \vert G \vert }{ \vert S(C) \vert }<br>$$ </p><p>由引理2, 可知每个 $f$ 有 $\vert G(c)\vert$ 个和它作用到 $c$ 上效果相同, 那么它们就构成了一个大小为 $G(c)$ 的等价类, 由于一共有 $\dfrac{\vert G\vert}{\vert G(c)\vert }$ 个等价类, 不同等价类会把 $c$ 置换成不同的东西, 所以定理成立.</p><h3 id="引理4"><a href="#引理4" class="headerlink" title="引理4"></a>引理4</h3><p>$$<br>\sum_c \frac {1}{S(c)}&#x3D;F(A, G)<br>$$ </p><p>原因是每一组等价的 $c$ 正好加成了1</p><h3 id="Burnside引理-1"><a href="#Burnside引理-1" class="headerlink" title="Burnside引理"></a>Burnside引理</h3><p>$$<br>F(A, G) &#x3D; \frac{1}{ \vert G \vert } \sum_c  \vert G(c) \vert &#x3D;\frac{1}{ \vert G \vert } \sum_f  \vert C(f) \vert<br>$$ </p><p>第二个等号直接用引理1得到, 较为显然. 而第一个等号是组合定理4和定理3:</p><p>$$<br>F(A, G)&#x3D;\sum_c \frac{1}{S(c)}&#x3D;\frac {1}{ \vert G \vert }\sum_c  \vert G(c) \vert<br>$$ </p><p>于是命题得证.</p><p>应用时, 因为置换一般远比方案少, 所以第三种形式比第二种形式常用.</p><h2 id="Polya定理-声调飞了"><a href="#Polya定理-声调飞了" class="headerlink" title="Polya定理 (声调飞了)"></a>Polya定理 (声调飞了)</h2><p>那如何快速计算 $C(f)$ 呢, 考虑我们可以把一个置换写成这个形式:</p><p>$$<br>\begin{pmatrix}<br> 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\<br> 3 &amp; 1 &amp; 2 &amp; 5 &amp; 4<br>\end{pmatrix}<br>$$ </p><p>表示1变成3, 2变成1, 3变成2, 4变成5, 5变成4. 这里数字表示的是染色对象集合里的元素, 比如一个圈把它旋转一下, 对应的大概就是:</p><p>$$<br>\begin{pmatrix}<br> 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\<br> 2 &amp; 3 &amp; 4 &amp; 5 &amp; 1<br>\end{pmatrix}<br>$$ </p><p>这个形式, 表示第1个的颜色变成了第2个的, 第2个的变成了第3个的. . . 第5个的变成了第1个的.</p><p>而这个东西又可以再分解成若干个循环, 比如第一个例子我们换一个说法:</p><p>$$<br>\begin{pmatrix}<br> 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\<br> 3 &amp; 1 &amp; 2 &amp; 5 &amp; 4<br>\end{pmatrix}<br>$$ </p><p>表示1变成3, 3变成2, 2变成1, 4变成5, 5变成4</p><p>相当于拆成了若干个首尾相接的置换的复合, 即</p><p>$$<br>\begin{pmatrix}<br> 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\<br> 3 &amp; 1 &amp; 2 &amp; 5 &amp; 4<br>\end{pmatrix}<br>&#x3D;<br>\begin{pmatrix}<br> 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\<br> 3 &amp; 1 &amp; 2 &amp; 4 &amp; 5<br>\end{pmatrix}<br>*<br>\begin{pmatrix}<br> 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\<br> 1 &amp; 2 &amp; 3 &amp; 5 &amp; 4<br>\end{pmatrix}<br>$$ </p><p>我们称拆出来的一个为一个循环, 因为它是首尾相接的一个环, 那么一个循环里如果有任意两个元素不一样, 被这个循环置换一下就不一样了, 所以对于 $C(f)$ 的每个染色, 都要求一个循环里的元素被染成了相同的颜色. 而不同的循环是互不影响的, 所以得到</p><p>$$<br>C(f)&#x3D;m^{k(f)}<br>$$ </p><p>其中 $m$ 表示颜色总数, $k(f)$ 表示 $f$ 可以拆成多少个循环, 这就是polya定理了, 完整形式可以是</p><p>$$<br>F(A, G)&#x3D;\frac {1}{ \vert G \vert }\sum m^{k(f)}<br>$$ </p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="P4980-模板-Polya-定理"><a href="#P4980-模板-Polya-定理" class="headerlink" title="P4980 [模板]Pólya 定理"></a>P4980 [模板]Pólya 定理</h3><blockquote><p>$t$ 次询问计数用 $n$ 种颜色对一个长 $n$ 的项链染色的本质不同的方案数, 两个方案本质相同指可以通过旋转(注意不能翻转)从一个变成另一个.</p><p>$t \le 10^3, n\le 10^9$ </p></blockquote><p>对一种颜色的数量没有限制, 一个置换就是把它转几下满足群的定义, 可以Polya, 问题是怎么算 $k(f)$ , 即怎么算旋转 $i$ 步的置换能拆成几个循环.</p><p>考虑在旋转过程中, 每个位置开始的情况是一样的所以在一个循环中不会重复经过一个数, 拆出的每个循环的情况是一样的所以每个循环的长度相等. 由于一个位置回到原位走的路程是 $\mathrm{lcm}(n, i)$ , 也就是转了 $\frac{\mathrm{lcm}(n, i)}{i}$ 步后回到原来的位置, 也就是单个循环长度, 所以循环个数就是 $\dfrac{n}{\frac{\mathrm{lcm}(n, i)}{i}}&#x3D;\gcd(n, i)$ , 于是就是要求</p><p>$$<br>\sum_f{n^{k(f)}}\<br>&#x3D;\sum_i n^{\gcd(i, n)}\<br>&#x3D;\sum_{d \vert n} n^d\sum_i^n [\gcd(i, n)&#x3D;d]\<br>&#x3D;\sum_{d \vert n} n^d\sum_i^{\frac{n}{d}} [\gcd(i, \frac{n}{d})&#x3D;1]\<br>&#x3D;\sum_{d \vert n} n^d\varphi(\frac{n}{d})<br>$$ </p><p>因为 $n$ 很大很难预处理, 但直接暴力就能过. 因为 $10^9$ 次方以内只有 $10^3$ 量级的因子, 每个再平均 $\sqrt{\sqrt{n}}$ 的求, 界就很松.</p><h3 id="P4727-HNOI2009-图的同构计数"><a href="#P4727-HNOI2009-图的同构计数" class="headerlink" title="P4727 [HNOI2009]图的同构计数"></a>P4727 [HNOI2009]图的同构计数</h3><blockquote><p>问 $n$ 个点组成的不同构的完全图的个数, 两个图同构指它们可以通过重编号顶点相同.</p><p>$n \le 60$ </p></blockquote><p>一个置换就是对顶点重编号, 一共有 $n!$ 个置换</p><p>考虑对一个置换如何算它的 $C(f)$ , 这里的困难在于置换是对顶点的, 但染色对象确是对边的, 需要先把对顶点的置换转化为对边的.</p><p>考虑一个顶点的重标号, 会形成若干循环, 考虑一个边要么连接两个循环, 要么在同一个循环里:</p><ul><li><p>对于同一个循环里的边, 设循环长度为 $len$ , 发现这个点的置换关于边形成 $\dfrac{len}{2}$ 个循环, 如果不明白可以看这张图:</p><p><img src="/img/2022-07-01-13-59-32-v2-7723aba3a81e40fa0d25ab19ba3a230d_720w.jpg"></p><p>其中每个颜色代表了一个循环, 根据一条边跨越了几个顶点分类.</p></li><li><p>对于不在同一个循环里的边, 若两个循环大小分别为 $a, b$ , 则一共有 $ab$ 条这样的边, 此时相当于每个时刻有两个环一起转一步, 我们考虑一条边什么时候会回到原位, 发现小学数学可知它 $\mathrm{lcm}(a, b)$ 步后会回去, 所以一个边的循环大小为 $\mathrm{lcm}(a, b)$ , 所以个数就是 $\gcd(a, b)$ 个.</p></li></ul><p>于是, 对于一个点的置换, 设它拆成大小为 $a_1$ , $a_2$ . . . $a_k$ 的循环, 那么它对于边的循环个数为</p><p>$$<br>\sum_{i&#x3D;1}^k \dfrac{a_i}{2}+\sum_{i&#x3D;1}^k\sum_{j&#x3D;1}^{i-1}\gcd(a_i, a_j)</p><p>$$ </p><p>但现在由于我们要遍历 $n!$ 个置换, 仍然无法通过, 发现其实一个置换我们只关心每个循环的大小, 每个循环由哪些点构成是不重要的, 所以我们可以直接枚举所有循环大小的情况, 即枚举不同的升序序列 $A&#x3D;a_1, a_2. . . a_k$ , 并计算有多少个置换会拆成这样的序列.</p><p>首先任意排列有 $n!$ 种, 再除掉每组内的相对顺序 $a_i!$ , 每组里是个圆排列乘上 $\dfrac{a_i! }{a_i}$ , 最后因为大小相同的组是不计顺序的, 设 $v$ 出现了 $c_v$ 次我们要再除掉 $\prod_v c_v!$ , 所以次数为</p><p>$$<br>\frac{n! }{a_i\prod_v (c_v! )}<br>$$ </p><p>所以最后方案数为</p><p>$$<br>\frac{1}{n! }\sum_A \frac{n! }{a_i\prod_v (c_v! )} \times 2^k\<br>k&#x3D;{\sum_{i&#x3D;1}^k \dfrac{a_i}{2}+\sum_{i&#x3D;1}^k\sum_{j&#x3D;1}^{i-1}\gcd(a_i, a_j)}<br>$$ </p><p>拿这个算就好了. 我们枚举的这个东西其实是拆分数, 60的拆分数大约在1e6量级, 再乘上 $n^2$ 看起来过不了, 但其实大多数拆分项数较少, 所以跑的飞快.</p><h3 id="CF1630E-Expected-Components"><a href="#CF1630E-Expected-Components" class="headerlink" title="CF1630E Expected Components"></a>CF1630E Expected Components</h3><blockquote><p>给一个长 $n$ 的序列 $A$ , 求随机一个 $A$ 的本质不同排列其权值的期望</p><p>定义两个序列本质不同当且仅当不能通过旋转得到</p><p>定义一个序列的权值, 为若相邻两数相同则连边, 最后形成的连通块数, 注意 $a_1$ 和 $a_n$ 属于相连的.</p><p>$n \le 10^6$ </p></blockquote><p>首先这个连通块数等于 $a_i\ne a_{(i\bmod n) +1}$ 的数量, 但要记得特判全相等的情况.</p><p>这个本质不同让人很想 burnside 或 polya , 但 $A$ 中可能会有相同的数导致不能用 $m^{k(f)}$ 的形式, 考虑burnside.</p><p>此外, 容易发现答案与 $A$ 中数的出现次数有关, 于数的大小无关, 所以用 $cnt_v$ 表示 $v$ 的出现次数, 颜色个数为 $k$ .</p><p>分成两步, 求本质不同的排列数和求答案.</p><h4 id="求本质不同方案数"><a href="#求本质不同方案数" class="headerlink" title="求本质不同方案数"></a>求本质不同方案数</h4><p>burnside后我们要计算一个置换的作用上去不变的数量(不动点), 考虑现在若是转 $i$ 步, 根据上面 polya模板 那题的结论, 会有 $\gcd(n, i)$ 个长为 $\frac {n}{\gcd(n, i)}$ 的循环, 设循环长度为 $d$ , 考虑如果一个循环不是同一个颜色则一定不可能不变, 所以每个循环必然是同一个颜色, 也就是 $d \vert \gcd(cnt_1, cnt_2. . . cnt_k)$ , 令所有 $cnt$ 的 $\gcd$ 为 $g$ .</p><p>而当可以满足每个循环颜色均相同时, 我们可以直接用可重排列来做, 因为循环与循环是区分的, 但同种颜色的每个数是不区分的, 同种循环之间也是不区分的, 所以不动点个数为</p><p>$$<br>\dfrac{\dfrac{n}{d}! }{\prod_i \dfrac{cnt_i}{d}! }<br>$$ </p><p>算一个置换的不动点个数是 $O(k)$ 的. 由于 $\sum_i cnt_i &#x3D; n$ , 所以 $g&#x3D;\gcd(cnt_1, cnt_2. . . cnt_k)\le \dfrac {n}{k}$ , 所以我们只算 $d \vert g$ 的不动点, 那么复杂度就是 $O(k\times \dfrac{n}{k})&#x3D;O(n)$ .</p><p>为了方便, 这里记循环长度为 $d$ 的不动点数量为 $fixpoint_d$ </p><h4 id="求答案-权值和"><a href="#求答案-权值和" class="headerlink" title="求答案(权值和)"></a>求答案(权值和)</h4><p>接下来要求答案, 考虑使用带权burnside, 形式为:</p><p>$$<br>\begin{aligned}<br>sum &#x3D; \dfrac{1}{ \vert G \vert }\sum_f w(C(f))\<br>w(C(f))&#x3D;\sum_{c\in C(f)} w(c)<br>\end{aligned}<br>$$ </p><p>要算每个 $f$ 的 $w(C(f))$ , 这种问题常常要把贡献拆开, 发现一个特点是, 在上一步我们计算不动点个数时把所有 $cnt$ 和 $n$ 都除以 $d$ , 本质相当于我们去算一个长为 $\dfrac {n}{d}$ 的数组的可重排列, 而最关键的是若原序列两个位置是相邻的, 它们所在的循环一定也是相邻的, 所以我们考虑如何算在这个数组上两个相邻元素的贡献.</p><p>一个相邻而不想等的贡献应为确定这个之后其他的排布方案乘上它自己的贡献, 即</p><p>$$<br>\begin{aligned}<br>&amp;\frac{(n-2)! }{\prod_{i&#x3D;2} cnt_i! }\times d\times \dfrac{n}{d}\<br>&#x3D;&amp;fixpoint_d\times \frac{1}{n(n-1)}\times cnt_1\times cnt_2\times d\times \dfrac{n}{d}<br>\end{aligned}<br>$$ </p><p>最后乘上 $d\times \dfrac{n}{d}$ , $d$ 是因为新数组每相邻两个之间的贡献为 $d$ , $\dfrac{n}{d}$ 是因为新数组上有这么多个位置, 我们当前算的两个东西可以在里面随便挑一个相邻.</p><p>所以总和就是</p><p>$$<br>fixpoint_d \times \frac{1}{n(n-1)}\times sum\ of\ cnt_i\times cnt_j\ s. t. (i\ne j)\times d\times \frac{n}{d}<br>$$ </p><p>然后算就好了, 复杂度 $n \log n$ , $\log$ 来自 $\gcd$ .</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一轮省集1杂题选讲</title>
      <link href="/2022/06/18/2022_sdjx1/"/>
      <url>/2022/06/18/2022_sdjx1/</url>
      
        <content type="html"><![CDATA[<h1 id="Day1-contest-of-TYY"><a href="#Day1-contest-of-TYY" class="headerlink" title="Day1 contest of TYY"></a>Day1 contest of TYY</h1><h2 id="T1-小N的独立集"><a href="#T1-小N的独立集" class="headerlink" title="T1 小N的独立集"></a>T1 小N的独立集</h2><p>给一棵树, 每个点权 $a_i$ 在[0, m]间, 每次独立的钦定一个点 $a_x&#x3D;y$ , 求此时有多少方案满足对所有 $v\in [1, m]$ , 满足 $a_i\le v$ 的点构成一个连通块.</p><p>考虑如果不钦定怎么做, 设f_{u, i, 0&#x2F;1}表示 $u$ 的值为 $i$ , 且子树内是否有比 $i$ 大的时考虑 $u$ 子树的方案数, 对于1的情况容易转移</p><p>$$<br>f_{u, i, 1}&#x3D;\prod_v \sum_j f_{v, j, 1} s. t. j\le i<br>$$ </p><p>对于0的情况, 可以枚举哪一个儿子是比它大的:</p><p>$$<br>f_{u, i, 0}&#x3D;\sum_k (\prod_v \sum_{j\ne k} f_{v, j, 0} s. t. j\le i) \times f_{k, j, 1} s. t. j\ge i<br>$$ </p><p>用前缀和和后缀和处理空出k后其他儿子的信息再和k合并不然复杂度爆炸.</p><p>那么现在要支持单点修改, 于是ddp和整体dp拍上去, 然后你发现这玩意ddp用矩阵表示简直发疯, 整体dp赛场上也没写出来(这就是”命运”)</p><p>而这个可以<strong>使用换根dp</strong>: 处理它子树内的答案和子树外的答案, 然后修改时以修改的点为根合并.</p><h2 id="T2-整数序列"><a href="#T2-整数序列" class="headerlink" title="T2 整数序列"></a>T2 整数序列</h2><p>首先有一个 $n^2$ dp, $f_{i, j}$ 表示和为 $i$ , 最后一个数为 $j$ , 如果记录了选的数个数, 那么你降智了.</p><p>这个是慢的, 然而发现比较浪费在于当 $j$ 很大时几个数直接结束了, 这种乘积一定的让人想到根号分治, 当 $a_1&lt;B$ 时使用这种方案.</p><p>于是有另一种方式, 当 $a_1&gt;B$ 时, 记 $f_{i, j, k}$ 表示长度为 $i$ , 最后一个数减去第一个数为 $j$ , 所有数减去第一个数的和为 $k$ , 这样做当值很大时 $i$ 和 $k$ 都很小, 复杂度是 ${\frac {n} {B}}^4$ , 调阈值可以有奇怪复杂度 $O(n^{\frac {8} {5}})$ </p><p>优化后面这种方式, 常常可以考虑在前面加数, 那么因为第一个数可以始终当成0, 相当于给后面的整体抬升, 可以记 $f_{i, j}$ 表示选了 $i$ 个数, 所有数减去 $a_1$ 的和为 $j$ , 那么最后枚举 $a_1$ 即可.</p><h2 id="T3-有处存储"><a href="#T3-有处存储" class="headerlink" title="T3 有处存储"></a>T3 有处存储</h2><p>一个结论</p><p>$$<br>\mu^2(x)&#x3D;\sum_{d^2 \vert x}\mu(d)<br>$$ </p><p>我的证明是</p><p>$$<br>\begin{aligned}<br>x&amp;&#x3D;\prod_i p_i^{a_i} \<br>令x’&amp;&#x3D;\prod p_i^{\lfloor \frac{a_i}{2} \rfloor}\<br>则\mu^2(x) &amp;&#x3D;[x’&#x3D;1]\<br>&amp;&#x3D;\sum_{d \vert x’}\mu({d_i})\<br>&amp;&#x3D;\sum_{d^2 \vert x}\mu(d)<br>\end{aligned}<br>$$ </p><h1 id="TYY杂题选讲-tyy"><a href="#TYY杂题选讲-tyy" class="headerlink" title="TYY杂题选讲-%%tyy"></a>TYY杂题选讲-%%tyy</h1><h2 id="UOJ67-新年的毒瘤"><a href="#UOJ67-新年的毒瘤" class="headerlink" title="UOJ67 新年的毒瘤"></a>UOJ67 新年的毒瘤</h2><blockquote><p>给一个简单无向图, 求删去哪个节点后变成一颗树</p></blockquote><p>如果删完了图联通且边数为 $n-1$ 就行, 然后tarjan判割点</p><p>另外要判孤立点</p><h2 id="UOJ575-光伏元件"><a href="#UOJ575-光伏元件" class="headerlink" title="UOJ575 光伏元件"></a>UOJ575 光伏元件</h2><blockquote><p>给出一个 n×n 的 01 矩阵 A, 其中 A_i, j&#x3D;1 表示开始时位置 (i, j) 有光伏元件, 而 0 表示没有元件.<br>你需要给出一组新的光伏元件的排布方案, 光伏元件的分布有下列要求:<br>设第 i 行的元件个数为 c_0, i, 第 i 列的元件个数为 c_1, i.<br>对于每个 i, 给出 dl_i, dr_i, k_i , 要求  \vert c_0, i−c_1, i \vert ≤k 且 c_0, i, c_1, i∈[dl_i, dr_i]. 即: 要求第 i 行和第 i 列的元件个数在 [dl_i, dr_i] 之间, 且相差不超过 k_i.<br>给出 n×n 的矩阵 C, 以 C_i, j 表示改变位置 (i, j) 上元件有&#x2F;无状态的代价; 特别地, 若 C_i, j&#x3D;−1, 则表示 (i, j) 位置的状态不可改变.<br>你需要找一组方案, 在满足要求的前提下, 使得总费用最小. 保证存在合法方案.<br>1≤n≤100, 0≤dl_i≤dr_i≤n, 0≤k_i≤n, C_i, j≥−1, ∑▒ \vert C_i, j \vert ≤2×10^9.</p></blockquote><p>这种棋盘上要求行的个数和列的个数的长的很像网络流的套路</p><p>考虑建一排行点一行列点 $col_i$ 和 $row_i$ , 则 $(i, j)$ 有点则 $row_i\to col_j$ , 费用相应设置</p><p>然后要处理两列间的这个问题, 简单的想法是通过 $row_i\to col_i$ 有上下界的网络流, 接下来考虑给行和列补流来解决绝对值相差不超过 $k$ :</p><blockquote><p>做法是建一个新点 w_i, 加入  $(col_i, w_i, [0, inf])$ , $(col_i, T, [0, k_i])$ , $(S, w_i, [0, k_i])$  来允许  $k_i$  的差距, 之后再对  $w_i$  和  $row_i$  连边即可.</p></blockquote><p>可以使用强制流满的方法处理负环, 像上下界一样补流, <del>直接网络单纯形</del></p><h2 id="UOJ577-打击复读"><a href="#UOJ577-打击复读" class="headerlink" title="UOJ577 打击复读"></a>UOJ577 打击复读</h2><p>每个位置有一个 $wl$ 和 $wr$ , $vl(s[l, r])$ 为 $s[l, r]$ 出现位置的所有左端点的 $wl$ 之和, $vr(s[l, r])$ 为右端点之和. 每次修改一个位置的 $wl$ , 求</p><p>$$<br>\sum l\sum r vl(s[l, r])*vr(s[l, r])<br>$$ </p><p>设 $s[l, r]$ 出现次数为 $c([i, j])$ </p><p>如果直接维护 $s[l, r]$ 的值会比较麻烦, 还要考虑它的出现次数, 所以维护<br>$f_i&#x3D;\sum_{i\le j\le n} c(s[i, j])\times vr(s[i, j])$<br>那么答案就是 $\sum f_i wl_i$ </p><p>建出 $s$ 的后缀树(这个是反串后缀自动机parent tree), 和后缀自动机</p><p>考虑一个厉害结论, 后缀树上一个节点对应的是后缀自动机上的一条链, 且<strong>这一条链之外除了最后一个点外都只有一条出边</strong>, 由于后缀自动机上每个节点对应endpos相同, 所以每个节点对应的出现次数和 $wr$ 均相等, 对后缀树上每个叶子(叶子即一条后缀)到根路径累加路径上每个节点对应的</p><p>$$<br>\sum c(s[l, r])\times wr_r<br>$$ </p><p>即为 $f$ , 这个东西要在后缀自动机的链上求, 刚才说明这条链中间都只有一条出边, 所以一条链的信息是容易维护的, 只要在后缀自动机上遍历一遍就能得到这些信息.</p><p>对于修改发现可以简单O(1).</p><h2 id="UOJ152-汉诺塔"><a href="#UOJ152-汉诺塔" class="headerlink" title="UOJ152 汉诺塔"></a>UOJ152 汉诺塔</h2><blockquote><p>汉诺塔, 但不要求过程中大的在小的上面, 有1e4个圆盘, 1e6次操作把它排序</p></blockquote><p>可以用操作把一个序列分成两个子序列或把两个子序列合并成一个.</p><p>于是按大于或小于mid分成两个子序列, 对每个子序列, 发现可以忽略另一个子序列, 因为操作都是在栈顶</p><p>于是递归下去归并即可</p><h2 id="UOJ153-世界线"><a href="#UOJ153-世界线" class="headerlink" title="UOJ153 世界线"></a>UOJ153 世界线</h2><blockquote><p>交互题<br>要求你进行两次实验猜出一个长为 $n$ 的排列 $a$ , 值域1-n, 你可以调用的函数包括</p><ul><li>new_round() 新的一次实验, 只能调用两次, 会生成一个 $2n$ 点的无向图, 其中 $i\to n+a_i$ , 此时实验为第一阶段</li><li>next_step() 实验进入第二阶段</li><li>add_edge(u, v) 在第一阶段调用, 连接 $u, v$ </li><li>query(u, v) 在第二阶段调用, 询问 $u+n, v+n$ 的连通性</li></ul></blockquote><p>我们可以在第一阶段把点连成若干连通块, 第二阶段来问每个点在哪个连通块, 我们无法通过add_edge的操作知道另一边的连通块是什么样的, 会形成什么样的结构, 题目相当于连通块和点是无标号的为点找到对应.</p><p>那么我们要想一种方式区分这些连通块和点, 发现可以使用连通块的大小, 即我们用大小分别为1, 2, 3. . . k的连通块来区分, 发现 $k$ 是 $O(\sqrt n)$ 的</p><p>把一个点记为 $(a, b)$ 表示它在左边连通块是a, 右边连通块是b, 把它画到一个平面上, 把它画成一个阶梯状, 第一次实验将行连成连通块, 第二次将列连成连通块, 然后构造一种方式使得我们可以通过连通块的大小来区分每一个元素.</p><p>设 $n&#x3D;\frac {k\times (k+1)}{2}+c$ </p><ul><li>若 $c&#x3D;0$ , 直接分成y&#x3D;x下方三角形样子的阶梯状</li><li>若 $0&lt;c\le k$ , 在上面基础上放上(k+1, k+1), 再把多出来的从上往下堆在最右边, 惊喜的发现由于可以区分出 $(k+1, k+1)$ (所在行大小为1), 那么仍然可以解决</li></ul><p>再考虑次数限制, 连边是 $O(n)$ 的毫无问题, 而询问时我们从每个点询问前面的连通块看它属于哪个是 $O(n\sqrt n)$ 的. 卡常优化是从大的连通块开始尝试, 为了防hack再把加点顺序随机.</p><h2 id="UOJ218-火车管理"><a href="#UOJ218-火车管理" class="headerlink" title="UOJ218 火车管理"></a>UOJ218 火车管理</h2><blockquote><p>有n个栈形成序列a, m次操作, 每次</p><ul><li>给定 $l$ , $r$ 询问 $a_{l. . r}$ 的栈顶和</li><li>给定 $i$ , a_i弹栈</li><li>给定 $l$ , $r$ , $x$ , 把 $a_{l. . r}$ 每个push一个 $x$</li></ul></blockquote><p>如果不带弹栈就是显然的区间推平区间和, 线段树</p><p>那么现在带上修改, 考虑我们需要得到弹出后的栈顶进行修改, 此时有两种解决方案.</p><h3 id="Sol1"><a href="#Sol1" class="headerlink" title="Sol1"></a>Sol1</h3><p>开线段树套堆, 堆按时间为关键字, 对于一个操作按标记永久化的思想拆成线段树节点push进对应的堆中, 那么弹出时查到一条链上最新的就是栈顶, 把这个修改直接撤销了, 再拆成不包含push点的两个修改再修改回去, 发现每个修改的影响都是区间推平, 所以开另一个线段树维护区间推平区间和. 要用一些配对堆之类的牛逼堆.</p><h3 id="Sol2"><a href="#Sol2" class="headerlink" title="Sol2"></a>Sol2</h3><p>开可持久化线段树, 修改直接区间推平, pop可以在历史版本上查到pop完后应该是谁, 进行单点修改, 同时仍然要开另一棵树维护区间覆盖区间和.</p><p>复杂度都是2log</p><h2 id="SDOI-D1T3-子串统计"><a href="#SDOI-D1T3-子串统计" class="headerlink" title="SDOI D1T3 子串统计"></a>SDOI D1T3 子串统计</h2><p>差不多得了 to do</p><h2 id="UOJ727-团队竞技"><a href="#UOJ727-团队竞技" class="headerlink" title="UOJ727 团队竞技"></a>UOJ727 团队竞技</h2><blockquote><p>一堆人选3个人结对编程(? ), 每个人有3个指标, 要求选出的三个人中每个人都有一个指标严格大于另外两个人, 最大化选出来的三个人(每个指标的最大值)的和</p></blockquote><p>诈骗, 如果一个人在多于一个的指标上是最大值, 他就无法被选直接扔了.</p><p>剩下的选三个分别最大的</p><h2 id="UOJ177-新年的腮雷"><a href="#UOJ177-新年的腮雷" class="headerlink" title="UOJ177 新年的腮雷"></a>UOJ177 新年的腮雷</h2><blockquote><p>有n个雷排成一个序列, $i$ 的大小为 $a_i$ , 合并参数序列b, 每次可以把m个合并, 设合并的雷的大小序列为 $x$ , 合并成一个代价为 $\max {x_i+b_i}$ 的雷, 最小化合成一个的代价, 保证能成一个.</p></blockquote><p><strong>反向考虑</strong>, 二分最后的答案, 然后看能不能把一个大小为 $v$ 的最后拆成 $n$ 个, 使得每个大小都不小于对应 $a_i$ </p><p>那么把a和b分别排序, 如果拆掉当前最大的大小为 $x$ 的雷后, 发现如果能拆一定会拆, 而如果这个最大的雷能拆, 发现拆了它一定比拆更小的优秀.</p><h2 id="UOJ730-蚂蚁和方糖"><a href="#UOJ730-蚂蚁和方糖" class="headerlink" title="UOJ730 蚂蚁和方糖"></a>UOJ730 蚂蚁和方糖</h2><blockquote><p>数轴上有蚂蚁和方糖, 给定常数 $L$ , 每次有两个操作:</p><ul><li>为位置 $i$ 增加若干蚂蚁</li><li>为位置 $i$ 增加若干方糖</li></ul><p>并在每次操作后输出, 每个蚂蚁能吃它左右 $L$ 的位置的方糖, 可以多个蚂蚁吃一个方糖, 那么至少被一个蚂蚁吃的方糖有多少个.</p></blockquote><p>hall定理表明我们只要求任选一个蚂蚁集合能吃到方糖减去它们数量的最小值即可.</p><p>如果一个方糖贡献一堆蚂蚁那么蚂蚁的重叠区间部分部分较为困难, 所以改为一个方糖贡献一个蚂蚁的区间, 蚂蚁的区间双向拓展 $L$ 是其方糖区间.</p><p>那么如果两个蚂蚁区间的方糖区间重叠了, 我们把它合并成一个是一定不劣的. 由于要求的是最优解所以可以假设它们不交.</p><p>接下来处理一个方糖贡献一个区间的问题, 为了让一个方糖只算一次, 在相邻两个位置增加虚点, 对每个方糖给它能贡献到的区间间隔加1和-1, 发现此时若蚂蚁的区间于方糖贡献到的区间的交集大小超过1, 仍然只会在容斥后算一次, 类似圆方树的容斥. 注意要钦定区间端点不在虚点上.</p><p>使用线段树维护, 每个节点记录左右端点和中间虚点的信息, 发现答案可以合并</p><h2 id="UOJ732-鱼-2"><a href="#UOJ732-鱼-2" class="headerlink" title="UOJ732 鱼 2"></a>UOJ732 鱼 2</h2><p>鱼排成一个序列, 大小序列为 $A$ , 一个鱼可以吃掉相邻的大小不大于自己的鱼然后大小变为两者之和, 每次给出一个区间, 吃到最后只剩一个的鱼, 求可能成为幸存者的鱼的个数. 询问独立.</p><p>如果一个区间的和小于它左右端点的值, 那么其中的鱼都不能成为幸存者, 定义这样的区间为坏区间, 发现被坏区间包含是死掉的充要条件.</p><p>此外两个重要性质</p><ul><li><p>坏区间不会相交, 只会包含和不交, 因为如果相交的话, 考虑长成这个样子:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-------------------------</span><br><span class="line">     \vert --------- \vert </span><br><span class="line">          \vert --------- \vert </span><br><span class="line">    a    b    c    d</span><br></pre></td></tr></table></figure><p>发现 $A_{b-1}&gt;\sum A_{b. . d}, A_{c+1}&gt;\sum A_{a. . c}$ , 显然直接矛盾</p></li><li><p>坏区间个数为 $O(n \log n)$ , 考虑对于一个点, 坏区间每次拓展至少翻一倍, 因为包含了原来两边的墙, 所以总个数是 $n \log n$ 的.</p></li></ul><p>于是可以考虑求出包含每个点的坏区间, 考虑对每个点向左向右分别得到log个满足点权大于到这个点的区间和的端点, 坏区间的点一定在这些中产生, 由于求区间和是1log的, 我们要O(点数)的求出端点, 发现每个左边端点对应的右边端点必然是左边端点值的前驱后继之一, 可以主席树去维护.</p><p>然后询问时因为是单独拿出来一段, 所以要求出左右端点在区间内的坏区间, 直接进去倍增即可.</p><p>最后要维护未被覆盖的数量, 可以通过线段树维护区间加区间最小值个数, 因为可能会有被询问的区间整体包含的情况所以不是1的个数.</p><h1 id="Day5-contest-of-LXL"><a href="#Day5-contest-of-LXL" class="headerlink" title="Day5 contest of LXL"></a>Day5 contest of LXL</h1><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><blockquote><p> 给一棵树, 时间 $t&#x3D;0$ 时只有叶子有权值, 以后的每个时间, 记 $i$ 在时刻 $t$ 权值 $f_{i, t}$ 为 $f_{i, t}&#x3D;\max_{j\in Son_i}{f_{j, t-1}}$ , 求一条链上的和, 最小值, 最大值.</p></blockquote><p>发现直接维护每个时刻的信息过于困难, 很没前途, 先考虑链上的情况, 对于一个连续的值相等的段一起考虑, 全都插进平衡树, 那么若它上下两段的值都大于它它会缩小1, 都小于它它会扩大1, 否则向上移动一格, 它的移动状况不依赖于当前的时间, 那么可以通过一个全局标记表示所有区间实际经过了多长时间进行询问, 每次如果一个区间没了就把它删了. 标记的处理就是, 因为移动后虽然位置变化了, 但它的相对位置还是一样的(就是两个段的上下关系不变)可以二分出询问涵盖的范围算.</p><p>拓展到树上, 进行树剖, 那么对每个段如果它即将移动出这个重链, 因为是取max, 所以只要考虑其第一个元素的移动, 等它整体移动出下面那条链后把它再插到上面那条里.</p><p>复杂度计算就是, 一开始有 $O(n)$ 个段, 每个段最多有 $log$ 次跳出重链的过程, 复杂度就是 $n\log n$ 了.</p><h2 id="T2-P7882-Ynoi2006-rsrams"><a href="#T2-P7882-Ynoi2006-rsrams" class="headerlink" title="T2 P7882 [Ynoi2006] rsrams"></a>T2 P7882 [Ynoi2006] rsrams</h2><blockquote><p>查询一个区间的子区间里出现次数超过一半的数的权值和, 定义它叫绝对众数, $n, q\le 1e6, 10s$ </p></blockquote><p>看数据范围先猜测复杂度根号或2log</p><p>显然这个绝对众数一个区间只有一个.</p><p>一个容易想到的转化是, 把等于 $c$ 的设为1, 不等于的设为-1, 那么这个数在这个区间是绝对众数等价于区间和大于0.</p><p>那么把区间和差分成两个前缀, 若 $[l, r]$ 的绝对众数是 $c$ , 即 $l\le r$ 且 $pre_r-pre_{l-1}&gt;0$ , 这是区间逆序对, 可以二次离线莫队等解决.</p><p>颜色很少的时候这是对的, 但颜色多了不行, 考虑进行一个匹配: 每个1向前后第一个未匹配的-1匹配, 这个匹配实际上标记了区间和可能大于0的所有点, 那么此时只有匹配的点可能出现在绝对众数为 $c$ 的区间中, 而被标记的总点数显然是 $O(n)$ 的</p><p>那么我们可以对每个颜色抽出匹配了的位置跑一遍, 一次莫队的复杂度是 $n\sqrt q+q$ , 发现如果没有第二项是对的, 而有了遍历询问这一步又变成 $O(nq)$ 的了.</p><p>进行根号分治, 则对出现次数大于 $\sqrt n$ 的颜色每个跑一遍莫队, 复杂度是 $n\sqrt q+q\sqrt n$ .</p><p>对于次数小于 $\sqrt n$ 的颜色, 设颜色 $i$ 的次数为 $cnt_i\le \sqrt n$ , 总点对数就是 $O(\sum_i {cnt_i}^2)$ , 直接看似乎是 $O(n^2)$ 的, 但实际上只要提出一个 $\sqrt n$ 就是 $O(n\sqrt n)$ 的了.</p><p>那直接把点对放到平面上, $(l, r)$ 能贡献当且仅当询问的 $ql, qr$ 满足 $l\ge ql, r\le qr$ , 需要一个 $O(1)-(\sqrt n)$ 修改询问的二维数点. 离线用分块维护扫描线即可.</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><blockquote><p>给 $m$ 个半平面和 $n$ 个点, 设两个半平面 $i$ , $j$ 包含的点的集合的对称差大小为 $f(i, j)$ , 一个半平面的大小为 $size_i$ , 构造一个排列使得 $size_1+\sum_{i&#x3D;1}^{n-1} f(i, i+1)\le 1. 8e8$</p><p>数据范围 $n, m\le 1e5$</p></blockquote><p>相当于半平面莫队模板吧, 看下面的半平面莫队.</p><p>然后spj复杂度是平方的, 评测一个人需要一年.</p><h1 id="lxl讲课-DS-is-good"><a href="#lxl讲课-DS-is-good" class="headerlink" title="lxl讲课-DS is good"></a>lxl讲课-DS is good</h1><h2 id="半平面技巧"><a href="#半平面技巧" class="headerlink" title="半平面技巧"></a>半平面技巧</h2><p>给定平面上的一些点, 查询一个半平面上的信息</p><h3 id="六分树"><a href="#六分树" class="headerlink" title="六分树"></a>六分树</h3><p>通过三条斜线把点集均分成六份, 每次会递归进入6个儿子中的4个, 复杂度 $O(n+nm^0. 77)$</p><h3 id="分块旋转扫描线"><a href="#分块旋转扫描线" class="headerlink" title="分块旋转扫描线"></a>分块旋转扫描线</h3><p>考虑我们连续的旋转一条线, 维护以这条线为y轴时点集的x轴顺序, 那么半平面里的点就是序列的一个前缀或后缀了. 由于对于任意两个点, 他们顺序(一个在另一个前面的关系)的翻转是 $O(1)$ 的, 所以复杂度是 $O(n^2)$ 的</p><p>那你直接把它分块, 每个块复杂度 $O({\sqrt n}^2)&#x3D;O(n)$ , 它就成了 $n\sqrt n$</p><h3 id="半平面莫队"><a href="#半平面莫队" class="headerlink" title="半平面莫队"></a>半平面莫队</h3><p>超级厉害的技巧</p><p>如果这些半平面都交于一点, 那这个问题是简单的, 因为旋转一遍的过程中我们的半平面区域包含一个点&#x2F;不包含一个点的切换次数是 $O(n)$ 的.</p><p>而如果把半平面都平移到一个点, 这个过程的切换次数是 $O(n^2)$ 的, 一定爆炸.</p><p>于是考虑平衡这两个做法, 在给定的 $O(n)$ 个点中随机选 $\sqrt n$ 个作为关键点, 把直线平移到这些点再对没给点一起旋转.</p><p>具体的, 对于每条线, 我们找到从它向下平移的过程中碰到的第一个点, 那么过程中期望经过 $\sqrt n$ 个点, 所以总复杂度是每条线经过 $\sqrt n$ 个点的 $m\sqrt n$ 加上每个关键点旋转的 $n$ , 为 $(n+m)\sqrt n$</p><h3 id="等差数列位置区间加-等差数列位置求和"><a href="#等差数列位置区间加-等差数列位置求和" class="headerlink" title="等差数列位置区间加, 等差数列位置求和"></a>等差数列位置区间加, 等差数列位置求和</h3><p>用第十分块的方式时间分块</p><p>时间分治后问题变成三个子问题:</p><ul><li>算一个修改对另一个询问的贡献</li><li>静态算一个询问, $O(\sqrt n)-O(n)$ 询问和重建</li><li>静态算一个修改, $O(\sqrt n)-O(n)$ 修改和查每一个位置.</li></ul><p>对于第一个问题, 贡献就是修改和询问这两个等差数列位置的交集*修改的值, 交集要离线下来一起算, 不然在线做不到O(1)</p><p>对于第二第三个问题, 套用”初始化”的方法进行根号分治, 对于大于的暴力, 小于的维护前缀和, 平衡成 $O(n^\frac {5}{3})$</p><h3 id="3dmq"><a href="#3dmq" class="headerlink" title="3dmq"></a>3dmq</h3><p>长方体加, 长方体乘, 长方体求和, 长方体均为左下方的3face长方体</p><p>和上一个题一样时间分块, 则仍然考虑三个子问题:</p><ul><li><p>修改对询问的贡献显然可以快速算吧</p></li><li><p>询问需要3side加和乘, 可以离线一维变成</p></li></ul><h3 id="给定一些点-求半平面内相等点对个数"><a href="#给定一些点-求半平面内相等点对个数" class="headerlink" title="给定一些点, 求半平面内相等点对个数"></a>给定一些点, 求半平面内相等点对个数</h3><p>直接用上面半平面莫队做, 插入点和删除点都是平凡的.</p><h3 id="半平面逆序对"><a href="#半平面逆序对" class="headerlink" title="半平面逆序对"></a>半平面逆序对</h3><p>求半平面有多少点构成逆序对</p><p>对于 $(x_i, y_i)$ , 预处理有多少 $j\ s. t. \ x_i&lt;x_j, y_i&gt;y_j$ , 那么半平面的直线斜率为正就是半平面内 $f_i$ 的和, 否则再处理与这个点构成顺序对的对数 $g_i$ , 然后拿总对数减去半平面的 $g_i$ 的和即可. 转化成了半平面数点.</p><h3 id="P8283-「MCOI-08」Dantalion"><a href="#P8283-「MCOI-08」Dantalion" class="headerlink" title="P8283 「MCOI-08」Dantalion"></a>P8283 「MCOI-08」Dantalion</h3><blockquote><p>给一个序列, 每次问区间里有多少个子区间里值构成的集合关于异或封闭</p></blockquote><p>这个东西看起来很像线性基, 考虑若一个区间的线性基大小为 $k$ , 则这个区间的颜色数必然是 $2^k$ , 由于颜色是满足包含单调性的, 所以可以进行 $\log n$ 遍双指针, 求出一共 $n \log n$ 对 $(l1, l2, r, k)$ 表示 $\forall l\in [l1, l2], [l, r]$ 的颜色段数为 $2^k$ .</p><p>然后对于这些 $n \log n$ 个对, 我们需要知道它的线性基大小是否和颜色数匹配, 所以需要扫一遍得到每一个的线性基.</p><p>最后就是我们知道若干个 $(l1, l2, r)$ 是满足条件的, 直接二维数点即可.</p><p>考虑继续优化</p><p>线性基可以优化成1log的, 方法是我们添加数的时候维护线性基每个位置什么时候有值, 并维护1-r的线性基, 那么 $l, r$ 点线性基就是所有最早位置＞ $l$ 的, 那么此时只需要在每个位置扫一遍线性基上的位置扫一遍右端点在这里的对就可以完成1log统计</p><p>接下来是数点的优化, 可以按 $l$ 为横轴, $r$ 为纵轴做一个平面, 则 $(l1, l2, r)$ 就是平面上的一条横线, 而询问是问一个矩形内包含的线段总长度, 注意这里右端点在外面. 如果允许离线这个可以扫描线, 做成扫描 $r$ 轴, 区间加和区间历史和, 那么要求在线就把维护的数据结构可持久化即可. 复杂度2log.</p><p>把它优化成1log, 首先对于 $(l1, l2, r)$ 差分成 $(1, l2, r)-(1, l1, r)$ , 然后把加的和减的单独计算. 因为一开始我们说明过对于同一个 $k$ , 它是不会有包含的, 所以拆成 $1, l, r$ 后 $l$ 和 $r$ 分别单调递增, 那么我们把它排序后做前缀和, 询问区间包含的一定是连续的一段. 求出询问区间 $L, R$ 里第一个 $l&gt;L$ 的和最后一个 $r&lt;R$ 的, 最后直接减去多算的 $L \times len$ , $len$ 为包含的线段个数.</p><h3 id="P4062-Code-1-Yazid-的新生舞会"><a href="#P4062-Code-1-Yazid-的新生舞会" class="headerlink" title="P4062 [Code+#1]Yazid 的新生舞会"></a>P4062 [Code+#1]Yazid 的新生舞会</h3><blockquote><p>给定一个序列, 求有多少子区间的众数的出现次数超过子区间长度的一半, 线性复杂度</p></blockquote><p>首先它和T2长的很像, 可以考虑仍然使用那个对于每一个数看成1和-1, 然后1和-1匹配得到若干个连续段的做法, 那么需要找到一个 $O(1的个数)$ 跑匹配的方法, 具体的, 可以用一个并查集维护, 对每个集合额外记录一个最左边的端点, 每次匹配之后就把这次匹配行成的一个和为0的段合并, 那么找匹配的时候只要看前一个元素的集合的最左边元素的再左边一个.</p><p>然后现在要对每一个段求答案, 划分成若干个段的好处是原来的区间逆序对变成了现在相邻两数差为1的逆序对, 考虑以下标为 $x$ 轴值为 $y$ 轴会画出一个折线, 从前往后扫不断把数加入到一个值域桶里, 那么+1-1时, 比当前大的数的个数的变化量其实就是刚才那个桶里对应位置的值了.</p><h3 id="P7889-「MCOI-06」Eert-Tuc-Knil"><a href="#P7889-「MCOI-06」Eert-Tuc-Knil" class="headerlink" title="P7889 「MCOI-06」Eert Tuc Knil"></a>P7889 「MCOI-06」Eert Tuc Knil</h3><blockquote><p>给一个 $n$ 个点的有根树, 点 $i$ 权值为 $a_i$ , 每次询问给出 $u$ , $x$ , 问如果给 $u$ 子树整体加上 $x$ , 那么它内部包含 $u$ 的连通块的权值和最大多少.</p></blockquote><p>看到这个题发现这个最大连通块和其实和序列上的最大子段和是很像的, 可以写出一个简单dp: $f_i&#x3D;\sum_{j\to i}{\max(f_j, 0)}$ .</p><p>现在加上了函数 $x$ , 可以设 $f_u(x)$ 表示给 $u$ 的子树整体加上 $x$ 后它的最大连通块和, 把它看成一个关于 $x$ 的分段函数, 则因为叶子分两段, 那么每个点的分段都是 $O(n)$ 的, 用启发式合并即可.</p><h3 id="半平面数点数据随机做法"><a href="#半平面数点数据随机做法" class="headerlink" title="半平面数点数据随机做法:"></a>半平面数点数据随机做法:</h3><p>把平面分成 $\sqrt n \times \sqrt n$ 块, 每块期望常数个, 半平面经过 $\sqrt n$ 个块, 那么完整包含的部分可以前缀和, 一个块内的可以暴力判定, 复杂度期望 $\sqrt n$ , 感觉相比那几个半平面莫队之类的很可写啊! </p><h1 id="Day6-contest-of-LXL"><a href="#Day6-contest-of-LXL" class="headerlink" title="Day6 contest of LXL"></a>Day6 contest of LXL</h1><h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a>T1</h2><blockquote><p>给一个由栈构成的序列和常数A, 每次给一个区间里一起加入一个数, 或者询问从这个栈开始连着几个的乘积大于A</p></blockquote><p>把时间维和序列维换一下, 扫描序列维, 维护时间维, 若以序列为横轴, 时间维为纵轴, 则一个修改就是平面上一条横线, 一个询问则相当于询问一点的区间历史和(差分得到一段). 扫描线进入一个修改时, 一个修改会影响向上log个不是1的段, lxl说随便数据结构至少1log找一段, 每次进行一个区间修改, 所以数据结构支持区间修改和单点历史时刻和, 线段树即可</p><p>也可以1log找出所有的被影响的段, 把一堆插入的1缩成1个, 在平衡树上找log个后继相当于finger search.</p><p>修改也可以1 log finger search性质修改.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这种扫描线是利用了一个维度的不对称性, 时间维的结构有时会比序列的更简单.</p><h3 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h3><h4 id="饮食区"><a href="#饮食区" class="headerlink" title="饮食区"></a>饮食区</h4><blockquote><p>有一个队列构成的序列, 每次</p><ul><li><p>给 $[l, r]$ 中的队列队尾加入 $k$ 个 $c$</p></li><li><p>$[l, r]$ 中的队列弹出 $k$ 个队首, 不足则弹空</p></li><li><p>查询第 $i$ 个队列的第 $k$ 个数</p></li></ul></blockquote><p>仍然用刚才的套路, 扫描序列维护时间, 可以用个线段树, 位置 $t$ 表示 $t$ 时刻插入的人有几个, 删除则为负数, 那么发现直接求一个区间里有多少人是困难的, 因为删除还会和0取max, 方法是维护时间维上后缀和的min, 那么只要二分它第一次小于0的位置就能得到最后一次取max的位置, 接下来就直接二分kth就好了</p><p>复杂度1log</p><h4 id="相关例题UOJ515"><a href="#相关例题UOJ515" class="headerlink" title="相关例题UOJ515"></a>相关例题UOJ515</h4><blockquote><p>单点修改, 询问 $a_x, \ldots, a_n$ 的不同的后缀最小值个数.</p></blockquote><p>首先显然和前缀最小值一样</p><p>仍然用扫描序列维维护时间维的方法, 扫的时候在后面增加个数是不会改变已有的最小值, 所以转化后序列后区间询问转化成单点历史询问, 单点的修改会影响一段后缀所以是区间修改. 计算个数时, 如果取min生效了就代表前缀最小值多了一个. 这个可以线段树均摊, 分析就是取min时递归到的每个区间本质不同数字的数量至少减1, 所以复杂度1log.</p><h4 id="相关例题Comet-OJ-Contest-14-D"><a href="#相关例题Comet-OJ-Contest-14-D" class="headerlink" title="相关例题Comet OJ Contest#14 D"></a>相关例题Comet OJ Contest#14 D</h4><blockquote><p>有一个序列 $c$ , 一个操作序列每个操作是对 $c$ 区间赋值, 然后每次询问按顺序执行操作序列一个区间的操作后 $c$ 的全局和, 询问独立.</p></blockquote><p>对于操作序列上的一个操作 $(t, l, r, v)$ 表示 $t$ 时刻把 $[l, r]$ 赋值为 $v$ , 我们把它的影响</p><p>范围画出来, 以操作序列的下标(或者说时间)为横轴, 以序列为纵轴, 那么它影响的 $(x1, y1, x2, y2)$ 的矩形就是 $(t, l, inf, r)$ , 是3side的矩形.<br>这些矩形相互覆盖, 统计信息较为复杂, 可以把它们划分成若干不交的矩形, 相当于我们向右扫描线时用ODT维护区间值相等的段, 在每一个段消失的时候, 以它从加入到消失这个时间段为底, 以这个段消失的时候在序列c上的左右端点为高, 划分成一个矩形. 由和镜中的昆虫相同的颜色段均摊原理, 这样做复杂度是正确的, 划分完矩形个数仍然是 $O(n)$ 的</p><p>于是现在一个横坐标在 $[x1, r1]$ 的矩形对一个询问 $l, r$ 有贡献, 当且仅当 $l\le x1, r\in [x1, x2]$ , 而贡献就是它的长度成值, 这就是二维数点啊.</p><h4 id="相关例题Ynoi2009-rprmq1"><a href="#相关例题Ynoi2009-rprmq1" class="headerlink" title="相关例题Ynoi2009 rprmq1"></a>相关例题Ynoi2009 rprmq1</h4><p>n*n矩形全是0, 先进行m次矩形加, 所有修改结束后有q次查询最大值</p><p>扫描线的基本模型是先修后查, 只是因为扫一维转化成了动态, 所以这就是标准扫描线.</p><p>不能直接扫描线因为max不具有差分性质</p><p>一种方法是扫到起始边时把询问打标记, 所以需要再用数据结构维护所有询问.</p><p>另一种方法是进行分治, 在坐标平面正中间切开, 两边拼起来得到答案, 但这样修改可能跨多个分治部分复杂度是假的.</p><p>考虑把分治的切开线画到平面上, 对同一个深度的层一起考虑, 询问一定不会跨过两条线(因为一定在没跨过的时候, 在最高层处理了)且贴在一条线上, 那么相当于区间加区间历史最大值, 而且信息每次经过一个分治切割线要把历史值清空一次(设为当前值), 方式是每次经过一条线整体加inf.</p><p>我们每一层进行了一遍所有修改, 而询问只会出现在一层, 所以修改复杂度 $O(m log^2 n)$ , 询问 $O(q log n)$</p><h4 id="相关例题Ynoi2019-rprmq2"><a href="#相关例题Ynoi2019-rprmq2" class="headerlink" title="相关例题Ynoi2019 rprmq2"></a>相关例题Ynoi2019 rprmq2</h4><p>m*m的矩形初值为0, 有m次操作, 每次修改一个2side矩形, 维护全局最大值</p><p>这个是严格不弱于刚才的问题的: 可以直接规约成矩形4side最大值和加: 全局的直接区间加inf然后查完结果再减inf相当于矩形最大值, 而2side也可以差分出4side. 所以一些奇怪的乱搞是不行的.</p><p>对于又有询问又有修改不容易做的问题, 考虑时间分块.</p><p>但我们无法直接对一个修改计算询问的贡献.</p><p>对于当前的时间块, 对于所有询问修改的矩形边界为边线, 把平面按照这些线划分成一个网格图, 则这一块修改询问都以网格为单位, 而上一块的却不是, 解决方案是对这 $\sqrt n$ 个格子找到在上一个时间块的最大值, 由于我们不会深究这一个格子里面到底是啥, 所以只要知道这个就可以了. 对于这个问题我们可以用rprmq1的扫描线得到答案.</p><p>由于以块为单位, 可以把块看成点, 每次块内修改贡献是矩形加矩形最大值, 可以用KDT单次 $\sqrt n$ 解决.</p><p>复杂度还有俩log要砍, 需要再研究一下.</p><p>update:</p><p>观察到rprmq1那一步的查询有性质: 我们查的是一个网格中每个格子的值, 考虑删掉横坐标分治, 直接从左向右扫描线, 那么把线段树的建法改成, 关于格子建线段树, 在格子下再关于坐标建线段树, 形成的高度和直接按坐标相同, 但现在每个格子对应上层线段树的一个叶子, 也就是所有查询都被拆成 $1$ 个区间而不是 $\log n$ 个, 复杂度从 $(n+B^2)\log n$ 变成 $n\log n+B^2$($B$ 为时间分块大小), 就可以平衡到 $n\sqrt{n\log n}$</p><p>据说这题写出来常数大的离谱, 除了std700行以外没人能过, 还是差不多得了.</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>给一个序列, 记第k小为 $kth(k-1)$ , 问区间里 $\sum kth(i) b^i$ 的值</p><p>来自CF633H</p><p>赛时写了个垃圾 $\sqrt n\log n$ 的莫队套线段树</p><p>对序列分块一定会涉及到去重没前途, 对值域分块</p><p>先考虑无重复元素的个数.</p><p>设第 $i$ 块里有 $x_i$ 个数, 答案为 $y_i$ , 则发现两个一起的答案可以 $O(1)$ 得到.</p><p>于是考虑一块的怎么做, 仅考虑在当前块的位置, 它对应的原序列上的位置也只有 $\sqrt n$ 个, 则<strong>在原序列上只有 $O(n)$ 个本质不同(值域情况不同)区间</strong>, $O(n)$ 预处理 $f_i$ 表示每个位置前面第一个在当前块里的位置, $g_i$ 表示每个位置后面第一个, 这个只要正反各扫描一遍即可. 然后则可以把一个询问定位到这一块在序列上一个本质不同的区间, 那么预处理这些一共 $n\sqrt n$ 个区间的答案即可.</p><p>接下来考虑有重复元素的情况, 此时可能一个值域里有很多数, 那么可以对于一个值以它的出现次数为权值分块(like 势能均摊莫队), 如果一个颜色出现次数多的离谱(多于 $\sqrt n$ )那么单独分一块, 那么此时这种的要单独处理, 我们只需要知道它的出现次数即可, 考虑在线要二分多个 $\log$ , 于是把询问离线, 存下它们的端点, 然后用刚才定位本质不同的区间扫两遍得到最左和最右的关键点, 于是就能得到个数了.</p><h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a>T3</h2><p>信息是可以快速合并的(然而我是智障没有发现)</p><p>合并方法: 两个块, 设包含的等于 $x$ 的个数为 $b1$ , $b2$ , 每个点到端点的颜色切换数是 $a1$ , $a2$ , 那么合起来答案就是 $a1b2+a2b1$ , $b$ 合并显然, $a$ 合并相当于整体延伸一段, 再算一下整块一共切换多少次就可以合并.<br>那么只要考虑区间赋值了, 如果一个块已经成了一个就 $O(1)$ 算, 否则暴力, 那么复杂度是每个块的 $O(\sqrt n \times \sqrt n+m\sqrt n)$ 和散块的 $O(m\times \sqrt n)$</p><h1 id="lxl讲课-lxl"><a href="#lxl讲课-lxl" class="headerlink" title="lxl讲课-lxl"></a>lxl讲课-lxl</h1><h2 id="P7125-Ynoi2008-rsmemq"><a href="#P7125-Ynoi2008-rsmemq" class="headerlink" title="P7125 Ynoi2008 rsmemq"></a>P7125 Ynoi2008 rsmemq</h2><blockquote><p>给一个询问, 每次问一个区间里有多少子区间的 $\frac {l+r} {2}$ (注意是下标而不是这个位置的值)是区间众数(非严格, 可以有多个)且长度是奇数</p></blockquote><p>枚举每个位置为中心, 设中心位置为 $x$ , 有 $y$ 个 $i$ 个满足 $a_i&#x3D;x$ , 则最多有 $y$ 段 $k$ 的极长区间满足 $[x-k, x+k]$ 合法. 然后因为 $x$ 互不相同(再次读题)所以总段数 $O(n)$.</p><p>考虑如何求出所有段, 根号分治, 对出现次数大于根号的可以暴力扫描 $k$, 对小于根号的考虑要对每个 $i$ 得到众数出现次数为 $i$ 的最大的 $k$, 可以对每个出现次数双指针得到最小的 $p_r$ 使得 $[p_r, r]$ 众数小于 $i$, 那么对当前中心 $x$ 就要只要求最大的 $r$ 使得 $\forall i\in [x+1, x+r], p_i\le x-i$, 而二分复杂度是出现次数之和也就是 $O(n)$, 二分的 $n\log n$ 就不用管了.</p><p>求出来之后得到若干个 $(p, l, r)$ 的段, 画到平面上是若干个左上-右下的斜线, 要给定矩形求矩形内长度和, 按照矩形主对角线分开算即可, 完全包含和部分包含都是 $2side$ 直接求和的问题.</p><h2 id="CF1491H"><a href="#CF1491H" class="headerlink" title="CF1491H"></a>CF1491H</h2><blockquote><p>给定序列 $a$ , $a_i$ 表示 $i$ 的父亲构成一棵树, 保证 $1\le a_i &lt; i$ , 支持两个操作:<br> <code>1 l r x</code> 令 $a_i&#x3D;\max(a_i-x, 1)(l\leq i\leq r)$ .<br><code>2 u v</code> 查询在当前的 a 数组构成的树上 u, v 的 LCA.</p></blockquote><p>这个修改对形态的影响很大, 根本不能维护树, 由于修改太神询问一定较弱, 从询问角度考虑:</p><p>为了处理lca我们不需要知道树的形态, 发现 $a_i-i$ 很大时可以暴力, 于是根号分治, 当 $a_i-i\le \sqrt n$ 时, 分块后预处理每个点跳几次会跳出当前块, 每个点跳出来在哪.</p><p>由于 $a_i-i$ 是单增的且每次至少减1, 那么若一个块被整体减了 $\sqrt n$ 次, 其中每个数必然都会一次跳出去, 就不需要维护这个块了. 这使得每个整块只被减 $\sqrt n$ 次, 一共 $\sqrt n$ 块, 于是可以每块暴力 $\sqrt n$ 做.</p><p>那么复杂度就是完整包含的 $n\sqrt n$ 或零散的 $m\sqrt n$ 了</p><p>然后剩下的可以暴力lca(向上标记法, 先整块后散块)</p><h3 id="奇妙小技巧"><a href="#奇妙小技巧" class="headerlink" title="奇妙小技巧"></a>奇妙小技巧</h3><p>lxl给我们讲对着一个老哥块长把这个题的 $n^\frac {5}{3}$ 卡了, 讲了下防卡技巧:<br>分块散块有一半常数, 线段树期望也卡不满 $2\log n$ , 为了防卡可以直接给序列整体右移一个随机值, 就能让构造数据变成随机的.</p><h2 id="CF700D-Huffman-Coding-on-Segment"><a href="#CF700D-Huffman-Coding-on-Segment" class="headerlink" title="CF700D Huffman Coding on Segment"></a>CF700D Huffman Coding on Segment</h2><blockquote><p>给定一个长度为 $n$ 的串, $q$ 次询问一个区间的最小二进制编码长度(给每个数找一个二进制对应, 总长度最小)</p></blockquote><p>首先全局的是经典的, 可以按出现次数建huffman树, 那么每个点的编码就是根到叶子路径走过边形成的01串, 长度就是深度*权值, 所以相当于在这一段以次数为代价合并果子.</p><p>我们要维护区间每个数的次数, 这个东西常常莫队. 因为这类问题常常不弱于矩阵乘法, 如区间出现次数第 $k$ 大的这类的, 此时考虑莫队.</p><p>但显然不能暴力合并果子, 要进行优化, 对于出现次数小于 $\sqrt n$ 的, 可以 $O(1)$ 代价批量合并一个数, 剩下的数都是大于 $\sqrt n$ 的, 可以进行暴力(势能为剩下数的个数). 就能 $O(\sqrt n)$ 完成一次查询.</p><h2 id="CF1476G-Minimum-Difference"><a href="#CF1476G-Minimum-Difference" class="headerlink" title="CF1476G Minimum Difference"></a>CF1476G Minimum Difference</h2><blockquote><p>有一个长为 $n$ 的数组, 进行 $m$ 次询问, 每次为以下两种中的一种:</p><ul><li><code>1 l r k</code>: 给定区间 $[l, r]$ , 你需要求出最小的 $\text{dif}$ , 使得能够选出 $k$ 个互不相同的数 $a_1, a_2, \cdots, a_k$ , 令这些数在区间中的出现次数分别为 $cnt_1, cnt_2, \cdots, cnt_k$ (任意 $cnt_i &gt; 0$ ), 则 $\text{dif}$ 为这些 $cnt_i$ 的极差; 若无法选出 $k$ 个数, 则输出 $-1$ .</li><li><code>2 p x</code>: 将位置 $p$ 赋值为 $x$ .</li></ul></blockquote><p>和上一个一样进行莫队, 求出每个出现次数, 和盼君勿忘一样有数的出现次数不同的只有 $\sqrt n$ 种, 因为有修改所以待修莫队.</p><h2 id="lxl现场造题"><a href="#lxl现场造题" class="headerlink" title="lxl现场造题"></a>lxl现场造题</h2><p>三维空间有一堆长方体, 求他们的并的体积. 长方体个数 $10^5$ , 时限10s.</p><p>扫描线一维, 然后是动态的二维问题, 每次要矩形加一减一或查询0的个数, 那么就用上面的rprmq2把最大值变成最小值再维护最小值个数.</p><h1 id="Day7-contest-of-CYX"><a href="#Day7-contest-of-CYX" class="headerlink" title="Day7 contest of CYX"></a>Day7 contest of CYX</h1><h2 id="T1-2"><a href="#T1-2" class="headerlink" title="T1"></a>T1</h2><p>给一个树, 一开始都是蓝边, 每次删掉一条全是蓝色的链上的一条边, 然后再把链的两端点连一条红边, 问能不能把它变成另一棵全是红色的树.</p><h2 id="法1"><a href="#法1" class="headerlink" title="法1"></a>法1</h2><p>一条链可以进行操作当且仅当它上面只有一条要删的边, 然后树剖线段树求每个链覆盖了多少条要删的边每次找最小的即可.</p><h2 id="法2"><a href="#法2" class="headerlink" title="法2"></a>法2</h2><p>把操作反过来, 那么每次能操作的就是两个点间有一条红边有一条蓝边的情况, 操作后, 由于任何一个接下来的操作都不能再经过它了, 所以它相当于变成了一个点, 可以启发式合并的把原来这些点的边添加到一个上, 重复这个过程.</p><h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a>T2</h2><p>todo</p><h2 id="T3-2"><a href="#T3-2" class="headerlink" title="T3"></a>T3</h2><p>todo</p><h1 id="cyx讲课-只有dp不会-不会就是不会"><a href="#cyx讲课-只有dp不会-不会就是不会" class="headerlink" title="cyx讲课-只有dp不会, 不会就是不会"></a>cyx讲课-只有dp不会, 不会就是不会</h1><h2 id="四边形不等式"><a href="#四边形不等式" class="headerlink" title="四边形不等式"></a>四边形不等式</h2><p>这里是讨论的最小值</p><p>四边形不等式, 等价于二维差分后 $\le 0$ , 感觉一般写成 $w_{l, r}+w_{l-1, r+1}\ge w_{l-1, r}+w_{l, r+1}$ 的形式更容易看性质啊, 那么发现这个式子其实就是在矩阵上二维差分.</p><p>满足四边形不等式的矩阵, 称为蒙日矩阵, 在每一行最小值位置<strong>单调递增</strong>(决策单调性).</p><p>蒙日矩阵的行列没有关系, 转置后仍然满足条件</p><h3 id="常见形式1DAG上最短路"><a href="#常见形式1DAG上最短路" class="headerlink" title="常见形式1DAG上最短路"></a>常见形式1DAG上最短路</h3><p>$f_i&#x3D;\min{f_j+w(j, i)}$ , 其中 $w$ 满足四边形不等式</p><p>结论: $f$ 满足决策单调性</p><p>因为一个 $j$ 贡献一个后缀的 $i$ , 那么可以使用二分栈维护. 二分栈的元素 $(l, r, j)$ 表示在区间 $[l, r]$ 中最优决策点为 $j$ .</p><h3 id="常见形式2DAG上定长最短路"><a href="#常见形式2DAG上定长最短路" class="headerlink" title="常见形式2DAG上定长最短路"></a>常见形式2DAG上定长最短路</h3><p>$f_{i, j}&#x3D;\min f_{i-1, k}+w(k, j)$</p><p>$f$ 同时具有决策单调性和凸性, 可以wqs二分</p><h3 id="常见形式3区间DP"><a href="#常见形式3区间DP" class="headerlink" title="常见形式3区间DP"></a>常见形式3区间DP</h3><p>$f_{l, r}&#x3D;\min_{k\in[l, r]} {f_{i, k}+f_{k, j}}+w(l, r)$</p><p>要求 $w$ 还满足区间包含单调性</p><p>可以把 $n^3$ 优化成 $n^2$</p><h3 id="基站选址"><a href="#基站选址" class="headerlink" title="基站选址"></a><a href="/P2605-%E5%9F%BA%E7%AB%99%E9%80%89%E5%9D%80-dp-%E7%BA%BF%E6%AE%B5%E6%A0%91">基站选址</a></h3><p>经典线段树优化dp了</p><p>然而这题状态是满足四边形不等式的!</p><p>证明: 考虑dp式子:</p><p>$$<br>f_{i, j}&#x3D;\min <em>k {f</em>{i-1, k}+cost(j, k)}+c_j \<br>cost(l, r)&#x3D;\sum _{i&#x3D;l}^r{[d_i-s_i &gt; d_l][d_i+s_i &lt; d_r]w_i}<br>$$ </p><p>那么考虑当 $cost$ 扩展一个时, 记两个条件为 $a_1$ , $a_2$ , 相比于 $cost_{l, r}$ , $cost_{l+1, r}$ 增加了原来一些 $a_1&#x3D;0, a_2\ne 0$ 的部分, $cost_{l, r+1}$ 为原来一些 $a_2&#x3D;0, a1\ne 0$ 的部分, 而 $cost_{l-1, r+1}$ 除了完整包含这两类外还有一些 $a_1&#x3D;0, a_2&#x3D;0$ 的部分, 所以证明了包含大于相交.</p><p>然后可以凸优化把原来的 $nk\log n$ 优化成 $n\log k\log n$</p><h3 id="FJOI物流仓库选址"><a href="#FJOI物流仓库选址" class="headerlink" title="FJOI物流仓库选址"></a>FJOI物流仓库选址</h3><blockquote><p>数轴上 $n$ 个点, 选择最少1个最多 $k$ 个仓库, 第 $i$  点位置 $x_i$ , 在这里建立代价为 $c_i$ , 若 $i$ 到最近仓库距离为 $d$ , 代价为 $a_id$ , 最小化代价.</p></blockquote><p>设第 $i$ 个仓库在 $j$ 时的费用为 $f_{i, j}$</p><p>$$<br>f_{i, j}&#x3D;\min{f(i-1, k)+\sum_{p&#x3D;k}^j\min({x_p-x_k, x_j-x_p}})*a_p+c_j<br>$$ </p><p>转移函数满足四边形不等式, 可以凸优化去掉第一维</p><p>证明: 仍然看</p><p>$$<br>cost(l, r)&#x3D;\sum_{p&#x3D;l}^r\min({x_p-x_l, x_r-x_p})*a_p+c_j<br>$$ </p><p>像上面一样考虑拓展一个的情况, 发现相比 $f_{l, r}$ 有两个变化:</p><ul><li><p>增加了新的位置的数, 但这里距离正好所以直接可以不管.</p></li><li><p>所有取 $min$ 的 $x_l$ , $x_r$ 变了, 且都是往大里变, 那么取个 min 就显然是包含大于相交了.</p></li></ul><p>凸优化后就是考虑不考虑限制随便选的情况, 设 $g_i$ 表示仓库在 $i$ 时考虑前缀 $[1, i]$ 的代价, $h_i$ 表示仓库在 $i$ 前时前缀 $[1, i]$ 的代价, 再预处理每个前缀所有点到 $1$ 的代价, 后缀所有点到n的代价就可以快速通过 $h$ 和 $g$ 互相转移了. 两个转移都可以斜率优化. 最后复杂度就是 $O(n\log V)$</p><h3 id="IOI2014假期"><a href="#IOI2014假期" class="headerlink" title="IOI2014假期"></a>IOI2014假期</h3><blockquote><p>$n$ 个城市一行, $i$ 号城市权值为 $a_i$ , 给定起点 $s$ 每次可以选择向左或向右移动一步或者获得现在所在位置的权值, 权值不能重复获得, 求 $d$ 天内拿到的最大权值和</p></blockquote><p>期间只会回头一次, 否则一定可以调整为不劣的方案. 设走过的区间为 $[s-l, s+r]$ , 移动用时就是 $l+r+\min(l, r)$ , 那么答案就是前 $d-(l+r+min(l, r))$ 大的和这个可以用主席树做.</p><p>可以把形式转化成固定 $l$ , 则 $f_l&#x3D;\max{sumkth(d-l-r-min(l, r))}$ , 其中 $sumkth(k)$ 表示前 $k$ 大的值. 那么只要看看<code>max</code>里面的部分是否满足四边形不等式就能证明 $r$ 对 $l$ 是否有单调性. 考虑 $w(l, r)+w(l-1, r+1)$ 与 $w(l-1, r)+w(l, r+1)$ 的大小关系. 首先等式两边包含的数的个数显然相同, 而左边的任何决策右边都可以覆盖到, 所以这里相交大于等于包含, 式子成立.</p><p>既然有决策单调性, 因为算一个决策的代价不是 $O(1)$ 所以单调栈的复杂度是2log, 而因为计算一个点的代价是不依赖于左右两边的答案的, 所以可以分治维护决策单调性做完.</p><h3 id="CTT2018旅行"><a href="#CTT2018旅行" class="headerlink" title="CTT2018旅行"></a>CTT2018旅行</h3><blockquote><p>n个点的树, 以s为根, 要把编号区间分成恰好 $k$ 段, 一个区间的得分是从 $s$ 出发的最短回路的边数, 最大化得分和 $nk\le 1e5$</p></blockquote><p>$f_{i, j}&#x3D;\max_{0\le j’\le j}{f_{i-1, j’}+w(j’+1, j)}$</p><p>首先最短回路等价于虚树边权和的二倍</p><h4 id="解法1"><a href="#解法1" class="headerlink" title="解法1:"></a>解法1:</h4><p>todo</p><h4 id="解法2"><a href="#解法2" class="headerlink" title="解法2:"></a>解法2:</h4><p>$w$ 是满足四边形不等式的, 可以分治维护决策单调性, 每次询问中点这个决策的代价.</p><p>但 $w$ 很难维护, 第一眼是 $\sqrt n\log n$ 的分块?</p><p>然而<strong>这题暴力莫队是对的</strong>, 考虑在分治过程中, 当前左右端点是分治区间, 那么现在它进入左区间的时候右端点移动到左区间右端点固定不动分治下去, 一会等算完了再移动到右区间, 那么发现这个过程里, 左右端点移动是 $1. 5$ 区间长度的, 所以总复杂度是 $n\log n$ 的. 注意这里分治区间是决策点的区间</p><p>实际实现时不用这么维护, 要求哪里时直接移动过去是不比我们上面分析的做法劣的.</p><p>启发了一种分治套莫队的方法</p><h2 id="Slope-Trick"><a href="#Slope-Trick" class="headerlink" title="Slope Trick"></a>Slope Trick</h2><h3 id="APIO2016烟火表演"><a href="#APIO2016烟火表演" class="headerlink" title="APIO2016烟火表演"></a>APIO2016烟火表演</h3><p>给一棵 $n$ 点的带权有根树, 要求给每一个边重新赋值使得根到所有叶子的路径权值和相等, 代价为新旧边权的差的绝对值, 最小化代价</p><p>记 $f_{u, x}$ 表示修改 $u$ 的子树, 使高度为 $x$ 的答案</p><p>$f_{u, x}&#x3D;\sum_{u\to v}\min_{0\le i\le x}{f_{v, x-i}+ \vert w_{u\to v}-i \vert }$</p><p>转移时先把儿子和绝对值函数做 $\min, +$ 卷积, 再加起来.</p><p>把 $f_{u, x}$ 看成关于 $x$ 的函数, 那么一开始这个函数是下凸的(叶子处 $f_0&#x3D;0, f_i&#x3D;\inf$), 运用归纳法, 若儿子都是下凸的, 那么绝对值函数显然下凸, 和下一层的函数加起来仍然是下凸, 证明了每一时刻它都是非严格下凸分段函数, 且每一时刻斜率为整数.</p><p>于是Slope Trick 维护即可.</p><p>然后这题又比较特殊使得代码很简单, 做闵和就是光让函数底部向右平移, 而不改变左边斜率(显然要让函数底部向右平移 $w$, 此时左边正好是接上了长 $w$ 的斜率为 $1$ 的线段不用处理)</p><ul><li><h3 id="ARC070ENarrowRectangles"><a href="#ARC070ENarrowRectangles" class="headerlink" title="ARC070ENarrowRectangles"></a>ARC070ENarrowRectangles</h3></li></ul><p>$f_{i, j}$ 表示前 $i$ 个区间最后一个左端点在 $j$ 的代价, 则有</p><p>$$<br>f_{i, j}&#x3D;\min_{j-a_{i-1}\le k\le j+a_i}(f_{i-1, k}+ \vert j-l_i \vert )<br>$$ </p><p>因为是平面, 所以 $j$ 是无限空间, 可以考虑继续使用刚才的Slope Trick维护, 由于是凸函数, 可以直接根据 $j$ 讨论出最小值是在 $j-a_{i-1}$ 还是在 $j+a_i$ 取得, 那么就成了简单的函数平移. 所以转移就是, 先给上一个函数加上一个绝对值函数, 再把两边向中间平移.</p><p>讲的有点快啊</p><h3 id="老鼠进洞"><a href="#老鼠进洞" class="headerlink" title="老鼠进洞"></a>老鼠进洞</h3><blockquote><p>$n$ 个球位于, 第 $i$ 个位置为 $a_i$ , $m$ 个洞, 第 $i$ 个位于 $b_i$ , 每个球往洞里走, 一个洞对应一个球, 最小化移动总距离</p></blockquote><p>模拟费用流经典为什么在动态规划里呢? 因为也可以Slope Trick.</p><h4 id="法1动态规划"><a href="#法1动态规划" class="headerlink" title="法1动态规划"></a>法1动态规划</h4><p>显然可以有他们移动路径不会交叉, 可以看成选取 $n$ 个洞按顺序一个对一个配对, 把路费算在边的左端点上.</p><p>记 $f_{i, j}$ 为扫描了前 $i$ 个左端点, 求比洞多 $j$ 个的费用:</p><p>那么因为当前球比洞多或少, 一定会有相应的球滚回来或滚过去, 那么此时经过右端点那条边的球数就是 $j$ , 所以扫到球时</p><p>$$<br>f_{i, j}&#x3D;f_{i-1, j-1}+ \vert j \vert (x_{i+1}-x_i)<br>$$ </p><p>扫到洞时 $f_{i, j}&#x3D;\min {f_{i-1, j}, f_{i-1, j+1}}+ \vert j \vert (x_{i+1}-x_i)$</p><p>仍然是下凸折线, 但此时 $\vert j \vert (x_{i+1}-x_i)$ 的斜率可能很大, 所以点要带权. 而函数变换就是遇到洞要把斜率为0的部分(函数的底)扩大一个, 平底可能会拆开支持一个 split</p><p>对于第一种转移, 相当于平移一位再加上一个绝对值函数, 问题是这里 $\vert j \vert (x_{i+1}-x_i)$ 的斜率较大, 要改为点带权, 而第二种转移仍然套路的讨论一下它的平移方向再加上一个绝对值函数.</p><h4 id="法2模拟费用流"><a href="#法2模拟费用流" class="headerlink" title="法2模拟费用流"></a>法2模拟费用流</h4><p>老鼠进洞!</p><p>建出模型是一个二分图, 左边表示球右边表示洞, 分别向源点汇点连(1, 0)的边, 中间两两连(1, 球和洞距离)的边跑费用流.</p><p>如图</p><p><img src="/img/2022-06-27-17-20-21-image.png"></p><p>左边是球, 右边是洞, 那么增加最下方的一个球&#x2F;洞时, 可能有以下几种负环和增广路:</p><ul><li>红色的增广路, 表示把一个球和最近都一个洞匹配</li><li>蓝色的负环, 表示这个球替换掉原来一个匹配的球</li><li>紫色的负环, 不会出现, 因为会只留增广那部分</li><li>绿色负环, 表示新洞替换掉一个匹配的洞</li></ul><h3 id="法3贪心"><a href="#法3贪心" class="headerlink" title="法3贪心"></a>法3贪心</h3><p>路径不会交叉, 可以划分若干个分界线, 两个分界线间的球向左向右状况相同.</p><p>设 $f_i$ 表示前 $i$ 个点正好没有都匹配了的最小总路费.</p><p>然后呢理解不能todo</p><h2 id="杂题部分"><a href="#杂题部分" class="headerlink" title="杂题部分"></a>杂题部分</h2><h3 id="莫名选物体"><a href="#莫名选物体" class="headerlink" title="莫名选物体"></a>莫名选物体</h3><blockquote><p>n个物品, 权值 $a_i, b_i &gt;0$</p><p>选择一个物品序列 $i_1. . . i_k$ , 最大化</p><p>$$<br>\sum^k_{j&#x3D;1}((j-1)a_{i_j}+b_{i_j})<br>$$ </p><p>对每个 $k$ 求最值, $n\le 3e5$</p></blockquote><p>贪心加dp</p><p>首先你把 $a$ 排序</p><p>贪心1: $k$ 从小到大的过程中, 一个东西成为最优解的一部分后不会在出来 </p><p>证明: 考虑证明每次贪心都会遇到它, todo</p><h3 id="牛逼老师题CF573E"><a href="#牛逼老师题CF573E" class="headerlink" title="牛逼老师题CF573E"></a>牛逼老师题CF573E</h3><p>todo</p><h3 id="莫名计数"><a href="#莫名计数" class="headerlink" title="莫名计数"></a>莫名计数</h3><blockquote><p>求有多少个长度为 $n$ , 值不超过 $m$ 的整数构成的序列 $a$ 满足 $a_i%a_{i+1}\ne 0$ , 对Q取模</p></blockquote><p>首先有dp, 设 $f_{i, j}$ 表示前 $i$ 个数最后一个是 $j$ 的方案数</p><p>$$<br>f_{i, j}&#x3D;\sum_{k\mod j\ne 0, k\le m}f(i-1, k)\<br>&#x3D;\sum 1\le k\le m f(i-1, k)-\sum_{k \vert j}f(i-1, k)<br>$$ </p><h3 id="乱码日文题"><a href="#乱码日文题" class="headerlink" title="乱码日文题"></a>乱码日文题</h3><blockquote><p>用 $1\times 2$ 骨牌覆盖 $H\times W$ 棋盘, 不重叠不超出, 两种方案不同当骨牌覆盖的格子集合不同. 膜998244353. $H\le 5, W\le 10^9, 2s, 1G$</p></blockquote><p>todo</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 笔记 </tag>
            
            <tag> 集训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tricks</title>
      <link href="/2022/06/15/tricks/"/>
      <url>/2022/06/15/tricks/</url>
      
        <content type="html"><![CDATA[<h1 id="记录一些技巧"><a href="#记录一些技巧" class="headerlink" title="记录一些技巧"></a>记录一些技巧</h1><h2 id="一半的半平面交"><a href="#一半的半平面交" class="headerlink" title="一半的半平面交"></a>一半的半平面交</h2><p>当求半平面交的一半(相当于求一个直线构成的下凸壳或上凸壳)时, 可以把如 $y&#x3D;kx+b$ 的直线转化成 $(a, b)$ 求凸壳</p><h2 id="长剖换根"><a href="#长剖换根" class="headerlink" title="长剖换根"></a>长剖换根</h2><p>长链剖分的换根说的是, 你做完长链剖分之后跑换根dp, 那么现在一个点有其长儿子的信息, 短儿子的信息和子树外的信息, 那么直接把所有短儿子都合并到子树外的信息上, 进入一个轻儿子的时候把自己删了, 把重儿子前 $h$ 个加入, 退出的时候撤销, 进入重儿子的时候就用全部的即可.</p><p>要求信息可合并, 可删, 且信息量是仅深度相关对.</p><h2 id="二项式系数"><a href="#二项式系数" class="headerlink" title="二项式系数"></a>二项式系数</h2><p>$$<br>\sum \binom {n}{i}^2&#x3D;\binom{2n}{n}<br>$$</p><p>证明考虑 $[x^k] (1+x)^{2k}$</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><p>模 $n$ 的环上存在排列 $p_n$ 满足 $i-p_i$ 互不相同当且仅当 $n$ 为奇数.</p><p>必要性显然.</p><p>充分性考虑率 $\sum_i i&#x3D;\sum_i i-p_i&#x3D;\sum i-\sum p_i&#x3D;0$ 即可.</p><h2 id="末尾添加删除节点的线段树动态构建"><a href="#末尾添加删除节点的线段树动态构建" class="headerlink" title="末尾添加删除节点的线段树动态构建"></a>末尾添加删除节点的线段树动态构建</h2><p>UOJ191</p><h2 id="Bitset字符串匹配"><a href="#Bitset字符串匹配" class="headerlink" title="Bitset字符串匹配"></a>Bitset字符串匹配</h2><p>抄写 <a href="https://www.cnblogs.com/alex-wei/p/bitset_yyds.html">alexwei</a></p><p>对 $s$ 和多个模式串 $t$ 求 $t$ 在 $s$ 中出现位置, 对 $s$ 维护字符集个 bitset $b_c$ 表示字符 $c$ 的出现位置, 遍历 $t$ 中的每个字符 $t_i$, 那么如果 $t$ 要在 $x$ 处结尾则 $x-\vert t\vert+i$ 位置应该是字符 $t_i$, 于是把每个 $b_{t_i}$ 左移对应位与起来即可. 复杂度是 $\dfrac{\vert s\vert \vert \sum t\vert}{w}$</p><p>为了遍历结束位置, 可以用bitset的 <code>_Find_first()</code> 和 <code>_Find_next(int x)</code> 函数 </p><h2 id="奇怪卷积"><a href="#奇怪卷积" class="headerlink" title="奇怪卷积"></a>奇怪卷积</h2><blockquote><p>给定集合的序列 $f, g$, 要求 $h_S&#x3D;\sum_T f_Sg_T2^{S\cap T}$</p></blockquote><p>考虑经典容斥 $2^{\vert S\vert}&#x3D;\sum_{T\subseteq S} 1$, 有</p><p>$$<br>\begin{gathered}<br>    h_S&#x3D;f_S\sum_T g_T\sum_{A\subseteq S, A\subseteq T}1\<br>    &#x3D;f_S\sum_{A\subseteq S} \sum_{T\supseteq A} g_S<br>\end{gathered}<br>$$</p><p>发现是对 $g$ 先做高维后缀和再做高维前缀和.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构选做</title>
      <link href="/2022/06/08/ds/"/>
      <url>/2022/06/08/ds/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构综合选做"><a href="#数据结构综合选做" class="headerlink" title="数据结构综合选做"></a>数据结构综合选做</h1><p>高妙分块都塞进<a href="/%E5%88%86%E5%9D%97%E9%80%89%E5%81%9A/">分块选做</a>了</p><h3 id="P3714-树的难题-点分治-线段树-单调队列"><a href="#P3714-树的难题-点分治-线段树-单调队列" class="headerlink" title="P3714 树的难题 [点分治] [线段树] [单调队列]"></a>P3714 树的难题 [点分治] [线段树] [单调队列]</h3><h4 id="线段树解法"><a href="#线段树解法" class="headerlink" title="线段树解法"></a>线段树解法</h4><p>用线段树维护之前的子树中, 与当前子树颜色相同和不同的情况, 把颜色排序, 可以保证先前碰到的颜色不相同后后面不会再相同, 每次到新颜色则把相同颜色插入到不相同颜色中.</p><h4 id="单调队列合并"><a href="#单调队列合并" class="headerlink" title="单调队列合并"></a>单调队列合并</h4><p>to do</p><h3 id="P3345-幻想乡战略游戏-点分树-线段树"><a href="#P3345-幻想乡战略游戏-点分树-线段树" class="headerlink" title="P3345 幻想乡战略游戏 [点分树] [线段树]"></a>P3345 幻想乡战略游戏 [点分树] [线段树]</h3><ul><li>重心的性质, 可以利用对当前答案移动一条边的方式证明答案既是全树点带权重心(边权无影响), 每次会走向自己儿子中点权和大于一半的儿子,</li></ul><h4 id="解法1-线段树"><a href="#解法1-线段树" class="headerlink" title="解法1: 线段树"></a>解法1: 线段树</h4><p>由于所有大于一半的儿子形成了由根开始的一条链可以直接在线段树中二分出重心, 问题变为求所有点到重心的距离, 设重心为u, 点到根距离为dis, 则答案为:</p><ul><li>$$ \sum dis_u+dis_v-dis_{lca(u, v)}\\&#x3D;\sum dis_u + \sum dis_v - \sum dis_{lca(u, v)}$$<br> 其中前两个式子可以直接求解, 最后一个式子则考虑首先 lca 一定在u到根的链上, 其中考虑边 e 被 dis_{lca(u, v)} 计算的次数为 e 较深端点的子树大小 (这个子树中的每个 v 都可以和 u 构成一个 lca 在e下的点对), 所以对每个点维护父边边权和子树大小的乘积, 注意这里大小都是点权和</li></ul><h4 id="解法2-动态点分治"><a href="#解法2-动态点分治" class="headerlink" title="解法2: 动态点分治"></a>解法2: 动态点分治</h4><p>to do</p><h3 id="P632-9震波-点分树"><a href="#P632-9震波-点分树" class="headerlink" title="P632 9震波 [点分树]"></a>P632 9震波 [点分树]</h3><p>每层维护两棵线段树, 下标 i 表示到父亲或当前点的距离为i的点的和, 查询从叶子出发向上跳, 算上当前层的, 容斥掉父亲的</p><h3 id="P4587神秘数-主席树"><a href="#P4587神秘数-主席树" class="headerlink" title="P4587神秘数 [主席树]"></a>P4587神秘数 [主席树]</h3><blockquote><p>一个可重复数字集合 $S$ 的神秘数定义为最小的不能被 $S$ 的子集的和表示的正整数. 例如 $S&#x3D;{1, 1, 1, 4, 13}$, 有: $1 &#x3D; 1$, $2 &#x3D; 1+1$, $3 &#x3D; 1+1+1$, $4 &#x3D; 4$, $5 &#x3D; 4+1$, $6 &#x3D; 4+1+1$, $7 &#x3D; 4+1+1+1$.</p><p>$8$ 无法表示为集合 $S$ 的子集的和, 故集合 $S$ 的神秘数为 $8$.</p><p>现给定长度为 $n$ 的<strong>正整数</strong>序列 $a$, $m$ 次询问, 每次询问包含两个参数 $l, r$, 你需要求出由 $a_l, a_{l+1}, \cdots, a_r$ 所组成的可重集合的神秘数.</p><p>对于 $100%$ 的数据点, $1\le n, m\le {10}^5$, $\sum a\le {10}^9$.</p></blockquote><p>若当前可表示的值域为 [1, x] , 升序加入值v后, 若v&gt;x+1, 则x+1一定无法表示, 答案为 x+1 , 否则答案为 x+v</p><p>发现若一个区间中数均不大于 x+1 , 则这个区间的数可以一起加进去, 答案更新为x+区间和</p><p>于是可以用线段树优化, 在值域上建线段树, 每次线段树查出所有未被加入的数中不大于 x+1 的数的和, 若为0说明无数可加, 答案为x+1, 否则把这个和加进答案, 暴力重复这个过程</p><p>对于复杂度, 设 $b_i$ 表示第 i 次的x+1, 那考虑对于得到 $b_{i+1}$ 的过程中, 由于我们加入的区间中至少有一个数, 而且这个数上次没被加入说明这个数大于 $b_{i-1}$ 所以 $b_{i+1} &#x3D; b_i + sum_i &gt; b_i + b_{i-1}$ b的增长是严格大于斐波那契的, 斐波那契增长是指数的, 所以我们最多进行 log(v) 次这个操作</p><h3 id="P4197-Peaks-Kruskal重构树-线段树合并"><a href="#P4197-Peaks-Kruskal重构树-线段树合并" class="headerlink" title="P4197 Peaks [Kruskal重构树] [线段树合并]"></a>P4197 Peaks [Kruskal重构树] [线段树合并]</h3><p>如标签, 过于模板</p><h3 id="P2839-middle-主席树"><a href="#P2839-middle-主席树" class="headerlink" title="P2839 middle [主席树]"></a>P2839 middle [主席树]</h3><p>中位数性质, 对中位数把所有大于它的设1, 小于的设-1, 答案是0, 然后主席树维护区间大于小于个数即可</p><h3 id="P6071-TreeQuery-虚树-主席树"><a href="#P6071-TreeQuery-虚树-主席树" class="headerlink" title="P6071 TreeQuery [虚树] [主席树]"></a>P6071 TreeQuery [虚树] [主席树]</h3><p>相当于p到[l, r]中点构成虚树的最短距离, 分几种情况:</p><ul><li><p>p在虚树根的子树内, 则距离为把p添加到虚树后p到其父亲的距离, 有一个结论是<strong>一个点在虚树中的父亲是该点和所有点中它dfs序的前驱或后继的lca</strong>根据这个用主席树找区间前驱后继.</p></li><li><p>p在虚树根的子树外, 此时最短路径就是它和虚树根的lca.</p></li><li><p>虚树包含p, 答案为0.</p></li></ul><h3 id="P5069-Ynoi2015-纵使日薄西山-线段树"><a href="#P5069-Ynoi2015-纵使日薄西山-线段树" class="headerlink" title="P5069 [Ynoi2015] 纵使日薄西山 [线段树]"></a>P5069 [Ynoi2015] 纵使日薄西山 [线段树]</h3><p>发现如果位置 $i$ 被操作, 那么位置 $i+1$ 和 $i-1$ 一定不会被操作, 因为它们永远不会比 $i$ 大了, 于是 $i$ 位置会被操作恰好 $a_i$ 次.</p><p>所以题目就成了给定一个序列求所有被操作位置的和.</p><p>发现合并两个区间时, 只要看左区间右端点和右区间左端点是否被选了去分类讨论, 如果都被选了就强制两个中小的那个不能选. 又因为我们会有钦定一个端点不能选的情况, 所以每个节点要记录4个情况, 分别表示是否忽略左右端点, 记录每个情况下的被操作位置和, 左&#x2F;右端点是否被选.</p><p>拿着这个去讨论, 以得到父亲是两个端点都被选的为例, 发现:</p><ul><li>若左区间右端点和右区间左端点未被同时选中, 则和可以直接相加, 左右端点是否选中直接照搬左右区间完整情况的左右端点信息.</li><li>若同时选中, 则比较两个端点谁的值更大, 若左端点的更大, 则合并左端点完整区间情况和右端点忽略左端点情况. 右端点更大的同理</li></ul><p>于是可以写出线段树的更新, 接下来可以单点修改, 区间赋值, 区间加, 区间查. . . 然而这题只要写个单点修改就行了.</p><h3 id="P5070-Ynoi2015-即便看不到未来-树状数组-性质"><a href="#P5070-Ynoi2015-即便看不到未来-树状数组-性质" class="headerlink" title="P5070 [Ynoi2015] 即便看不到未来 [树状数组] [性质]"></a>P5070 [Ynoi2015] 即便看不到未来 [树状数组] [性质]</h3><p>首先有比较明显的莫队做法, 维护一个值域数组, 在连续值域段的左右端点记录对应的另一个端点位置, 添加一个元素时像第十分块一样合并俩连续区间, 回滚</p><p>然后 $O(\sqrt n)$ 会时间炸飞, 显然 $10^6$ 次方是个单 log 做法, 3s是个大常数, 而且毒瘤肯定不会无端只问你1到10的, 一定要用这个条件</p><p>另一个维护序列区间的常用套路是右端点向右扫描数据结构维护左端点, 首先, 若记位置 $i$ 上一次出现位置为 $last_i$ , 则新增右端点 $r$ 只会影响 $(last_r, r]$ 这一个区间的左端点的答案.</p><p>然后再因为利用1-10的这个条件, 可以考虑把值在 $[a_r-10, a_r+10]$ 这个区间的数的<strong>最后一次出现位置</strong>拿出来, 按出现位置从大到小排序扫描, 取最后一个原因是这个数是否在区间 $[l, r]$ 中出现取决于 $l$ 和这个数最后一次出现的大小关系, 从右往左扫是意味着出现的值只会增加而不会减少, 可以用莫队的 $O(1)$ 维护方式.</p><p>于是相当于这21个数把 $(last_r, r]$ 区间划分成若干段, 每个段值的出现情况相同, 由于每次是算出这个区间的左端点增加了多少, 所以数据结构只要单点查和区间加, 可以用一个树状数组, 而且是对每个答案分别开一个树状数组维护.</p><p>然后你发现莫队的O(1)方式是毫无必要的, 码量大细节多, 而因为你在扫这个区间的过程中始终只计算某一时刻 $x$ 的贡献, 所以只要记两个指针表示x往上&#x2F;往下连续段最大到哪就均摊 $O(1)$ .</p><p>代码不多, 但有一堆一堆细节, 放段核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> v = a[i];  <span class="comment">//a是原数组</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec; <span class="comment">//vec是我们单独拿出来的21个数的位置</span></span><br><span class="line">    <span class="type">int</span> up = <span class="number">0</span>, down = <span class="number">0</span>; <span class="comment">//上下两个连续段的延伸长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v == a[i - <span class="number">1</span>]) &#123; <span class="comment">//对于相邻两个值相等的特殊处理,否则按照我的垃圾写法会把一个值加两遍</span></span><br><span class="line">        bs[<span class="number">1</span>].<span class="built_in">add</span>(i, <span class="number">1</span>);  <span class="comment">//bs是答案树状数组,bs[i]表示连续段长i的左端点出现次数数据结构</span></span><br><span class="line">        bs[<span class="number">1</span>].<span class="built_in">add</span>(i + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">goto</span> query;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis)); <span class="comment">//vis是这个值是否有值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">max</span>(v - <span class="number">11</span>, <span class="number">0</span>); j &lt;= v + <span class="number">11</span>; j++) &#123; <span class="comment">//对于x+10,x-10更新的时候会碰到的边界条件,所以加上11</span></span><br><span class="line">        <span class="keyword">if</span> (lastpos[j] &amp;&amp; lastpos[j] &gt; lastpos[v]) &#123; <span class="comment">//lastpos是一个值的上次出现位置</span></span><br><span class="line">            vec.<span class="built_in">push_back</span>(lastpos[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乱七八糟边界条件</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">max</span>(<span class="number">0</span>, lastpos[v])); <span class="comment">//标定了待更新左端点区间的左端点(好绕啊,就是从左往右第一个要更新的左端点)</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(i); <span class="comment">//要先把自己插入进去,相当于修改以i为左端点的答案</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; vec.<span class="built_in">size</span>() - <span class="number">1</span>; k++) &#123;</span><br><span class="line">        <span class="type">int</span> j = vec[k], jv = a[j];</span><br><span class="line">        vis[jv - v + C] = <span class="literal">true</span>; <span class="comment">//C是一个偏移,避免下标负数</span></span><br><span class="line">        <span class="keyword">for</span> (; vis[up + C + <span class="number">1</span>]; up++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="keyword">for</span> (; vis[-down + C - <span class="number">1</span>]; down++)</span><br><span class="line">            ;</span><br><span class="line">        <span class="type">int</span> len = up + down + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ml = vec[k + <span class="number">1</span>] + <span class="number">1</span>, mr = j; <span class="comment">//当前这个值的出现情况是对于区间在[ml,mr]中的左端点的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意长度区间不在1-10的不用管</span></span><br><span class="line">        <span class="keyword">if</span> (up &gt;= <span class="number">1</span> &amp;&amp; up &lt;= <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">del</span>(ml, mr, up); <span class="comment">//这个辅助函数就是bs[up]的区间删除</span></span><br><span class="line">        <span class="keyword">if</span> (down &gt;= <span class="number">1</span> &amp;&amp; down &lt;= <span class="number">10</span>)</span><br><span class="line">            <span class="built_in">del</span>(ml, mr, down);</span><br><span class="line">        <span class="keyword">if</span> (len &gt;= <span class="number">1</span> &amp;&amp; len &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            bs[len].<span class="built_in">add</span>(ml, <span class="number">1</span>);</span><br><span class="line">            bs[len].<span class="built_in">add</span>(mr + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">query:</span><br><span class="line">    <span class="keyword">for</span> (Q q : queries[i]) &#123;</span><br><span class="line">        <span class="built_in">query</span>(q.l, q.id);</span><br><span class="line">    &#125;</span><br><span class="line">    lastpos[a[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="P5354-Ynoi2017-由乃的-OJ"><a href="#P5354-Ynoi2017-由乃的-OJ" class="headerlink" title="P5354  [Ynoi2017] 由乃的 OJ"></a>P5354  [Ynoi2017] 由乃的 OJ</h3><p>大家肯定都做过那个经典的序列上全局的版本, 那么对于这个题可以相同方式考虑.</p><p>由那个题我们知道位运算每一位是独立的, 只要从高位往低位看每一位能不能是1就行了.</p><p>首先考虑序列上的区间询问, 那么容易发现可以简单线段树维护, 每个点记录在每一位1进去出来什么和0进去出来什么.</p><p>然后搬到树上可以合并方式不变的变成LCT和树剖, 此时要注意要记录两个方向(到序列上就是从左往右和从右往左)走的进出映射, 因为一条链又有向上的又有向下的.</p><p>然后被卡常了, 需要用位运算优化, 可以把每一位进去1出来什么这种压成一个int, 直接位运算, 然后就能过了.</p><p>由于合并操作比较复杂且询问的时候也要用这种合并操作, 一般就把线段树存的数据写成结构体了. 这里只放合并信息的关键代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dat是记录的信息,zero,one,rzero,rone每一位分别表示这一位正着走一开始是0,正着走一开始是1,反着走一开始是0,反着走一开始是1四种情况.</span></span><br><span class="line"><span class="function">Dat <span class="title">merge</span><span class="params">(<span class="type">const</span> Dat&amp; a, <span class="type">const</span> Dat&amp; b)</span> </span>&#123;</span><br><span class="line">    Dat ans;</span><br><span class="line">    ans.zero = (a.zero &amp; b.one) | ((~a.zero) &amp; b.zero);</span><br><span class="line">    ans.one = (a.one &amp; b.one) | ((~a.one) &amp; b.zero);</span><br><span class="line">    ans.rzero = (b.rzero &amp; a.rone) | ((~b.rzero) &amp; a.rzero);</span><br><span class="line">    ans.rone = (b.rone &amp; a.rone) | ((~b.rone) &amp; a.rzero);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树剖查询的时候注意分清向上向下的细节.</p><h3 id="P5068-Ynoi2015-我回来了"><a href="#P5068-Ynoi2015-我回来了" class="headerlink" title="P5068 [Ynoi2015] 我回来了"></a>P5068 [Ynoi2015] 我回来了</h3><p>首先显然乘上区间长度后问的就是每个 $d$ 的次数之和.</p><p>由于两个血量相同的小兵和一个是等价的, 可以把小兵按血量映射到一个数轴上.</p><p>而对于一个 $d$ , 这个答案次数就等价于把数轴分成若干长为 $d$ 的块, 求一个最长的前缀使得每一块里都至少有一个数.</p><p>考虑对于每个 $d$ , 可能的答案只有 $\frac {n} {d}$ 种, 调和级数分析一下发现, 总数是 $n \log n$ 的, 那么答案变大一, 或者说前缀向后拓展一块的次数也是 $n \log n$ 的.</p><p>于是插入一个点时, 我们要能快速找到包含一个点的区间, 并支持插入和删除区间.</p><p>一开始想了一种建出线段树, 把一个区间拆成 $\log n$ 段挂到节点上标记永久化, 发现这玩意删除是困难的</p><p>正确的做法是, 考虑开 $n$ 个 set , 第 $i$ 个里面有以 $i$ 为左端点的区间的右端点, 再开一棵线段树算区间内set里面放的右端点的最大值, 查包含 $p$ 的所有区间时只要查左端点在 $1-p$ 的最大右端点, 并把这个区间删了加新的, 不断重复这个过程, 直到右端点在 $p$ 左侧.</p><p>这样就能做了, 但还有个很厉害的离线做法.</p><p>考虑反向考虑, 要求 $[l, r]$ 的和, 可以考虑哪些小兵会贡献一个答案, 发现仍然应该转化成数轴模型, 那么算出每个块最早开始有数的时间 $t$ , 插入点 $(d, t)$ , 查询就是查时间在询问之前的并且伤害 $d\in[l, r]$ .</p><p>这是个静态二维数点, 由于有 $n \log n$ 个点所以复杂度 $n \log^2 n$ , 而每个块最早有数的时间只要先处理每个位置最早开始有数的时间就可以ST表或猫树 $n \log n$ 解决了.</p><p>写的第二种做法, 不怎么卡常, 不用快读快写不很稳, 如果放个fread&#x2F;fwrite基本就很没问题.</p><h3 id="Frog-2022一轮省集"><a href="#Frog-2022一轮省集" class="headerlink" title="Frog 2022一轮省集"></a>Frog 2022一轮省集</h3><blockquote><p>给一个序列 $a$ , 每次查询区间 $[l, r]$ 中最短的区间 $[l’, r’]$ 满足 $[l, r]$ 中出现的数都在 $[l’, r’]$ 出现.</p></blockquote><p>std:</p><p>考虑序列上扫描线扫描答案右端点, 开一个set维护所有数的最后一次出现都位置, 记 $last_i$ 表示 $i$ 的上一次出现位置, 那么对于位置 $r$ 作为右端点时, 只有询问的 $l$ 在 $(pre(last_i), last_i]$ 中时答案才可能比 $r-1$ 更优, 记这个区间为 $rg_r$ , 且这一段答案是一样的, 为 $ans_r&#x3D;r-succ(last_i)+1$ , pre表示一个数在set中的前驱. 所以我们对每个询问处理出它的 $r_0$ 表示 $r’$ 只有在 $r_0$ 右边才能包含区间中所有的数, $r_0$ 可以简单线段树求. 接下来就变成了对于一个询问 $[l, r]$ , 求 $\min_{r’&#x3D;r_0}^r ans_r’, \ s. t. \ i\in rg_r’$ , 这个可以再跑第二遍线段树扫描线解决.</p><p>zsy 吊打 std:<br>直接维护答案, 在序列上扫描线扫描询问的右端点, 开一个线段树, 维护 $r_i$ , $len_i$ , 表示以 $i$ 为答案左端点时对应答案右端点的位置和答案长度, 显然 $len_i&#x3D;r_i-i+1$ . 那么若当前位置为 $r$ , $a_r$ 上一次出现在 $a_pre$ , 则 $a_r$ , $a_pre$ 中的答案左端点对应的答案右端点一定要包含 $a_r$ 所以都设成 $a_r$ .</p><p>每次查询的时候, 查的就是区间 $\min len_i\ s. t. i\in[l_0, r]$ , 其中 $l_0$ 表示 $[l, r]$ 中最短的后缀包含其中所有元素的左端点, 或者说区间里所有数的最后一次出现位置的min, 这个可以用线段树做不影响复杂度. 也可以并查集卡个常.</p><h3 id="ZSContest5-主席树"><a href="#ZSContest5-主席树" class="headerlink" title="ZSContest5 [主席树]"></a>ZSContest5 [主席树]</h3><blockquote><p>给定一个长 $n$ 的排列, $q$ 次选定长度相同的两个区间 $a$ , $b$ , 保证第二个区间在第一个区间右侧(不相交), 询问第二个区间的重排中有多少种使得每一位都大于第一个区间对应位. $n, q\le 10^5$ . 排列逆序对数不超过 $10^5$ . 3s</p></blockquote><p>这个逆序对很突兀啊, 一看就是复杂度相关, 然而仍然不会做啊.</p><p>记 $cnt_i$ 表示 $b_i$ 大于 $a$ 中的 $cnt_i$ 个数. 答案显然为 $\prod (cnt_i-i+1)$ , 这里 $i$ 顺序任意.</p><p>那么考虑利用逆序对的条件, 两个区间形成的逆序对个数为 $\sum (m-cnt_i)\le k$ , 所以 $m-cnt_i$ 和 $cnt_i$ 只有 $\sqrt k$ 种取值, 需要相同 $cnt$ 一起计算, 由于顺序任意按照 $cnt$ 从小到大也是值从小到大计算, 那么就要支持查等于某 $cnt$ 的有多少种.</p><p>用主席树求即可. 仍然值域上建, 实现一下rank和kth即可每次动态跳不同 $cnt$</p><p>最后复杂度 $(n+q\sqrt k)\log n$ , 可能因为 $\sqrt n$ 不满能跑 $10^5$ 吧.</p><h3 id="CF639F-Bear-and-Chemistry-虚树-tarjan"><a href="#CF639F-Bear-and-Chemistry-虚树-tarjan" class="headerlink" title="CF639F Bear and Chemistry [虚树] [tarjan]"></a>CF639F Bear and Chemistry [虚树] [tarjan]</h3><blockquote><p>给定一张 $n$ 个点 $m$ 条边的初始无向图.<br>$q$ 次询问, 每次询问给定一个点集 $V$ 和边集 $E$ .<br>你需要判断, 将 $E$ 中的边加入初始无向图之后, $V$ 中任意两个点 $x$ , $y$ 是否都能<strong>在每条边至多经过一次</strong>的情况下从 $x$ 到 $y$ 再回到 $x$<br>$n, m, q, \sum \vert V\vert , \sum\vert E\vert \le 3\times 10^5$ , 强制在线.</p></blockquote><p>众所周知绕一圈回来这个相当于 $V$ 的点位于同一边双. 而 $V$ 这个询问方式让人想到虚树. . . 之类的东西.</p><p>于是显然边双缩点变成一棵树, 然后可以用NOI2021庆典的做法去求虚树用虚树上的点建图跑tarjan解决问题.</p><h3 id="NOI2020山东省队集训-Day7-货车运输"><a href="#NOI2020山东省队集训-Day7-货车运输" class="headerlink" title="[NOI2020山东省队集训 Day7]货车运输"></a>[NOI2020山东省队集训 Day7]货车运输</h3><blockquote><p>$n$ 点 $m$ 条边, $q$ 次查询任意把一条边改成 $inf$ 后, 两点之间边权最小值最大.</p><p>$n, m, q\le 3\times 10^5$</p></blockquote><p>建kruskal重构树, 二分答案, 那么相当于我们同时从起点和终点向上跳, 然后查询这两棵子树内是否有边. 这个可以直接二维数点, 或者线段树合并. 复杂度 $n\log^2 n$</p><p>考虑整体二分的思想, 离线询问后将每一轮二分的值拿出来, 从小到大排序, 并模拟kruskal的过程, 并查集维护连通性, 那么就可以知己并查集知道两棵子树是否有边了.</p><h3 id="CF983D-Arkady-and-Rectangles"><a href="#CF983D-Arkady-and-Rectangles" class="headerlink" title="CF983D Arkady and Rectangles"></a>CF983D Arkady and Rectangles</h3><blockquote><p>给定平面上 $n$ 个矩形, 标号大覆盖标号小的, 求最后平面上能看到的颜色个数.</p><p>$n\le 10^5$ , 值域 $10^9$ .</p></blockquote><p>暑假和杜赢看的ds题, 一直没记录.</p><p>rewrite 2024. 3. 1</p><p>扫描线, 区间覆盖颜色段均摊掉, 另外肯定有线段树套东西. 每个点开个set存当前节点上的颜色覆盖标记, 则一个点真实颜色是其到根的路径的set中的最大值. 颜色应该在其第一次出现时统计, 则覆盖时要知道这个颜色有没有露出来, 比较其和 当前子树内所有叶子到根路径上最大值的最小值 即可.</p><p>此外可能会若干次删除一个颜色, 会露出被覆盖的颜色, 每个颜色只有 $\log n$ 个标记, 考虑均摊的每次合并一个. 考虑维护每个set中最大的没看到的颜色 $mc$, 和子树中最大的没看到的颜色 $tc$, 则可以快速判断一个子树是否存在新颜色, 于是可以以 $\log n$ 的代价移除一个标记, 总复杂度 $n\log^2 n$</p><h3 id="P3295-SCOI2016-萌萌哒"><a href="#P3295-SCOI2016-萌萌哒" class="headerlink" title="P3295 [SCOI2016]萌萌哒"></a>P3295 [SCOI2016]萌萌哒</h3><blockquote><p>给定序列长度和限制个数, 每个限制 $(l_1, r_1, l_2, r_2)\ s. t. \ r_2-l_2&#x3D;r_1-l_1$ 表示序列 $[l_1, r_1]$ 和 $[l_2, r_2]$ 完全相同, 序列每个数都在 $[0, 9]$ 中, 求序列个数.</p><p>膜 $10^9+7$ , $n\le 10^5, m\le 10^5$ .</p></blockquote><p>同样是和杜赢看的题.</p><p>单独考虑每一位的可能, 发现我们的问题相当于区间 $l_1+i$ 对应连边 $l_2+i$ , 最后求连通块个数. 那么一个 $n^2$ 是暴力并查集.</p><p>考虑现在要优化这个暴力, 我们用st表结构把每个区间拆成2个的并, 而一个长度为 $2^k$ 的显然有可以再合并到两个长度为 $2^{k-1}$ 的.</p><p>于是我们一开始只直接合并每个区间拆出来的那两个, 再所有合并都结束之后, $k$ 从大到小遍历: 对于一个 $k$ 的一个连通块, 每一个节点拆成两部分在 $k-1$ 连成一个连通块, 就到了 $k-1$ 这一层, 发现这样做是线性的, 你就做完了.</p><p>那么这个题现在是修改 $q\alpha(n)$ , 查询 $n\log n \alpha(n)$ 的. 不能用线段树的结构因为结构不对应.</p><p>能优化的本质是我们本来连了一个稠密图, 现在从顶上一层一层向下的过程中我们保证了每次都仅连最少的边. 于是每一层的复杂度贡献都是线性的.</p><p>顺手写一发, 发现我像个智障. 码力没了.</p><h3 id="ABC238G"><a href="#ABC238G" class="headerlink" title="ABC238G"></a>ABC238G</h3><blockquote><p>给定一个序列 $a_n$ , $q$ 次判断一个区间的乘积是否是完全立方数.</p><p>忘了数据范围所以福建OI</p></blockquote><p>降智题, 和qyc一起降大智.</p><p>每个数拆成小于 $V^{\frac{1}{3}}$ 的质因数和一个质数, 那么小的直接前缀和, 大的莫队, 就是根号的.</p><p>然后发现我们是智障, 它相当于判断两个前缀的所有质因数次数膜3相同, 直接hash复杂度是 $n\log v$ 的.</p><h3 id="CF1588F-Jumping-Through-the-Array"><a href="#CF1588F-Jumping-Through-the-Array" class="headerlink" title="CF1588F Jumping Through the Array"></a>CF1588F Jumping Through the Array</h3><blockquote><p>给定 $a_n$ 和排列 $p_n$ , 对每个 $i$ 建有向边 $(i, p_i)$ , $q$ 次操作:</p><ul><li>询问 $a$ 区间和</li><li>对点 $u$ 能走到的所有点加 $x$ .</li><li>交换 $p_x$ 与 $p_y$<br>$n\le 2\times 10^5, 8s$</li></ul></blockquote><p>第一眼看成在内向基环树森林上做这个问题, 好吧其实是一堆环.</p><p>那么第三个操作会把环断开或合并, 稍微考虑一下发现断开和合并是十分”自由”的, 也就是说找不到多大性质.</p><p>$8s$ 提醒我们根号复杂度.</p><p>于是通过根号分治, 序列分块与一堆平衡树可以想到各种根号log.</p><p>考虑假设没有对环的修改, 你直接时间分块, 那么可以直接维护所有环, 加就直接加到环上, 区间和可以直接遍历被加的所有环去算对这个区间的贡献, 每根号个重构. 那现在有了对环的修改, 考虑在根号个修改的情况下, 你只切了根号刀, 所以实际上可以看成一共只有根号个点集, 那么加就直接遍历环包含的每个点集加, 询问考虑被加的每个点集的贡献, 这里不需要二分, 而是直接处理出每个数在这个块里被询问分成的根号段中的哪一段, 那么直接对每个环前缀和即可. 最后复杂度单根号.</p><p>我们糊出了不用时间分块的做法!</p><p>考虑根号分治, 那么在没有3操作的情况下, 小块加法直接暴力加到序列上, 大块加法把标记打在大块上, 那么查询的时候就查询序列上的和, 遍历每一个大环, 就行了.</p><p>现在有了合并&#x2F;分裂, 仍然根号分治, 考虑对于一个大环, 维护的结构是一个块状链表, 链表上每一块维护其在原序列上的每一块的元素个数, 及其前缀和. 于是考虑:</p><ul><li>查询<ul><li>分成整块和散块<ul><li>整块部分和遍历每一个大环的块状链表上的每一块, 就能 $O(1)$ 查询这一块其对序列上整块的和的贡献</li><li>散块部分若属于某个大环, 就直接查每个位置所属的大环的那个块的加法标记.</li></ul></li></ul></li><li>加法<ul><li>大环: 遍历大环上的每一块, 打加法标记, 复杂度根号</li><li>小环: 暴力加到序列上</li></ul></li><li>合并<ul><li>就是把两个块状链表接起来, 可能会合并块状链表上的两块, 合并是根号的.</li></ul></li><li>拆分<ul><li>把一个块状链表拆成两个, 可能会把大块中间劈开.</li></ul></li></ul><p>合并拆分都是块状链表经典操作, 不再赘述.</p><p>注意复杂度分析的时候, 块状链表的块的总个数是根号的, 因为一个大环的块状链表上小于根号的块左右必然都是大于根号的, 而小环我们不开块状链表. 所以复杂度正确.</p><h3 id="CF1746F-Kazaee"><a href="#CF1746F-Kazaee" class="headerlink" title="CF1746F Kazaee"></a>CF1746F Kazaee</h3><blockquote><p>给定 $a_n$ , $q$ 次询问区间 $l, r$ 中是否所有数都出现 $k$ 的倍数次.</p><p>$n, q\le 3\times 10^5$</p></blockquote><p>直接hash, 对于每个数进行一个随机映射, 那么如果这个区间的和不是 $k$ 的倍数就说明不是, 是的话发现有 $\dfrac{1}{k}$ 的概率错, 所以跑30遍. 复杂度2log.</p><h3 id="CF482E-ELCA"><a href="#CF482E-ELCA" class="headerlink" title="CF482E ELCA"></a>CF482E ELCA</h3><blockquote><p>给定 $T&#x3D;Tree(n)$ , 根为 $1$ , $i$ 的父亲为 $f_i$ , 点有点权 $a_i$ , $m$ 次修改, 每次单点修改或者把以 $u$ 为根的子树挂到 $B$ 上(作为儿子), 每次修改后输出任意两个点的lca的权值的期望.</p><p>$n, m\le 5\times 10^4$</p></blockquote><p>做dp的时候打错题号进来的. . .</p><p>先考虑静态怎么做, 以一个点 $u$ 为 lca 的方案数就是 ${siz_u}^2-\sum {siz_v}^2$ , $v$ 是 $u$ 的儿子. 那么子树接上去这个操作就是, 受影响的只有它到根的这条链, 看看是怎么影响的: 发现是减去 $2siz_v\cdot (siz_u-siz_w)$ , 其中 $w$ 是 $u$ 子树包含 $v$ 的儿子.</p><p>影响含有 $w$ 不好维护, 但直接重新合并可是简单的很, 但答案不能每次重新统计, 所以就再记录个 $ans$ 表示子树内所有方案的lca编号与权值的乘积的和即可. 这个题信息看看维护虚子树信息显然是免不了了.</p><h3 id="CF1550F-Jumping-Around"><a href="#CF1550F-Jumping-Around" class="headerlink" title="CF1550F Jumping Around"></a>CF1550F Jumping Around</h3><p>注意到这个玩意是可以左右跳的, 所以不能用一些简单dp.</p><p>考虑维护当前连通块, 按 $k$ 递增的顺序处理, 显然不能去尝试新点.</p><p>考虑维护每个连通块 $v$ 表示最小的 $k$ 使得其能扩张. 问题变成如何确定合并两个连通块时新的 $v$. 根本不会.</p><p>停, 注意到起点固定的, 那就只需要维护一个连通块, 那反过来对每个点维护它距离当前连通块的最小 $k$.</p><p>直接考虑函数 $f(x)$ 表示位置 $x$ 距离当前连通块的最短距离 $-d$ 后的绝对值, 那么每次加入一个点相当于把一部分减等差数列, 然后要求最小的点, 这个可以ktt冲对吧</p><p>但是注意到每次凹下去的那个线斜率绝对值都是 $1$, 相当于取min, 所以每个直接维护每个位置被取min的直线的截距的最大最小值即可.</p><p>另一个方法是求Brovka求完全图MST, 可以支持 $s$ 不一样的.</p><p>重点就在于如何求与当前点距离最近的不在连通块里的点.</p><p>一个方法是, 按照连通块编号顺序扫点, 一个点的贡献是插入几条斜率绝对值为 $1$ 的直线, 用数据结构维护, 正反扫两遍就能排除档期那连通块了.</p><h3 id="不知名典题"><a href="#不知名典题" class="headerlink" title="不知名典题."></a>不知名典题.</h3><blockquote><p>给一棵 $n$ 点树, 定义 $f(l, r)$ 表示把编号在 $[l, r]$ 之间的点连通的最小边数, 求 $\sum_{l, r}f(l, r)$</p><p>$n\le 10^5$</p></blockquote><p>考虑一条边有贡献当且仅当两边都有点, 于是统计只有一边有点的区间个数, 方式是维护子树内编号连续段并树上启发式合并, 在过程中计算即可.</p><p>启发式合并的时候如果用splay就优化到单log.</p><h3 id="GYM102586A"><a href="#GYM102586A" class="headerlink" title="GYM102586A"></a>GYM102586A</h3><blockquote><p><img src="/img/2024-05-10-18-06-25-image.png" alt="图 0"></p><p>$a$ 强制在线. $n, m\le 2\times 10^5$</p></blockquote><p>qyc的题解:</p><blockquote><p><img src="/img/2023-05-12-17-14-32-image.png" alt="picture 1"></p></blockquote><h3 id="QOJ-5098-第一代图灵机"><a href="#QOJ-5098-第一代图灵机" class="headerlink" title="QOJ #5098. 第一代图灵机"></a>QOJ #5098. 第一代图灵机</h3><blockquote><p>给定 $a_n, c_n$, $q$ 次操作, 每次单点改 $c$ 或者询问 $[l, r]$ 中没有重复颜色且数字和最大的子区间的数字和.</p><p>$n, q\le 2\times 10^5, a_i&gt;0$</p></blockquote><p>考虑没有重复颜色, 维护每个位置上一次&#x2F;下一次出现的 $lst, nxt$, 则对于每个 $i$, 答案 $[l, r]$ 不能满足 $l&lt;lst_i, r&gt;i$.</p><p>把区间表示成点画到平面上, 每个 $i$ 排除了一个左上角的2-side矩形, 于是答案是一条左上方的包络线.</p><p>考虑要能带删除插入的维护包络线, 它就是后缀min, 使用类楼房重建线段树维护即可.</p><p>线段树部分, 对每个点维护其答案, $calc(u, k)$ 定义为在 $u$ 节点右边添加一个 $k$ 后, 它的答案和最右边的点, 算它的时候如果 $k$ 比右二子最小值小就递归到左儿子, 否则就合并维护好的 $calc(lson, rson_{min})$ 递归右边.</p><h3 id="CF1712F-Triameter"><a href="#CF1712F-Triameter" class="headerlink" title="CF1712F Triameter"></a>CF1712F Triameter</h3><p>WJQ给的题</p><blockquote><p>-不是, 我是说, 我们的目标是什么?</p><p>-去整点找直径问题.</p><p>你有一棵树, 树上的每条边权值都为 $1$. 现在有若干次询问, 每次询问一个整数 $x$, 并将叶子结点全部相连上权值为 $x$ 的边(操作不会保留). 问每次操作后图的直径是多少. 图的直径定义为 $\underset{ 1 \leq u &lt; v \leq n }{ \max } d(u, v)$.</p><p>O(nq)</p></blockquote><p>容易想到对每个点 $u$ 求出最近的叶子距离 $h_u$, 设深度为 $d_u$, 于是答案是 $\max_{u, v} \min (h_u+h_v+x, d_u+d_v-2d_{\mathrm{lca}(u, v)})$.</p><p>那么启发式合并双log爆炸, fingersearch启发式合并单log常数爆炸, 长链剖分直接过了.</p><p>另一个想法是, 考虑这是最大化最小值, 转化为判定题, 那么枚举 $u$, 判定 $h_v+x+h_u\ge mid$ 的 $v$ 中是否存在 $u\to v$ 距离不小于 $mid$. 然后继续转化, 满足第一个条件的 $v$ 是按 $h_v$ 排序后的一个后缀, 那么就成了问点到区间距离最大值, 众所周知直径可以 $O(1)$ 合并, 于是上个 $O(1)$ lca.</p><h3 id="CF1303G-Sum-of-Prefix-Sums"><a href="#CF1303G-Sum-of-Prefix-Sums" class="headerlink" title="CF1303G Sum of Prefix Sums"></a>CF1303G Sum of Prefix Sums</h3><p>前缀和的和不就是数组 $\sum_i ia_i$ 吗, 那么想到点分治, 对于当前根 $u$, 处理 $f_v$ 表示 $u$ 走到根路径上 $ia_i$, $g_v$ 表示根走到 $u$ 上 $ia_i$, $s_v$ 表示权值和, $l_v$ 表示距离, 那么 $x\to y$ 就是 $f_x+g_y+l_xs_y$, 看到两个相乘, 李超树优化即可. 复杂度 $n\log^2 n$</p><h3 id="CF1446D2-Frequency-Problem-Hard-Version"><a href="#CF1446D2-Frequency-Problem-Hard-Version" class="headerlink" title="CF1446D2 Frequency Problem (Hard Version)"></a>CF1446D2 Frequency Problem (Hard Version)</h3><p>结论是, 这两个值中一定有一个是全局众数. 因为如果不是, 你一定可以扩展使得其与全局众数一样多.</p><p>于是只要求另一个数在区间中数量相等且最大, 发现最大是不必要的, 如果其中有另一个数比这个区间的全局众数和它都大, 那么全局众数就会和另一个数构成答案. 那么只要数量相等的话就很好做了吧, 对全局众数前缀和, 看到出现次数想根号分治, 大于根号的有根号个, 直接扫整个序列hash掉前缀和之差, 对于小于根号的, 枚举出现次数, 双指针看是否有另一个数达到这个次数, 每次加一个数删一个数可以用桶维护其出现次数并统计答案.</p><h3 id="CF1316F-Battalion-Strength"><a href="#CF1316F-Battalion-Strength" class="headerlink" title="CF1316F Battalion Strength"></a>CF1316F Battalion Strength</h3><p>容易想到把相邻贡献拿出来, 答案写成 $2^n \sum_{p_i&lt;p_j}p_ip_j2^{-{s_i-s_j}}$ 的形式, 其中 $s$ 是排名. 然后再拆成 $(\sum_i p_i2^{-s_i})(\sum_{j&lt;i} p_j2^{s_j})$, $j&lt;i$ 怎么办, 考虑对值域分治, 那么现在就只要维护两边这两团式子的和, 写个值域线段树即可.</p><h3 id="CF484E-Sign-on-Fence"><a href="#CF484E-Sign-on-Fence" class="headerlink" title="CF484E Sign on Fence"></a>CF484E Sign on Fence</h3><blockquote><p>给定一个长度为 $n$ 的数列, 有 $m$ 次询问要你在区间 $[l, r]$ 内选一个长度为 $k$ 的区间, 求区间最小数的最大值</p><p>$n, m\le 10^5$</p></blockquote><p>此时你应该想到二分, 把大于答案的数设为 $1$, 小于答案的数设为 $0$, 然后求区间最长连续段长度, 主席树以维护每个二分答案的值.</p><p>怎么这破ds都能降智啊.</p><h3 id="CF997E-Good-Subsegments"><a href="#CF997E-Good-Subsegments" class="headerlink" title="CF997E Good Subsegments"></a>CF997E Good Subsegments</h3><blockquote><p>给定排列 $p_n$, $q$ 次询问 $[l, r]$ 内满足值域连续的区间个数.</p><p>$n\le 1. 2\times 10^5$</p></blockquote><p>首先肯定要把值域连续换一个不这么全局而只和少数数字相关的性质:</p><p>[trick] 值域连续等价于 $max-min&#x3D;r-l$</p><p>这就好很多, 于是你开始扫描线答案区间的 $r$, 区间更新前面每个点的 $max-min+l$ 是简单的, 但是现在要求等于 $r$ 的个数? 哦你仔细想一下, 这是个排列, 保证了 $max-min\ge r-l$, 于是 $r\le max-min+l$, 就成了求最小值个数了, 要求历史和的话, 都可以写成矩阵, 复杂度1log.</p><h3 id="P4688-Ynoi2016-掉进兔子洞"><a href="#P4688-Ynoi2016-掉进兔子洞" class="headerlink" title="P4688 [Ynoi2016] 掉进兔子洞"></a>P4688 [Ynoi2016] 掉进兔子洞</h3><p>3s 1e5的数据结构有xxx, xxx和bitset(</p><p>考虑求被删掉的公共元素之和, 但这里元素出现次数取min不能直接bitset and, 离散化, 并且把值相同的元素 $a_1\ldots a_k$ 映射到 $p\ldots p+k-1$, 然后区间的bitset满足若这个值出现了 $x$ 次bitset上 $p\ldots p+x-1$ 的位置为 $1$, 这样直接与起来就是公共元素数了.</p><p>区间bitset提取上莫队是套路.</p><h3 id="P3934-Ynoi2016-炸脖龙-I"><a href="#P3934-Ynoi2016-炸脖龙-I" class="headerlink" title="P3934 [Ynoi2016] 炸脖龙 I"></a>P3934 [Ynoi2016] 炸脖龙 I</h3><p>根据扩展欧拉定理指数上是模 $\varphi(p)$ 做再可能需要加 $\varphi(p)$, 于是每递归一次 $p\to \varphi(p)$, 那么递归两次至少减半(偶数必定减半), 于是只会递归 $\log n$ 次每次暴力做就是对的.</p><h3 id="P5355-Ynoi2017-由乃的玉米田"><a href="#P5355-Ynoi2017-由乃的玉米田" class="headerlink" title="P5355 [Ynoi2017] 由乃的玉米田"></a>P5355 [Ynoi2017] 由乃的玉米田</h3><p>区间差, 和都可以bitset</p><p>区间乘积直接枚举因数</p><p>区间商考虑根号分治, 对大于根号的询问 $x$ 对每个 $a_i$ 只有 $\sqrt n$ 个可能的值和他对应直接处理, 对于小于根号的询问 $x$ 对每个 $p$ 预处理第一个 $l_p$ 表示左边第一个位置满足 $a_{l_p}$ 和 $a_p$ 的商是 $x$ 即可.</p><p>复杂度单根号加 $\dfrac{n^2}{w}$</p><h3 id="P4692-Ynoi2016-谁的梦"><a href="#P4692-Ynoi2016-谁的梦" class="headerlink" title="P4692 [Ynoi2016] 谁的梦"></a>P4692 [Ynoi2016] 谁的梦</h3><p>跟数据结构没啥关系, 算贡献秒了, 就是对每个颜色分别算贡献, 单个颜色的贡献就是随便选减去不包含, 不包含用set维护出现位置即可单log.</p><h3 id="P5062-Ynoi2014-在太阳西斜的这个世界里"><a href="#P5062-Ynoi2014-在太阳西斜的这个世界里" class="headerlink" title="P5062 [Ynoi2014] 在太阳西斜的这个世界里"></a>P5062 [Ynoi2014] 在太阳西斜的这个世界里</h3><h3 id="P9000-CEOI2022-Measures"><a href="#P9000-CEOI2022-Measures" class="headerlink" title="P9000 [CEOI2022] Measures"></a>P9000 [CEOI2022] Measures</h3><p>小清新题.</p><p>每个人从 $0$ 时刻开始方向固定且走路时间是一个前缀, 所以看出点对贡献独立, 即答案为 $\max_{i, j} (i-j)*d-\vert p_i-p_j\vert$.</p><p>线段树即可.</p><h3 id="P5064-Ynoi2014-等这场战争结束之后"><a href="#P5064-Ynoi2014-等这场战争结束之后" class="headerlink" title="P5064 [Ynoi2014] 等这场战争结束之后"></a>P5064 [Ynoi2014] 等这场战争结束之后</h3><p>可以离线显然操作树, 支持加边&#x2F;撤销&#x2F;查询连通块第 $k$ 大. 值域分块, 维护每块数的个数, 再按块维护链表存块内数, 时间空间都是 $n\sqrt n$, 容易想到的, 然后一看20MB.</p><p>打开题解, 块长40&#x2F;fn</p><p>大概因为正解是bitset, 注意要 $\dfrac{n}{w}$ 分治, 少于这个的可以直接链表存起来.</p><h3 id="P7983-JRKSJ-R3-practiceZ"><a href="#P7983-JRKSJ-R3-practiceZ" class="headerlink" title="P7983 [JRKSJ R3] practiceZ"></a>P7983 [JRKSJ R3] practiceZ</h3><p>颜色段均摊修改都可以变成区间加</p><p>对 $b$ 分块, 修改时如果我们维护了 $a$, 则对 $b$ 修改是区间加. 对 $a$ 修改时一块增加的值是 $\sum_i \sum_{j&#x3D;l}^r [b_i\ge j]x$, 维护 $b$ 的值域桶, 就成了 $\sum_i c_i\min(r-l+1, i-l+1)x$ 的值, 只需要维护 $c_i$ 和 $ic_i$ 的前缀和吧.</p><p>然后下放标记直接暴力, 散块区间加是暴力, 散块询问也是暴力. 需要一个 $O(\sqrt n)-O(1)$ 区间加区间和的分块是简单的.</p><p>这题卡空间, 要逐块处理.</p><h3 id="P6782-Ynoi2008-rplexq"><a href="#P6782-Ynoi2008-rplexq" class="headerlink" title="P6782 [Ynoi2008] rplexq"></a>P6782 [Ynoi2008] rplexq</h3><p>假设没有编号限制, 显然是 $siz_x^2-\sum_{i\in son(x)} siz_i^2$, 则满足条件下 $siz_x$ 如果单独算显然是个二维数点, 考虑对点度数根号分治, 小于的每个拆成 $\sqrt n$ 个询问, 二维数点平衡一下. 发现空间开不下, 不过对于一个 $x$ 询问的区间是连续递增的,</p><p>难点在于不能差分啊, 考虑直接对子树染色, dfs序提出来, 相当于询问区间不同数对数的典题, 莫队是 $\sqrt n n \sqrt m$ 爆炸, 爆炸在于所有这类点的儿子子树和是 $n\sqrt n$, 那如果每个都拿走前 $\sqrt n$ 大的按照上面做法跑, 分析复杂度, 就是分析 $\sqrt n$ 叉重链剖分的轻子树大小和, 显然是 $n\log_{\sqrt n} n&#x3D;O(n)$ 的, 就做完了.</p><h3 id="P7448-Ynoi2007-rdiq"><a href="#P7448-Ynoi2007-rdiq" class="headerlink" title="P7448 [Ynoi2007] rdiq"></a>P7448 [Ynoi2007] rdiq</h3><p>考虑拓展区间逆序对, 区间逆序对简单做法是二次离线莫队, 复习一下, 移动时要计算 $f(l, r, x)$, 差分成 $f(1, r, x)$ 和 $f(1, l, x)$, 其中形如 $f(1, r, r)$ 可以预处理, 形如 $(1, l, x)$ 的离线下来是 $n$ 个 $l$ 相同的 $x$ 的区间的和, 扫描线扫 $l$ 即可.</p><p>本质不同, $f(l, r, x)$ 就是和 $x$ 贡献的颜色数, 数颜色经典方法是考虑上次出现位置 $p$, 则若 $p$ 在 $l, r$ 外就查询 $f(l, r, x)$, 否则查询 $p, x$ 这个区间的贡献, 下标和值两维的4side矩形贡献不好做, 考虑离线, 扫掉一维, 差分一维, 变成 $n$ 次插入和 $n\sqrt m$ 次查询的单点插入矩形和问题.</p><p>然后上个trick: 单根号的在线二维数点, 先按大小 $n^{0. 75}\times n^{0. 75}$ 的矩形分块, $\sqrt n$ 块. 对一行($n\times n^{0. 75}$)按大小 $n^{0. 75}\times n^{0. 25}$ 的矩形分块, 是 $\sqrt n$ 个, 竖着同理. 再对剩下的 $n^{0. 5}\times n^{0. 5}$ 分块, 也是 $\sqrt n$ 块. 全都维护二维前缀和.</p><p>最后是散块, 枚举散块内的一维坐标去查对应另一维是否在范围内, 复杂度是单根号.</p><h3 id="P6019-Ynoi2010-Brodal-queue"><a href="#P6019-Ynoi2010-Brodal-queue" class="headerlink" title="P6019 [Ynoi2010] Brodal queue"></a>P6019 [Ynoi2010] Brodal queue</h3><p>首先看到这个, 一打眼肯定是要求 $\sum_i c_i^2$, $c$ 为出现次数. 那么第二步肯定是差分掉, $\sum_i (s_{i, l}-s_{i, r})^2&#x3D;\sum_i s_{i, l}^2 + \sum_i s_{i, r}^2 -2\sum_i s_{i, l}s_{i, r}$.</p><p>修改都先颜色段均摊, 也就变成一种颜色替换成另一种颜色. 分块的时候颜色段均摊好像和对只有一种颜色的块跳过做是等价的. 所以只有一个颜色的单独拿出来可以在询问的时候统计. 而现在问题就是维护整块的 $f_{l, r}&#x3D;\sum_l s_{i, l}s_{i, r}$. 总的修改一块的次数是 $O(n)$ 的.</p><p>修改第 $x$ 块的值 $k$ 增加 $v$ 次, 本来 $v$ 在 $[1, l], [1, r]$ 的出现次数分别为 $a, b$, 则对 $l, r\ge x$, $f_{l, r}&#x3D;g_{l, r}+(a+b)v+v^2$, 对 $l, r&lt;x$ 没影响, 对 $l\ge x, r&lt;x$, $g_{l, r}&#x3D;g_{l, r}+bv$. 一次修改看起来要影响 $n$ 个值肯定不行, 考虑对 $l$ 相等的记录 $av+v^2$ 的贡献, 对 $r$ 相等的记录 $bv$ 的贡献, 只需要修改 $O(\sqrt n)$ 次, 用修改 $O(1)$ 查询 $O(\sqrt n)$ 的数据结构维护即可.</p><p>散块修改暴力重构, 散块询问暴力扫描.</p><h3 id="P5063-Ynoi2014-置身天上之森"><a href="#P5063-Ynoi2014-置身天上之森" class="headerlink" title="P5063 [Ynoi2014] 置身天上之森"></a>P5063 [Ynoi2014] 置身天上之森</h3><p>考虑一棵正常的线段树, 同层的区间长度只有两种. 长度相同的节点一定不交.</p><p>于是把每个长度的节点排序分别维护, 问题变成区间加, 区间小于一个数个数, 后面这个复杂度是众所周知的 $n\sqrt {n\log n}$ 的.</p><p>然后对每个的复杂度都是这个的话, 累加一下似乎是 $\sum_{i&#x3D;0} \dfrac{n}{2^i} 2^i\sqrt {i2^i}&#x3D;n\sum_i \sqrt {i2^i}$, 注意这玩意相邻两项做比显然小于 $1&#x2F;2$, 拿等比数列放缩一下最大是 $n\sqrt {n\log n}$ 不变.</p><h3 id="P5065-Ynoi2014-不归之人与望眼欲穿的人们"><a href="#P5065-Ynoi2014-不归之人与望眼欲穿的人们" class="headerlink" title="P5065 [Ynoi2014] 不归之人与望眼欲穿的人们"></a>P5065 [Ynoi2014] 不归之人与望眼欲穿的人们</h3><p>分块, 每块从端点向内只有 $\log n$ 个 or 和变化的位置, 询问的时候块间双指针 $\sqrt n\log n$ 个位置, 块内直接维护每个长度的答案, 单点修改时要重构一块, 复杂度是 $n\sqrt n\log V$</p><p>但是这题可以 $nPoly(\log n)$, 线段树, 每个区间维护从前往后, 从后往前的 $\log V$ 个位置, 然后组合出 $\log^2 V$ 个新区间记到这个节点上, 修改时暴力更新复杂度是 $n\log n\log^2 V$, 然后为了统计答案再对每个长度开一个可删堆, 再用线段树维护这些堆堆顶的值, 查询的时候在线段树上二分. 因为有堆所以是 $n\log^2 n\log^2 V$ 了.</p><p>还有神秘的三log做法.</p><h3 id="P5066-Ynoi2014-人人本着正义之名"><a href="#P5066-Ynoi2014-人人本着正义之名" class="headerlink" title="P5066 [Ynoi2014] 人人本着正义之名"></a>P5066 [Ynoi2014] 人人本着正义之名</h3><p>好像已经成套路了, 平衡树维护连续段移动.</p><h3 id="P5067-Ynoi2014-长存不灭的过去、逐渐消逝的未来"><a href="#P5067-Ynoi2014-长存不灭的过去、逐渐消逝的未来" class="headerlink" title="P5067 [Ynoi2014] 长存不灭的过去、逐渐消逝的未来"></a>P5067 [Ynoi2014] 长存不灭的过去、逐渐消逝的未来</h3><p>对于没有括号的信息是容易合并的, 维护左右两边乘法连续段当前值, 除最左最右乘法连续段以外中间项的和即可.</p><p>考虑怎么合并信息, 对于一条分界线, 考虑跨过它匹配的若干对括号, 从深到浅依次合并, 也是能做的, 此时需要记录向左, 向右的未匹配括号位置去合并</p><p>正解是fhq treap直接维护表达式树.</p><p>tocheck</p><h3 id="P5310-Ynoi2011-遥远的过去"><a href="#P5310-Ynoi2011-遥远的过去" class="headerlink" title="P5310 [Ynoi2011] 遥远的过去"></a>P5310 [Ynoi2011] 遥远的过去</h3><p>字符串相等就是rank数组相等, 考虑对 $a$ 做滚动哈希, 平衡树&#x2F;线段树维护一下, 你发现你怎么做完了.</p><h3 id="P5311-Ynoi2011-成都七中"><a href="#P5311-Ynoi2011-成都七中" class="headerlink" title="P5311 [Ynoi2011] 成都七中"></a>P5311 [Ynoi2011] 成都七中</h3><p>考虑用点分树维护联通块, 那么对于当前询问的点 $x$, 一定存在点分树上最浅的祖先 $y$ 满足 $y\to x$ 路径完全被 $[l, r]$ 包含, 则 $x$ 所在连通块被当前子树包含且包含根节点, 这样只要考虑处理分治中心的问题, 预处理每个点 $u$ 到 $y$ 路径上最大值 $mx_u$ 和最小值 $mn_u$, 则限制是二维数颜色, 那么对一个分治中心扫描 $r$, 维护每个颜色最右出现的位置即可.</p><p>复杂度是 $n\log^2 n$</p><h3 id="P5312-Ynoi2011-竞赛实验班"><a href="#P5312-Ynoi2011-竞赛实验班" class="headerlink" title="P5312 [Ynoi2011] 竞赛实验班"></a>P5312 [Ynoi2011] 竞赛实验班</h3><p>考虑把数组分成有序部分和无序部分, 排序时把无序部分插入到有序部分就能保证复杂度, 无序部分用拆位线段树, 有序部分用01trie, 那么现在问题只有三操作可能改变有序部分的顺序, 发现若异或 $x$ 时 $x$ 第 $i$ 位是 $1$, 相当于翻转了在这一层的先后顺序, 只要记录一下有没有被翻转, 决定询问时往哪边走.</p><p>复杂度是 $n\log^2 V$</p><h3 id="P5313-Ynoi2011-WBLT"><a href="#P5313-Ynoi2011-WBLT" class="headerlink" title="P5313 [Ynoi2011] WBLT"></a>P5313 [Ynoi2011] WBLT</h3><p>要求以 $b$ 为公差的等差数列长度, 注意值域不大.</p><p>考虑bitset, 则莫队提取区间bitset, 然后每 $b$ 个一块, 从前往后与起来直到没有 $0$ 了, 复杂度是 $\dfrac{qV}{b}+n\sqrt q$</p><p>则只要考虑 $b&lt;w$ 的情况, 此时直接把 $b$ 的每个同余类开一个莫队, 仍然莫队提取区间bitset就做完了.</p><h3 id="P5314-Ynoi2011-ODT"><a href="#P5314-Ynoi2011-ODT" class="headerlink" title="P5314 [Ynoi2011] ODT"></a>P5314 [Ynoi2011] ODT</h3><p>看起来要单log啊, 然而并不是这样.</p><p>首先容易想到的做法是直接树剖, 开数据结构维护轻儿子支持单点加和查询kth, 是好做的. 复杂度是修改 $\log^2 n$ 查询 $\log n$ 的.</p><p>考虑优化, 每个点开 $b$ 个重儿子, 那么一个点到根的路径上最多有 $\log_{b+1}^n$ 个轻边, 于是复杂度是修改 $\log_{b+1}^n\log n&#x3D;\dfrac{\log^2 n}{\log b}$, 查询 $b\log n$, 平衡一下.</p><h3 id="P5524-Ynoi2012-NOIP2015-充满了希望"><a href="#P5524-Ynoi2012-NOIP2015-充满了希望" class="headerlink" title="P5524 [Ynoi2012] NOIP2015 充满了希望"></a>P5524 [Ynoi2012] NOIP2015 充满了希望</h3><p>如果只有赋值, 从大到小扫描 $l$, 维护每个查询操作的贡献, 在用线段树或ODT来找还没被赋值的查询操作, 查答案就是区间和.</p><p>发现从后往前扫的情况下, 交换两个位置的值就相当于在这两个位置上还没有被覆盖的查询操作换一下, 覆盖情况换一下, 就做完了.</p><h3 id="P5525-Ynoi2012-WC2016-充满了失望"><a href="#P5525-Ynoi2012-WC2016-充满了失望" class="headerlink" title="P5525 [Ynoi2012] WC2016 充满了失望"></a>P5525 [Ynoi2012] WC2016 充满了失望</h3><p>容易发现一个圆满足条件当且仅当它完全在凸包内. 即圆心距离任意凸包的边距离大于 $r$, 那么把圆从小到大排序, 考虑凸包不断向内收缩(每条边向内平移 $r$), 发现可能会有两边的直线把中间的干掉的情况, 于是要算两边的把中间的干掉的时间点, 此时两边的直线的交点到三条直线相等, 即角平分线交点. 现在已经有某时刻凸壳形状, 要判定圆心是否在里面怎么做? 二分处对应线段即可.</p><p>可以用并查集维护边集支持删掉一个元素, 求前驱后继.</p><h3 id="P5526-Ynoi2012-惊惶的-SCOI2016"><a href="#P5526-Ynoi2012-惊惶的-SCOI2016" class="headerlink" title="P5526 [Ynoi2012] 惊惶的 SCOI2016"></a>P5526 [Ynoi2012] 惊惶的 SCOI2016</h3><p>考虑要算一个颜色贡献相当于算不经过该颜色点对数量, 那么直接删掉这些点, 维护连通块大小平方和. lct维护树大小, 问题是改一个点可能断度数条边, 不考虑常数的话可以三度化或拆点吧, 但题解区好像都是用的把点上移到边, 特殊处理连通块根的方法.</p><p>不过先想到的是另一个东西, 考虑一个dp, 相当于每个连通块可以选两个点, 于是, $f_{u, 1&#x2F;2}$ 表示已经选了 $1&#x2F;2$ 个点的方案数, 则 $f_{u, 1}&#x3D;\sum_v f_{v, 1}+1$, $f_{u, 2}&#x3D;\sum_v f_{v, 2}+2f_{x, 1}(1+\sum_{w\ne v} f_{w, 1})+\sum_{i\ne x}\sum_{j\ne i, j\ne x} f_{i, 1}f_{j, 1}$, 那么都可以矩阵转移.</p><p>于是离线询问, 枚举颜色 $c$, 拿出所有对颜色 $c$ 的修改算即可, 全局平衡二叉树复杂度 $(n+m)\log n$.</p><p>感觉全局平衡二叉树还是leafy的比较正常.</p><h3 id="P5607-Ynoi2013-无力回天-NOI2017"><a href="#P5607-Ynoi2013-无力回天-NOI2017" class="headerlink" title="P5607 [Ynoi2013] 无力回天 NOI2017"></a>P5607 [Ynoi2013] 无力回天 NOI2017</h3><p>std的差分再 $n\log n\log^2 V$ 线段树维护线性基感觉是板子</p><p>但是怎么有逆天俩log做法&#x2F;xia todo</p><h3 id="P5612-Ynoi2013-Ynoi"><a href="#P5612-Ynoi2013-Ynoi" class="headerlink" title="P5612 [Ynoi2013] Ynoi"></a>P5612 [Ynoi2013] Ynoi</h3><p>考虑和 P5312 [Ynoi2011] 竞赛实验班 一样, 01trie维护有序段, 然后异或就是把若干层子树翻转, 记一下整体异或多少就行了吧.</p><h3 id="P5609-Ynoi2013-对数据结构的爱"><a href="#P5609-Ynoi2013-对数据结构的爱" class="headerlink" title="P5609 [Ynoi2013] 对数据结构的爱"></a>P5609 [Ynoi2013] 对数据结构的爱</h3><p>记 $x$ 经过 $[l, r]$ 出来的值为 $f_{l, r}(x)$</p><p>注意到若 $x&gt;y$, 则经过相同区间 $x$ 一定不比 $y$ 减去更少的 $p$, 于是 $f_{l, r}(x)$ 是 $r-l+1$ 段分段一次函数, 形如 $x+sum_{l, r}-kp$.</p><p>那么问题就是如何合并两个这样的一次函数 $f(x)$ 和 $g(x)$, 从小到大枚举减去几个 $k$ 确定出这个分界点所在的 $f$ 的区间, 注意到 $x$ 增加 $p$ 最多多减一个 $p$, 于是就做完了.</p><p>复杂度是 $n\log n+m\log^2 n$(求值需要二分所在段)</p><h3 id="P5611-Ynoi2013-D2T2"><a href="#P5611-Ynoi2013-D2T2" class="headerlink" title="P5611 [Ynoi2013] D2T2"></a>P5611 [Ynoi2013] D2T2</h3><p>如果没有空间限制, 考虑序列分块, 对一个块只有 $O(n)$ 种本质不同的 $L, R$ 区间, 那么维护 元素和 最大前缀&#x2F;后缀和 和 块内答案.</p><p>块内答案怎么处理? 考虑在序列维分治, 那么现在已经算出 $[l, mid]$ 和 $[mid+1, r]$ 的各 $\dfrac{len^2}{4}$ 上面四个信息, 对于 $L, R$ 的答案只要在左右两个区间中找到最大的值域区间然后合并. 复杂度是 $T(n)&#x3D;O(n^2)+2T(n&#x2F;2)&#x3D;O(n^2)$. 需要离散化端点.</p><p>散块是暴力.</p><p>现在卡空间, 只要维护这个询问的四个信息, 每次处理一块, 再把这块的信息合并上去即可.</p><h3 id="P5399-Ynoi2018-駄作"><a href="#P5399-Ynoi2018-駄作" class="headerlink" title="P5399 [Ynoi2018] 駄作"></a>P5399 [Ynoi2018] 駄作</h3><p>先拍一个topcluster树分块, 则一个邻域会被拆成若干个块内的邻域, 其中除了只有一个不以界点为中心, 把贡献分成同一块内的和跨块的:</p><p>对同一块内的, 如果两个邻域中心都是界点可以预处理, 处理就是枚举一个深度分别为 $a&lt;b$ 点对, 然后在 $(a, b)$ 处加上贡献, 再跑二维前缀和即可. 复杂度是 $n\sqrt n$. 如果有至少一个邻域中心不是界点, 这样的情况只有 $O(m)$ 次, 考虑对一个点集建虚树, 枚举另一个点集的点, 那么这个点到虚树上点的距离和是可以计算的. (每个点维护虚树上所有点到它的距离和子树里所有点到它的距离即可吧).</p><p>对不在同一块的, 考虑都需要先到自己的界点然后经过中间一段, 发现只要预处理界点邻域内所有点到界点距离和和点的个数, 设 $a$ 的答案分别为 $d_a, c_a$, 另一个界点的是 $d_b, c_b$, 那么答案是 $c_ad_b+c_bd_a+dis(a, b)c_ac_b$. 现在要一起算, 那么跑树形dp就行了.</p><p>复杂度是 $(n+m)\sqrt n$</p><h3 id="P6106-Ynoi2010-Self-Adjusting-Top-Tree"><a href="#P6106-Ynoi2010-Self-Adjusting-Top-Tree" class="headerlink" title="P6106 [Ynoi2010] Self Adjusting Top Tree"></a>P6106 [Ynoi2010] Self Adjusting Top Tree</h3><p>问题显然是可以差分的, 先变成只有右边和上边的2side矩形询问.</p><p>只考虑斜率为正的线段, 则处理右边上边2side矩形时, 完全在矩形内的线段的贡献是二维数点.</p><p>其他的线段可以分成交于右边界或交于上边界, 然后分别扫描线即可. 特殊处理同时交于右上角的.</p><p>对于斜率为负的反过来再做一遍就好了.</p><h3 id="P6108-Ynoi2009-rprsvq"><a href="#P6108-Ynoi2009-rprsvq" class="headerlink" title="P6108 [Ynoi2009] rprsvq"></a>P6108 [Ynoi2009] rprsvq</h3><p>考虑方差的式子是</p><p>$$<br>\begin{gathered}<br>    \dfrac{1}{n}\sum_i a_i^2-(\dfrac{\sum_i a_i}{n})^2<br>    &#x3D;\dfrac{n-1}{n^2}a_i^2-\dfrac{1}{n^2}\sum_{i\ne j}a_ia_j<br>\end{gathered}<br>$$</p><p>$$<br>\begin{gathered}<br>    ans&#x3D;\sum_S \dfrac{\vert S\vert-1}{\vert S\vert^2}\sum_{i\in S} a_i^2-\sum_S \dfrac{1}{\vert S\vert^2}\sum_{i, j\in S, i\ne j}a_ia_j\<br>    &#x3D;\sum_i a_i^2\sum_k \dfrac{k-1}{k^2}\binom{len-1}{k-1}+\sum_{i\ne j} a_ia_j\sum_k \binom{len-2}{k-2}\dfrac{1}{k^2}\<br>    \because (k-1)\binom{len-1}{k-1}&#x3D;(len-1)\binom{len-2}{k-2}\<br>    \therefore ans&#x3D;((len-1)\sum_i a_i^2+\sum_{i\ne j} a_ia_j)\sum_k \binom{len-2}{k-2}\dfrac{1}{k^2}<br>\end{gathered}<br>$$</p><p>现在只要能对每个 $n$ 求</p><p>$$<br>\sum_{k&#x3D;0}^n \binom{n}{k}\dfrac{1}{(k+2)^2}<br>$$</p><p>考虑 $\sum_k \dfrac{1}{(k+2)^2}x^k&#x3D;\dfrac{1}{x^2}\int\dfrac{1}{x}\int x\dfrac{1}{1-x}$ 怎么积不出来</p><p>直接NTT吧.</p><h3 id="P6107-Ynoi2010-Worst-Case-Top-Tree"><a href="#P6107-Ynoi2010-Worst-Case-Top-Tree" class="headerlink" title="P6107 [Ynoi2010] Worst Case Top Tree"></a>P6107 [Ynoi2010] Worst Case Top Tree</h3><p>看到这个连边条件想到建出大根笛卡尔树, 发现连到往上走左边&#x2F;右边第一个祖先, 相当于当前区间向左右扩展得到.</p><p>[conclusion] 完全想不到, 结论是, 树上任意四个点组成的连通块, 以及连通块的根向上连的点, 构成六元环.</p><p>对连通块分类讨论证明是容易的.</p><p>然后再考虑修改, 把一个数变大在笛卡尔树结构上相当于不断上旋直到它小于父亲, 发现一段连续的左右链只会改变 $O(1)$ 条边, 修改 $O(1)$ 的信息, 那么考虑左右链切换次数, 发现经过一段连续左右左右这样的切换后, 会把所有左链放在一边, 所有右链放在一边, 于是若一个切换所在的链的长度每次变成一半, 总切换次数是 $(n+q)\log n$ 的.</p><p>[trick] 结论: $n$ 个点的树, 每次把一个点上旋到一个位置, 经过左链&#x2F;右链切换次数是 $(n+q)\log n$.</p><h3 id="P6778-Ynoi2009-rpdq"><a href="#P6778-Ynoi2009-rpdq" class="headerlink" title="P6778 [Ynoi2009] rpdq"></a>P6778 [Ynoi2009] rpdq</h3><p>点分治, 则对每个分治中心求 $\sum_{i\ne j} s_i(tot-c_i)$, $s_i, c_i$ 表示子树 $i$ 在 $[l, r]$ 内点的深度和, 个数.</p><p>这么做肯定不行, 考虑点分治分块, 即点分树大小大于等于 $B$ 的子树分一块, 注意要三度化保证每个块大小在 $B\ldots 2B$ 之间.</p><p>每次询问块间可以用上面的方法枚举每一块算一个 $n$ 个点, $\dfrac{nq}{B}$ 次询问的二维数点, 块内直接枚举点对是 $\dfrac{n}{B} \cdot B^2$ 个点, $q$ 次询问的二维数点, 分别平衡一下就好了.</p><p>另一个做法是莫队, 二次离线后是 $n$ 次加点 $n\sqrt n$ 次查询当前集合内的所有点到一个点的距离, 考虑topcluster分块, 每个块维护这个块内的在集合内的点到所有其他簇的界点的距离, 到块内每个点的距离. 那么询问是 $O(1)$, 加入一个点时块内可以一遍换根dp块间暴力更新.</p><p>额, 其实这里有个经典转化, $\sum_{u\in S} dis(u, v)&#x3D;\sum_{u\in S} dep_u+dep_v+\sum_{u\in S}-2dep_{lca(u, v)}$, 二后面这部分是经典的:</p><p>[trick] 将 $S$ 中的点到根的路径上加上父边边权, $u$ 到根的路径和即是 $\sum_{u\in S} dep_{lca(u, v)}$.</p><p>然后后面一样二次离线或点分治分块.</p><h3 id="P4118-Ynoi2018-末日时在做什么-有没有空-可以来拯救吗"><a href="#P4118-Ynoi2018-末日时在做什么-有没有空-可以来拯救吗" class="headerlink" title="P4118 [Ynoi2018] 末日时在做什么? 有没有空? 可以来拯救吗?"></a>P4118 [Ynoi2018] 末日时在做什么? 有没有空? 可以来拯救吗?</h3><p>序列分块, 考虑块间答案肯定是要前缀和max, 后缀和max, 块内总和, 设块被整体加了 $x$, 则前两个显然是 $x$ 的分段下凸一次函数, 要维护它们的凸包. 每次查询的时候在凸包上二分, 散块修改时分治再合并凸包, 复杂度是 $n\sqrt n\log n$. 现在要去掉 $\log n$</p><p>先考虑散块怎么办, 不能每次都重头建线段树. 被区间加后拆到 $\log n$ 个节点上, 那么往上合并这 $\log n$ 个节点复杂度是线性的, 这些节点上打上标记就行了.</p><p>然后查询的时候需要在凸包上二分, 考虑逐块处理, 则可以把相邻两个散块修改之间的部分拿出来离线, 使得每次只加正数, 这样指针单调移动复杂度就线性了. 这个排序要卡大常鸡排.</p><p>题解区好像维护的凸包下标是区间长度? 感觉维护加了多少能简单点?</p><h3 id="P6779-Ynoi2009-rla1rmdq"><a href="#P6779-Ynoi2009-rla1rmdq" class="headerlink" title="P6779 [Ynoi2009] rla1rmdq"></a>P6779 [Ynoi2009] rla1rmdq</h3><p>相当于一个序列每个位置时一个指针指向数上一个点, 每次让指针指向父亲或者查询深度最小值.</p><p>考虑序列分块, 对于一块的指针不断向上跳的过程中若存在某时刻两个指针有祖先关系则深的那个一定没用了, 那么也可以认为, 当一个指针在另一个指针曾经存在的位置时这个指针就没用了, 即树上每个点只会被指针覆盖一次, 那么做法就简单了, 每个块维护到现在还有用的指针, 维护所有点是否被经过的标记, 维护懒标记应该被加了多少, 维护这个块的答案. 区间修改时修改懒标记, 让有用的指针往上跳并更新答案, 标记经过的点然后可能从有用指针集合中删去一些.</p><p>散块修改&#x2F;查询暴力下传懒标记(树剖即可, 每个点总共往上只会跳 $\log n$ 条重链复杂度正确), 然后暴力统计答案&#x2F;重建.</p><p>为了卡空间逐块处理.</p><p>复杂度 $n\sqrt n$.</p><h3 id="P6780-Ynoi2009-pmrllcsrms"><a href="#P6780-Ynoi2009-pmrllcsrms" class="headerlink" title="P6780 [Ynoi2009] pmrllcsrms"></a>P6780 [Ynoi2009] pmrllcsrms</h3><p>注意 $c$ 是固定的, 按照 $c$ 分块. 询问只有一块内和两块之间的.</p><p>对于一块内的直接就做完了. 对于两块之间的, 设左边块长 $i$ 的后缀和为 $l_i$, 右边块长 $i$ 的前缀和为 $r_i$, 就要求 $\max_{i+j\l. e c} l_i+r_j$.</p><p>考虑这个范围画到平面上是一个三角形内的区域, 那么分治, 拿出中间 $\dfrac{c}{2}\times \dfrac{c}{2}$ 的一个正方形, 会递归到两个小三角形. 因为有修改还多测对这个建线段树, 维护节点(三角形)范围内的答案其中 $s_l, s_r$ 的最大值即可合并.</p><p>修改一块时只影响前后两个块间和自己块内, 然后更新答案, 还需要拿个线段树维护全局答案. 复杂度 $m\log n$.</p><h3 id="P6781-Ynoi2008-rupq"><a href="#P6781-Ynoi2008-rupq" class="headerlink" title="P6781 [Ynoi2008] rupq"></a>P6781 [Ynoi2008] rupq</h3><p>容易想到括号匹配完了一定是剩下若干个右括号紧接着若干个左括号, 考虑如果没有 $3$ 操作就直接线段树, 维护每个节点左右括号部分分别信息, 合并的时候左边左部和右边右部不用变, 中间的一定是一边剩下了若干个, 也就是求线段树区间的左部&#x2F;右部的一个后缀的信息, 递归下去即可.</p><p>复杂度是 $n\log n+m\log^2 n$.</p><h3 id="P6783-Ynoi2008-rrusq"><a href="#P6783-Ynoi2008-rrusq" class="headerlink" title="P6783 [Ynoi2008] rrusq"></a>P6783 [Ynoi2008] rrusq</h3><p>扫描线扫右端点, 维护每个点最后一次被覆盖时间, 那么就是矩形内点赋值, 全局小于 $x$ 的数的权值和.</p><p>那么建KDT, 开一个 $O(1)-O(n^\epsilon)$ 单点改区间和分块维护覆盖时间为 $i$ 处的点的权值和, 矩形赋值时打标记并回收子树内所有标记, 可以在回收&#x2F;打标记时去修改分块. 则标记一共打了 $n\sqrt n$ 个(KDT复杂度), 回收复杂度相同.</p><p>另一个考虑, 把点按 $x$ 排序分块, 块内按纵坐标排序, 散块重构整块操作用颜色段均摊, 那么一开始有 $O(n)$ 段, 每次操作增加 $O(\sqrt n)$ 段(散块), 操作次数是对的但是时间复杂度多log.</p><p>KDT那个东西可以认为实现了二维颜色段均摊吧.</p><h3 id="P7124-Ynoi2008-stcm"><a href="#P7124-Ynoi2008-stcm" class="headerlink" title="P7124 [Ynoi2008] stcm"></a>P7124 [Ynoi2008] stcm</h3><p>直接照着 换根重剖&#x2F;长剖 的思路编.</p><p>考虑树剖, 有经典结论所有轻子树大小之和是 $n\log n$, 那么直接加入所有轻子树递归重儿子, 然后加入重儿子处理轻儿子, 则考虑缺一分治, 但这样复杂度是俩log. 但注意按照子树大小建哈夫曼树, 然后用缺一思路(进入一个子树的时候加入另一个子树的)复杂度就是单 $\log n$ 了.</p><p>但是重剖再建哈夫曼树就是静态toptree把rake tree建出来了吧.</p><h3 id="P8511-Ynoi-Easy-Round-2021-TEST-68"><a href="#P8511-Ynoi-Easy-Round-2021-TEST-68" class="headerlink" title="P8511 [Ynoi Easy Round 2021] TEST_68"></a>P8511 [Ynoi Easy Round 2021] TEST_68</h3><p>考虑全局最大值是 $a_x\operatorname{xor} a_y$, 则 $x, y$ 到根链上以外的点答案全都有了. 只要求两条链上的, 考虑对 $x$ 那条链的直接dfs+01trie, 每个点只被加一次, 就做完了.</p><h3 id="P7126-Ynoi2008-rdCcot"><a href="#P7126-Ynoi2008-rdCcot" class="headerlink" title="P7126 [Ynoi2008] rdCcot"></a>P7126 [Ynoi2008] rdCcot</h3><p>对于这种数某种条件连通块的题,考虑构造有限信息,我们钦定一个连通块里点的大小关系,只数每个连通块中最小的点.记对$u$在这个大小关系中小于$v$记为$u&lt;&lt;v$.</p><p>我们希望若$u\ \text{is connected with}\ v$,则$u\to v$可以只经过$u&lt;&lt;w&lt;&lt;v$的$w$.这个目的是,一个点是代表元$u$只要求不存在$v&lt;&lt;u$与$u$连通.等价于对$u&lt;&lt;v&lt;&lt;w$,若$u\leftrightarrow w,v\leftrightarrow w$则$u\leftrightarrow v$</p><p>这样对点$u$找到$l_u&lt;u,l_u&lt;&lt;u,l_u\ \text{is connected with}\ u$和$r_u&lt;u,r_u&lt;&lt;u,r_u\ \text{is connected with}\ u$,则只有包含$u$不包含$l_u,r_u$的点可以贡献,简单数点.</p><p>考虑如何构造偏序信息,发现 深度 是一个,在深度相同的情况下任意偏序信息好像都行,比如我们选择编号. 或者很难注意到<strong>直接把bfs序作为偏序信息</strong>也是对的.</p><p>然后就要看怎么求$l_u,r_u$,只考虑$l_u$,点分治,对一个分治中心处理出每个点的距离$d_u$,按照点原树深度从小到大加点,就要查$d_u\le x$的编号前驱后继,在平衡树上二分即可.</p><h3 id="P7446-Ynoi2007-rfplca"><a href="#P7446-Ynoi2007-rfplca" class="headerlink" title="P7446 [Ynoi2007] rfplca"></a>P7446 [Ynoi2007] rfplca</h3><p>分块,每次都是往前跳,查询$u,v$时那么从后往前枚举块,查$u,v$进入这个块时是否到了同一个点,如果是那么找到$u$上一次出现的块和$v$上一次出现的块,记这两个块里第一次出现位置分别是$u’,v’$,显然$u’,v’$暴力跳是$O(\sqrt n)$的.</p><p>要支持区间减,查一个位置跳出这个块会到哪,以及一个点跳一步到哪.于是维护减法标记,最后两个点暴力跳时只经过$1$个块.</p><p>设$i$跳出一个块时会到$p_i$,那么重构一块时从前往后扫一遍就能求,区间减$x$时,设这块为$[l,r]$:对$a_i&lt;l$是$p_i\gets p_i-x$,对剩下的点我们不会做,但注意到一个点最多减$\sqrt n$次就变成第一类点,所以如果存在剩下的点直接暴力重构复杂度就对的.</p><p>最后是$n\sqrt n$</p><h3 id="P7897-Ynoi2006-spxmcq"><a href="#P7897-Ynoi2006-spxmcq" class="headerlink" title="P7897 [Ynoi2006] spxmcq"></a>P7897 [Ynoi2006] spxmcq</h3><p>这是区间最大子段和上树啊.</p><p>考虑一个点的答案凸包,设$f_u(x)$表示了$u$子树内加$x$后最大与$u$连通的连通块权值,则$f_u(x)&#x3D;val_u+x+\sum_{v\in son_u} \max(f_v(x),0)$.</p><p>对$f$的合并只需要支持加法(所有函数都是非负的不会有和$0$取max),维护差分即可吧.</p><p>或者维护$f_u(x)$表示$u$子树内大小为$x$的连通块,与$u$连通的,最大权值,$g$表示不要求连通的.$f_u$是$(max,+)$卷积,用平衡树维护差分是不是就行了.</p><p>复杂度$O(n\log n)$</p><h3 id="P7721-Ynoi2007-rvrewsus"><a href="#P7721-Ynoi2007-rvrewsus" class="headerlink" title="P7721 [Ynoi2007] rvrewsus"></a>P7721 [Ynoi2007] rvrewsus</h3><p>显然$r(k)$是第$k$小的数值(即相同的算一个).</p><p>信息在值域维可合并,值域分块,对每个块内分治,注意长$l$的根号,设要算$[l,r]$的$O((r-l)^2)$个信息(有$r-l+1$个点,那么只有$(r-l+1)^2$个本质不同区间),那么递归算$[l,mid]$和$[mid+1,r]$的信息,然后暴力合并,复杂度就是$O(n)$的.总复杂度是$n\sqrt n$.</p><p>然后因为有重复的数所以要处理一些细节,比如要按照数的出现次数和分块,有些数次数超过$\sqrt n$的要拿出来单独做,在递归$[l,r]$的时候找不到好的$mid$,只能变成递归到 $[l,mid)$,$mid$,$(mid,r]$三部分同事保证两边部分都小于一半.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 虚树 </tag>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串题目选做</title>
      <link href="/2022/06/08/sam/"/>
      <url>/2022/06/08/sam/</url>
      
        <content type="html"><![CDATA[<h1 id="SAM字符串题目选做"><a href="#SAM字符串题目选做" class="headerlink" title="SAM字符串题目选做"></a><del>SAM</del>字符串题目选做</h1><p>~~这类题好多也可以用后缀数组和后缀平衡树, 但我还是热爱SAM. ~~</p><p>一开始是SAM题目选做, 现在也会加入部分其他字符串.</p><h3 id="P4022-熟悉的文章-SAM-dp"><a href="#P4022-熟悉的文章-SAM-dp" class="headerlink" title="P4022 熟悉的文章 [SAM] [dp]"></a>P4022 熟悉的文章 [SAM] [dp]</h3><blockquote><p>给定01串标准文章, 定义一个01串是熟悉的当且仅当长度大于 $L$ 且z在标准文章中出现过. 现 $q$ 次给定询问串 $T$ , 求最大的 $L$ 使得可以把 $T$ 分成若干段, 其中有90%以上是熟悉的.</p><p>输入文件小于1100000Byte.</p></blockquote><p>对于一篇作文, 可以求出每个点向前最多匹配多长还在标准作文库中(zsy数组), 这里前是指向下标小的方向(似乎对于序列, 前和后会产生歧义) 把这个长度记为 $len_i$ , 方法:</p><ul><li><p>建出包含所有作文库作文的SAM.</p></li><li><p>初始匹配长度为0, p 借点在根, 每次若能匹配沿自动机边向前走, 否则跳parent tree, 注意向前匹配时匹配长度不能直接用 p 点 sam 节点的len值, 但跳parent tree树时可以.</p></li></ul><p>-<strong>qyc: 这里暴力跳parent tree是对的因为跳一步深度减一, 匹配一个深度加一, 所以总复杂度O(n)</strong></p><p>然后考虑二分答案, 对于每一个答案, 进行判断, 方法:</p><ul><li><p>$f_i$ 表示 考虑前 i 位时, 最多能有多少位是熟悉的, 转移就是考虑前面匹配到哪里 $f_i &#x3D; \max_j {f_j + i - j }, s. t. \ j \in [i-len_i, i-l]$ .</p></li><li><p>这样做是 $O(n^2)$ 的, 发现可以进行简单单调队列优化, 总复杂度 $O(n\log n)$ </p></li><li><p>最后判断熟悉的位数是否多于90%.</p></li></ul><h3 id="P6640-封印-SAM-二分答案"><a href="#P6640-封印-SAM-二分答案" class="headerlink" title="P6640 封印 [SAM] [二分答案]"></a>P6640 封印 [SAM] [二分答案]</h3><blockquote><p>给出只包含小写字母 $a, b$ 的两个字符串 $s, t$ , $q$ 次询问, 每次询问 $s[l \dots r]$ 和 $t$ 的最长公共子串长度.</p><p>$\vert s \vert , \vert t \vert \le 2\times 10^5, q\le 2\times 10^5$ </p></blockquote><p>向熟悉的文章一样, 可以先求出s中每个点向前匹配多长还在t中, 二分答案, 若当前答案为x, 询问为 l, r , 则只要判断 $\min {len[l+x-1, r]}$ 这段区间的最大值是否不小于x即可, 于是你需要一个静态RMQ, 为了不写成2log, 于是学了猫树.</p><p>猫树要注意:</p><ul><li><p>补成完全二叉树时(即要把 $n$ 弄成2的倍数)才满足叶子lca为叶子编号的lcp.</p></li><li><p>只要求出lca在第几层, 设编号为x和y, 则层数为 $\lg{x}-\lg{x \mathrm {xor} y}$ .</p></li></ul><h3 id="P4094-字符串-SAM-线段树合并-二分答案"><a href="#P4094-字符串-SAM-线段树合并-二分答案" class="headerlink" title="P4094 字符串 [SAM] [线段树合并] [二分答案]"></a>P4094 字符串 [SAM] [线段树合并] [二分答案]</h3><blockquote><p>给定字符串 $s$ , $q$ 次询问区间 $[a, b]$ 中的所有子串与 $[c, d]$ 的最长公共前缀长度.<br>$\vert s \vert , q\le 2\times 10^5$ </p></blockquote><p>二分答案, 对于一个答案x, 从s[1. . d]跳parent tree到最后一个长度大于x的节点, 看这个节点的endpos是否有在[a+len-1, b]之间的, 所以用线段树合并维护endpos, 复杂度 $O(n\log^2n)$ </p><h3 id="P4770-NOI2018-你的名字-SAM-线段树合并-区间SAM"><a href="#P4770-NOI2018-你的名字-SAM-线段树合并-区间SAM" class="headerlink" title="P4770 NOI2018 你的名字 [SAM] [线段树合并] [区间SAM]"></a>P4770 NOI2018 你的名字 [SAM] [线段树合并] [区间SAM]</h3><blockquote><p>给一个串 $S$ , $q$ 次询问在 $T$ 中但不在串 $S$ 的区间 $[l, r]$ 中的本质不同子串个数. $\vert S \vert \le 5\times 10^5, \sum  \vert T \vert  \le 10^6$ .</p></blockquote><p>首先考虑询问 $S$ 整串与 $T$ 的答案的情况, 此时可以对 $S$ 和 $T$ 建SAM. 同时容易想到容斥成在 $T$ 的本质不同子串数减去同时在 $S$ 和 $T$ 中出现的本质不同子串数.</p><p>同时出现的子串数有经典做法广义SAM, 但因为多次询问死了, 要让复杂度关于 $\vert T \vert$ 而不是 $\vert S \vert$ .</p><p>考虑拓展本质不同子串数的办法, 我们求和了所有 $T$ 的SAM节点代表的子串个数 $len-father. len$ , 那么求和 $\min(lim, len)-father. len$ 就是共同出现的, 其中 $lim$ 表示这个节点代表的子串中所有在 $S$ 中的长度最大值 . 然后你发现根本不用容斥, 直接求和 $\max(0, len-\max(father. len, lim))$ 就行了. 能想到这个 $lim$ 大概是因为它和封印, 熟悉的文章的zsy数组类似. 那么考虑求 $lim$ , zsy数组求法是成熟的, 由于对于一个点表示的所有串情况是相同的, 所以 $lim$ 可以取第一次出现位置的zsy数组值.</p><p>这样做复杂度就只根 $\vert T \vert$ 相关了. 复杂度 $\vert S \vert +\sum \vert T \vert$ 考虑如何再拓展到区间上.</p><p>考虑我们对于 $S$ 的SAM要支持在区间意义下:</p><ul><li><p>跳parent tree</p></li><li><p>查转移边</p></li><li><p>查 $len$</p></li></ul><p>于是思考SAM的节点定义, 压缩的是全串信息的情况下, 一定保留了区间的所有信息, 唯一不同是可能压缩不彻底. 于是想到利用全局的SAM实现区间信息:</p><ul><li><p>parent tree可以直接用全局的, 因为在全局上的父亲一定是区间上的祖先, 区别仅在于在区间意义下endpos从真包含变成可能相等.</p></li><li><p>转移边也可以用全局的, 但有可能转移到的其实在外面, 要判断转移到的是否在区间里.</p></li><li><p>$len$ 也可以用全局的, 但有可能这个节点代表的最长串延伸出区间.</p></li></ul><p>而线段树合并维护 $endpos$ 是众所周知的, 于是实现就是, 在S的SAM上线段树合并, 然后我们代码类似于:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">p = s_sam.root;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s_sam.ns[p].nxt[t[i]] &amp;&amp; segs[roots[s_sam.ns[p].nxt[t[i]]]].<span class="built_in">query</span>(<span class="number">1</span>, n, sl + len, sr)) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = s_sam.ns[p].nxt[t[i]];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!len)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">if</span> (len == s_sam.ns[s_sam.ns[p].link].len)</span><br><span class="line">            p = s_sam.ns[p].link;</span><br><span class="line">    &#125;</span><br><span class="line">    lens[i] = len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要点: 有可能一个节点最长的子串在区间外而较短的在区间内, 而我们线段树判断 $endpos$ 的时候需要长度作为参数, 所以当不匹配时要把已经匹配的长度一个一个一个变短, 直到长度变成父亲的长度再跳parent tree而不能直接跳.</p><p>最后就冲代码吧. 建议把SAM封装一下 $S$ 和 $T$ 可以共用. 然后线段树合并的时候可以只在非叶子且儿子都不为空的情况下新建节点.</p><h3 id="CF119D-String-Transformation-exkmp"><a href="#CF119D-String-Transformation-exkmp" class="headerlink" title="CF119D String Transformation [exkmp]"></a>CF119D String Transformation [exkmp]</h3><blockquote><p>给两个字符串 $a, b$ , 定义 $r(s)$ 表示串 $s$ 的逆序串, 求 $i, j$ 使得 $a_{i+1\ldots j-1}+r(a_{j\ldots \vert s \vert})+r(a_{1\ldots i})&#x3D;b$<br>$\vert a\vert, \vert b\vert \le 10^6, \vert \sigma\vert \le 94$</p></blockquote><p>不会Z函数, 死了死了. 哦实际上是个简单题啊.</p><p>就是你确定了 $i$ 之后, 变成了切成两段, 然后判断是否能匹配, 就是求 $a, b$ 两个前&#x2F;后缀的匹配长度, 用z函数处理然后直接判断.</p><h3 id="CF123D-String-SAM"><a href="#CF123D-String-SAM" class="headerlink" title="CF123D String [SAM]"></a>CF123D String [SAM]</h3><blockquote><p>给出字符串 $s$ , 定义子串 $a$ 在 $s$ 中的出现次数为 $cnt(a)$ , 求 $\sum \frac{cnt(a)(cnt(a)+1)}{2}$ .<br>$\vert s\vert \le 10^5$</p></blockquote><p>直接SAM</p><h3 id="CF235C-Cyclical-Quest-SAM"><a href="#CF235C-Cyclical-Quest-SAM" class="headerlink" title="CF235C Cyclical Quest [SAM]"></a>CF235C Cyclical Quest [SAM]</h3><blockquote><p>给定一个主串 $s$ 和 $n$ 个询问串, 求每个询问串的所有循环同构在主串中出现的次数总和.</p><p>$n\le 10^5$ , $\vert s \vert \le 10^6$</p></blockquote><p>如果一个题是 SAM, 但不是直接 SAM, 那就是在 SAM 上跑匹配</p><p>考虑把一个询问串 $t$ 的复制一倍在 SAM 上跑匹配, 那么如果当前匹配长度大于 $\vert t \vert$ , 就可以加上这个SAM上节点的出现次数.</p><p>然后一个问题是可能 $t$ 的不同循环同构可能相等, 那么一个方法是用 KMP 跑出它的周期, 另一个做法是直接在 SAM 上经过的节点打标记, 就结束了</p><h3 id="记录广义SAM的特判"><a href="#记录广义SAM的特判" class="headerlink" title="记录广义SAM的特判"></a>记录广义SAM的特判</h3><p>好像已经广为人知了, 我比较致远星.</p><p>本来写法是直接每次插入一个串之后 $last$ 指向 $root$ .</p><p>rewrite 2024. 3. 1</p><p>出现问题的情况是, 我们要插入一个字符时 $last已经有对应字符的出边:</p><ul><li>如果出边指向的等价类长度和$ last $长度差$ 1 $, 那么它就是我们要建的点, 此时返回它即可.</li><li>如果出边指向的等价类长度不对, 那么应该把它分裂.</li></ul><p>而离线建法中, 容易发现bfs保证了不会有出边(没有插入过包含当前前缀的字符), dfs保证了不会有长度差$ 1 $的出边.</p><h3 id="P7114-NOIP2020-字符串匹配"><a href="#P7114-NOIP2020-字符串匹配" class="headerlink" title="P7114 [NOIP2020] 字符串匹配"></a>P7114 [NOIP2020] 字符串匹配</h3><p>复习KMP, 发现这个题还没补.</p><blockquote><p>给定$ s $, 求把$ s $划分成$(ab)\cdot x+c, x\ge 1 $的方案数, 定义乘法是重复若干次, 加法是拼接, 并要求$ a $中出现奇数次的字符数少于$ c $.</p><p>$ n\le 2^{20} $</p></blockquote><p>看起来最性质的当然是$ s&#x3D;ab $, 枚举它, 再调和级数的枚举个$ i $, 也就确定了$ c $, 问题就成了前$ i $个前缀有多少个出现奇数次字符少于$ c $的, 需要$ O(1)$, 考虑$ s $是从前往后, 每往后一位暴力改前缀和, 复杂度$ 26n+n\ln n $, 哈希被卡常了(取模), kmp还是没问题的.</p><p>本机比luogu慢了一倍.</p><h3 id="P2444-POI2000-病毒"><a href="#P2444-POI2000-病毒" class="headerlink" title="P2444 [POI2000] 病毒"></a>P2444 [POI2000] 病毒</h3><p>建出一张图, 节点表示状态, 边表示走字符$ 0&#x2F;1 $到达哪个点, 至于状态是什么可以直接上AC自动机, 其中的点就是状态.</p><p>用SAM真是愚蠢的决定, 因为标记合法状态是困难的.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> SAM </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络流题目选做</title>
      <link href="/2022/06/08/flow/"/>
      <url>/2022/06/08/flow/</url>
      
        <content type="html"><![CDATA[<h1 id="网络流选做"><a href="#网络流选做" class="headerlink" title="网络流选做"></a>网络流选做</h1><p>建图套路深</p><p>费用流边的描述用 $u \stackrel{f, c}{\longrightarrow} v$ , $f, c$ 分别是流量和费用.</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="P5458-水晶-网络流-最小割"><a href="#P5458-水晶-网络流-最小割" class="headerlink" title="P5458 水晶 [网络流] [最小割]"></a>P5458 水晶 [网络流] [最小割]</h3><p>对于水晶, 染色时能量源染成一种, 能量源周围六个点间隔着染两种, 发现若共振则一定三种颜色都包含且相邻, 同色格子互不影响</p><p>于是可以每个能量源拆三个点, 分别表示三种颜色删去哪一种, 串联起来跑最小割, 表示从这三种任意删一个</p><h3 id="P2774-方格取数问题-网络流-最小割"><a href="#P2774-方格取数问题-网络流-最小割" class="headerlink" title="P2774 方格取数问题 [网络流] [最小割]"></a>P2774 方格取数问题 [网络流] [最小割]</h3><p>黑白染色, 做成二分图, 两种颜色各一边.</p><p>对于一个格子, 向源点或汇点连自己点权的边(取决于自己在哪一边), 向周围四个格子连容量inf的边, 跑最小割即可</p><p>[思考] : 限制明显而许可(可以这么做)不明显时最小割</p><h3 id="P5038-奇怪的游戏-网络流-思维"><a href="#P5038-奇怪的游戏-网络流-思维" class="headerlink" title="P5038 奇怪的游戏 [网络流] [思维]"></a>P5038 奇怪的游戏 [网络流] [思维]</h3><p>看到相邻的两个格子想到黑白染色后一定一黑一白</p><p>于是黑白染色, 统计黑, 白色格子个数和权值和, 记为 $cnt_b, cnt_w, sum_b, sum_w$ , $sum_b-sum_w$ 始终不变 设最后所有数都变成x, 接下来分两种情况</p><ul><li><p>如果黑白格子数量相同, 因为权值差不变, 如果一开始不相等可以直接特判掉, 所以 $sum_u&#x3D;sum_v$ 发现两者相同的情况下, 棋盘的长或宽一定有一个是偶数, 所以可以用相邻格子平铺使x+1, 所以答案具有单调性, 可二分</p></li><li><p>如果不同, 则 $sum_b - sum_w &#x3D; x\times(cnt_b - cnt_w)$ , 解释一下就是因为操作时两者差始终不变, 所以一开始的差等于结束的差, 解出x后也要判断一下</p></li></ul><p>于是要考虑如何判断是否可行, 对每个格子算出还剩几次操作到 x, 然后染色后分成两边, 向源点汇点连自己剩余次数的边, 中间连inf, 判断最大流是否流满</p><h3 id="P4553-80人环游世界-网络流"><a href="#P4553-80人环游世界-网络流" class="headerlink" title="P4553 80人环游世界 [网络流]"></a>P4553 80人环游世界 [网络流]</h3><p>每个点拆入点出点, 之间连上下界都是经过次数的边, 费用为0, 然后点之间正常连, 跑费用流</p><h3 id="P4043-支线剧情-网络流"><a href="#P4043-支线剧情-网络流" class="headerlink" title="P4043 支线剧情 [网络流]"></a>P4043 支线剧情 [网络流]</h3><p>上下界网络流板子, 下界为1, 上界inf</p><p>上下界网络流方式是, 每个边流量设成上界-下界, 然后对于每个点出边下界和和入边下节和之差进行补流, 最后还要记得给汇点到源点连一条流量inf的边</p><h3 id="P1646-happiness-网络流-最小割"><a href="#P1646-happiness-网络流-最小割" class="headerlink" title="P1646 happiness [网络流] [最小割]"></a>P1646 happiness [网络流] [最小割]</h3><p>建两个点表示文理, 从文科连到同学连到理科, 对于两个人同时选一科的情况建一个点, 一边连文理, 流量为共同选这个科目的开心程度, 另一边连这两个人, 边权为inf, 最后跑最小割</p><h3 id="CF277E-Binary-Tree-on-Plane-网络流"><a href="#CF277E-Binary-Tree-on-Plane-网络流" class="headerlink" title="CF277E Binary Tree on Plane [网络流]"></a>CF277E Binary Tree on Plane [网络流]</h3><p>拆点成u1, u2, 每个点u1向所有可能的儿子的u2连容量1, 费用为距离, 源点像所有u1连容量2, 所有u2向汇点连容量1, 费用为0, 跑最小费用流.</p><h3 id="CF103E-Buying-Sets-网络流-最小割"><a href="#CF103E-Buying-Sets-网络流-最小割" class="headerlink" title="CF103E Buying Sets [网络流] [最小割]"></a>CF103E Buying Sets [网络流] [最小割]</h3><blockquote><p>有一个大小为 $n$ 的全集, 每个元素是一个数 $a_i$ , 有 $n$ 个子集. 题目保证任意 $k$ 个子集的并的大小 $\ge k$ .<br>每个子集有一个可正可负的权值, 你需要选出一些子集使得这些子集并的大小等于子集个数, 且所选子集的权值和最小. 可以为空集.<br>$n\le 300$ , $a_i\in [1, n]$</p></blockquote><p>好厉害的网络流!</p><p>当你试着搞费用流模型建图, 你会发现边需要是阶跃函数, 就寄, 此时如果确实是网络流题多半是最小割题了. 但这个题还是见过的极为巧妙的最小割问题.</p><p>建图是源点向所有表示集合的点连 $inf-a_i$ , 集合向元素连 $inf$ 的边, 元素 向汇点连 $inf$ 的边. 并且选择一个集合是保留它的边, 选择一个数字是断掉它的边, 最后局面就是选了的集合里所有数字被断掉.</p><p>那么考虑这么做能保证集合数量等于元素数量, 由于每条边都加 $inf$ , 我们会断尽量少的边, 再考虑可以直接断所有右边的数字, 所以我们一定只断 $n$ 条边, 于是选的数字的个数和不选的集合的个数总和是 $n$ , 那么选的数字的个数就是选的集合的个数了.</p><p>十分巧妙啊!</p><p>要点主要是, 想到最小割后要想到全集是一种方案, 且不选集合的个数和选的数字的个数一定, 那么你很容易想到都加 $inf$ 这一步, 然后再针对构造.</p><h3 id="CF132E-Bits-of-merry-old-England-时间轴建图-最大流-网络流"><a href="#CF132E-Bits-of-merry-old-England-时间轴建图-最大流-网络流" class="headerlink" title="CF132E Bits of merry old England [时间轴建图] [最大流] [网络流]"></a>CF132E Bits of merry old England [时间轴建图] [最大流] [网络流]</h3><blockquote><p>一个有 $n$ 个数组成的序列 $a$ , 你有 $m$ 个寄存器, 每次你可以给一个寄存器赋值为 $x$ , 代价为 $\mathrm{popcount}{x}$ , 或者输出一个寄存器, 代价为 $0$ , 求最小的代价按顺序输出这个序列. 输出方案.<br>$n\le 250, m\le 26$</p></blockquote><p>极为厉害的网络流.</p><p>只能对时间建图. 并且有个贡献消除.</p><p>变量可以一直保留这件事十分毒瘤, 考虑变量不能保留, 但如果一个变量从上一次保留到这里, 我们在后面减去这一次赋值的代价.</p><p>看这个建图:</p><p><img src="/img/2022-10-12-17-22-00-image.png" alt="buildgraph"></p><ul><li>对每个 $a_i$ 建立两个点 $u_i, u_i’$ .<ul><li>$u_i\stackrel{1, 0}{\longrightarrow}u_i’$ 表示输出 $a_i$ 这一变量</li><li>$s\stackrel{1, \mathrm{popcount}(a_i)}{\longrightarrow} u_i$ 表示这一时刻你进行赋值 $1$ 个变量, 花费 $1$ 的代价.</li><li>$u_i’\stackrel{1, 0}{\longrightarrow} t$ 表示你输出 $1$ 个变量.</li></ul></li><li>对每个 $u_i\stackrel{m-1, 0}{\longrightarrow} u_{i+1}$ , 表示上一时刻赋值的变量中有 $m-1$ 个.</li><li>对每个 $u_i$ , 设 $j$ 是最大的满足 $a_j&#x3D;a_i$ , 连边 $a_i\stackrel{1, -\mathrm{popcount}(a_i)}{\longrightarrow}a_j$ . 表示上一次在 $j$ 处没有流 $u_j\to u_j’$ , 而是顺着 $u_i\to u_{i+1}$ 的边一直流到 $u_j$ , 再从这里回去流 $u_j’\to t$ , 就相当于把 $j$ 时刻的一个变量一直保留到现在.</li></ul><p>然后就做完了, 输出方案的时候哪些 $u_i\to u_j’$ 的边被流了就能知道是不是被保留了.</p><p>太神仙了网络流.</p><h3 id="CF164C-Machine-Programming-时间轴建图-最大流-费用流-网络流"><a href="#CF164C-Machine-Programming-时间轴建图-最大流-费用流-网络流" class="headerlink" title="CF164C Machine Programming [时间轴建图] [最大流] [费用流] [网络流]"></a>CF164C Machine Programming [时间轴建图] [最大流] [费用流] [网络流]</h3><blockquote><p>直线上 $n$ 线段 $[l_i, r_i]$ , 每个线段有价值 $c_i$ , 你要选择若干条线段, 可以重叠, 但一点处最多有 $k$ 个区间重叠<br>$n\le 1000, k\le 50$</p></blockquote><p>居然没见过这类网络流. . . 见识少了. 但一旦提示网络流, 想到时间轴建图还挺简单的. (可能是受上面那题影响? )</p><p>时间轴建图, 那么一个点最多有 $k$ 个重叠可以看作最多有 $k$ 个区间左右端点分属区间两侧, 那么直接每个时刻建一个点, 用 $(k, 0)$ 的边串起来, 对每个区间 $r_i\stackrel{1, c_i}{\longrightarrow}l_i$ , 跑最大费用任意流, 但因为权值全是正的所以跑最大流就行了.</p><h3 id="P3980-NOI2008-志愿者招募-网络流-时间轴建图"><a href="#P3980-NOI2008-志愿者招募-网络流-时间轴建图" class="headerlink" title="P3980 NOI2008 志愿者招募 [网络流] [时间轴建图]"></a>P3980 NOI2008 志愿者招募 [网络流] [时间轴建图]</h3><p>其实很早以前就做过了, 不过qyc今天在看这个题学网络流.</p><blockquote><p>给定长 $n$ 的数轴和序列 $a$ , 有 $m$ 种区间 $[l_i, r_i]$ , 费用是 $c_i$ , 求最小代价使得位置 $i$ 至少被 $a_i$ 个区间覆盖.</p><p>$n\le 1000, m\le 10^4$</p></blockquote><p>考虑时间轴建图, 每个区间从 $r_i\stackrel{1, c_i}{\longrightarrow} l_i$ , 每个点向下一个点连 $(inf, 0)$ , 每个点拆成两个, 内部连 $(a_i, 0)$ , 就做完了.</p><p>qyc: “<strong>这种建图本质上是用一个环表示一个区间</strong>“</p><h3 id="ABC193F-Zebraness"><a href="#ABC193F-Zebraness" class="headerlink" title="[ABC193F] Zebraness"></a>[ABC193F] Zebraness</h3><blockquote><p>给你一个 $n\times n$ 的黑白矩阵, 格子 $(i, j)$ 可能是白的(W), 黑的(W), 不确定(? ). 现在让你确定每个不确定格子的黑白, 使得两边颜色不一样的边数最大, 输出这个最大值. (这里的边指的是每个格子的边)<br>$n\le 100$</p></blockquote><p>小清新网络流, 来自dwt的vp.</p><p>容易想到最小割建图.</p><p>然后你只需要把相邻各自颜色反向就可以把很容易做的相同限制(若 $u\in S$, 则 $v\in S$)变成相反限制(若 $u\in S$ 则 $v\in T$)</p><h3 id="ABC326G-Unlock-Achievement"><a href="#ABC326G-Unlock-Achievement" class="headerlink" title="[ABC326G] Unlock Achievement"></a>[ABC326G] Unlock Achievement</h3><p>x&gt; 有 $n$ 个技能, $m$ 个成就. 每个技能有一个等级, 初始均为 $1$.</p><blockquote><p>你可以用 $c_i$ 块钱令技能 $i$ 提升一个等级, 该操作没有次数限制.</p><p>第 $i$ 个成就达成的条件是对于 $\forall j\in [1, n], level_j \ge L_{i, j}$, 其中 $level_j$ 表示第 $j$ 个技能的等级. 达成成就 $i$ 后, 你会获得 $a_i$ 元的奖励. 注意这里奖励与成本是分开的, 也就是说你不能用奖励的钱去提升等级.</p><p>请最大化获得的奖励与所需成本之差, 并输出该值.</p><p>$n, m\le 50, , 1\le L_{i, j}\le 5, , 1\le a_i, c_i\le 10^6$.</p></blockquote><p>退火!</p><p>这是个网络流题, 费用流很难处理不连续的收益, 考虑最小割, 对每个第 $i$ 个技能为 $j$ 级建点, 把 $6$ 个点串成一串, $t$ 连到 $6$ 级 $inf$, $j$ 级和 $j+1$ 级连 $jc_i$, 用割掉从下往上第 $i$ 条边表示选 $i+1$, 然后每个奖励会和 $i$ 的 $L_i-1$ 级连.</p><h2 id="qyc讲课"><a href="#qyc讲课" class="headerlink" title="qyc讲课"></a>qyc讲课</h2><h3 id="建图"><a href="#建图" class="headerlink" title="建图"></a>建图</h3><h4 id="CTT22001177-无限之环"><a href="#CTT22001177-无限之环" class="headerlink" title="CTT22001177 无限之环"></a>CTT22001177 无限之环</h4><p>提示网络流题后, 容易想到相邻两个格子接头染色,</p><p>于是每个格子建表示向上下左右四个方向接头的四个点, 然后逐个分析出每个管子的边权即可.</p><h4 id="CF1404E-Bricks"><a href="#CF1404E-Bricks" class="headerlink" title="CF1404E Bricks"></a>CF1404E Bricks</h4><p>注意到, 分析每个格子的边, 一个格子的邻边不能同时在同一个矩形内, 若一条边两边有一个格子是白色那就不能选, 于是就在每个格子内建边, 选的是二分图最大独立集.</p><h3 id="循环流"><a href="#循环流" class="headerlink" title="循环流"></a>循环流</h3><p>做法是, 先强制满流正边(相当于上下界网络流预先流下界), 然后超级源和超级汇向每个点连边平衡, 此部分流量用来抵去所有超额部分, 这部分一定要满流才有解. (就是上下界弱化版啊).</p><h4 id="志愿者招募"><a href="#志愿者招募" class="headerlink" title="志愿者招募"></a>志愿者招募</h4><p>have done</p><h4 id="ARC137E"><a href="#ARC137E" class="headerlink" title="ARC137E"></a>ARC137E</h4><p>循环流, 一条边表示一个位置, 一条反向边表示一个区间(类似上一个志愿者招募), 然后对 $a_i$ 取min是十分简单的, 两条费用不同的边即可.</p><h4 id="HNOI2013-切糕"><a href="#HNOI2013-切糕" class="headerlink" title="HNOI2013 切糕"></a>HNOI2013 切糕</h4><p>对每个格子建一列点, 割掉第 $i$ 条边表示第 $i$ 个点, 然后黑白染色, 相邻两个格子, 在两列格子跨度为 $d$ 的连 $inf$ 的边, 每列点顶上连源底下连汇, 但此时问题是可能会在一条链上删好几条边, 于是你在每个边权都加 $inf$ 就可以避免这件事.</p><h4 id="人员雇佣"><a href="#人员雇佣" class="headerlink" title="人员雇佣"></a>人员雇佣</h4><p>先全选, 用最小割表示限制, 让 $S\to i$ 表示选, 割 $i\to T$ 表示不选, 然后在任意两个 $i-&gt;j$ 连边, 在这个基础上赋边权跑最小割即可.</p><p>要点应该是你让它至少选不选都先断一条.</p><h4 id="THUPC22-I-分组"><a href="#THUPC22-I-分组" class="headerlink" title="THUPC22 I. 分组"></a>THUPC22 I. 分组</h4><p>考虑仍然 $S\to i, i\to T$, 在上个题的基础上, 对 $(i, j)$ 建一个点 $c$ 也向源汇连边, 并让 $i\stackrel{inf}{\longrightarrow} c$, 最后只要给一些 $c\to i$ 这种东西就行了.</p><h3 id="特殊图"><a href="#特殊图" class="headerlink" title="特殊图"></a>特殊图</h3><h4 id="单位圆图最大团"><a href="#单位圆图最大团" class="headerlink" title="单位圆图最大团"></a>单位圆图最大团</h4><blockquote><p>平面上任意两个距离少于1连边, 求最大团. $n\le 100$</p></blockquote><p>注意到最大团必然在最远点对画半径为 $1$ 的圆的交里, 连这两个点把交划分成两部分, 则左右两部分都是团, 因此两部分都是二分图. 因为最大团是补图的最大独立集, 于是网络流跑二分图最大独立集即可.</p><h4 id="CCPC2021-WEIHAI-L-SHAKE-HANDS"><a href="#CCPC2021-WEIHAI-L-SHAKE-HANDS" class="headerlink" title="CCPC2021 WEIHAI L. SHAKE HANDS"></a>CCPC2021 WEIHAI L. SHAKE HANDS</h4><p>注意到 $\forall i &lt; j &lt; k$, 若 $i, j$ 没换过, $j, k$ 没有换过, 那么 $i, k$ 也没有换过, 于是小于并且没换过是偏序, 按照这个发现这个图的补图是可比图, 于是原图最大团补图最大独立集就是补图最长反链就是最小链覆盖.</p><p>剩下部分被qyc割了.</p><h3 id="模拟费用流"><a href="#模拟费用流" class="headerlink" title="模拟费用流"></a>模拟费用流</h3><p>费用流关于流量是凸的大家都知道</p><h4 id="XX-OPEN-CUP-GP-OF-KAZAN-H-HONORABLE-MENTION"><a href="#XX-OPEN-CUP-GP-OF-KAZAN-H-HONORABLE-MENTION" class="headerlink" title="XX OPEN CUP GP OF KAZAN H. HONORABLE MENTION"></a>XX OPEN CUP GP OF KAZAN H. HONORABLE MENTION</h4><p>先考虑全局, 用每条边表示一个 $a_i$, 费用为 $a_i$ 容量为 $1$, 每个点向源汇连边, 然后再加一些随便拆点就可以了. 于是要模拟费用流, 你可以建个线段树, $f_{i, j, 0&#x2F;1, 0&#x2F;1}$ 表示节点 $i$, 内部流量为 $j$, 左右端点连出去是否有流量, 因为费用流可以说明 $f$ 关于 $j$ 是凸的, 而你发现每次转移就是左右儿子做闵和.</p><p>那么区间问题的时候你要归并线段树上 $\log n$ 个区间, 因为我们只要求一个位置的值, 相当于你排序这 $log n$ 个区间的函数的差分取前 $k$ 大, 于是你二分那个第 $k$ 大的值, 然后在每个凸函数上求有多少个小于它的个数即可判定, 复杂度是 $3log$, ~~分散层叠成 $2log$ ~~</p><h4 id="XX-OPEN-CUP-GP-OF-SPB-F-FESTIVE-BAOBAB"><a href="#XX-OPEN-CUP-GP-OF-SPB-F-FESTIVE-BAOBAB" class="headerlink" title="XX OPEN CUP GP OF SPB F. FESTIVE BAOBAB"></a>XX OPEN CUP GP OF SPB F. FESTIVE BAOBAB</h4><p>首先费用流就是源连到根, 每个点连到汇, 因为源汇边不退流, 那么模拟费用流, 实际上这个图根本不带反悔的, 所以你干的就是每次找最小的.</p><h4 id="ICPC-SHENYANG-L-FORGED-IN-THE-BARRENS"><a href="#ICPC-SHENYANG-L-FORGED-IN-THE-BARRENS" class="headerlink" title="ICPC SHENYANG L. FORGED IN THE BARRENS"></a>ICPC SHENYANG L. FORGED IN THE BARRENS</h4><p>考虑先把极差变成段内任意两个的差.</p><p>那么 $a_i$ 向源, 汇连边表示自己的贡献为正&#x2F;负, 然后把所有 $a_i$ 双向穿一排, 但可能会有相交的, 于是拆两排解决掉这个问题.</p><p>然后你分析增广路发现, 每次要么是新加一个区间, 要么是在一个区间内再选一个最大一个最小, 用线段树维护区间最大最小值和区间内拆一个子区间的贡献, 再用set维护外部区间, 开一个堆维护全局最大值即可.</p><h4 id="PA2013-RAPER"><a href="#PA2013-RAPER" class="headerlink" title="PA2013 RAPER"></a>PA2013 RAPER</h4><p>费用流怎么做是显然的. $S\to i, i\to i+1, i\to T$</p><p>那么你每次干的增广路是上去正着走或者上去反着走.</p><p>于是线段树维护, 注意到一个反向边容量有 $0$ 的区间不会再被减, 所以要维护每个区间当前的答案和所有点都减去区间最小值的答案, 后者维护左边极长有流量, 右边极长有流量的部分, 以及这个部分的最小值, 以及其他一些平凡物, 一共九个.</p><h4 id="P1484-种树"><a href="#P1484-种树" class="headerlink" title="P1484 种树"></a>P1484 种树</h4><p>考虑费用流建图, 假设用流量表示树, 那么可以用边表示坑, 用点表示坑之间的间隔, 就可以做到相邻两个只能选一个了.</p><p>于是就是每次取反一个区间并和左右两边的合并</p><h3 id="增量网络"><a href="#增量网络" class="headerlink" title="增量网络"></a>增量网络</h3><h4 id="CF865D-BUY-LOW-SELL-HIGH"><a href="#CF865D-BUY-LOW-SELL-HIGH" class="headerlink" title="CF865D BUY LOW SELL HIGH"></a>CF865D BUY LOW SELL HIGH</h4><p>费用流和RAPER那个一样, 注意在一天买卖等于啥也没干所以不用管, 所以图建出来也是 $S\to i, i\to i+1, i\to T$.</p><p>然后分析增广路和负环, 决策仅有两种: 把这一支等到现在在卖, 或者把之前一次卖的不卖了现在卖. 一个堆即可.</p><h4 id="UER8-雪灾与外卖"><a href="#UER8-雪灾与外卖" class="headerlink" title="UER8 雪灾与外卖"></a>UER8 雪灾与外卖</h4><p><a href="https://www.luogu.com.cn/blog/uakioi/snow-disaster-and-take-out">题解很长, qyc写的很好</a></p><h3 id="怪题"><a href="#怪题" class="headerlink" title="怪题"></a>怪题</h3><h4 id="CF724E-GOODS-TRANSPORTATION"><a href="#CF724E-GOODS-TRANSPORTATION" class="headerlink" title="CF724E GOODS TRANSPORTATION"></a>CF724E GOODS TRANSPORTATION</h4><p>出现在lyh那篇</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非信竞杂题</title>
      <link href="/2022/06/01/not_oi_problems/"/>
      <url>/2022/06/01/not_oi_problems/</url>
      
        <content type="html"><![CDATA[<h3 id="数竞趣题"><a href="#数竞趣题" class="headerlink" title="数竞趣题"></a>数竞趣题</h3><p>来自数竞同学, 有12个球和一个天平, 天平可以比较两组球的重量和的大小关系, 其中一个球是假的, 可能更重或更轻, 称3次找出</p><p>这类题的关键是对获得信息量的考虑, 要使得每次询问的最坏情况下获取的信息量最多, 相当于尽量均衡</p><p>这个题第一步可以划分成4, 4, 4也可以是3, 3, 6, 发现若是3, 3, 6, 则不相等比相等多知道一个大小关系, 而4, 4, 4则更均衡</p><p>于是先考虑4, 4, 4, 如果相等则用2次从剩下的4个里找, 简单</p><p>如果不相等, 就要想办法利用这个不相等关系, 设球从1编号, 两组分别为1, 2, 3, 4和5, 6, 7, 8, 显然可以设1, 2, 3, 4&gt;5, 6, 7, 8, 于是考虑问1, 2, 5和3, 4, 6, 如果相等仍然简单</p><p>如果又不相等, 考虑如果那个假球比正常的大, 则只能在1, 2, 3, 4和两组中大的那组的交中, 只有两个, 如果更小则是5, 6, 7, 8和两组中更小的那组的交中, 只有一个, 可以假设更大称那两个, 如果相等说明假设错了就是那一个, 否则取更大的一个.</p><p>还是很有意思的</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂题 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机房杂题</title>
      <link href="/2022/06/01/talking_problems/"/>
      <url>/2022/06/01/talking_problems/</url>
      
        <content type="html"><![CDATA[<h1 id="机房杂题"><a href="#机房杂题" class="headerlink" title="机房杂题"></a>机房杂题</h1><h2 id="奇怪通信题"><a href="#奇怪通信题" class="headerlink" title="奇怪通信题"></a>奇怪通信题</h2><h3 id="通信题1-线性基-随机化-构造"><a href="#通信题1-线性基-随机化-构造" class="headerlink" title="通信题1 [线性基] [随机化] [构造]"></a>通信题1 [线性基] [随机化] [构造]</h3><p>A程序输入 $x\le 10^18$ 和最多40个位置, 要求编码长为150的01串给B, 其中给定的位置必须为0, B从这长150的串里恢复信息.</p><p>法1: 每3个分一块, 若一块内有两个位置必须为0则全填0, 否则按照如下方式编码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">块编码  -&gt;  实际信息</span><br><span class="line">001     -&gt;  1</span><br><span class="line">010     -&gt;  0</span><br><span class="line">101     -&gt;  00</span><br><span class="line">100     -&gt;  01</span><br><span class="line">110     -&gt;  10</span><br><span class="line">111     -&gt;  11</span><br></pre></td></tr></table></figure><p>构造满足不管是哪个位置挂了, 都可以用一种编码表示它, 最坏情况下我们也能有40个坏了的和10个没坏的, 其中没坏的可以表示2位, 坏了的表示至少1位, 就能表示 $2^40*4^10&#x3D;2^60$ , 正好表示 $10^18$ </p><p>法2: 每2个分一块, 如果有一个位置挂了就全0, 否则可以编码3种信息, 那么能表示 $3^35$ 个信息, 发现 $3^38$ 才行, 发现这种最坏情况仅当每个数单独占一块, 这时可以两个程序选用同一个种子把位置随机打乱, 则极大概率就会有些0跑到同一块, 然后就能过了</p><p>法3: 使用科技, 随机150个数每个位置表示一个, 用线性基看是否满秩能表示出来, 编码就是直接把每一位当成这个数是否选, 最后异或起来.</p><h3 id="通信题2-构造-思维"><a href="#通信题2-构造-思维" class="headerlink" title="通信题2 [构造] [思维]"></a>通信题2 [构造] [思维]</h3><p>A程序输入一棵有 $n\le 2. 5\times 10^5$ 个点的树, 要为每个位置定一个点权 $w\le 2^28$ , B程序有许多询问, 每次给两个你定的点权, 问两点关系(谁是祖先或并非祖先关系)</p><p>解法: 用dfs序判断关系, 那么就要存自身的dfs序号和子树大小, 这两个东西大小都是 $n$ 的存不下, 做法是通过加儿子把每个子树的大小都补成一个数 $a$ 的幂, 那么此时子树大小就只有 $\log_a{n}$ 种, 通过调节 $a$ 就能卡进去了.</p><h2 id="神仙题1-思维-平面图"><a href="#神仙题1-思维-平面图" class="headerlink" title="神仙题1 [思维] [平面图]"></a>神仙题1 [思维] [平面图]</h2><p>给一个网格图, 每两个格子间有一条边, 求每个点能到达的点的个数和</p><p><strong>因为是平面图, 如果扶着边走一圈其中包含的点就是所有能到达的点</strong></p><p>然后再用一个dp, f[i][0&#x2F;1]表示从i开始沿着哪一侧的墙走的结果, 转移是走一步</p><h2 id="POI某题"><a href="#POI某题" class="headerlink" title="POI某题"></a>POI某题</h2><blockquote><p>给 $m$ 个点, 点有权值 $w_i$ , 其有 $n$ 个点在凸包上, 求凸包上三点最大化它们形成的三角形内点的点权和.<br>$n\le 600, m\le 10^5$</p></blockquote><p>$n^3$ 枚举, 预处理每两个点连线向外里面的点数(对每个点跑一遍极角排序即可).</p><h2 id="奇怪数学题"><a href="#奇怪数学题" class="headerlink" title="奇怪数学题"></a>奇怪数学题</h2><blockquote><p>求 $1\ldots n$ 内有多少个数可以被唯一的表示成 $c^2-a^2-b^2$ , 其中 $a, b, c\in Z^+, c-b&#x3D;b-a, a&lt;b&lt;c$ .<br>$n\le 10^10$</p></blockquote><p>todo</p><h2 id="奇怪数学题2"><a href="#奇怪数学题2" class="headerlink" title="奇怪数学题2"></a>奇怪数学题2</h2><blockquote><p>给定 $n\times n$ 矩阵 $A$ , 求不断求二维前缀和(膜2意义下的二维前缀和), 最少几次让 $A$ 变会自己.</p><p>$n\le 1000$ </p></blockquote><p>前缀和变成差分, 倒着找规律.</p><h2 id="VUQProblem"><a href="#VUQProblem" class="headerlink" title="VUQProblem"></a>VUQProblem</h2><blockquote><p>给定数列对每个数求左边第 $k$ 近的比他大的数</p></blockquote><p>考虑倒着扫, 维护 $k$ 级单调栈, 一个数被弹了就进入下一级, 那么每个数在每一级被弹的时候, 正在插入的那个数就是它左边最近的比它大的数之一</p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem?"></a>Problem?</h2><blockquote><p>求区间最大异或对. 值域 $10^9$. 数据随机.</p></blockquote><p>考虑对于一个固定的数, 每个数异或这个数得到的数是均匀的, 所以前&#x2F;后缀max只有 $\log n$ 个, 只要用可持久化字典树求出 $n\log n$ 个可能贡献的对然后数点即可.</p><h2 id="蓝桥杯某题"><a href="#蓝桥杯某题" class="headerlink" title="蓝桥杯某题"></a>蓝桥杯某题</h2><blockquote><p>给定 $l, r$, 求 $(i, j)$ 数量满足 $i^2+j^2\in [l, r]$ 且 $p\vert (i^2+j^2), p&#x3D;2^3\times 3^3\times 53^2\times (10^6+3)$.</p><p>$l, r\le 10^{28}$</p></blockquote><p>判定 $a$ 在模 $p$ 存在二次条件的要求是 $a^{\dfrac{p-1}{2}}\equiv 1$, 发现 $2^3, 3^3, (10^6+3)$ 都没有 $-1$ 的二次剩余, 则因为 $(\dfrac{i}{j})^2+1\equiv 0$ 只有 $i&#x3D;j&#x3D;0$ 一组解, 则枚举 $i$ 模 $53^2$ 的值, 放到哈希表可以求出所有 $\bmod p$ 意义下的 $(i, j)$, 然后直接枚举倍数即可.</p><h2 id="Project-Eular-427"><a href="#Project-Eular-427" class="headerlink" title="Project Eular 427"></a>Project Eular 427</h2><blockquote><p><img src="/img/2024-06-17-09-33-03-image.png" alt="picture 0">  </p></blockquote><p>容易想到数长度不超过$k$的,即把序列划分成$i$段极长相同颜色段,每段长不超过$k$的方案数,一段的GF是$G(x)&#x3D;\dfrac{x-x^{k+1}}{1-x}$,则这个方案数是$[x^n] \dfrac{n}{n-1}\dfrac{1}{1-(n-1)G(x)}&#x3D;[x^n] \dfrac{n}{n-1}\dfrac{1-x}{1-nx+(n-1)x^{k+1}}$.</p><p>暴力拆分母:</p><p>$$<br>[x^n]\dfrac{1}{1-nx+(n-1)x^{k+1}}\<br>&#x3D;[x^n]\sum_j (n-1)^jx^{j(k+1)}(1-nx)^{-1-j}(-1)^j\<br>&#x3D;\sum_j (n-1)^jn^{n-j(k+1)}(-1)^j\binom{-1-j}{n-j(k+1)}<br>$$</p><p>注意到暴力枚举$j$是调和级数$n\ln n$,做完了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
            <tag> 通信题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分块选做</title>
      <link href="/2022/05/24/block/"/>
      <url>/2022/05/24/block/</url>
      
        <content type="html"><![CDATA[<h1 id="分块选做"><a href="#分块选做" class="headerlink" title="分块选做"></a>分块选做</h1><p>省选分块显然也挂了, 感觉又能数据结构又练码力, <del>唯一的问题是不会做</del></p><h3 id="P4108-HEOI2015-公约数数列-分块-分析性质"><a href="#P4108-HEOI2015-公约数数列-分块-分析性质" class="headerlink" title="P4108 HEOI2015 公约数数列 [分块] [分析性质]"></a>P4108 HEOI2015 公约数数列 [分块] [分析性质]</h3><p>[结论]:**一个序列前缀 gcd 是 log 段的函数!**因为每次gcd改变至少要除以2, 所以就 $\log n$ 段, 这个性质还挺优秀.</p><p>第二是发现序列长度为 $10^5$ , 但询问 $10^4$ , 放过了 $O(q\sqrt n \log n)$ 的做法</p><p>于是只需要考虑计算对于gcd的每一种取值是否可行即可, 如果线段树需要支持后缀异或一个数和查询一个区间是否存在某个数, 这是不可做的, 因为首先标记显然不能pushdown, 那么对于标记永久化, 可能会走到一个节点, 它一部分被打上了标记, 然后就G了</p><p>所以只能分块, 设块长为 $B$ , 对每个块维护块内 gcd 和 xor和, 再开一个哈希表存储当前块内前缀xor和为 $x$ 的最早的位置, 修改时暴力 $O(B)$ 重构当前块, 并对后面 $O(\frac{n}{b})$ 个块暴力, 询问则在外层从前到后遍历每一个块, 并在过程中记录当前块前缀 gcd 和 xor, 如果发现一个块前后 gcd不同, 则说明其 gcd 发生了改变, 在块内暴力扫一遍, 否则直接查维护的哈希表, 其实哈希表也可以map, 不影响复杂度. 由于gcd只会改变 $\log n$ 次, 所以这样做也只会暴力 $\log n$ 个块, 在B取 $\sqrt n$ 时总复杂度为 $O(n+q\sqrt n\log n)$ </p><h3 id="P4891-序列-分块-性质"><a href="#P4891-序列-分块-性质" class="headerlink" title="P4891 序列 [分块] [性质]"></a>P4891 序列 [分块] [性质]</h3><p>这个东西较难线段树, 然而据说貌似也可以, 但这里还是写分块做法, 把序列分成 $\sqrt n$ 块, 维护每一块 $\prod\limits_{i&#x3D;1}^n \min(B_i, C_i)$ 的值和B的排序数组和B排序数组的前缀积数组</p><p>对于B的修改, 可以暴力重构所在块的答案, 排序数组和前缀积, 这里可以直接插入而不每次排序来砍掉一个 log, 复杂度 $\sqrt n$ .</p><p>对于A的修改, 由于C是A的前缀max, 所以一次修改相当于对一个后缀取 max, 若把位置 $i$ 修改为 $x$ , 可以二分最后一个满足 $C_i&lt;x$ 的位置 $j$ , 相当于对区间 $[i, j]$ 赋值为x. 仍然暴力重构散块, 对于一个整块整体赋值为 $c$ , 则可以在 $B$ 排序后的数组中找到第一个满足 $B_i&gt;c$ 的位置, 则答案就是两段拼起来, 直接二分的话会带个log, 发现这个c每次修改是单增的, 可以每一个块维护个指针, 一次对B的修改最多令一个块的指针移动一位, 应该就能砍掉一个 log</p><p>查询就暴力把每一块的答案乘起来, 最后总复杂度就是 $O(n\sqrt n)$ </p><h3 id="雅加达的摩天楼-根号分治-bfs-暴力-建图"><a href="#雅加达的摩天楼-根号分治-bfs-暴力-建图" class="headerlink" title="雅加达的摩天楼 [根号分治] [bfs] [暴力] [建图]"></a>雅加达的摩天楼 [根号分治] [bfs] [暴力] [建图]</h3><p>很妙的一个题, ~~虽然它是这个分块题单里不用分块和莫队的唯一的题. ~~</p><p>首先暴力, bfs状态为 $(pos, jump, time)$ 表示当前位置, 跳跃能力和已经用的次数, 则每次有三种转移:</p><ul><li>$(pos, jump) \to (pos+jump, pos, time+1) \ s. t. \ pos+jump&lt;n$ </li><li>$(pos, jump) \to (pos-jump, pos, time+1) \ s. t. \ pos-jump\ge 0$ </li><li>$(pos, jump) \to (pos, p_i, time) \ s. t. \ b_i&#x3D;pos$</li></ul><p>比较显然, 最后一个多意思就是跳到一个楼上只后你换了一个 doge.</p><p>然后惊喜的发现这样暴力直接过了, 原因如下</p><ul><li>首先每个(pos, jump)只可能对应一个最小的time, 也就是拿前两个判重</li><li>考虑进行根号分治, 对于一个 doge 的 $p_i$ <ul><li>若 $p_i\ge \sqrt n$ , 则它只能跳到 $\frac {\sqrt n}{p_i}\le \sqrt n$ 个位置, 一共只有 $m \times \frac {\sqrt n}{p_i}\le m \sqrt n$ 状态</li><li>若 $p_i&lt; \sqrt n$ , 则一共n个位置, 每个位置一共 $\sqrt n$ 个可能的跳跃值, 所以一共只有 $n \sqrt n$ 个状态</li></ul></li></ul><p>然后这题实现的时候注意几个细节:</p><ul><li>用 bitset 判重而不能用 map , unordered_map 也不行, 都会 TLE</li><li>bitset空间玄学, 你可以开 $3\times 10^4$ 个大小为 $3\times 10^4$ 的 bitset, 但不能开一个大小为 $9*10^8$ 的</li><li>BFS时边权有 0 有 1 , 所以要用双端队列 bfs, 注意标记访问过要在出队时, 不然可能会先有一个被扔到队尾的标记了访问使得后来要扔到队头的进不来</li></ul><p>看到还有一种分层图的做法, 就是对于 $p_i&gt;\sqrt n$ 可以直接暴力连边, 对于 $p_i\le \sqrt n$ 可以建立分层图, 每一层表示一个 doge, 层 $k$ 每个位置 $i$ 的点和 $i-p_k$ , $i+p_k$ 连边, 因为只对 $p_i\le \sqrt n$ 的建立, 所以层数只有 $\sqrt n$ , 也可通过.</p><h3 id="王室联邦-树分块-分块"><a href="#王室联邦-树分块-分块" class="headerlink" title="王室联邦 [树分块] [分块]"></a>王室联邦 [树分块] [分块]</h3><p>树分块! 然而并不是我们分块常用的树分块, 更多给莫队用了</p><p>分块方法就是 dfs 每个点, 访问到一个点时, 维护一个集合表示还没有被分块的点, 然后依次遍历它的儿子, 把儿子中未被分块的点加进自己的集合, 如果大小超过 $B$ 就分一块, 首都为自己(而不是儿子), 最后把分块剩下的集合加上自己返回给父亲. 对于根节点, 剩下的部分塞进最后一个块里.</p><p>实现时可以用一个栈代替传递集合, 但要注意当前的栈底是进入这个节点时的栈顶, 而不是整个栈道栈底</p><p>这种分块保证了直径, 块内点个数和块数量, 但不能保证联通限制了较难应用在不是莫队的树分块上</p><h3 id="P6177-Count-on-a-tree-II-x2F-模板-树分块-树分块-分块-bitset"><a href="#P6177-Count-on-a-tree-II-x2F-模板-树分块-树分块-分块-bitset" class="headerlink" title="P6177 Count on a tree II&#x2F;[模板]树分块 [树分块] [分块] [bitset]"></a>P6177 Count on a tree II&#x2F;[模板]树分块 [树分块] [分块] [bitset]</h3><p>于是这是真正的树分块, 还是有挺多分块方法的, 这里只写几个最常用的</p><p>随机撒点法, 即完全随机的取 $B$ 个点, 每个点和它祖先中第一个关键点分为一块, 能满足</p><ul><li>每个点到根的路径上期望经过 $n&#x2F;B$ 个点能遇到一个关键点</li><li>一共 $B$ 个关键点</li><li>每一块点数期望 $n&#x2F;B$ </li><li>每一块直径期望 $n&#x2F;B$ </li><li>保证联通</li></ul><p>对于这题, 可以预处理所有关键点两两之间的颜色构成的值域 bitset , 对于一个询问算出两个点的 lca, 于是分三类情况:</p><ul><li>两个点到 lca 的路径上没有任何关键点, 则直接暴力</li><li>两个点到 lca 的路径上都有关键点, 则暴力从两个点向上跳到第一个关键点, 两个关键点之间的部分已经预处理好了</li><li>一个有一个无, 无的点直接暴力到 lca, 有的点先跳到第一个关键点, 然后再按关键点跳(每个关键点跳到它祖先中最深的关键点)到最后一个比 lca 深的关键点点, 这一段用预处理的, 最后再跳到lca</li></ul><p>实现时第三种还是不要倍增, 因为并不能降低复杂度, 而且会在块长小的时候 WA , 原因如果倍增的数组不是处理的每个关键点的父关键点, 而是原本的父子关系, 最后并不能跳到最浅的比lca深的关键点</p><p>另外这题也可以仅处理关键点到它父关键点这段的答案, 但这样实现起来更麻烦, 因为一个询问要分成更多段处理, 然而预处理常数更小且空间小.</p><h3 id="P5072-Ynoi2015-盼君勿忘-莫队-链表-性质"><a href="#P5072-Ynoi2015-盼君勿忘-莫队-链表-性质" class="headerlink" title="P5072 [Ynoi2015] 盼君勿忘 [莫队] [链表] [性质]"></a>P5072 [Ynoi2015] 盼君勿忘 [莫队] [链表] [性质]</h3><p><del>有人说不强制在线的YNOI常常是莫队</del></p><p>不强制在线和没有修改让人想到可以莫队. 首先考虑计算每个子序列的和必然是没有前途的, 所以考虑每个位置对这个区间的贡献, 由于要去重仍然不好办, 所以考虑每个值对区间的贡献, 只要计算它被多少子序列包含, 可容斥的计算又多少子序列不包含它, 发现若记 $v$ 出现次数为 $cnt_v$ , 区间长度为 $len$ , 则其被 $2^{len}-2^{len-cnt_v}$ 个区间包含, 贡献就是 $v \times (2^{len}-2^{len-cnt_v})$ </p><p>这时我想到也许可以考虑加入一个值后每个答案都乘上了2, 再给它自己的答案除以2, 用数据结构维护, 然而由于每次询问模数不同导致这样做没有前途, 必须每次询问再计算答案.</p><p>[结论]:<strong>一个序列总长度 $n$ , 则值的出现次数的种类只有 $\sqrt n$ 量级, 推广对任意累计和为n的序列其不同元素数也是 $\sqrt n$ 量级</strong>, 原因是考虑 $1+2+3+. . . +\sqrt n &#x3D; \dfrac {(1+\sqrt n)\sqrt n}{2}$ </p><p>所以可以考虑维护每个出现次数对应的所有值的和, 由于乘法分配率则可以给它们整体呈上被包含数 $\sqrt n$ 计算答案, 于是接下来只要考虑在插入删除时如何 $O(1)$ 维护, 我们要有一个数据结构, 支持 $O(1)$ 把一个元素的值的一部分挪到相邻元素(就是挪到代表次数多1或少1的项中), 同时能 $O(\sqrt n)$ 的遍历所有有值的元素.</p><p>后一个条件让我们想起链表, 于是维护一个双向链表, 每一项存储 $cnt$ 和 $val$ 表示代表队出现次数和出现次数为 $cnt$ 的所有值的和, 但这样插入删除元素也是 $O(\sqrt n)$ 的. 于是发现可以开一个数组辅助记录每个出现次数对应的链表位置, 因为如果我们发现一个出现次数之前没出现并需要插入一个代表新的出现次数的元素时, 它左边或右边的节点一定存在, 使得我们可以 $O(1)$ 得到其前后元素, 那就可以 $O(1)$ 插入和维护这个辅助数组了.</p><p><del>这是不是最好写的Ynoi之一啊</del></p><h3 id="P4117-Ynoi2018-五彩斑斓的世界-分块-大分块-并查集-链表-性质"><a href="#P4117-Ynoi2018-五彩斑斓的世界-分块-大分块-并查集-链表-性质" class="headerlink" title="P4117 [Ynoi2018] 五彩斑斓的世界 [分块] [大分块] [并查集] [链表] [性质]"></a>P4117 [Ynoi2018] 五彩斑斓的世界 [分块] [大分块] [并查集] [链表] [性质]</h3><p>~~64MB? problemprovidercreep! 无处存储! ~~</p><p>学到了一个卡空间技巧, 对于这种两个区间答案是独立的且可快速合并的时可以通过分块卡空间, 即每次只处理这一小块的答案最后合并起来, 用了一个 $O(\sqrt n)$ 的代价把空间缩小到 $\dfrac {1}{\sqrt n}$ </p><p>于是接下来问题变成如何 $O(n)$ 求一个区间的答案, 由于这题值域也是1e5, 可以在这个方向思考一下, 这个做法是定义一个块的势能为这个块的最大值, 考虑如何处理操作, 发现如果我们维护一个全局(这一块的全局)加标记, 记块内最大值为 $v$ , 就有两种处理方式</p><ol><li>给所有多于x的数减去x, 修改量为 $v-x$ </li><li>全局减x, 并给所有少于x的数增加x, 修改量为 $x$</li></ol><p>由于定义了势能, 所以要把操作量和势能挂钩, 发现</p><ul><li>当 $v&lt;x$ 时这块不用管</li><li>当 $x&lt;v&lt;2x$ 时, 用方案1会使 $v&lt;x$ , 可以把势能减小最少 $v-x$ , 修改量也为 $v-x$ </li><li>当 $v&gt;2x$ 时, 用方案2会使 $v$ 减小x, 修改量也为 $x$</li></ul><p>势能一开始是 $O(n)$ 的, 所以一块复杂度 $O(n)$ , 总复杂度 $O(n\sqrt n)$ 次修改</p><p>然后我们需要找到一个数据结构, 可以支持 $O(1)$ 的把一个值的元素改成另一个, 能 $O(\sqrt n)$ 查出一个时刻每个位置的值是啥, 发现可以对每个值开一个链表, 挂上它所有的位置, 然后当把一个值改成另一个只需把链表接起来, 查的话就是遍历所有的链表, 或者把链表换成vector启发式合并, 还有一种方法是用简化版并查集, 只要支持合并和遍历, 遍历因为一共 $\sqrt n$ 个元素, 合并每次都是合并两个根, 所以这个神奇并查集是 $O(1)$ 的</p><p>零散块查询和修改都是先还原每个点的值然后暴力重构或暴力判断相等</p><h3 id="P4119-Ynoi2018-未来日记-分块-大分块-并查集-链表-性质"><a href="#P4119-Ynoi2018-未来日记-分块-大分块-并查集-链表-性质" class="headerlink" title="P4119 [Ynoi2018] 未来日记 [分块] [大分块] [并查集] [链表]  [性质]"></a>P4119 [Ynoi2018] 未来日记 [分块] [大分块] [并查集] [链表]  [性质]</h3><p>qyc瞬间就胡出了解法</p><p>既然是第一分块肯定要分块, 而且对于区间替换这个操作看起来很难线段树</p><p>对于查询, 两个可能都方案是二分和值域分块( $\sqrt n$ 分), 发现如果二分我们要么能 $O(1)$ 求出区间内小于一个数的个数, 要么就因为 $n\sqrt n\log n$ 被卡飞, 所以只能用 $\sqrt n$ 分, 即把值域分块, 因为反正都要顺着从下向上扫一遍块, 所以不需要维护小于一个块的个数, 而可以只维护区间内值在这个块的个数. 然后就是要能知道区间内在某一值域块内某个数出现的个数, 所以考虑在序列分块维护这两个信息, 做成两个前缀和, 即 $cnt_{i, j}$ 表示前 $i$ 块的数出现在值域 $j$ 块的数的个数, $cnt2_{i, j}$ 表示前 $i$ 块的数等于 $j$ 的个数, 散块可以套路的暴力, 这里可以先只暴力外层块的数, 再暴力某一块内的数(仅当这个数在这一块内才加进去).</p><p>对于修改把 $x$ 改成 $y$ , 分情况讨论</p><ol><li>$x$ 在区间中未出现或 $x&#x3D;y$ : 跳过</li><li>$y$ 在区间中未出现: 发现对于一次修改, 我们修改的是 $l$ 到 $r$ 的整块中 $j&#x3D;x\ or\ j&#x3D;y$ 的 $cnt2_{i, j}$ , $cnt_{i, j}$ 也同理, 即虽然单修改一个块影响 $\sqrt n$ 个后面的块, 但一个区间的所有块对后面的影响可以通过一个前缀和合并起来, 使得区间里的所有块对后面的影响可以用相同方式修改最多 $\sqrt n$ 个后面的块, 复杂度仍然是 $O(\sqrt n)$ , 此时这个修改相当于把一个数映射成另一个数, 可以直接开一个数组记录这个映射(即原数组中某个值的实际值和实际值对应的原数组值), 重构时先还原, 而整块修改时只要 $O(1)$ 的修改这个映射表即可.</li><li>$x$ 和 $y$ 均在区间中出现: 此时修改相当于把 $x$ 合并到 $y$ 上, 考虑一个修改对于一个块内的数的种类数的种类数的影响, 完整包含时种类数不会增加, 部分包含则最多增加一, 由于一个块一开始种数最多有 $\sqrt n$ , 每次修改最多给种数增加2, 所以发现所有块的种类数减少次数的和(一次修改把两个数合成一个数)只有 $n+m$ 级别, 这使得我们可以不处理两个数合成一种数的情况而选择暴力重构, 因此只会执行 $O(n+m)$ 次这样的暴力重构.</li></ol><p>然后在做这个200行大程序的过程中我查出了亿堆堆错误, 细节, 和可以更快的点, 这里总结一下:</p><ul><li><p>值域分块和序列分块不要一起写, 便于调块长, 这个貌似真的会TLE一个点, 而且既然要调块长, 数组大小常量要两个分别是块长和块个数</p></li><li><p>寻址连续还是靠玄学两边都试试</p></li><li><p>分块的每块左端点和每个位置属于的块在Ynoi卡常题里还是存起来, 否则会TLE一个点</p></li><li><p>映射关系仔细想想, 主要是上面情况2中映射修改, 代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mapping[block][v]表示块block中数组中的v的实际值,reverse_mapping就是实际值对应的数组中的值</span></span><br><span class="line">mapping[block][reverse_mapping[block][x]] = y;</span><br><span class="line">reverse_mapping[block][y] = reverse_mapping[block][x];</span><br><span class="line">reverse_mapping[block][x] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//**这里不能mapping[block][x] = 0,仔细想想发现它意义不对**</span></span><br></pre></td></tr></table></figure></li><li><p>使用 $\sqrt n$ 分时可以在求出答案在哪一值域块后再求散块的 $cnt_2$ , 只用处理在这一块内的就行了, 能快一些</p></li><li><p>最最最最最关键的我判断块内是否存在y的部分, 写的是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(rever_mapping[y]==<span class="number">0</span>) <span class="comment">//二维数组!相当于判断空指针,始终为假全部暴力,关键是还能过一堆点让人以为是卡常了</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="P5397-Ynoi2018-天降之物-分块-大分块-性质-根号分治"><a href="#P5397-Ynoi2018-天降之物-分块-大分块-性质-根号分治" class="headerlink" title="P5397 [Ynoi2018] 天降之物 [分块] [大分块] [性质] [根号分治]"></a>P5397 [Ynoi2018] 天降之物 [分块] [大分块] [性质] [根号分治]</h3><p>这次不是复杂度写假了, 而是真的常数爆炸</p><p>这里先写根号重构版, 以后如果有空可能会在那个序列分块加强的题做那种解法</p><p>一开始想的根号分治后给每个数维护 $O(1)$ 查询的kth和rank来支持前驱后继, 后来qyc说可以直接维护O(1)查询的前驱后继, 每次把一个点插进来修改的是一个区间, 然后才发现还有附属集合这种根号分治后套根号重构的妙法</p><p>首先和 SDOI2022 Day1T1 一样很容易想到根据出现次数进行根号分治. 维护每一个值的所有出现位置的有序数组, 和所有出现次数多的数对其他数的答案.</p><p>对于修改, 发现这个修改操作和第一分块的类似, 都具有一个势能均摊性质, 即对于把 $x$ 改成 $y$ , 两者都在序列中存在则每次种类数减一, 否则只要 $O(1)$ 修改映射, 因为一开始种类数是 $O(n)$ 的, 而次数较多的只有 $O(\sqrt n)$ , 所以对于两个次数多的的合并直接用 $O(n)$ 的暴力就 $n\sqrt n$ 了. 对于两个次数小的的如果合并后还是小, 就暴力归并一下, 否则仍然可以 $O(n)$ 重建, 原因是新晋次数多的数也是 $O(\sqrt n)$ 的, 这个理解就是如果两个后面被合并成大的了, 那你可以一开始就把它们看成一个大的, 由于这样后大的仍然不会多于 $O(\sqrt n)$ , 所以这样暴力归并也是对的, 最后就是一大一小的问题了, 这里使用了根号重构, 为每个块再开一个数组记录合并进来的不到 $\sqrt n$ 的数, 直到到了一起跑一个暴力归并, 这个的分析和两个小的合并成大的的相同. 由于要进行根号重构, 所以我们预处理的答案只包含整的部分, 零散部分不被包含.</p><p>修改过程中显然可以简单维护那个预处理的答案, 只要在合并两个数时, 遍历所有次数多的数, 更新答案为这两个数中较小的一个</p><p>对于查询只要暴力归并计算这两个零散块彼此间的贡献, 再查一查如果两个数是次数多的就再和预处理的答案取最小值即可</p><p>总复杂度是 $O(n\sqrt n)$ 的, 调出一份正确代码并不难, 但毒瘤把时限开到0. 5s , 内存开到256M 后就有些注意事项</p><ul><li>每个值只用维护根号重构中的零散部分的有序数组, 整的只记录答案, 不然合并时还要归并整的有序数组常数爆炸</li><li>要用 vector 维护位置, 因为256M 开不下两个 $n \sqrt n$ 的数组, 而出现位置在每个数最大 $\sqrt n$ , 但总个数确是 $n$ </li><li>vector 调用<code>clear()</code>后不会释放内存, 解决方案是紧接着调用<code>vector. shrink_to_fit()</code>或用网上流传的传统艺能开一个局部变量vector并和要清空的交换</li></ul><p>祝卡常愉快</p><h3 id="P6578-Ynoi2019-魔法少女网站-Trick-分块-大分块-性质"><a href="#P6578-Ynoi2019-魔法少女网站-Trick-分块-大分块-性质" class="headerlink" title="P6578 [Ynoi2019] 魔法少女网站 [Trick] [分块] [大分块] [性质]"></a>P6578 [Ynoi2019] 魔法少女网站 [Trick] [分块] [大分块] [性质]</h3><p><del>上一个还可以是卡常愉快, 这个就直接毒瘤</del></p><p>这几个题似乎都是先考虑询问, 因为询问的形式多样, 但修改却形式少一些. “最大值小于等于 $x$ “就相当于这个区间的所有数都小于等于 $x$ , 可以用中位数或二分答案的套路把大于 $x$ 的设为0, 小于等于的设为1, 会得到若干个1的连续段, 发现长为 $len$ 的区间会贡献 $\frac{len\times(len-1)}{2}$ . 思考如何维护这个 $0\to 1$ 和 $1\to 0$ 的过程, 发现 $0 \to 1$ 的过程可以 $O(1)$ 的更新而 $1\to0$ 的过程不行(如何维护在后面序列分块)</p><p>为了区分, 把 $0\to 1$ 和 $1\to 0$ 的过程叫更新, 题目的修改叫修改.</p><p>在无修改的情况下, 容易想到如果把询问按x排序, 因为x单调增, 那么每个数符合要求后就一直符合, 只会被从 0 到 1 更新一次, 那现在加上修改, 一个比较厉害的做法(做题少第一次见)把所有被修改过的位置单独拿出来, 剩下的用上面的做法, 而对于这些被改过的位置, 每次询问遍历所有修改暴力更新, 算完询问再回滚撤销, 这样仍然复杂度爆炸, 但可以进行一个根号重构, 或者说时间分块, 即把每 $B$ 个操作作为一块, 块内这样处理, 每结束一块把所有修改作用上去重构.</p><p>因为一个块最多有 $B$ 个修改操作, 每个修改操作会被应用最多这个块的询问次(也是最大 $B$ ), 所以修改引起的更新次数就是 $\dfrac {n}{B} \times B^2&#x3D;nB$ , 此外对于每一块, 会从小到大把每个没被修改过的位置更新一次, 一共 $\dfrac {n^2}{B}$ 次, 所以 $B&#x3D;\sqrt n$ 时, 复杂度为 $n\sqrt n$ 最优.</p><p>所以就是要一个数据结构能 $O(\sqrt n)$ 求区间内的这个式子和, 并要支持 $O(1)$ 单点更新和撤销.</p><p><del>既然是Ynoi这个数据结构多半是分块</del>, 可以序列分块, 每一块记录 $ans$ 表示块内答案(如果一个连续1区间伸出去了或延伸到区间端点整个连续段都不算, 不包含端点是因为包含端点的连续段会在查询时作为块间的算, 看后面), 以及块内的连续1区间的两个端点分别对应的另一个端点(即设数组 $begin_i$ 表示以 $i$ 结尾的全1区间的开头, $end_i$ 表示以 $i$ 开始的全1区间的结尾, 再记录区间全一前后缀长度, 此时一个修改有三种情况, 分别讨论着去修改, 注意前后缀长度单调增加, 均摊是 $O(1)$ , 注意只有整个区间都被包含时才算它的答案.</p><p>查询时对于散块可以暴力扫描, 对于整块如果全是1就是直接跳(判断前缀长度是否直接等于块长), 否则就给之前的长度加上最长前缀并计算这个区间的贡献, 然后更新下一个连续1区间的左端点为最长全1后缀的位置, 也记得加上这个区间的内部贡献.</p><p>至于撤销, 只要开个栈, 照着修改改了的信息记录一下就行了.</p><p>但按这个实现虽然复杂度时对的, 但还有不少细节:</p><ul><li><p>可以用块分界线把全1段隔断, 即 $begin_i$ , $end_i$ 记录的是同一块内这个连续1区间的左右端点, ans记录的就成了不延伸到区间端点的贡献, 这样做就可以不维护区间前后缀长度, 中等优化</p></li><li><p>$begin$ 和 $end$ 可以用一个数组, 因为一个点要么是自己, 要么只能作为左端点或右端点, 较小优化</p></li><li><p>发现修改的时候常数仍然大, 要复杂的判断连续段是否连到了左右端点, 于是直接ans包含它们, 每次在查询的时候单独去掉前缀连续段和后缀连续段的贡献, 这一步有较大的常数优化.</p></li><li><p>栈要手写, 较大优化</p></li><li><p>每次完成一个时间块的处理后就不用撤销更新了, 直接<code>memset</code>更新会更快, 较大优化</p></li><li><p>预处理数组记录某长度的贡献</p></li><li><p>从小到大加入每一个数时不要用<code>sort</code>, 虽然不影响复杂度, 但必须用桶排, 写vector或模拟邻接表</p></li><li><p>反复调块长, 中等到较大优化</p></li><li><p>对于同一个位置的修改操作生效的是询问时间前最后一个, 同时如果对这个位置的修改在询问时间后要把原数组的值更新上</p></li><li><p>快读快写, <code>register</code>, 开变量缓存等基本操作</p></li></ul><p>于是再经过一小时写大约六七k代码再一小时调试正确性和加起来大概一天半的卡常就能过了, 这题时限简直# $%^$ %^%&amp;^%&amp; $%$<br>卡常卡常, 代码越卡越长</p><h3 id="P4690-Ynoi2016-镜中的昆虫-分块-根号重构-思维"><a href="#P4690-Ynoi2016-镜中的昆虫-分块-根号重构-思维" class="headerlink" title="P4690 [Ynoi2016] 镜中的昆虫 [分块] [根号重构] [思维]"></a>P4690 [Ynoi2016] 镜中的昆虫 [分块] [根号重构] [思维]</h3><p>大分块做的太折磨了, 换几个不是大分块的做做. <del>可为什么这个我也写了250行啊</del></p><p>首先区间数颜色令人想起HH的项链, 考虑用同样的转化, 对于每个位置 $i$ 记录 $a_i$ 上一次出现位置 $pre_i$ , (同时为了方便下一次出现位置写作 $next_i$ ), 则区间查询 $[l, r]$ 中有多少 $i\in [l, r]\ s. t. \ pre[i]&lt;l$ , 变成了个二维数点</p><p>那么下一步考虑修改, 对于单点修改发现修改一个点 $i$ 只会影响 $i$ 和 $next_i$ 的 $pre$ , 为了快速找到新的 $pre_i$ , $next_i$ 和 $pre_{next_i}$ , 对于每个颜色开一个 set 记录出现位置, 于是就成了一个带修二维数点.</p><p>而对于区间赋值, 体现出了这个题神仙的地方, 虽然单点赋值变成了区间赋值,<strong>但 $pre$ 的改变仍是 $O(n+m)$ 的</strong>!</p><p>考虑对于每个值相等的区间, 发现除了左端点之外的所有点 $i$ 满足 $pre_i&#x3D;i-1$ , 此时若整个区间被改成另一个, 那么要更新的 $pre$ 就只有自己的左端点和下一块的左端点, 所以对于一次修改, 要更新的 $pre$ 就只有中间每个值域连续段的第一个和以每个值域连续段的 $next$ 的 $pre$ .</p><p>定义势能为当前总区间个数, 则每次的 $pre$ 变化量对应了势能的减少数, 同时一个修改最多增加3个势能(产生3个新的值域区间), 一开始势能为 $n$ , 所以**总复杂度 $n+3m$ **</p><p>于是就可以转化成单点修改了. 为了快速找到 $pre$ 的变化位置, 用一个 set 维护所有区间, 再用一堆 set 维护每个颜色的值域区间(后面这个就是把单点修改的 set 中的元素变成区间, 这两个 set 相当于把区间看成点. ) 就能 $O(\log n)$ 的找到一个区间的前驱后继, $O(cnt \log n)$ 的遍历连着的 $cnt$ 个区间了.</p><p>然后考虑如何处理单点修改的动态二维数点, 方案很多:</p><ul><li>无脑树套树拍上去, 发现64MB内存炸飞了</li><li>cdq分治大法好, 可惜我不会</li><li>KDT玄学</li><li>Ynoi怎能没有分块</li></ul><p>于是写分块</p><p>最简单的想法是直接二维数点的分块, 先序列分块, 散块暴力, 整块要支持快速查块内小于一个数的个数和单点修改, 由于单点修改数 $O(n+m)$ 的, 而查询是 $O(n\sqrt n)$ 的, 值域分块维护就是 $O(\sqrt n)$ </p><p>然后发现内存又炸了 (lxl点名卡的做法)</p><p>但有一种很巧妙的根号重构&#x2F;时间分块做法可以 $O(n)$ 空间, 看另一篇题解写的有点简略, 我来说一说:</p><p>其实这个做法很像第十分块, 如果做过那个只要猛地听见”根号重构”, “时间分块”立马就会了.</p><p>具体的, 像第十分块一样, 当我们把询问按照 $l$ 排序, 元素只会变得更满足条件( $pre_i&lt;l$ ), 所以可以从小到大加入每个符合条件的元素(就是对于每个 $pre_i&lt;l$ , 给位置 $i$ 加1), 一共是 $O(n)$ , 然后对每个询问遍历这一块的所有修改, 判断一下是否要给答案加一, 这一步显然是 $O(q\times u)$ (即询问个数*修改个数)的, 而查询就是查询区间和.</p><p>套路的根号重构, 每 $\sqrt n$ 个跑一遍, 总复杂度 $O(n\sqrt n)$ . 另外为了保证复杂度, 区间求和单点加用 $O(1)$ 修改 $O(\sqrt n)$ 查询的分块平衡一下就行了.</p><p>这题代码量不小, 类似珂朵莉树的那块不少细节, 特判一下前后缀不存在的情况, 然后最重要的是注意<strong>STL的set在删除时迭代器会失效, 但又不是每次都会失效</strong>, 如果出现了开调试就对直接运行就WA之类的看看是不是用了失效的迭代器, 这种野指针解引用情况<strong>不会RE</strong>.</p><p>但好在时间良心, 我的实现一堆 STL 不卡常不快读就过了, 时间分块块长要稍大一点, 我是 $2\sqrt n$ .</p><p>其他地方的细节其他题解说的很清楚, 根号重构只要注意修改可能多次修改一个位置, 然后记得清空, 就是和第十分块一样的细节啦.</p><h3 id="P6580-Ynoi2019-美好的每一天-不连续的存在-大分块-思维-莫队-分块"><a href="#P6580-Ynoi2019-美好的每一天-不连续的存在-大分块-思维-莫队-分块" class="headerlink" title="P6580 [Ynoi2019] 美好的每一天~ 不连续的存在 [大分块] [思维] [莫队] [分块]"></a>P6580 [Ynoi2019] 美好的每一天~ 不连续的存在 [大分块] [思维] [莫队] [分块]</h3><p>传说中的势能均摊莫队, 代码先咕, 吐槽毒瘤的话等写了再放</p><p>如果直接回滚莫队+线段树合并, 由于线段树合并的复杂度是均摊的, 右指针复杂度 $O(n\log n)$ , 但左指针在块内反复撤销和合并是假的</p><p>由于在任意一个右端点的基础下左端点向左合并的代价必然不高于右端点是序列结尾的情况, 因为图是一颗树.</p><p>令位置 $l$ 的代价为当区间 $[l+1, n]$ 都被加入时的代价, 那么代价总和相当于从后往前扫一遍合并的代价, 是 $O(n\log n)$ 的.</p><p>此时把序列分块, 要求每一块大小都小于一个选定的阈值B(贪心的分即可), 再在这个上面跑莫队, 那么左端点移动就是 $O(Bm)$ .</p><p>而右指针的复杂度要求总块数, 如果一个块的大小小于 $\frac {B}{2}$ , 那么它下一个数一定要大于 $\frac {B}{2}$ , 所以这样的块个数是 $\frac {2n\log n}{B}$ 的, 于是块个数也正确了</p><p>最后拿这个分块方式跑回滚莫队, 复杂度应该是 $O(\frac {n^2\log^2 n}{B}+Bm)$ , 取 $B&#x3D;\frac {n\log n}{\sqrt m}$ </p><h3 id="P5398-Ynoi2018-GOSICK-大分块-分块-思维-莫队"><a href="#P5398-Ynoi2018-GOSICK-大分块-分块-思维-莫队" class="headerlink" title="P5398 [Ynoi2018] GOSICK [大分块] [分块] [思维] [莫队]"></a>P5398 [Ynoi2018] GOSICK [大分块] [分块] [思维] [莫队]</h3><p>十四分块是二次离线莫队这件事已经众所周知了. . . 而且它也确实是二次离线莫队最擅长的点对贡献模式</p><p>所以考虑如何莫队, 当一个数加入区间时, 贡献分成两部分, 它的倍数和因数, 这两块要分开考虑.</p><p>为了方便设 $f(l, r, x)$ 表示位置 $x$ 对区间 $[l, r]$ 的贡献, 同时记 $f&#x3D;f_1+f_2$ , 分别是因数的贡献和倍数的贡献.</p><p>于是离线差分后贡献变成了两部分, 一部分是 $f(1, r, r)$ 或 $f(1, r-1, r)$ , 另一部分是f(1, l-1, r), 为了方便, 我们可以钦点自己不对自己产生贡献, 则可以把 $f(1, r, r)$ 当成 $f(1, r-1, r)$ 使用, 接下来单独讨论四种贡献的维护</p><ol><li>预处理 $f_1(1, r, r-1)$ , 只需要扫一遍序列, 扫的过程维护一个桶记录所有数的出现次数, 到一个数时暴力枚举因数加入答案即可.</li><li>预处理 $f_2(1, r, r-1)$ , 仍然扫一遍序列, 扫的过程维护一个桶, 位置 $i$ 表示值 $i$ 是多少个数的因数, 就可以直接统计了</li><li>计算 $f_2(1, l-1, r)$ , 那么就是离线之后扫描过程中维护情况2. 的桶即可</li><li>计算 $f_1(1, l-1, r)$ , 此时这种倍数类的容易想到根号分治, 设阈值为 $B$ :<ul><li>对于 $x\ge B$ , 暴力枚举倍数给答案加一</li><li>对于 $x&lt;B$ , $x$ 的数量较少, 考虑如何对每个 $x$  $O(n)$ 计算答案, 那么对于离线后的一个询问 $q(p, l, r)$ 表示 $[l, r]$ 中的点对前缀 $p$ 的贡献和时, 每个 $[l, r]$ 中的点贡献相同, 那么只要知道 $x$ 在前缀 $[1, p]$ 中出现的次数和区间 $[l, r]$ 中 $x$ 的倍数个数就能做了, 于是记录 $x$ 的出现次数和倍数个数的前缀和.</li></ul></li></ol><p>这题的解法就这样了, 不过还有一些优化:</p><ul><li>因数预处理存下来代替每次枚举</li><li>把对每个位置 $p$ 开 vector 记录 $q(p, l, r)$ 改为一起存进一个数组排序</li><li>快读快写</li><li>阈值开小! $\sqrt {5\times 10^5} \approxeq 700$ , 但我确实是开70左右能过.</li></ul><h3 id="P5309-Ynoi2011-初始化-分块-思维"><a href="#P5309-Ynoi2011-初始化-分块-思维" class="headerlink" title="P5309 [Ynoi2011]初始化 [分块] [思维]"></a>P5309 [Ynoi2011]初始化 [分块] [思维]</h3><p>容易想到根号分治, 修改时 $x&gt;\sqrt n$ 可以直接暴力, 那么只要考虑剩下的部分.</p><p>此时x只有 $\sqrt n$ 种, 可以思考能不能对于一个询问单独计算每个 $x$ 的贡献加起来, 考虑对于相同的 $x$ , 如果把序列按 $x$ 为块长分块, 那么整块每一块被加的量相同. 而对于散块, 能贡献到一个块内区间的 $y$ 是一个连续区间, 所以可以以 $y$ 为下标开前缀和记录 $y\in[1, i]$ 的修改的 $z$ 之和, 散块就也解决了, 修改时暴力修改前缀和即可. 复杂度 $n\sqrt n$ </p><p>还提过一个时间分块的想法, 但这个东西很难 $O(n)$ 重构, 就算重构也就是上面的做法所以寄了.</p><h3 id="P6774-NOI2020-时代的眼泪"><a href="#P6774-NOI2020-时代的眼泪" class="headerlink" title="P6774 [NOI2020] 时代的眼泪"></a>P6774 [NOI2020] 时代的眼泪</h3><blockquote><p>给定一个长 $n$ 排列, $m$ 次询问区间内值在某一区间的顺序对. $n\le 10^5, m\le 2\times 10^5$ .</p></blockquote><p>我是十代的眼泪.</p><p><img src="/img/2022-07-13-19-57-00-image.png"></p><p>有</p><p>$$<br>\begin{aligned}<br>&amp;ans(ABCD)\<br>&#x3D;&amp;ans(AB)+ans(CD)+ans(AC)+ans(BD)\<br>&amp;-ans(A)−ans(B)−ans(C)−ans(D)+size(A)\times size(D)​<br>\end{aligned}<br>$$ </p><p>可以建立树套树, 内层节点对应二维平面上的一个矩形, 则可以分治求出每个矩形的 $ans, size$ .</p><p>那么接下来考虑如何处理询问, 每个询问在图上会拆成 $\log^2 n$ 个矩形, 那么贡献成了三部分:</p><ul><li><p>每个小矩形内部的, 第一步已经预处理结束.</p></li><li><p>所有不同行且不同列的矩形, 这个的贡献相当于每个矩形左下方的矩形的 $size$ 的和. 可以一边遍历矩形一边求出.</p></li><li><p>同一行或同一列的, 行和列情况显然相同, 这仍然是一个二维矩形顺序对问题, 但好处是有一重限制为线段树的节点对应区间, 可以每个节点跑一遍二次离线莫队或分块. 对于复杂度, 考虑对每节点分别考虑, 若当前节点位于第 $k$ 层, 则复杂度为 $\dfrac{n}{2^k}\sqrt {q}$ , 这里 $q$ 是拆分到这个节点的询问, 然后我们在按层考虑, 每个询问会被拆成 $\log n$ 个节点, 但同一层只有两个, 所以每一层的询问总数为 $2m$ , 那么又因为发现当所有 $p$ 都相等的时候最大所以复杂度为 $n\sqrt{\dfrac{q}{2^k}}$ , 累加每一层的即为 $n\sqrt q \times \sum_i \dfrac{1}{\sqrt{2}^i}$ , 后面那个式子收敛于 $1+\sqrt 2$ 的位置为常数, 所以复杂度仍为 $n\sqrt q$ .</p></li></ul><p>于是不卡空间的版本就做完了.</p><p>这个题启发了一种分治套分块的做法, 使得若分治后每一层的 $\sum a_i$ 和 $\sum b_i$ 一定, 则每个节点 $a_i\sqrt b_i$ 的复杂度套上分治后仍为 $n\sqrt n$ .</p><h3 id="P8349-SDOI-x2F-SXOI2022-整数序列"><a href="#P8349-SDOI-x2F-SXOI2022-整数序列" class="headerlink" title="P8349 [SDOI&#x2F;SXOI2022] 整数序列"></a>P8349 [SDOI&#x2F;SXOI2022] 整数序列</h3><blockquote><p>给定整数序列 $a$ , $b$ , $q$ 次给定两个参数 $x$ , $y$ , 询问若构造序列 $c$ 满足 $c_i&#x3D;[a_i&#x3D;x]-[a_i&#x3D;y]$ , 则找出区间 $[l, r]$ 最大化 $\sum_i&#x3D;l^r b_i\times [c_i\ne 0]$ , 且满足 $\sum_i&#x3D;l^r c_i&#x3D;0$ .<br>$n\le 3\times 10^5, q\le 10^6, \vert b_i\vert \le 10^9, a_i\le n$ </p></blockquote><p>SDOI噩梦的开始, 送zrz退役的题</p><p>首先暴力做法和根号分治还都挺明显的, 暴力就是我们可以处理出所有数的位置, 每次归并两个数的位置, 然后搞一搞 $\sum b_i\times [c_i\ne 0]$ , $\sum c_i$ 的前缀和就可以了. 也容易想到对出现次数分治, 设阈值为 $B$ , 问题变为:</p><h4 id="两数出现次数均小于-B"><a href="#两数出现次数均小于-B" class="headerlink" title="两数出现次数均小于 $B$ :"></a>两数出现次数均小于 $B$ :</h4><p>刚才的暴力, 复杂度 $O(qB)$ . 上</p><h4 id="两数出现次数均超过-B"><a href="#两数出现次数均超过-B" class="headerlink" title="两数出现次数均超过 $B$"></a>两数出现次数均超过 $B$</h4><p>仍然是刚才的暴力, 但考场上错误的估计复杂度后直接寄飞.</p><p>设出现次数多于 $B$ 的出现次数分别为 $s_1, s_2. . . s_k$ , 复杂度显然是 $\sum_i \sum_j s_i+s_j \le nk \le \dfrac{n^2}{B}$ .</p><h4 id="一大一小"><a href="#一大一小" class="headerlink" title="一大一小"></a>一大一小</h4><p>这是最困难的部分了, 不过据说如果不会做这个在上一个基础上暴力判断小的次数为 $1$ 可以过题</p><p>但zrz一眼就秒了啊! 如果把小的插入到大的里面, 对于小的连续的长 $len$ 一段, 因为有 $c$ 的和为 $0$ 的限制, 所以其最多向左向右拓展 $len$ 个出现次数多的数就结束了, 于是只要暴力找出每个连续段向左向右的这些数, 再和小的本身的位置归并到一起, 然后用最初的暴力只跑这 $O(B)$ 个数即可.</p><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>于是你就切完了这题, 然而细节还挺多的, 包括:</p><ul><li>一大一小不能只向左右找 $len$ 个, 而要找 $len+1$ 个, 否则会出现忽略两个连续段中间的东西把两个连续段最左最右形成一个区间的情况.</li><li>搞连续段的时候不要重复添加中间的数, 主要是这一段的下标处理细节比较多.</li><li>$\sum c_i$ 显然可以是负的, 谁把它直接放数组下标里了我不说.</li></ul><h3 id="科技-分散层叠"><a href="#科技-分散层叠" class="headerlink" title="[科技]-分散层叠"></a>[科技]-分散层叠</h3><p>神仙科技, 因为常常用来优化多块二分所以放在这里了. 不过好像EI的论文里可以用这个实现 $O(\log n\alpha (n))$ 插入线段, $O(\log n)$ 询问单点最大值的科技啊.</p><h4 id="分散层叠模板"><a href="#分散层叠模板" class="headerlink" title="分散层叠模板"></a>分散层叠模板</h4><blockquote><p>给定 $k$ 个长均为 $n$ 的序列 $a$ , $q$ 次询问 $x$ 在每个序列的非严格后继(恰好大于等于的数).<br>要求 $O(nk)$ 预处理, $O(q\log n + qk)$ 查询.</p></blockquote><p>对每个序列 $a_i$ 建立序列 $b_i$ , $next_i$ , $cur_i$ :</p><ul><li>$b_{i, j}$ 表示 $b_{i-1}$ 中所有偶数位置(即 $b_{i-1, 2k}$ )与 $a_i$ 归并起来的结果, 若 $i&#x3D;1$ 则 $b_i&#x3D;a_i$ .</li><li>$cur_{i, j}$ 表示 $b_{i, j}$ 在 $a_i$ 中非严格后继的下标.</li><li>$next_{i, j}$ 表示 $b_{i, j}$ 在 $b_{i-1}$ 中非严格后继的下标.</li></ul><p>$b$ 通过每次归并就得到了, 而 $cur$ 和 $next$ 可以在归并过程中维护得到.</p><p>而查询的时候, 只要先从 $b_k$ 进行一次二分, 然后通过 $next$ 得到每一层的答案, 具体原理是, 若 $x$ 在 $b_i$ 的后继为 $b_{i, j}$ , 则其 $b_{i-1}$ 的实际后继下标与 $next_{i, j}$ 之差不超过1. 原因是考虑 $b_{i-1}$ 每隔一个就有一个在 $b_i$ 中.</p><p>实现起来会发现, 查询非严格后继和非严格前驱分别应在递增和递减序列里二分, 而严格的应分别在两者上直接减一.</p><p>你发现这个就很像从上一层渗透下来一部分和这一层融合到一起, 这样层层渗透下来, 所以被称为分散层叠.</p><h4 id="简单拓展"><a href="#简单拓展" class="headerlink" title="简单拓展"></a>简单拓展</h4><p>如果不是每次渗透 $\dfrac{1}{2}$ 呢? 发现若每层渗透 $\dfrac{1}{p}$ , 则位置差少于 $p$ . 使得修改复杂度降低而查询复杂度增加.</p><p>同时, 我们这里渗透的结构是一层链( $i$ 渗透向 $i+1$ ), 实际上其可以是一个 $DAG$ , 或者更为有用的, 树.</p><p>但一考虑到修改这玩意就出问题了, 于是有了下面的技术让其支持修改.</p><h4 id="线段树分散层叠"><a href="#线段树分散层叠" class="headerlink" title="线段树分散层叠"></a>线段树分散层叠</h4><p>于是根据拓展部分的思考, 就有了这样的技术.</p><p>仍然是 $k$ 个序列的情况, 我们把渗透建一棵线段树, 由两个儿子各渗透 $\dfrac{1}{2}$ 得到父亲, 那么:</p><p>修改时, 我们从儿子出发, 会需要重新处理叶子到根一条链的信息. 若每次渗透 $\dfrac{1}{2}$ , 则单次渗透复杂度是 $O(n)$ , 修改复杂度为 $\log k$ . 然而平衡一下发现, 若每次渗透 $\dfrac{1}{p}, p&gt;2$ , 则级数 $n+2n&#x2F;p+4n&#x2F;p^2+. . .$ 收敛, 复杂度就变成了线性.</p><p>接下来是查询, 查询单点随便做, 查询区间不可避免的带了区间长度的线性, 因为每次必须递归到叶子, 复杂度 $O(len+\log k)$ .</p><p>于是你发现这个东西用于多块二分刚刚好, 每个叶子对应一个块的话, 原来点名被卡 $O(\sqrt {n\log n})$ 就成了美妙的 $n\sqrt n+n\log n&#x3D;n\sqrt n$ </p><h4 id="例题-由乃打扑克"><a href="#例题-由乃打扑克" class="headerlink" title="例题: 由乃打扑克"></a>例题: 由乃打扑克</h4><blockquote><p>区间加, 区间 $kth$ .</p></blockquote><p>发现区间加中间直接打标记不用动, 只要改散块, 把散块重新来一遍, 中间块打标记即可. 知道这个之后直接用裸的两层二分就实现了在线+空间线性+ $n\sqrt {n\log n}$ .</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 分块 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp选做</title>
      <link href="/2022/05/18/dp/"/>
      <url>/2022/05/18/dp/</url>
      
        <content type="html"><![CDATA[<h1 id="dp选做"><a href="#dp选做" class="headerlink" title="dp选做"></a>dp选做</h1><p>省选dp挂了不会来补一补</p><h2 id="刷题记录-2022暑假前"><a href="#刷题记录-2022暑假前" class="headerlink" title="刷题记录-2022暑假前"></a>刷题记录-2022暑假前</h2><h3 id="UVA1626-括号序列-dp-区间dp"><a href="#UVA1626-括号序列-dp-区间dp" class="headerlink" title="UVA1626 括号序列 [dp] [区间dp]"></a>UVA1626 括号序列 [dp] [区间dp]</h3><p>区间dp(似乎括号类的都是区间dp? )</p><p>设 $f_{l, r}$ 表示把区间l到r中补到合法的操作步数, 则转移是:</p><ul><li>最外侧是匹配的括号: $f_{l, r}&#x3D;f_{l+1, r-1}\ \ s. t. \ s_l&#x3D;s_r$</li><li>区间由若干 $f_{l, r}&#x3D;\min_{l\le k\le r}{f_{l, k}+f_{k+1, r} }$</li><li>在最右侧添加一个与最左侧的括号匹配的括号或相反, 发现这种情况不优于直接在与这个新添加的括号匹配的括号旁边直接匹配</li></ul><p>然后初始情况就是 $f_{i, i}&#x3D;2$ , 表示为每个括号加一个反括号匹配</p><p>这题输出方案, 所以记录最有解位置即可.</p><h3 id="P1220-关路灯-dp-区间dp"><a href="#P1220-关路灯-dp-区间dp" class="headerlink" title="P1220 关路灯 [dp] [区间dp]"></a>P1220 关路灯 [dp] [区间dp]</h3><p>由于老王走过去关一盏灯时顺手关掉路上经过的一定不劣, 所以被关掉的灯是一个区间, 于是记 $f_{l, r}$ 表示已经被关了的灯的区间, 发现这样转移不了, 比如当我们向右扩展一位时我们不知道老王是刚刚关完左端点的灯还是右端点的, 所以设 $f_{l, r, 0&#x2F;1}$ 表示区间 $[l, r]$ 已经关掉, 老王此时正在左端点或右端点转移即可.</p><h3 id="UVA1362-Exploring-Pyramids-dp-区间dp-计数dp"><a href="#UVA1362-Exploring-Pyramids-dp-区间dp-计数dp" class="headerlink" title="UVA1362 Exploring Pyramids [dp] [区间dp] [计数dp]"></a>UVA1362 Exploring Pyramids [dp] [区间dp] [计数dp]</h3><p>每个子树对应欧拉序上一段区间, 可以区间dp统计答案</p><p>设 $f_{l, r}$ 表示 $[l, r]$ 这段区间的方案数, 转移就是枚举第一棵子树划分到哪里, 即</p><p>$$<br>f_{l, r}&#x3D;f_{l+1, k-1}*f_{k+1, r-1}\ s. t. \ s_k&#x3D;s_l&#x3D;s_r\ \mathrm{and}\ k\in[l+2, r-2]<br>$$</p><p>$s$ 为颜色区间, 因为 $l$ , $r$ , $k$ 对应的都是根的颜色.</p><h3 id="P7914-CSP-S-2021-括号序列-dp-区间dp-计数dp"><a href="#P7914-CSP-S-2021-括号序列-dp-区间dp-计数dp" class="headerlink" title="P7914 [CSP-S 2021] 括号序列 [dp] [区间dp] [计数dp]"></a>P7914 [CSP-S 2021] 括号序列 [dp] [区间dp] [计数dp]</h3><p>仍然区间dp</p><p>$f_{i, j}$ 表示区间 $[i, j]$ 的方案数, 则转移就是同UVA1626最外层相等的情况和中间划分的情况, 但这题要求方案数, 发现对于中间划分时, 形如”()()()”的括号既可以划分成”()+()()”也可以划分成”()()+()”, 会被计算多次, 所以设 $g_{l, r}$ 表示 $l$ 和 $r$ 恰好匹配的情况, 转移就成了 $f_{l, r}&#x3D;g_{l, k}*f_{k+1, r}$ , 然后考虑亿点点细节.</p><h3 id="P5504-JSOI2011-柠檬-dp-斜率优化"><a href="#P5504-JSOI2011-柠檬-dp-斜率优化" class="headerlink" title="P5504 [JSOI2011] 柠檬 [dp] [斜率优化]"></a>P5504 [JSOI2011] 柠檬 [dp] [斜率优化]</h3><p>首先显然相当于把序列划分成若干段的方案</p><p>重要结论是<strong>对于划分的每一段, 两端点贝壳大小相同</strong>, 否则把它划分到其他部分或单独成段一定不劣.</p><p>所以我们可以只考虑相同颜色的转移, 令 $f_i$ 表示考虑前i个的答案, $cnt_i$ 表示第i个贝壳的大小包含它的前缀中的出现次数, $size_i$ 表示它的大小, 则转移可以枚举前面的j, 就是</p><p>$$<br>\begin{aligned}<br>f_i&amp;&#x3D;f_{j-1}+size_i\times(cnt_i-cnt_j+1)^2\\<br>   &amp;&#x3D;f_{j-1}+size_i\times cnt_i^2+size_i\times cnt_j^2+size_i\\<br>   &amp;\ \ \ \ -2size_i\times cnt_i\times cnt_j - 2size_i\times cnt_j+2size_i\times cnt_i\\<br>\end{aligned}\\<br>$$</p><p>发现可以斜率优化, 所以整理式子:</p><p>$$<br>\begin{aligned}<br>(2size_i\times cnt_i)\times (cnt_j) \\<br>+(f_i-size_i\times cnt_i^2-size_i-2size_i\times cnt_i) \\<br>&#x3D;f_{j-1}+size_j\times cnt_j^2-2size_j\times cnt_j<br>\end{aligned}\\<br>$$</p><p>这里用到刚才结论 $size_i&#x3D;size_j$ , 式子中的四个括号分别是直线的 $k$ , $x$ , $b$ , $y$ .</p><p>注意式子对颜色不相同的情况是不成立且不保证答案更小的, 所以要对每种颜色单独维护凸包. 右发现对于同种颜色, $cnt_j$ 和 $2size_i\times cnt_j$ 单调增, 所以用单调栈维护上凸壳即可.</p><p>[trick] 先分类再每一类分别进行斜率优化的dp</p><h3 id="P3515-POI2011-Lightning-Conductor-dp-决策单调性"><a href="#P3515-POI2011-Lightning-Conductor-dp-决策单调性" class="headerlink" title="P3515 [POI2011]Lightning Conductor [dp] [决策单调性]"></a>P3515 [POI2011]Lightning Conductor [dp] [决策单调性]</h3><p>每个点 $i$ 对后面的贡献函数是 $\sqrt x$ 的平移, 发现一旦一个决策点的答案到另一个之上, 另一个再也没有机会反超, 所以这个题满足决策单调性.</p><p>于是有几种可以的方法利用决策单调性:</p><ul><li>分治法: 设当前区间为 $[l, r]$ , 可能的决策在 $[pl, pr]$ , 每次扫一遍算出序列上mid的答案, 则 $[l, mid-1]$ 中决策点在 $[pl, p]$ 中 $[mid+1, r]$ 中决策点在 $[p, pr]$ 中, 可以递归处理</li><li>单调队列或栈, 此题为单调队列: 用容器存储三元组 $(l, r, p)$ 表示以p为最有决策点的区间为 $[l, r]$ , 每次加入一个节点时, 如果它最后也不优秀就不用管, 否则二分出它和队尾的决策点切换的分界点 $k$ , 即它在 $[k, n]$ 更优秀而队尾在 $[l, k]$ 更优秀, 把原本队尾的区间修改并把它push进去</li><li>SMAWK: to do <del>等我先学会了</del></li></ul><p>分治法适用于离线决策单调性, 即 $f_i$ 的计算不依赖 $f_{[1, n]}$ 的答案, 而单调队列或栈的方法适用于可以快速计算在某个决策点下的答案的情况.</p><p>这种相同凸函数的平移, 常常存在决策单调性, 还有常见的 $y&#x3D;\max{(a(x-b), c)}$ 和 $y&#x3D;ax^2+bx+c$ , 其中要求所有a均相同, b单调(不单调可能也行? )</p><h3 id="P2497-基站建设-P4655-Build-Bridges-斜率优化-dp-李超树-cdq分治"><a href="#P2497-基站建设-P4655-Build-Bridges-斜率优化-dp-李超树-cdq分治" class="headerlink" title="P2497 基站建设, P4655 Build Bridges [斜率优化] [dp] [李超树] [cdq分治]"></a>P2497 基站建设, P4655 Build Bridges [斜率优化] [dp] [李超树] [cdq分治]</h3><p>   方程过于模板了不放了.</p><p>   推出方程后可以斜率优化, 没什么单调性所以用李超树或cdq或平衡树或二进制分组维护斜率优化dp, 基站建设注意第一步要初中几何一下.</p><h3 id="P4027-NOI2007-货币兑换-dp-斜率优化-李超树-cdq分治"><a href="#P4027-NOI2007-货币兑换-dp-斜率优化-李超树-cdq分治" class="headerlink" title="P4027 [NOI2007] 货币兑换 [dp] [斜率优化] [李超树] [cdq分治]"></a>P4027 [NOI2007] 货币兑换 [dp] [斜率优化] [李超树] [cdq分治]</h3><p>设 $f_i$ 表示第i天能拥有多少钱(在把所有券都卖光的情况), 转移就是考虑它能卖的券是之前的哪一天买的, 但这题给的比较麻烦, 首先要做一些转换, 设 $a_i, b_i, c_i, d_i, r_i$ 分别为两种券的钱数, 两种券的数量和题目中的 $Rate_i$ , 列出方程:</p><p>$$<br>\begin{cases}<br>a_ic_i+b_id_i&#x3D;f_i\\<br>\frac {c_i} {d_i}&#x3D;r_i<br>\end{cases}<br>$$</p><p>解出来得到:</p><p>$$<br>\begin{cases}<br>c_i&#x3D;\frac{f_ir_i}{r_ia_i+b_i}\\<br>d_i&#x3D;\frac{f_i}{r_ia_i+b_i}<br>\end{cases}<br>$$</p><p>于是方程就是:</p><p>$$<br>\begin{aligned}<br>f_i&amp;&#x3D;c_ja_i+d_jb_i\\<br>\frac {f_i}{b_i}&amp;&#x3D;c_j\frac {a_i}{b_i}+d_j\\<br>\end{aligned}<br>$$</p><p>现在就已经是斜率优化的形式了, 对于这种没有单调性的题目, 常见做法是cdq, 李超树和平衡树维护, 个人感觉李超树是最简单好用的. 复杂度 $O(n \log n)$</p><p>实现细节: 注意这里李超线段树的下标域是 $[1, 10]$ 的有理数, 可以先把所有 $\frac {a}{b}$ 离散化, 加速并不用卡精度.</p><h3 id="HDU4991-Ordered-Subsequence-dp-线段树-树状数组"><a href="#HDU4991-Ordered-Subsequence-dp-线段树-树状数组" class="headerlink" title="HDU4991 Ordered Subsequence [dp] [线段树] [树状数组]"></a>HDU4991 Ordered Subsequence [dp] [线段树] [树状数组]</h3><p>真正的线段树树状数组优化dp模板, 然而我是先做的后面那个基站选址, 但它更模板所以被我放到前面</p><p>首先暴力式子应该还挺显然的, 设 $f_{i, j}$ 表示以第 $i$ 个结尾, 长度为 $j$ 的LIS长度, 式子就是</p><p>$$<br>f_{i, j}&#x3D;\sum_{k &lt; i, a_k &lt; a_i} {f_{k, j-1} }<br>$$</p><p>初始条件 $f_{i, 1}&#x3D;1$</p><p>然后和基站选址类似的是它的 $m$ 最大100, 可以承受 $O(nm\log n)$ , 所以把j改为在外层枚举, 考虑优化式子</p><p>$$<br>f_i&#x3D;\sum_{k &lt; i, a_k &lt; a_i} f_k<br>$$</p><p>然后就是简单二维数点求和, 这里可以线段树也可以离散化后树状数组上</p><h3 id="P2605-基站选址-dp-线段树"><a href="#P2605-基站选址-dp-线段树" class="headerlink" title="P2605 基站选址 [dp] [线段树]"></a>P2605 基站选址 [dp] [线段树]</h3><p>首先要推出暴力dp式子, 设 $f_{i, j}$ 表示考虑前i个村庄, 在第i个村庄建了第j个基站的花费, 这里<strong>不考虑i到n部分的赔偿</strong>, 记 $i$ 到 $j$ 部分的补偿为 $cost(i, j)$ , 第i个村庄建立基站的花费为 $c_i$ , 则转移就是看上一个基站在哪:</p><p>$$<br>f_{i, j}&#x3D;\min_l {f_{l, j-1}+cost(l, i)} + c_i<br>$$</p><p>暴力转移为 $O(n^2k)$ , 发现这里n很大而j不大, 所以可以只优化i的转移, 外层暴力枚举j, 另外发现式子只和 $j-1$ 有关, 可以滚动掉一维空间, 式子就成了</p><p>$$<br>f_{i}&#x3D;\min_l {f_{k}+cost(k, i)} + c_i<br>$$</p><p>困难在于计算 $cost(k, i)$ , 正向计算在 $f_i$ 时哪些村庄在选 $k$ 时要赔偿较为困难, 可以反过来想对于每个村庄选择那些 $k$ 需要时需要赔偿这个村庄, 首先可以预处理对于每个村庄向左右最远到哪里建设不需要赔偿, 分别记为 $l_k$ , $r_k$ , 则对于一个村庄, 仅当处理到的 $i&gt;r_k$ 且选择的 $k &lt; l_k$ 时需要赔偿, 所以可以数据结构维护 $f_{k}+cost(k, i)$ , 则转移时就是查询 $[1, i-1]$ 的区间最小值, 每次处理完 $i$ 后, 对于所有 ${r_i&#x3D;l_k}$ 的村庄, 如果k在 $[1, r_i]$ 中需要赔偿, 所以给这个区间加上它的赔偿费用, 由于是区间加, 区间最小值, 可以使用线段树完成</p><p>第一次做线段树优化dp, 所以开始找其他类似题目. . .</p><h3 id="CF675E-Trains-and-Statistic-dp-贪心-RMQ"><a href="#CF675E-Trains-and-Statistic-dp-贪心-RMQ" class="headerlink" title="CF675E Trains and Statistic [dp] [贪心] [RMQ]"></a>CF675E Trains and Statistic [dp] [贪心] [RMQ]</h3><p>然后发现被骗了, 这题并不需要线段树优化dp, 因为这就一个RMQ根本不用线段树. . .</p><p>首先发现如果我们能到达 $i$ , 则一定能到达任意 $j s. t. \ j &lt; i$ , 因为我们可以在任意时刻中途下车</p><p>由于上面的性质, 可以对每个i找出 $\max_j{a_j}\ s. t. j\in[i, a_i]$ , 这个 $j$ 的意义是如果我们要走的这次到不了, 那么应该走到 $j$ , 记它为 $next_i$<br>这个可以用静态RMQ直接求, 我觉得猫树最<del>可爱</del>容易理解而好用</p><p>要求的这个答案应该可以想到计算对于每一个i的 $\sum_j {\mathrm{dis}(i, j)}$ , 记为 $f_i$ , 要想办法求 $f_i$ , 你可以画出下面的示意图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">       -------------------</span><br><span class="line">                                   -------</span><br><span class="line">       ^                  ^       ^       ^</span><br><span class="line">       i                nxt[i]  a[i]      n</span><br></pre></td></tr></table></figure><p>发现对于 $f_i$ 相比 $f_{nxt_i}$ 有两段距离增加, 一段是 $[i+1, nxt_i]$ , 是原来不需要走的, 另一段是 $[a_i+1, n]$ , 需要先用一步走到 $nxt[i]$ 再继续走, 所以转移为</p><p>$$<br>f_i&#x3D;f_{nxt_i} + (n - a_i) + (nxt_i - i)<br>$$</p><p>倒序递推即可</p><h3 id="CF946G-Almost-Increasing-Array-dp-树状数组"><a href="#CF946G-Almost-Increasing-Array-dp-树状数组" class="headerlink" title="CF946G Almost Increasing Array [dp] [树状数组]"></a>CF946G Almost Increasing Array [dp] [树状数组]</h3><p>我认为这个也不是严格的线段树优化dp, 它只是在值域上树状数组维护最大值而已</p><p>首先套路的可以把每个数减去他们的下标, 把问题转化为非严格递增, 这样转化的好处是, 我们可以任意在两个数中间添加一个值, 而原来如果这两个数相邻我们不能添加小数.</p><p>然后可以反向思考能留下哪些, 发现留下的就是已有的非严格LIS, 所以我们要在<strong>可以删一个数的前提</strong>下求这个LIS</p><p>思考删除这个数造成哪些影响, 发现对于它后面的每个数, 删去它后下标前进了一个, 也就是变大了一个</p><p>于是在原有LIS的dp上进行修改, 设 $f_{i, 0&#x2F;1}$ 表示考虑前i个, 是否已经删除过一个数, 则转移有三种:</p><ul><li>尚未删除任何数: $f_{i, 0}&#x3D;\max {f_{j, 0} } + 1, \ s. t. \ j &lt; i, a_j\le a_i$</li><li>已经删除过一个数: $f_{i, 1}&#x3D;\max {f_{j, 1} } + 1, \ s. t. \ j &lt; i, a_j\le a_i$</li><li>现在正要删一个数, 仍然考虑子序列里上一个数是谁, 因为这个与上一个间删除了一个数, 所以这个数的值变大了1, 所以式子为 $f_{i, 1}&#x3D;\max {f_{j, 0} } + 1, \ s. t. \ j &lt; i, a_j\le a_i+1$</li></ul><p>然后用树状数组记录值域上前缀max即可</p><h3 id="CF739E-Gosha-is-hunting-dp-wqs二分-二维wqs二分-费用流"><a href="#CF739E-Gosha-is-hunting-dp-wqs二分-二维wqs二分-费用流" class="headerlink" title="CF739E Gosha is hunting [dp] [wqs二分] [二维wqs二分] [费用流]"></a>CF739E Gosha is hunting [dp] [wqs二分] [二维wqs二分] [费用流]</h3><p>这题可以从费用流考虑, 从源点连到左边一排点表示宝可梦, 边权为2, 费用为0, 从宝可梦连向右边两个点表示两种球, 这一步边权为1, 费用为用这个球能捉住的概率, 从右边的球向汇点连边, 容量 inf , 边权为0, 但是发现同时对一个宝可梦使用两种球时还要减去两个同时发生的概率(独立事件), 所以把源点到宝可梦的每条边拆成两个, 一个容量为1边权为0, 另一个容量为1边权为两概率相乘, 就有了一个费用流做法, 已经可以通过.</p><p>有了费用流能说明关于流量(使用球总个数)有凸性, 所以可以进行二分一种球的使用数量把朴素的 $O(n^3)$ dp优化成 $O(n^2)$ 的, 然后又可以二分另一种的优化成 $O(n \log^2 n)$ 的, 可以更稳通过此题</p><p>然而这个题直接这么两重wqs二分是假的, 一重wqs二分时有两种写法, 分别找到:</p><ul><li>最大的斜率满足使用球数小于要求的</li><li>最小的斜率满足使用球数大于要求的</li></ul><p>这两个的选择要和二分时的 check 函数相对应, 比如题目 P4694 Raper 中有些买光盘决策收益为0, 这类光盘如果不购买则使用个数较少, 购买则个数较多, 分别对应前面两种情况, 所以二分时是要有这种对应的, 而当拓展到二维时, 就需要我们找到两者都最少的, 这里以谁为第一关键字似乎是个问题. 目前有两种解法:</p><ul><li>给每个数再加一个很小的随机权值, 直接避免出现这类二分遇到直线和平面的情况</li><li>二分过程中mid不再等于l+r, 而是等于两者之间的一个随机位置, 这个样跑一次成功概率较小, 需要重复多次选一个答案最小的(来自机房大佬qyc), 注意这种方法保证正确性的同时会TLE并不能通过</li></ul><p>所以还是很玄, 我再思考能不能在dp决策过程中使某个最小但仍然很困难. 有人有好办法了告诉我.</p><h3 id="P2619-Tree-I-wqs二分-最小生成树"><a href="#P2619-Tree-I-wqs二分-最小生成树" class="headerlink" title="P2619 Tree I [wqs二分] [最小生成树]"></a>P2619 Tree I [wqs二分] [最小生成树]</h3><p>是时候来点清新WQS二分了</p><p>凸性的证明是困难的(目前还没看到), 先尽量感性理解, 就是考虑总边数一定的情况下, 使用白边少时会需要用一些不优点黑边顶上, 多时要必须选一些不优的白边, 说明它是有一个谷的. . . 然后就不会了</p><p>在通过打表, 瞎猜等方式得到凸性之后就很简单了, 二分给每个白色边加上一个权值C(给所有黑色边也是一样), 再按照新的权值跑Kruskal, 统计有多少条白边去调整二分区间即可.</p><h3 id="P4983-忘情-wqs二分-斜率优化"><a href="#P4983-忘情-wqs二分-斜率优化" class="headerlink" title="P4983 忘情 [wqs二分] [斜率优化]"></a>P4983 忘情 [wqs二分] [斜率优化]</h3><p>中规中矩的wqs二分</p><p>首先把给的式子拆开后发现<del>npy很善良</del>其实就是 $(sum+1)^2$ , 那么不考虑段数情况下就是简单斜率优化, 考虑段数的情况就再使用wqs二分, 给每一段一个附加代价二分</p><p>这个题凸性证明由qyc给出, 先考虑原始dp方程, 即 $f_{i, j}$ 表示前 $i$ 个划分 $j$ 段, 则有</p><p>$$<br>f_{i, j}&#x3D;\min(f_{k, j-1}+(sum_i-sum_k)^2)<br>$$</p><p>对于类似 $f_{i, j}&#x3D;\min(f_{k, j-1}+w(k, i))$ 这种方程, 或者更泛化一些,<strong>对于在一个 DAG 上走k步从1走到n的最短路问题, 如果边权满足四边形不等式, 那么答案是关于k的凸函数</strong></p><p>然后再把sum变成前缀和形式拆开, 平方也拆开, 就有了一个显然斜率优化, 其中k和x都是单增多, 单调队列即可</p><h3 id="几个关于决策单调性-x2F-凸性结论"><a href="#几个关于决策单调性-x2F-凸性结论" class="headerlink" title="几个关于决策单调性&#x2F;凸性结论"></a>几个关于决策单调性&#x2F;凸性结论</h3><h4 id="wqs二分实现难点"><a href="#wqs二分实现难点" class="headerlink" title="wqs二分实现难点"></a>wqs二分实现难点</h4><p>为了统一, 把wqs二分中二分的值为 $C$ , 通过二分改变的题目要求的值为 $K$ , 答案为 $A$</p><p>问题主要是二分时二分区间变化的选择要与check函数相对应, 比如如果check函数选择的是给定 $C$ 下 $K$ 最小的, 那么二分时就应二分最大的小于等于 $K$ 的, 否则如果是给定 $C$ 下 $K$ 最大的, 则二分最小的大于等于 $K$ 的, 是一个十分重要的细节, 例子:</p><ul><li>Tree I中, 出现黑色白色边权值相同时, 如果选择白色边, 则相当于选择 $K$ 最小的, 我们要二分出最大的小于 $K$ 的</li><li>忘情中, 对于斜率优化中是否取等, 不取等相当于选择 $K$ 最小的, 要二分出最大都满足条件段数的</li><li>Gosha is hunting中, 对于遇到使用不使用球期望相同的情况, 选择不使用相当于 $K$ 最小, 要二分最大的球数小于 $K$ 的</li><li>Raper中对于获益为0的光盘是否要买也是相同的</li></ul><h4 id="凸性证明"><a href="#凸性证明" class="headerlink" title="凸性证明"></a>凸性证明</h4><ul><li>费用流问题, 费用是关于流量的凸函数</li><li>忘情中写的<strong>对于在一个 DAG 上走k步从1走到n的最短路问题, 如果边权满足四边形不等式, 那么答案是关于k的凸函数</strong></li><li>打表出奇迹</li><li>四边形不等式的一个思考方式, 首先只要证明 $f(l, r)+f(l-1, r+1)$ 与 $f(l-1, r)+f(l, r+1)$ 的关系, 其次一个常用方法是, 因为问题常常是每个位置有一个贡献, 这个贡献和区间的其他位置有关(而不是直接跟区间), 那就仅考虑 $l-1$ 位置从区间 $[l-1, r+1]$ 移动到 $[l, r]$ 的贡献</li></ul><h3 id="P4481-BJWC2018-序列合并-dp-区间dp"><a href="#P4481-BJWC2018-序列合并-dp-区间dp" class="headerlink" title="P4481 BJWC2018 序列合并 [dp] [区间dp]"></a>P4481 BJWC2018 序列合并 [dp] [区间dp]</h3><p>qyc说这是他童年阴影题, 然而他只用了两分钟就秒了</p><p>首先它长的这么像石子合并, 让人想到一个区间dp, 于是一种做法是记 $f_{l, r}$ 表示区间 $[l, r]$ 合并成一个的代价, 转移时就相当于要把这一段划分成k段, 所以可以用一个 $O(n^3)$ 的dp, 然后会得到一个五次方TLE做法</p><p>然后简单想一下发现对每个l向右跑一遍就能得到所有的r, 就成了四次方, 卡卡常就过了</p><p>不过还有一种长的更像区间dp的理解, 设 $f_{l, r, k}$ 表示把区间 $[l, r]$ 合并成k段, $g_{l, r}$ 表示这一段合并成一段的答案, 则方程就是</p><p>$$<br>\begin{aligned}<br>f_{l, r, k}&amp;&#x3D;g_{l, p}+f_{p+1, r, k-1} \ s. t. \ , k\ge 2 \<br>g_{l, r}&amp;&#x3D;\min f_{l, r, k} \ s. t. \ k \in [L, R] \<br>f_{l, r, 1}&amp;&#x3D;g_{l, r}<br>\end{aligned}<br>$$</p><h3 id="P4767-邮局"><a href="#P4767-邮局" class="headerlink" title="P4767 邮局"></a>P4767 邮局</h3><p>[结论] : 对于一个区间中的一个邮局, 若区间长度为奇数则邮局建在中位数上, 偶数则建在中间两个数的任意一个上<del>小学奥数经典</del></p><p>于是就可以考虑把原序列分成 $P$ 个区间, 每个区间里放一个邮局, 所以设 $f_{i, j}$ 表示前 $i$ 个村庄分了 $j$ 段(也就是建了 $j$ 个邮局)的代价, 转移即</p><p>$$<br>f_{i, j}&#x3D;\min f_{k, j-1}+cost(k+1, i)<br>$$</p><p>其中 $cost(l, r)$ 表示在区间 $[l, r]$ 中建立一个邮局的最小代价, 这个代价可以 $n^2$ 递推, 但我认为这种方法更好: 考虑知道中位数后, 距离就是对中位数两边的位置一一匹配后匹配位置间距离的和, 如图:</p><p><img src="https://raw.githubusercontent.com/FireInIceCode/imgs/main/imgs/202205291347317.png" alt="示意图"></p><p>可以结合图理解, 蓝色点表示村庄, 红色即表示一对位置的匹配, 总代价就是所有匹配点之间距离的和, 也就是右边的每个点位置分别减去左边每个点位置之和, 可以先处理一个前缀和之后 $O(1)$ , 用这个式子去做复杂度就成了 $O(n^2p)$ , 由于奇数偶数时的差异, 式子是</p><p>$$<br>cost(l, r)&#x3D;(sum_r-sum_{\lfloor \frac {l+r}{2} \rfloor})-(sum_{\lfloor \frac {l+r-1}{2} \rfloor}-sum_{l-1})<br>$$</p><p>接下来遍历能进行的优化策略, 式子有与 $k$ , $i$ 均有关的项废掉了单调队列, 这个项里与 $i$ , $k$ 相关的东西在下标里废掉了斜率优化, 只剩下wqs二分和决策单调性, 由于我在上面wqs二分总结的结论, 问题就转化为证明 $cost$ 满足四边形不等式</p><p>抛开式子会发现包含单调性的显然, 在原有区间上增加新村庄代价一定不会降低</p><p>对于四边形不等式的证明复杂一些, 首先因为 $x$ 单调递增, 所以 $sum$ 是凸函数, 此外在证明 $cost_{l, r}+cost_{l+1, r-1}\ge cost_{l+1, r}+cost_{l, r-1}$ 时会消掉所有 $sum_r$ 和 $sum_{l-1}$ , 剩下的可以套用琴生不等式证明</p><p>这样同时证明了四边形不等式和凸性, 单用四边形不等式可达到 $n^2$ 通过, 使用 wqs 二分和决策单调性可以达到 $n \log n\log v$</p><h2 id="汪娟的一套dp题"><a href="#汪娟的一套dp题" class="headerlink" title="汪娟的一套dp题"></a>汪娟的一套dp题</h2><h3 id="BJOI2019-光线"><a href="#BJOI2019-光线" class="headerlink" title="[BJOI2019]光线"></a>[BJOI2019]光线</h3><blockquote><p>若干层玻璃叠在一起, 一束光照到玻璃上时会有 $\dfrac{a}{100}$ 的光透过而 $\dfrac{b}{100}$ 的光反射. 不保证 $a+b&#x3D;100$ 求从一边射入1, 从另一边射出多少.<br>$n\le t\times 10^5$</p></blockquote><p>$f_{i, 0&#x2F;1, 0&#x2F;1}$ 表示第 $i$ 个玻璃从前&#x2F;后方向射进去光从前&#x2F;后出来的大小是进去的多少倍即可.</p><h3 id="SCOI2009-粉刷匠"><a href="#SCOI2009-粉刷匠" class="headerlink" title="[SCOI2009]粉刷匠"></a>[SCOI2009]粉刷匠</h3><blockquote><p>$n$ 条木板, 每条有 $m$ 个格子, 要被涂成0&#x2F;1, 每次只能选择一个木板上连续的一段涂成0&#x2F;1, 每个格子只能被涂一次, 只能粉刷 $t$ 次, 求能对多少.<br>$n, m\le 50, t\le 2500$</p></blockquote><p>考虑一条木板上的情况, 显然设 $f_{i, j}$ 表示前 $i$ 个涂了 $j$ 次的最多个数即可.</p><p>那么现在有多条木板, 做一个泛化背包合并即可. 复杂度 $nm^2$ 之类的</p><h3 id="P1373-小a和uim之大逃离"><a href="#P1373-小a和uim之大逃离" class="headerlink" title="P1373 小a和uim之大逃离"></a>P1373 小a和uim之大逃离</h3><blockquote><p>$n\times m$ 的网格, 每个格子上有一个数, 从任意格子开始任意格子结束, 每次向右或向下走一步. 手上有两个数初始都为 $0$ , 站在走到的第奇数个格子时(包括开始和结束格子)让第一个数加上网格上的数, 否则让第二个数加上. 每次加上之后都与 $k+1$ 取模. 求由多少种方案结束的时候两个数相同.<br>$n, m\le 800, k\le 15$ .</p></blockquote><p>如果从 $(1, 1)$ 起点是简单的, 设 $f_{i, j, k, l}$ 表示走到 $(i, j)$ 左右手分别是 $k$ , $l$ 的方案数, 复杂度 $n^2k^2$ .</p><p>可以进一步优化, 由于我们只关心是否相同, 可以用emiya家今天的饭的方法只记录差, 去掉一个 $k$</p><p>从任意位置结束只要求所有位置的dp值累加, 从任意位置开始只要每个位置转移的时候都额外算上这个位置的. 同时注意因为起始位置不同还要记录一维 $0&#x2F;1$ 表示这一步加给哪个数.</p><h2 id="CFdp乱做"><a href="#CFdp乱做" class="headerlink" title="CFdp乱做"></a>CFdp乱做</h2><p>是选择通过人数降序, 难度2600, 标签dp.</p><p>带有combination&#x2F;greedy的可能没有, 被收录到数数&#x2F;贪心中.</p><h3 id="CF1431G"><a href="#CF1431G" class="headerlink" title="CF1431G"></a>CF1431G</h3><blockquote><p>给一个 $n$ 个数的集合, 每轮A选一个不是最大值的数删掉, 然后B选一个比A选的大的数删掉, 并给得分累加两数的差, A希望最大得分, B希望最小得分, 求最后得分.</p><p>$n\le 400, k\le \lfloor \dfrac{n}{2} \rfloor$</p></blockquote><p>首先发现, 任意情况B选的一定是A选的后继, 只要B按照这个选就一定是最小的, 即使 $[1, 2, 3, 4]$ 中A选 $2$ , B选 $3$ 后下一次强制 $1$ 和 $4$ 也不比 $(3-1)+ (4-2)$ 更劣, 于是B的方案就是确定了. 所以实际上选出的是若干连续段, 对于一个连续段 $[l, l+2x-1]$ , 其得分为 $\sum_{i&#x3D;l}^{l+x-1}+ a_i-\sum_{i&#x3D;l+x}^{l+2x-1} a_i$</p><p>接下来就考虑A要如何选, 考虑dp, 设 $f_{i, j}$ 表示前 $i$ 个元素中, 两人选了 $2j$ 个数的情况下的得分, 转移是这个数不选或枚举最后选的一段, 复杂度 $nk^2$</p><p>注意这题只能Kotlin交哦.</p><h3 id="CF1740F-Conditional-Mix"><a href="#CF1740F-Conditional-Mix" class="headerlink" title="CF1740F Conditional Mix"></a>CF1740F Conditional Mix</h3><blockquote><p>给定 $n$ 个数, 每次可以把两个不交集合并起来, 求任意次合并后集合大小组成的可重集的方案数. 膜998244353.</p><p>$n\le 2000$</p></blockquote><p>值排序, 从小往大扫的好处是对不用考虑交.</p><p>$f_{i, j}$ 表示前 $i$ 个值, 组成 $j$ 个集合, 加入这一层的时候可以选择新开若干层或者加到已有的里面去. 但是 $S$ 只关心大小就死了.</p><p>考虑一个多重集 $S$ 合法当且仅当其和为 $n$ 并且降序排列时 $\sum_{i\in[1, k]} S_i\le \sum_{i\in [1, n]} \min(k, cnt_i)$ . $cnt_i$ 为数 $i$ 的出现次数.</p><p>感觉必要性比较显然(前 $k$ 个集合最多每个选 $1\ldots n$ 各一个), 充分性就直接体会把可以合并的拆开肯定是没问题的.</p><p>于是直接dp, 设 $f_{i, sum, last}$ 表示选了前 $i$ 个, 总和是 $sum$ , 最后一个是 $last$ 的即可. 复杂度 $n^3$ .</p><p>进一步分析, 考虑 $n\ge last\times i$ , 于是 $last$ 的取值是自然对数, 总复杂度就是 $n^2\log n$ 了.</p><p>[trick] 数数dp考虑最终合法判定</p><h3 id="CF321E-Ciel-and-Gondolas"><a href="#CF321E-Ciel-and-Gondolas" class="headerlink" title="CF321E Ciel and Gondolas"></a>CF321E Ciel and Gondolas</h3><blockquote><p>给定 $a_n$ , 要求你把它分成 $k$ 组, 若 $a_i$ 和 $a_j$ 分为一组会产生 $w_{i, j}$ 的代价, 最小化代价和.</p><p>$n\le 4000, k\le 800, w_{i, j}\ge 0$</p></blockquote><p>看一看发现是简单题, 显然 $cost(l, r)$ 是满足四边形不等式, 直接分治就结束了.</p><h3 id="CF631E-Product-Sum"><a href="#CF631E-Product-Sum" class="headerlink" title="CF631E Product Sum"></a>CF631E Product Sum</h3><blockquote><p>给定序列 $a_n$ , 移动一个数最大化 $\sum i\times a_i$</p><p>$n\le 2\times 10^5$</p></blockquote><p>可以先假定是往后移动, 再反过来做一遍即可.</p><p>考虑 $f_i$ 表示从某个位置插入到 $i$ 后面的答案最大值, 那么就是</p><p>$$<br>\max_j suf_{i+1}+pre_{i}-a_j j+a_j(i+1)+sum_i-sum_j<br>$$</p><p>直接斜率优化.</p><h3 id="CF662C-Binary-Table"><a href="#CF662C-Binary-Table" class="headerlink" title="CF662C Binary Table"></a>CF662C Binary Table</h3><blockquote><p>给定 $n\times m$ 01矩阵, 每次选择一行或一列翻转01, 求翻转任意次后1的个数的最小值.</p><p>$n\le 20, m\le 10^5$</p></blockquote><p>对每一种行的是否翻转情况, 列是否翻转是确定的. 只是不能直接计算.</p><p>猜到是FWT, 但不会. 做法是, 设 $a_i$ 表示 $i$ 这种状态的出现次数, $b_i$ 表示二进制数 $i$ 的0&#x2F;1个数的较小值, 那么当行的状态为 $S$ 的时候答案就是</p><p>$$<br>f_S&#x3D;\sum_T a_T\cdot b_{T\mathrm{xor}S}\<br>f_{S \mathrm{xor} T}&#x3D;a_S\cdot b_T<br>$$</p><p>于是直接FWT-XOR即可.</p><h3 id="CF1208F-Bits-And-Pieces"><a href="#CF1208F-Bits-And-Pieces" class="headerlink" title="CF1208F Bits And Pieces"></a>CF1208F Bits And Pieces</h3><blockquote><p>给定 $d_n$ , 求 $i&lt;j&lt;k$ 最大化 $d_i\mathrm{or}(d_j\mathrm{and}d_k)$</p><p>$n\le 10^6$</p></blockquote><p>又是FWT.</p><p>考虑从高到低贪心, 那么要确定是否有三个数这样运算起来包含一个前缀.</p><p>先解决后两个的与运算, 做一遍高维后缀和得到包含每个位置下标的最大值, 次大值即可.</p><p>然后再解决或, 做一遍高维前缀和得到每个位置被贡献的最小位置即可.</p><p>然后就简单贪心.</p><h3 id="CF1344C-Quantifier-Question"><a href="#CF1344C-Quantifier-Question" class="headerlink" title="CF1344C Quantifier Question"></a>CF1344C Quantifier Question</h3><blockquote><p>给定 $n$ 个变量 $x_n$ 和 $m$ 个关系, $m$ 个关系每个形如 $x_i&lt;&gt; x_j$ , 求序列 $q_n, q_i\in{\exists, \forall}$ , 使得拼出来 $q_i x_i$ 满足这 $m$ 个关系. 求最大的任意的个数和一个 $q$ 的方案, 或判断无解</p><p>我天什么烂题面, 举个例子:</p><p>假设 $n&#x3D;2, m&#x3D;1$ , 关系是 $x_1&lt;x_2$ , 那么可以 $\forall x_1, \exists x_2, x_1&lt;x_2$ , 不能 $\exists x_1, \forall x_2, x_1&lt;x_2$ 或两个都是 $\forall$ , 所以最大个数是1.</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>考虑建一个图, 若要求 $x_1&lt;x_2$ 则 $x_1\to x_2$ , 如果有环肯定无解, 注意到序列维和图上都是有意义的. 考虑若 $i&lt;j$ 且 $x_i\to x_j$ , 那么显然 $x_j$ 不能是任意, 如果有 $i&lt;j$ 且 $x_j\to x_i$ 同理, 于是一个点可以选当且仅当没有一个在它之前的点与它连通. 注意到有向图所以不能直接搞连通块, 而是类似dp的做法: $f_u$ 表示能走到 $u$ 的最小的, 那么 $f_u&#x3D;\min { u, \min f_v}\ s. t. \ v\to u$ 即可. 反着也是类似.</p><h3 id="CF6D-Lizards-and-Basements-2"><a href="#CF6D-Lizards-and-Basements-2" class="headerlink" title="CF6D. Lizards and Basements 2"></a>CF6D. Lizards and Basements 2</h3><blockquote><p>给定序列 $a_n$ , 每次可以选定 $i\in (1, n)$ , 对 $a_i$ 减去 $c_1$ , 对相邻的两个减去 $c_2$ , 问几次全小于0.</p><p>$n\le 10, 1\le c_2&lt;c_1\le 10, a_i\le 15$</p></blockquote><p>不是, 为啥数据范围有点小啊?</p><p>显然顺序无所谓, 于是 $f_{i, j}$ 表示前 $i$ 个位置, 第 $i+1$ 个位置减去了 $j$ 的代价, 那么转移到 $f_{i+1, k}$ 的时候只要枚举 $i+1$ 上被减了几下即可. 但这个是不对的, 发现可能干 $i+1$ 的时候 $i$ 死了, 所以再多记一维即可.</p><h3 id="CF750E-New-Year-and-Old-Subsequence"><a href="#CF750E-New-Year-and-Old-Subsequence" class="headerlink" title="CF750E New Year and Old Subsequence"></a>CF750E New Year and Old Subsequence</h3><blockquote><p>给定 $a_n$ , $q$ 次询问给定区间 $l, r$ , 删去最少的使得其没有子序列 $\texttt{2016}$ 而有子序列 $\texttt{2017}$</p><p>$n\le 2\times 10^5$</p></blockquote><p>画出识别2016, 2017的自动机</p><p><img src="/img/2022-11-04-07-36-01-image.png" alt="picture 1"></p><p>然后设 $f_{i, j}$ 表示前 $i$ 个自负, 走到节点 $j$ 至少要删多少, 用静态ddp做就好了.</p><h3 id="CF1363F-Rotating-Substrings"><a href="#CF1363F-Rotating-Substrings" class="headerlink" title="CF1363F Rotating Substrings"></a>CF1363F Rotating Substrings</h3><blockquote><p>给定 $s_n, t_n$ , 每次可以选择 $s_{l\ldots r}\to s_{r, l, l+1, \ldots r-1}$ , 求最少次数让两者相等.</p><p>$n\le 2000$</p></blockquote><p><strong>把循环移位操作看成插入</strong>, 就不考虑除了 $r$ 以外字符的影响了.</p><p>于是 $f_{i, j}$ 表示前 $i$ 个字符相等, 已经插入 $j$ 个字符的最小代价, 那么现在让 $i$ 这一位相等, 发现根本不会. 因为后面可能有若干字符跑到前面去, $s_{1 \ldots i}$ 不会和 $t_{1\ldots i}$ 相等, 所以改为 $f_{i, j}$ 表示 $s_{1\ldots i}&#x3D;t_{1\ldots j}$ 的最小代价.</p><p>可能的转移包括:</p><ul><li>$s_i&#x3D;t_j$ , $f_{i, j}&#x3D;f_{i-1, j-1}$</li><li>$s_i$ 需要被插入到前面去, $f_{i, j}&#x3D;f_{i-1, j}+1$</li><li>$s_i$ 从后面被插入过来, $f_{i, j}&#x3D;f_{i, j-1}$</li></ul><p>取个 $\min$ 即可.</p><h3 id="CF650D-Zip-line"><a href="#CF650D-Zip-line" class="headerlink" title="CF650D Zip-line"></a>CF650D Zip-line</h3><blockquote><p>给定 $a_n$ 和 $m$ 个操作 $x_i, v_i$ , 表示把 $x_i$ 改成 $v_i$ , 对每个操作求出操作后的LIS, 操作独立.</p><p>$n, m\le 4\times 10^5$</p></blockquote><p>是修改一次后的LIS. LIS分为不跨过 $i$ 的, 当前包含 $i$ 的, 将来包含 $i$ 的三种, 第一种显然直接解决.</p><p>考虑当前包含 $i$ 的影响, 只要求出 $f_i$ 和 $g_i$ 分别表示 $i$ 往前, 往后的LIS长度. 删掉 $i$ 就是 $f_i+g_i-1$ .</p><p>最后一种是将来包含 $i$ 的, 新的 $f_i, g_i$ 的dp值就是直接矩形数点, 就做完了.</p><h3 id="CF1554E-You"><a href="#CF1554E-You" class="headerlink" title="CF1554E You"></a>CF1554E You</h3><blockquote><p>给定 $T&#x3D;Tree(n)$ , 生成 $a_n$ 的过程是每次选择一个未被标记的点 $u$ , $a_u$ 为与 $u$ 相邻的点未被标记的个数, 然后将它标记, 求 $T$ 生成的排列中 $\gcd&#x3D;k$ 的数量</p><p>膜 $998244353$ , $n\le 10^5$</p></blockquote><p>本质是给边定向, $a_u$ 是点 $u$ 的入度.</p><p>那么任意两种不同定向方式 $a_u$ 是否可能相同? 你感觉一下发现只有有环才有可能, 所以合法的 $a$ 到定向方式是双射.</p><p>考虑若 $a$ 可以得到, 一定要满足 $\sum a_i&#x3D;n-1, a_i&lt;d_i$ , 显然不充分.</p><p>不会凑, 那只好从树上看定向方式, 设 $f_{u, v, 0&#x2F;1}$ 表示子树内和 $u$ 的父边所有定向方式中, 父边朝外&#x2F;内形成的 $gcd$ 为 $v$ 的方案数, 每次转移考虑父边的方向. 似乎是可以的. $u$ 取值范围只有 $\log$ . 转移的时候就先合并子树内的方案, $g_{i, j}$ 表示 $u$ 度数为 $i$ , 当前 $gcd$ 为 $j$ 的方案数, 加入一个子树时是gcd卷积, 最后复杂度应该是 $n\log n\log\log n$ 吧.</p><p>看题解, 原来 $k&gt;1$ 的的时候方案最大是1, $k&#x3D;1$ 的时候减去大于1的</p><p>考虑如何判定大于1的即可, 首先所有叶子边都是内向(不能有入度是1), 然后叶子全删了到下一层, 这样每次定向叶子即可. 原来我才是智障啊.</p><h3 id="CF755F-PolandBall-and-Gifts"><a href="#CF755F-PolandBall-and-Gifts" class="headerlink" title="CF755F PolandBall and Gifts"></a>CF755F PolandBall and Gifts</h3><blockquote><p>给定 $p_n$ , 点 $u$ 是好的当且仅当点 $u$ 不是坏的且 $p_v&#x3D;u$ 的点 $v$ 也不是坏的, 现在已知有 $k$ 个点是坏的, 求此时最少&#x2F;最多有多少点不是好的.</p><p>$n\le 10^6$</p></blockquote><p>看到排列想形成了若干环.</p><p>考虑根据这个定义一个点坏了其实是坏了它和它连向的点, 所以是每次干掉一条边, 求答案.</p><p>那么对于最大值, 一定要先让它每次干掉两个点, 最后干长奇数的环剩下的一个点即可. 对于最小值, 最好的方式显然是干满若干环, 这样平均每次干都是1的贡献.</p><p>于是最大值可以直接统计奇环个数, 最小值要找若干环加起来是 $k$, 所以就成了多重背包.</p><p>$10^6$ 卷起来上过不了了, 但显然不同的环长只有根号个, 就多重背包直接结束了.</p><h3 id="CF258D-Little-Elephant-and-Broken-Sorting"><a href="#CF258D-Little-Elephant-and-Broken-Sorting" class="headerlink" title="CF258D Little Elephant and Broken Sorting"></a>CF258D Little Elephant and Broken Sorting</h3><blockquote><p>给定排列 $p_n$ , $m$ 次操作交换 $p_i, p_j$ , 每一个操作有0. 5概率执行, 求逆序对期望.</p><p>$n, m\le 1000$</p></blockquote><p>交换和逆序对没有简单关系, 因为 $n\le 1000$ 考虑拆贡献.</p><p>于是求每一对数 $i, j, p_i&lt;p_j$ 的概率. 设这个为 $f_{i, j}$</p><p>初始状态应该是 $f_{i, j}&#x3D;[p_i&gt;p_j]$ . 每次进来一个操作 $a, b$ , 考虑:</p><p>$$<br>f_{i, a}&#x3D;\dfrac{1}{2}f_{i, a}+\dfrac{1}{2}f_{i, b}<br>f_{a, b}&#x3D;f_{b, a}&#x3D;\dfrac{1}{2}<br>$$</p><p>最后求个和就做完了.</p><h3 id="CF1223F-Stack-Exterminable-Arrays"><a href="#CF1223F-Stack-Exterminable-Arrays" class="headerlink" title="CF1223F Stack Exterminable Arrays"></a>CF1223F Stack Exterminable Arrays</h3><blockquote><p>对于一个序列, 定义其可消除当且仅当从头开始扫它, 若栈顶等于当前元素就弹, 否则就入栈, 最后栈是空的.</p><p>给定 $a_n$ , 求有多少子区间是可消除的.</p><p>$n\le 3\times 10^5$</p></blockquote><p>从前往后扫, 一个序列可以消除当且仅当其第一个元素入栈前和最后一个元素出栈后栈相等.</p><p>直接hash变成求相等元素对数.</p><p>就是dwtoj 括号序列加强版</p><h3 id="CF1389F-Bicolored-Segments"><a href="#CF1389F-Bicolored-Segments" class="headerlink" title="CF1389F Bicolored Segments"></a>CF1389F Bicolored Segments</h3><blockquote><p>给定 $n$ 条线段 $[l_i, r_i]$ , 每个线段有颜色 $t_i\in {1, 2}$ , 要选择最多的线段满足没有两个颜色不同的线段有交集(包括包含)</p><p>$n\le 2\times 10^5$</p></blockquote><p>考虑结束时, 一定是若干段颜色相同的, 之间没有交.</p><p>于是设 $f_{i, 0&#x2F;1}$ 表示前 $i$ 个位置, 最后一段是 $0&#x2F;1$ , 就要找 $f_{k, 0&#x2F;1}+w(k, i)$ 最大, 然后发现是线段树优化dp, 移动到一条线的右端点就区间加即可.</p><h3 id="CF1566F-Points-Movement"><a href="#CF1566F-Points-Movement" class="headerlink" title="CF1566F Points Movement"></a>CF1566F Points Movement</h3><blockquote><p>数轴上有 $n$ 个点 $a_i$ , $m$ 个区间 $[l_i, r_i]$ , 你可以任意次花费1的代价将一个点向左向右移动1, 求保证每个区间都有过某个时刻含有至少一个点的最小代价.</p><p>$n\le 2\times 10^5, \vert a_i\vert, \vert l_i\vert, \vert r_i\vert \le 10^9$</p></blockquote><p>读错题了. </p><p>那么先删掉显然多余的区间(已经有点的, 包含另一区间的). 可以把区间, 点排序.</p><p>于是现在是若干段点和区间, 每个点一定只会折返一次并且不会跨过起点.</p><p>于是现在每个点走过包含自己的一个区间. 如果一个点跑过一段区间编号 $[i, j]$ , 那么一定是走过 $[r_i, l_j]$ , 代价是 $r_i-l_j+\min(x-r_i, x-l_j)$ .</p><p>于是考虑dp: $f_{i, j}$ 表示前 $i$ 个点干掉了前 $j$ 个区间的最小代价, 注意状态数线性因为每个点的区间不会越过相邻点, 于是只要考虑转移, 现在的情况是</p><p>$$<br>f_{i, j}&#x3D;f_{i-1, k}+cost(k+1, j, i)<br>$$</p><p>其中 $cost(x, y, z)&#x3D;(r_y-l_x)+\min (r_y-p_z, l_x-p_z), (y&lt;z)$ 那因为都是一次项在没有 $min$ 的时候可以直接优化, 有的话就对 $min$ 两边分别维护即可.</p><h3 id="CF797F-Mice-and-Holes"><a href="#CF797F-Mice-and-Holes" class="headerlink" title="CF797F Mice and Holes"></a>CF797F Mice and Holes</h3><blockquote><p>$n$ 个老鼠, $m$ 个洞, 告诉你他们的一维坐标和 $m$ 个洞的容量限制, 问最小总距离.<br>$n, m\le 5000$</p></blockquote><p>模拟费用流!</p><p>(我感觉这题网络流直接冲)</p><p>可以dp. $f_{i, j}$ 表示前 $i$ 个老鼠, 进前 $j$ 个洞的最小总距离, 转移可以枚举这个洞装了几个老鼠, $f_{i, j}&#x3D;f_{k, j-1}+cost(k+1, i, j)$ , $cost$ 是区间中的点到另一个点的最小距离, 直接前缀和, 于是单调队列优化, 于是做完了.</p><h3 id="CF813D-Two-Melodies"><a href="#CF813D-Two-Melodies" class="headerlink" title="CF813D Two Melodies"></a>CF813D Two Melodies</h3><blockquote><p>给定 $a_n$ , 求找两个不交子序列使得长度和最大, 要求子序列满足相邻两个元素差为 $1$ 或膜 $7$ 同余.</p><p>$n\le 5000$</p></blockquote><p>一个子序列很显然, 两个子序列设两维, $f_{i, j}$ 表示第一个子序列选到 $i$ , 第二个选到 $j$ . 因为影响一个序列后面能不能选的只有最后一个元素所以我们是正确的.</p><h3 id="CF917D-Stranger-Tree"><a href="#CF917D-Stranger-Tree" class="headerlink" title="CF917D Stranger Tree"></a>CF917D Stranger Tree</h3><blockquote><p>给定 $T&#x3D;Tree(n)$ , 对每个 $k\in [0, n-1]$ , 求有多少 $T’&#x3D;Tree(n)$ 与 $T$ 有恰好 $k$ 条边相同. 相同指边的两个顶点相同.</p><p>$n\le 100$</p></blockquote><p>见到这种是不是应该立刻容斥, 钦定 $k$ 条边相同, 于是现在有 $n-k$ 个连通块, exCaylay说你要算 $\sum \prod siz$ , 注意选完这 $k$ 条边的连通块一定是树上的连通块, 所以就 $f_{i, j, k}$ 表示子树 $i$ 内选了 $j$ 个连通块, 连到 $i$ 上的这个里有 $k$ 个点. 复杂度 $n^4$ .</p><p>然后发现组合意义: $\prod siz$ 相当于每个连通块选一个点, 于是第三维改成 $0&#x2F;1$ 表示是否已经选过, $j$ 一维合并的时候用树上背包的办法, 复杂度就 $n^2$ .</p><h3 id="CF1051E-Vasya-and-Big-Integers"><a href="#CF1051E-Vasya-and-Big-Integers" class="headerlink" title="CF1051E Vasya and Big Integers"></a>CF1051E Vasya and Big Integers</h3><blockquote><p>Vasya 有三个大数字 $a, l, r$ . 求把 $a$ 划分成连续的若干段使得每一段的数字大小在区间 $[l, r]$ 之内(注意是按照数字大小比较而非按字符串大小比较), 且不含<strong>前导</strong>零的方案总数. 由于答案可能很大, 只需输出答案对 $998244353$ 取模的结果.</p><p>$n\le 10^6$</p></blockquote><p>首先地球人都知道的dp是 $f_{i}$ 表示前 $i$ 个, 想了想你觉得设后 $i$ 个更好, 此时满足条件的 $i$ 一定是一个区间.</p><p>那不就直接做了, 每次满足条件的一个区间, 区间长度与 $l, r$ 不同的可以直接搞掉, 现在还剩下判断相等的怎么弄, 可以二分&#x2F;exkmp算一算lcp然后比较lcp的下一位即可.</p><h3 id="CF441E-Valera-and-Number"><a href="#CF441E-Valera-and-Number" class="headerlink" title="CF441E Valera and Number"></a>CF441E Valera and Number</h3><blockquote><p>给定 $x$ , $k$ 次操作, 每次有 $p$ 概率乘 $2$ , 否则加 $1$ , 问最终 $x$ 二进制末尾0个数的期望.<br>s<br>$x\le 10^9, k\le 200$</p></blockquote><p>考虑这个是左移和加一.</p><p>发现加一的影响相对有点小. 感觉可以设最后8位表示的数是 $x$ 之类的, 但一个全1段就死了, 那再记录一个从最后8位开始的1长度是不是就行了, 现在状态成了 $f_{i, j, k, l}$ 表示 $i$ 次操作, 最后8位是 $j$ , 从最后8位往上有 $k$ 个0, $l$ 个1.</p><p>你想了想, 发现 $k$ 和 $l$ 有一个一定是0, 所以就解决战斗了吧.</p><p>可以去杜赢那里看另外两个做法.</p><h3 id="CF576D-Flights-for-Regular-Customers"><a href="#CF576D-Flights-for-Regular-Customers" class="headerlink" title="CF576D Flights for Regular Customers"></a>CF576D Flights for Regular Customers</h3><blockquote><p>给定有向图 $Graph(n, m)$, 当走过至少 $d_i$ 条边后允许走第 $i$ 条边, 问 $1$ 到 $n$ 最短路<br>$n, m\le 150, d_i\le 10^9$</p></blockquote><p>$n, m$ 很小而 $d$ 很大, 可以考虑邻接矩阵快速幂. 于是想到按 $d_i$ 排序, 不断加边. 用矩阵快速幂维护走 $k$ 次能到的位置并用bitset加速. 并且用每一次的位置集合跑多源bfs即可.</p><h3 id="CF932F-Escape-Through-Leaf"><a href="#CF932F-Escape-Through-Leaf" class="headerlink" title="CF932F Escape Through Leaf"></a>CF932F Escape Through Leaf</h3><blockquote><p>有一颗 $n$ 个节点的树(节点从 $1$ 到 $n$ 依次编号). 每个节点有两个权值, 第 $i$ 个节点的权值为 $a_i, b_i$.</p><p>你可以从一个节点跳到它的子树内任意一个节点上. 从节点 $x$ 跳到节点 $y$ 一次的花费为 $a_x\times b_y$. 跳跃多次走过一条路径的总费用为每次跳跃的费用之和. 请分别计算出每个节点到达树的每个叶子节点的费用中的最小值.</p><p>注意: 就算树的深度为 $1$, 根节点也不算做叶子节点. 另外, 不能从一个节点跳到它自己.</p><p>$2\leq n\leq 10^5$, $-10^5\leq a_i\leq 10^5$, $-10^5\leq b_i\leq 10^5$.</p></blockquote><p>dp方程显然(设 $f_u$ 表示 $u$ 的答案, $f_u&#x3D;\min_{v\in subtree(u)} f_v+a_u\cdot b_v$)</p><p>于是李超线段树合并优化dp看起来很好.</p><p>[trick] 李超树合并复杂度单log.</p><p>证明就是考虑每一个线最多被下传 $\log n$ 次.</p><h3 id="CF1733E-Conveyor"><a href="#CF1733E-Conveyor" class="headerlink" title="CF1733E Conveyor"></a>CF1733E Conveyor</h3><blockquote><p>有一个 $120$ 行, $120$ 列的棋盘, 行列编号均为 $0, 1, \cdots, 119$, $i$ 行 $j$ 列的格子的坐标为 $(i, j)$, 左上角的格子坐标为 $(0, 0)$. 每一个格子上都有一个传送带, 初始方向为右.</p><p>一开始, 有一个史莱姆在 $(0, 0)$, 其他格子都什么也没有, 每一秒传送带的方向都会如下变化:</p><ul><li>所有的史莱姆随着传送带的方向移动一格. 如果传送带的方向没有格子, 史莱姆就会离开棋盘; 如果两个史莱姆到了同一个格子上, 就会合并为一个史莱姆.</li><li>所有有史莱姆的传送带的方向都会改变, 向右的会变成向下的, 向下的会变成向右的.</li><li>$(0, 0)$ 处会出现一个史莱姆.</li></ul><p>给定 $q$ 个询问, 问在第 $t$ 秒, $(x, y)$ 格是否有史莱姆.</p></blockquote><p>显然两个史莱姆不可能碰上</p><p>显然一个格子的周期是 $2^{x+y-2}$, 但发现一个格子第一次到达的时间貌似没啥规律, 所以取模这套行不通了.</p><p>考虑一个好算的是前 $t$ 时刻内经过一个格子的次数, 可以 $n^2$ 递推(必然一半一半的到了下方和右方).</p><p>于是就做完了.</p><p>[trick] 把有没有前缀和成经过次数来做</p><h3 id="POI-Pizza-delivery"><a href="#POI-Pizza-delivery" class="headerlink" title="POI Pizza delivery"></a>POI Pizza delivery</h3><blockquote><p>给一棵 $n$ 点树, 有边权, 要求选至多 $k$ 条路径(可重复经过点和边), 使得每个点经过至少一次, 最小化路径经过的边权和(重复经过算多次).</p><p>$n, k\le 10^6$</p></blockquote><p>显然每条路都停在叶子上.</p><p>朴素dp说 $f_{u, i, j}$ 表示有 $u$ 点进去 $i$ 条边出来 $j$ 条边.</p><p>但注意到, $j\le 1$, 因为你往一个 $u$ 里放好多条路径的目的就是让其中的路径不用出来, 如果有两条路径都要出来不如替换成一条路径.</p><p>又注意到, 如果 $j&#x3D;1$ 则 $i&#x3D;1$, 因为又出来的路径做了个环, 可以接在进去没出来的上面, 然后原来那条出来的路径删掉这个环.</p><p>于是 $f_{u, i}$ 表示 $u$ 个点, 其中有 $i$ 条边进入子树且没出来.</p><p>$$<br>f_{u, 0}&#x3D;2 \cdot edgesum(u)\<br>f_{u, k}&#x3D;wk+\min_{a_n} \sum_{v} f_{v, a_v}<br>$$</p><p>注意到, 叶子显然是凸的, 如果 $f_v$ 是凸的, 那么一次min-add卷积再加一个一次函数之后也是凸的(下凸).</p><p>而 $f_{u, 0}$ 按照上面的式子算比下面的多考虑了父边, 所以只会更大, 因此合并上去也是凸点.</p><p>于是wqs二分即可.</p><h3 id="CF1461F-Mathematical-Expression"><a href="#CF1461F-Mathematical-Expression" class="headerlink" title="CF1461F Mathematical Expression"></a>CF1461F Mathematical Expression</h3><blockquote><p>给一个长度为 $n(n\le 10^5)$ 的序列 $a$, $0 \le a_i\le 9$, 现在给定你可以用+, -, *, 中的集合 $S$ 中的符号填到序列中 $n-1$ 个位置上, 使得最后的式子运算结果最大, 乘法运算优先于加法与减法, 请输出最后的式子<br>$n\le 10^5$, $S\subseteq {+, -, *}$</p></blockquote><p>考虑如果 $S$ 不包含 ${+, *}$, 那么这是智障题, 于是现在 $S$ 是 ${+, *}$</p><p>但此时不能直接一个斜率优化板子dp拍上去: 因为前缀积存不下.</p><p>分析性质, 注意到如果有 $0$ 直接拆成若干毫无关系的段, 对于每一个, 显然连续非 $1$ 段中间都是乘号, 问题来到了两段之间的 $1$(第一个段前面的 $1$ 当然都是加号).</p><p>注意到, 如果所有数乘起来不出意料的存不下, 那么一定中间全是乘号.</p><p>否则, 因为每个段至少是 $2$, 所以段数只有 $\log$ 段, 直接段数平方dp.</p><h3 id="CF1511G-Chips-on-a-Board"><a href="#CF1511G-Chips-on-a-Board" class="headerlink" title="CF1511G Chips on a Board"></a>CF1511G Chips on a Board</h3><blockquote><p>Alice 和 Bob 有一个 $n\times m$ 的棋盘. 每行恰好有一个棋子.</p><p>他们以如下的方式进行一个游戏:</p><ul><li>选择一对整数 $l, r(1\leq l\leq r\leq m)$, 将除第 $l\sim r$ 列之外的部分从棋盘上移除.</li><li>轮流进行操作, Alice 先手. 每一次操作, 玩家需要选择一个棋子, 并将其向左走任意正整数步(不能移出棋盘). 第一个不能移动的玩家判负.</li></ul><p>给定 $q$ 次独立的询问如 $L_i, R_i$ 所示, 试求如果第一步中选择的整数是 $(L_i, R_i)$, 谁会赢得游戏.</p><p>$1\leq n, m, q\leq 2\times 10^5$.</p></blockquote><p>如果不考虑那个区间, 博弈论部分当然不能更简单了: 就是每行坐标异或和.</p><p>于是现在就是求一个值域区间的所有数减左端点值的异或和.</p><p>一个众所周知的技巧是trie全局加减1, 那么在这个过程中维护异或和, 搭配一个莫队可以做到 $n\sqrt n\log n$. 卡常听说可过.</p><p>考虑假设左端点固定, 区间 $[l, l+2^{k-1}]$ 和 $[l+2^k, l+2^k+2^{k-1}]$ 的前 $k$ 位异或和是相同的, 并且第 $k$ 位只和后一个区间内的数的个数有关. 于是用这个倍增即可做到单log.</p><h3 id="2022SDFZ省选模拟赛1-石子游戏"><a href="#2022SDFZ省选模拟赛1-石子游戏" class="headerlink" title="[2022SDFZ省选模拟赛1]石子游戏"></a>[2022SDFZ省选模拟赛1]石子游戏</h3><blockquote><p>Alice 和 Bob 在玩取石子的游戏.</p><p>他们共有 $N$ 堆石子, 第 $i$ 堆石子有 $a_i$ 个石子.</p><p>Alice 和 Bob 轮流取石子, Alice 先取, 每一次取石子, 当前取石子的人可以任选一堆还没有被取完的石子, 从中取出至少 $1$ 个, 至多 $x$ 个石子.</p><p>如果当前取石子的人没有石子堆可选, 那么他(她)就输掉了游戏. 他们想知道, 如果 Alice 和 Bob 都用最优策略玩游戏的话, 谁会胜利.</p><p>由于 Alice 和 Bob 还没商量好 $x$ 取多少, 所以对于每个 $1$ 到 $N$ 之间的 $x$, 你都需要告诉他们谁将取得胜利.</p><p>$N\le 5\times 10^5, a_i\le N$</p></blockquote><p>类似上一题</p><h3 id="CF1218C-Jumping-Transformers"><a href="#CF1218C-Jumping-Transformers" class="headerlink" title="CF1218C Jumping Transformers"></a>CF1218C Jumping Transformers</h3><blockquote><ul><li>你要从 $(0, 0)$ 向右或向下走到 $(N - 1, M - 1)$</li><li>图上有 $K$ 个障碍, 每个障碍有 $(t_i, e_i, d_i, x_i, y_i)$, 在 $t_i$ 时刻, $(x_i, y_i)$ 会出现一个障碍, 并且接下来的每秒会按照 $(x+d, y-d), (x+d, y), (x, y+d), (x, y)$ 的方式周期性移动(保证不会跳出边界). 恰好碰到这个障碍时, 你可以花费 $e_i$ 将它移除(以后都不出现). 问从起点到终点最小花费</li><li>$1 \le N, M \le 500$, $0 \le K \le 5 \times 10^5$, $d_i \ge 1$, $0 \le t \le N+M-2$</li></ul></blockquote><p>todo</p><h3 id="CF1765C-Card-Guessing"><a href="#CF1765C-Card-Guessing" class="headerlink" title="CF1765C Card Guessing"></a>CF1765C Card Guessing</h3><blockquote><p>有 $4$ 种花⾊的牌, 每种牌均为 $n$ 张, 则牌的排列⼀共有 $(4\cdot n)!$ 种.</p><p>现在你从牌堆中逐张地取出牌, 取牌之前你都会猜⼀下这张牌是什么花⾊. 你会根据之前的 $k$ 张牌中出现最少的花⾊来猜这张牌.</p><p>如果有多种花⾊都是最少的, 你随机地猜⼀种. 如果之前抽出的牌不⾜ $k$ 张, 就按之前的所有牌中的最少花⾊来猜.</p><p>问你猜对的期望次数是多少?</p><p>$n\le 500$</p></blockquote><p>容易想到求某一次猜对的概率.</p><p>那么对于要考虑前 $k$ 张牌时, 方案数是</p><p>$$<br>\begin{gathered}<br>\binom{4n-k}{n-a, n-b, n-c, n-d}\binom{k}{a, b, c, d}\dfrac{n-\min(a, b, c, d)}{4n-k}\<br>&#x3D;(a+b+c+d)! (4n-a-b-c-d-1)! \cdot \dfrac{(n-\min(a, b, c, d))}{a! b! c! d! (n-a)! (n-b)! (n-c)! (n-d)! }<br>\end{gathered}<br>$$</p><p>此时你枚举一个 $\min(a, b, c, d)$, 然后把序列 $i! (n-i)!$ 卷起来, 然后再乘上其他的那些只和 $a+b+c+d$, 也就是卷完的下标有关的东西就行了. 复杂度是 $n^3$(暴力卷)或 $n^2\log n$</p><h3 id="CF1425B"><a href="#CF1425B" class="headerlink" title="CF1425B"></a>CF1425B</h3><blockquote><p>给定一张 $n$ 个点 $m$ 条边的无向连通图, 保证无自环, 保证除节点 $1$ 外每个点的度数都为 $2$.</p><p>有两人 $\text{Red}$ 和 $\text{Blue}$ 同时从节点 $1$ 出发. 初始时所有边都是灰色. $\text{Red}$ 每经过一条边就会将它染成红色, $\text{Blue}$ 每经过一条边就会将它染成蓝色. 每轮中, 每人会选择一条与当前所在节点相连的、灰色的边, 并走到边的另一端. 同一轮里两人选择的边不能相同.</p><p>当无法进行下一轮时, 整个过程停止. 问两人能走出多少种不同的最终局面, 答案对 $10^9+7$ 取模. 两个最终局面不同当且仅当存在一条边, 在最终局面下颜色不同.</p><p>数据范围: $1\le n\le 2000$, $1\le m\le 2n$.</p></blockquote><p>图的形状是一堆环, 有一个公共点1.</p><p>设环的大小序列为 $a$, 则一种方案对应集合划分 $S, T, {u} or \varnothing$, 使得 $S$ 中元素和与 $T$ 中和的差不多于 $a_u$</p><p>然后直接背包.</p><h2 id="Luogu一个dp题单"><a href="#Luogu一个dp题单" class="headerlink" title="Luogu一个dp题单"></a>Luogu一个dp题单</h2><h3 id="P8321-『JROI-4』沈阳大街-2"><a href="#P8321-『JROI-4』沈阳大街-2" class="headerlink" title="P8321 『JROI-4』沈阳大街 2"></a>P8321 『JROI-4』沈阳大街 2</h3><blockquote><p>给定 $a_n$, $b_n$, 求 $\dfrac{1}{n! }\sum_{p_n} \prod_i \min(a_i, b_{p_i})$<br>$n\le 5000$</p></blockquote><p>考虑贡献由两个数中大的一个决定, 序列顺序是无所谓的, 实际上是寻找 $a$ 到 $b$ 的全匹配.</p><p>于是把 $a, b$ 放到一起, $f_{i, j}$ 表示前 $i$ 个数, 其中有 $j$ 个 $a$ 元素选择比它大的 $b$, 于是根据元素个数能算出 $b$ 选比自己大的 $a$ 的数量, 贡献都留到消去一个插头的时候算.</p><h3 id="CF1628D2-Game-on-Sum-Hard-Version"><a href="#CF1628D2-Game-on-Sum-Hard-Version" class="headerlink" title="CF1628D2 Game on Sum (Hard Version)"></a>CF1628D2 Game on Sum (Hard Version)</h3><blockquote><p>Alice 和 Bob 正在玩一个游戏, 游戏分为 $n$ 个回合, Alice 和 Bob 要轮流对一个数 $x$ 进行操作, 已知这个数初始值是 $0$.</p><p>具体每个回合的行动规则如下:</p><ol><li>Alice 选择一个在区间 $[0, k]$ 之间的实数 $t$.</li><li>Bob 可以选择让 $x$ 变成 $x+t$ 或者 $x-t$, 但是 Bob 在 $n$ 个回合之内至少选择 $m$ 次让 $x$ 变成 $x+t$.</li></ol><p>Alice想让最终的 $x$ 最大, Bob 想让最终的 $x$ 最小.</p><p>已知双方均采用最优策略, 求最终的 $x$ 值(对 $10^9+7$ 取模).</p><p>数据范围保证: $1\le m\le n\le 10^6, k\le10^9+7$, $\sum\limits n\leq10^6$ .</p></blockquote><p>考虑一个暴力, $f_{i, j}$ 表示用 $i$ 次, 其中减了 $j$ 次. 那么 $f_{i, j}&#x3D;\max_c \min(f_{i-1, j}+c, f_{i-1, j-1}-c)$.</p><p>那么Alice应该会让内层全是 $\dfrac{f_{i-1, j}, f_{i-1, j-1}}{2}$. 边界大概是 $f_{i, 0}&#x3D;ik, f_{0, i}&#x3D;0$.</p><p>注意到没有 $\dfrac{1}{2}$ 再把 $k$ 变成 $1$ 就是组合数, 于是就做完了.</p><h3 id="P8290-省选联考-2022-填树"><a href="#P8290-省选联考-2022-填树" class="headerlink" title="P8290 [省选联考 2022] 填树"></a>P8290 [省选联考 2022] 填树</h3><blockquote><p>有一棵 $n$ 个节点的无根树, 刚开始树上每个节点的权值均为 $0$. KK 想对这棵树进行一些修改, 他会任选一个节点作为初始的当前节点, 然后重复以下动作:</p><ol><li>将当前节点 $i$ 的权值修改为一个<strong>正整数</strong> $x$, 需满足 $l_i \leq x \leq r_i$. 其中 $l_i, r_i$ 是输入中给出的两个正整数.</li><li>结束修改过程, 或移动到一个与当前节点相邻的权值为 $0$ 的节点(如果不存在这样的节点, 则必须结束修改过程).</li></ol><p>现在 KK 有两个问题:</p><ol><li>在修改结束后, 可以得到多少棵不同的树, 满足树上<strong>非零权值</strong>的最大值和最小值的差小于等于 $K$? 其中 $K$ 是输入中给出的一个正整数.</li><li>这些满足条件的树的权值之和为多少? (树的权值定义为这棵树上所有节点的权值之和)</li></ol><p>你需要输出这两个问题的答案模 $10^9 + 7$. 我们认为两棵树不同当且仅当至少存在一个节点的权值不同.</p><p>$n\le 200$</p></blockquote><p>其实一年前看过一次了.</p><p>发现对于一个节点, 枚举一个最大值 $x$, 就能确定最小值的范围. 于是对于一个节点, 方案数是关于 $x$ 的 $5$ 段一次函数, 总和应该是 $5$ 段二次函数.</p><p>那么最后是 $5n$ 段的大约 $n$ 次函数, 考虑如何得到.</p><p>设 $f_u(x)$ 表示从 $u$ 出发向子树走的函数, $g_u(x)$ 表示 $u$ 以内的函数, $h_u$ 表示 $u$ 自己的函数. 树形背包合并这些分段函数.</p><p>对于子树 $u$, 其内的函数至高为 $siz$ 段 $siz$ 次, 合并应该是 $siz^2$ 的. 总复杂度是 $n^3$ 的.</p><p>笑死, 一直以为树上 $\sum siz^2$ 可以树卷积</p><p>然后你最后会求出一个多项式, 可以对着有限微积分把他做了.</p><p>不过更合理的是, 分析出 $n$ 段 $n$ 次的东西后, 直接刚才那个dp可以 $O(n)$ 算一次, 再配一个拉插就行了.</p><p>然后发现我dp的时候是个智障: 记录了 $f_{u, 0&#x2F;1}, fh_{u, 0&#x2F;1}$ 表示 $u$ 子树内有没有最大值的和 $u$ 子树内且由 $u$ 出发的路径中有没有最大值的, 但实际上可以去掉那一维容斥出来不好吗.</p><h3 id="AGC034E-Complete-Compress"><a href="#AGC034E-Complete-Compress" class="headerlink" title="[AGC034E] Complete Compress"></a>[AGC034E] Complete Compress</h3><blockquote><p>给你一颗 $n$ 个节点的树, 并用二进制串告诉你哪些节点上有棋子(恰好一颗).</p><p>可以进行若干次操作, 每次操作可以将两颗距离至少为 $2$ 的棋子向中间移动一步.</p><p>问能否通过若干次操作使得所有的棋子都在一个点上, 如果能, 输出最小操作次数, 如果不能, 输出 $-1$ .</p><p>$2 \leq n\leq 2000$.</p></blockquote><p>考虑把最后所有节点都在的点当成根.</p><p>发现, 两个祖孙棋子向中间走是多余的. 于是每一步都让总距离减2, 步数变得确定.</p><p>那么设 $f_u$ 表示 $u$ 之内的点走到 $u$ 需要外面的点向上走几步, 那么转移的时候就是要解决, 给定一个数组, 每次给两个元素减 $1$, 求最后剩下的数最小. 暴力模拟的话, 每次是 $c\log c$($c$ 是儿子个数)(先排序, 然后不断用最大值和次大值匹配消掉).</p><p>注意到, 如果最大值不多于总和的一半, 那么一定可以消到 $sum\bmod 2$, 考虑消不掉一定是因为某一时刻最大值大于总和的一半, 而每次消最大值和次大值是不会发生这样的事情的.</p><p>于是可以直接转移了.</p><h3 id="P4765-CERC2014-The-Imp"><a href="#P4765-CERC2014-The-Imp" class="headerlink" title="P4765 [CERC2014]The Imp"></a>P4765 [CERC2014]The Imp</h3><blockquote><p>这道题的场景为你想要在商店里购买一件最值钱的魔法实体, 但是你只能携带一件, 每个魔法实体都锁在一个特殊的魔术宝箱中, 而宝箱的开启需要一定的金币, 同时小恶魔会用魔法将某一个魔术宝箱内的实体转化为毫无价值的灰尘(消耗你的金币), 你必须保留你已购买的魔法实体并离开商店. 你需要在小恶魔使用 $k$ 次灰尘魔法的前提下, 最大化你的收益(所购实体的价值减去购买所有实体和之前的灰尘的费用), 小恶魔则希望将这个收益最小化, 并且你和小恶魔都使用最佳策略.</p><p>$1\le n\le1. 5\times10^5, 0\le k\le9, 0\le v_i, c_i\le10^6$.</p></blockquote><p>[trick] 一个确定性的(所有已经确定的信息公开, 不存在概率)问题, 可以看成双方决策透明, 可以按照你先提供你的所有可能方案, 然后它给你的每个方案给出它的策略, 在所有的里面选一个最小的.</p><p>需要注意到你的选择是 $v$ 从小到大的, 假设你选了一个大的, 再选一个小的, 发现无论恶魔在大的处打断, 还是小的处打断, 都是不优的.</p><p>于是你选了一个递增的序列, 而恶魔每次决定是否打断. 但是你并不会算打断后的贡献所以不会转移.</p><p>于是从后往前转移, $f_{i, j}$ 表示你最大的 $i$ 个中选, 其中恶魔用了 $j$ 次魔法的收益即可.</p><h3 id="P4363-九省联考-2018-一双木棋-chess"><a href="#P4363-九省联考-2018-一双木棋-chess" class="headerlink" title="P4363 [九省联考 2018] 一双木棋 chess"></a>P4363 [九省联考 2018] 一双木棋 chess</h3><blockquote><p>两个人在 $n$ 行 $m$ 列的棋盘上下棋, 菲菲执黑棋先手, 牛牛执白棋后手. 落子规则是一个格子可以落子当且仅当这个格子内没有棋子且这个格子的左侧及上方的所有格子内都有棋子. 每个格子上都写有两个非负整数 $a_{i, j}$ 和 $b_{i, j}$. 在游戏结束后, 菲菲的得分是所有有黑棋的格子上的 $a_{i, j}$ 之和, 牛牛的得分是所有有白棋的格子上的 $b_{i, j}$ 的和. 菲菲和牛牛都希望自己的得分减去对方的得分得到的结果最大. 问题是, 在给定的棋盘上, 如果双方都采用最优策略且知道对方会采用最优策略, 那么最终的结果如何.<br>$n, m\le 10$</p></blockquote><p>尝试用chatgpt生成简化题意. 字确实少了100来个吧.</p><p>考虑我们只关心哪些格子可以落子. 状态数是要数一个阶梯数. 考虑差分就是 $0\ldots 10$ 中选10个数使和为10, 可以写一个搜, 发现原来这么少, 那么就随便做了.</p><h3 id="HNOI2007-梦幻岛宝珠"><a href="#HNOI2007-梦幻岛宝珠" class="headerlink" title="[HNOI2007]梦幻岛宝珠"></a>[HNOI2007]梦幻岛宝珠</h3><blockquote><p>给你 $n$ 颗宝石, 每颗宝石都有重量 $w_i$ 和价值 $v_i$. 要你从这些宝石中选取一些宝石, 保证总重量不超过 $W$, 且总价值最大, 并输出最大的总价值.</p><p>$1\le n \le 100$, $1\le W, w_i, v_i \le 2^{30}$.</p><p>保证每个 $w_i$ 能写成 $a \times 2^b\space (a, b \in \mathbb N)$ 的形式, $a \leq 10$ , $b \leq 30$, 且答案不超过 $2^{30}$.</p></blockquote><p>一个奇怪背包, 很经典.</p><p>因为看到那个保证, 所以按照 $b$ 分层处理.</p><p>于是 $f_{i, j}$ 表示 $2^i\times j$ 时的最大价值, 按照数位dp的思路从高位向低位做即可.</p><h3 id="AGC032D-Rotation-Sort"><a href="#AGC032D-Rotation-Sort" class="headerlink" title="[AGC032D] Rotation Sort"></a>[AGC032D] Rotation Sort</h3><blockquote><p>给定一个排列 $p_n$, 你可以花费 $a$ 使一个区间最左边的数跑到最右边, 或者花费 $b$ 的代价使最右边到最左边, 求把整个序列变成升序的最少花费.<br>$n\le 5000$</p></blockquote><p>每个数显然一次到位.</p><p>注意到不动的数是LIS, $f_{i, j}$ 表示前 $i$ 个数, 不动的数中最后一个是 $j$. 每次碰到一个新数, 比 $j$ 大可以固定, 或者往右走(从 $j$ 到 $i$ 这一段都被移动过, 一段往右的和一段往左的中间一定可以有一个不动的), 比 $j$ 小就往左走.</p><h3 id="CF1626F-A-Random-Code-Problem"><a href="#CF1626F-A-Random-Code-Problem" class="headerlink" title="CF1626F A Random Code Problem"></a>CF1626F A Random Code Problem</h3><p>考虑期望线性性算每个 $a$ 自己的贡献, 那么 $f_{i, j}$ 表示选了前 $i$ 次, $a$ 已经被减去了 $j$, 此时的贡献. 复杂度是 $nk^3$</p><p>注意到, 如果两个数膜 $lcm(1\ldots 17)$ 相同, 转移是一样的, 可以一起处理, 只要dp的时候记录的是 $f_{i, j}$ 为一次函数表示贡献即可.</p><p>注意到, 膜17的余数没有用, 所以现在复杂度是 $lcm(1\ldots 16)k^3$</p><p>又考虑到, 你可以把所有数合起来一起dp, 记录 $f_{i, j}$ 表示当前数是 $i$, 还有 $j$ 轮要进行的贡献, 复杂度是 $720720k$</p><h3 id="AGC030F-Permutation-and-Minimum"><a href="#AGC030F-Permutation-and-Minimum" class="headerlink" title="[AGC030F] Permutation and Minimum"></a>[AGC030F] Permutation and Minimum</h3><blockquote><p>有一个 $2 N$ 个数的序列 $A$, 从 $1$ 到 $2 N$ 标号. 你要把 $1 \sim 2 N$ 这些数填进去, 使它形成一个排列.</p><p>但是已经有一些位置强制填了特定的数了, 输入时会给出.</p><p>最后令长度为 $N$ 的序列 $B$ 为: 令 $B_i &#x3D; \min{A_{2 i - 1}, A_{2 i}}$.</p><p>询问所有方案中能得到的不同的 $B$ 的数量.</p><p>$1 \le N \le 300$.</p></blockquote><p>首先全是 $-1$ 的时候发现实际上看成选一条从 $(0, 0)$ 每次走 $(1, 1)$ 或 $(1, -1)$ 走到 $(n, 0)$ 的方案数再乘 $n!$, 因为显然此时只要考虑给数配对, 每一对数的 $\min$ 的集合, 于是从小到大, 让第 $i$ 次走 $(1, 1)$ 表示第 $i$ 小的数作为一个数对的 $\min$ 即可.</p><p>而现在有了一些确定的数, 显然填好的数对直接扔了, 而填了一半的是重点, 因为现在它的位置是重要的了! 那么只能考虑dp, 肯定是记录 $f_{i, j, k}$ 表示前 $i$ 个数, 有 $j$ 个填了一半且位置不定的和 $k$ 个填了一半且位置确定的. 如果从小到大走发现, 从大到小则很容易, 每次要么新开一个对要么结束一个以前的对, 如果用当前位置位置确定的结束一个不确定的对则要乘上不确定的个数, 相当于此时为那个对确定位置. 复杂度 $n^3$.</p><p>感觉比较迷惑的在于怎么看出转移方向, 主要问题就在于每个对中大的那一个不重, 于是从小到大dp时结束一个对的位置不同不应算多次, 但这个没法整.</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="CF1768F-Wonderful-Jump"><a href="#CF1768F-Wonderful-Jump" class="headerlink" title="CF1768F Wonderful Jump"></a>CF1768F Wonderful Jump</h3><blockquote><p>给定整数 $n$ 和长度为 $n$ 的序列 $a$.<br>从位置 $i$ 跳到位置 $j(1\leq i\leq j\leq n)$ 需要花费 $\min(a_i, a_{i+1}, \cdots, a_j)\times(j-i)^2$ 枚金币.<br>对于 $k&#x3D;1, 2, \cdots, n$, 求出从位置 $1$ 经若干次跳跃后跳到位置 $k$ 需要的最小金币总数.<br>$n\le 4\times 10^5, a_i\le n$</p></blockquote><p>考虑现在在 $i$ 要从 $j$ 转移, 区间最小值为 $m$.</p><p>容易发现的结论是, 如果 $m&#x3D;a_j$, 你选择的一定是一个后缀min, 如果是 $a_i$ 就没什么规律.</p><p>不容易发现的结论是, 如果一步走过去优于每次走一格, 即 $i-j&#x3D;l, l^2\min_k a_k&lt;\sum a_k&lt;nl\Rightarrow ml&lt;n$</p><p>有了这个剩下就, 根号分治, 对于 $l&gt;\sqrt n$ 的情况, 如果 $m&#x3D;a_j$ 就维护单调栈, 元素显然少于 $\sqrt n$, 如果是 $a_i$, 直接暴力往前走到第一个 $a_j\le a_i$, 因为每个值只会最多覆盖整个序列一遍所以复杂度对的.</p><p>[trick] 存在两种可能操作, 可以看一种在什么时候才会优于另一种使得复杂操作代价减少. 类似的还有nfls集训 CF354D</p><h3 id="杜赢的blog上的P8580-CoE-R5-罚球"><a href="#杜赢的blog上的P8580-CoE-R5-罚球" class="headerlink" title="杜赢的blog上的P8580 [CoE R5] 罚球"></a>杜赢的blog上的P8580 [CoE R5] 罚球</h3><blockquote><p>有 $n$ 个人在玩罚球游戏, 游戏规则如下:</p><ul><li>每个人编号为 $1, 2, \dots, n$ , 最开始由 $1$ 号罚球, 接下来让下一个没有出局的人罚球. 特殊地, $n$ 号的下一个是 $1$ 号.</li><li>如果罚球者没有碰到篮板, 那么直接出局.</li><li>如果罚球者碰到篮板但没有进球, 那么如果上一个人进球了, 这个人就会出局, 否则不会出局.</li><li>游戏结束的条件是最后只剩下一个人.</li></ul><p>注意最开始的那个人碰到篮板但没有进球不出局.</p><p>这 $n$ 个人中, 第 $i$ 个人碰不到篮板的概率为 $\dfrac{a_i}{1000}$ , 碰到篮板但没有进球的概率为 $\dfrac{b_i}{1000}$ , 求游戏结束时所有人总共罚球数量的期望值.</p><p>$n\le 18$</p></blockquote><p>$n$ 很小, 直接状压, 设 $f_{S, i, 0&#x2F;1}$ 表示还活着的是 $S$ , 然后现在是 $i$ 投球, 上一个人是否投中情况下期望值. 设 $next$ 表示 $i$ 之后下一个投球的人, 按照期望反向递推的套路写, 显然有:</p><p>$$<br>\begin{gathered}<br>   f_{S, i, 0}&#x3D;a_if_{S&#x2F;i, nxt, 0}+b_if_{S, nxt, 0}+(1-a_i-b_i)f_{S, nxt, 1}+1\<br>   f_{S, i, 1}&#x3D;a_if_{S&#x2F;i, nxt, 0}+b_if_{S&#x2F;i, nxt, 0}+(1-a_i-b_i)f_{S, nxt, 1}+1\<br>   f_{ {i}, i, 0&#x2F;1}&#x3D;0<br>\end{gathered}<br>$$</p><p>显然转移成环, 考虑分析:</p><p>首先, 环只有在同一个 $S$ 内部出现, $S$ 间不会有, 那么上来先按 $\vert S\vert$ 排序按顺序转移.</p><p>其次, 对于同一个 $S$ 内的, 发现 $f_{S, i, 1}$ 只在内部有环, 确定了 $f_{S, i, 1}$ 后 $f_{S, i, 0}$ 也只在内部有环, 考虑高消, 发现列出来每个方程都只有两个变量还是长成循环的样子, 用主元高消消元, 两个复杂度都是 $\vert S \vert$ 的.</p><p>主元高消指的是用一个变量表示其他变量(这也配起个名), 这里发现只要确定一个就能表示所有变量所以线性.</p><h3 id="P2282-HNOI2003-历史年份"><a href="#P2282-HNOI2003-历史年份" class="headerlink" title="P2282 [HNOI2003]历史年份"></a>P2282 [HNOI2003]历史年份</h3><blockquote><p>给定由不超过2000个数字组成的字符串, 存在前缀 $0$, 按照一定规则将这些数字还原成正确的年份序列, 满足从小到大, 末尾最小在此基础上字典序最大.<br>$\vert s\vert \leq 2000$, 有多组询问.</p></blockquote><p>容易想到满足末尾最小可以 $f_i$ 表示前 $i$ 个, 最后一个数是 $[f_i, i]$, 使最后一个数最小. 然后再一遍反着dp回来满足字典序.</p><p>此时dp式子大概是 $f_i&#x3D;\max j \ s. t. \ c(f_j, j)&lt;c(j+1, i)$, 因为字符串比较是 $O(len)$ 就成了 $n^3$</p><p>字符串比较容易优化: 只要先比较长度, 长度相同比较所在后缀字典序大小, 用SAM或SA都是 $O(1)$</p><p>优化dp: 填表形式需要每次给前面所有位置代表的 $c(j+1, i)$ 向后加一位, 不可做, 考虑刷表的时候一个 $i$ 一定贡献一个区间, 因为对 $c(i, j)$ 约束是一个下界, 所以区间赋值就能做.</p><p>因为还有一些 $0$, 使得你不能直接算长度, 而要预处理每个位置向左向右的 $0$ 长度并处理细节.</p><h3 id="P2305-NOI2014-购票"><a href="#P2305-NOI2014-购票" class="headerlink" title="P2305 [NOI2014] 购票"></a>P2305 [NOI2014] 购票</h3><blockquote><p>今年夏天, NOI 在 SZ 市迎来了她三十周岁的生日. 来自全国 $n$ 个城市的 OIer 们都会从各地出发, 到 SZ 市参加这次盛会.</p><p>全国的城市构成了一棵以 SZ 市为根的有根树, 每个城市与它的父亲用道路连接. 为了方便起见, 我们将全国的 $n$ 个城市用 $1\sim n$ 的整数编号. 其中 SZ 市的编号为 $1$. 对于除 SZ 市之外的任意一个城市 $v$, 我们给出了它在这棵树上的父亲城市 $f_v$  以及到父亲城市道路的长度 $s_v$.</p><p>从城市 $v$ 前往 SZ 市的方法为: 选择城市 $v$ 的一个祖先 $a$, 支付购票的费用, 乘坐交通工具到达 $a$. 再选择城市 $a$ 的一个祖先 $b$, 支付费用并到达 $b$. 以此类推, 直至到达 SZ 市.</p><p>对于任意一个城市 $v$, 我们会给出一个交通工具的距离限制 $l_v$. 对于城市 $v$ 的祖先 A, 只有当它们之间所有道路的总长度不超过 $l_v$  时, 从城市 $v$ 才可以通过一次购票到达城市 A, 否则不能通过一次购票到达.</p><p>对于每个城市 $v$, 我们还会给出两个非负整数 $p_v, q_v$  作为票价参数. 若城市 $v$ 到城市 A 所有道路的总长度为 $d$, 那么从城市 $v$ 到城市 A 购买的票价为 $dp_v+q_v$.</p><p>每个城市的 OIer 都希望自己到达 SZ 市时, 用于购票的总资金最少. 你的任务就是, 告诉每个城市的 OIer 他们所花的最少资金是多少.</p><p>$n\le 2\times 10^5$, 3s</p></blockquote><p>容易想到dp, $f_u$ 表示 $u$ 的答案, 于是 $f_u&#x3D;f_v+(dep_u-dep_v)p_u+q_u$, 其中 $v$ 是 $u$ 的祖先且 $dep_u-dep_v\le l_u$</p><p>然后这是个斜率优化, 考虑序列上的问题就直接斜率优化.</p><p>粗暴的做法是线段树套李超树, 出栈序+线段树套李超树.</p><h3 id="Gym-104128K-NaN-in-a-Heap"><a href="#Gym-104128K-NaN-in-a-Heap" class="headerlink" title="Gym - 104128K NaN in a Heap"></a>Gym - 104128K NaN in a Heap</h3><p>首先任意满足堆性质的都可以得到, 因为你从上往下插入肯定就不会发生调整了. 于是假如没有 <code>nan</code>且 $n&#x3D;2^k-1$, 直接 $f_{i}$ 表示大小为 $i$ 的子树的答案即可, 转移就是 $f_i&#x3D;\dfrac{1}{siz_i}f_{i&#x2F;2}^2$.</p><p>那么如果有 <code>nan</code>, 转移的时候一方面要记录当前子树里有没有出现 <code>nan</code>, 一方面要把 $siz_i$ 改成 $siz_i-siz_{nan}$, 于是直接再加一维 $j$ 表示当前子树内 $nan$ 的大小, 没有则为 $0$, 就可以转移了.</p><p>然后想如果 $n\ne 2^k-1$ 怎么办, 发现大多数子树仍然是整的, 只有 $n$ 号点到 $1$ 号点这条链上大小不整, 那么再记录一维 $0&#x2F;1$ 表示是不是整的子树状态下大小为 $i$ 的子树, 最后 $i, j$ 两维直接记的话都要开 <code>map</code></p><h3 id="CF1810G-The-Maximum-Prefix"><a href="#CF1810G-The-Maximum-Prefix" class="headerlink" title="CF1810G The Maximum Prefix"></a>CF1810G The Maximum Prefix</h3><p>看起来是2021年夏令营的股票的加强版, 第一部分相同: 对于前缀和最大值, 如果从前往后dp比较困难, 需要记录当前前缀和和最大前缀和, 但从后往前dp则比较容易, 只需要记录最大值, 感觉因为加一个数对应的操作从局部的变成了整体的. 总之前缀和这种两边不对称的东西要都尝试一下.</p><p>于是 $f_{i, j}$ 表示还要走 $i$ 步, 当前前缀和最大值为 $j$ 的方案数, 那么 $f_{i+1, j}\cdot p_{i, c_i}\to f_{i, \max(0, j+c_i)}$ 就好了. 其中 $p_{a, 0&#x2F;1}$ 表示在第 $a$ 步走 $0&#x2F;1$ 的概率.</p><p>但问题是这样做不能一次得到所有前缀的答案, 需要dp $n$ 次, 注意到每次dp除了初始状态之外都是一样的, 那么对于这种很线性的dp可以先反向推出每个位置对答案的贡献, 然后直接统计贡献.</p><p>[trick] 只有加法乘法的dp可以递推出每个位置的起始值最后加到结果中的系数, 以处理多次询问</p><h3 id="CF917C-Pollywog"><a href="#CF917C-Pollywog" class="headerlink" title="CF917C Pollywog"></a>CF917C Pollywog</h3><p>首先任意时刻青蛙一定在长度不超过 $k$ 的区间内, 因为一开始是这样的, 而后来怎么跳也不会改变这件事. 然后, $k$ 怎么才 $8$, 那就可以直接压出这 $2^8$ 种状态, 然后矩阵搞出转移. 特殊处理那 $q$ 个位置即可.</p><h3 id="AGC018C-Coins"><a href="#AGC018C-Coins" class="headerlink" title="AGC018C Coins"></a>AGC018C Coins</h3><p>考虑先让所有人选 $x$, 然后就是选 $y$ 个 $b-a$ 和 $z$ 个 $c-a$, 那么直接建图 $s \stackrel{(y&#x2F;z, 0)}{\rightarrow} y&#x2F;z, y&#x2F;z\stackrel{(1, b_i-a_i&#x2F;c_i-a_i)}{\rightarrow} i, i\to t$, 那么对着这个模拟费用流, 这题直接模拟比增量简单.</p><h3 id="AT-arc085-d-NRE"><a href="#AT-arc085-d-NRE" class="headerlink" title="AT_arc085_d NRE"></a>AT_arc085_d NRE</h3><blockquote><p>个全为 $0$ 的数组 $a$, 给一个数组 $b$ 和 $q$ 个操作, 每个操作将数组 $a$ 指定区间改成 $1$, 问合理选择部分操作后使得两个数组的 $\sum [a_i\ne b_i]$ 最小.  </p><p>$n, q\le 2\times 10^5$</p></blockquote><p>和前两天一个USACO2018Life Guards P一模一样啊()</p><p>右端点排序, 设 $f_i$ 表示前 $i$ 个区间最后一个区间必选开始dp, dp时分有交和无交用线段树维护转移即可.</p><h3 id="AT-abc304-g-Max-of-Medians"><a href="#AT-abc304-g-Max-of-Medians" class="headerlink" title="AT_abc304_g Max of Medians"></a>AT_abc304_g Max of Medians</h3><blockquote><p>给定一个长度为 $2N(1\le N\le 10^5)$ 的序列 ${A_i}(0\le A_i&lt; 2^{30})$, 你需要将其中元素两两配对并求异或和, 得到 $N$ 个数的集合 $B$. 最大化 $B$ 的中位数, 其中集合的中位数定义为将集合排序后得到序列的第 $\lfloor\dfrac N2\rfloor + 1$ 项.</p></blockquote><p>用 $u_0, u_1$ 表示 $u$ 在01trie上的儿子.</p><p>看见中位数, 二分答案, 变成只有大于 $x$ 的能匹配求最大匹配.</p><p>然后建01trie贪心匹配, 从高到低遍历 $x$ 的位同时在trie上从根往下走, 前若干位是 $0$, 此时肯定优先跨子树匹配, 把多的那边剩下的数递归下去, 然后出现一个 $1$ 就要跨子树匹配了, 设 $f(u, v)$ 表示 $u$, $v$ 之间匹配最大数量, 那么如果此时 $u, v$ 所在层对应 $x$ 为 $1$ 就只能跨子树匹配 $u_0, v_1$ 和 $u_1, v_0$, 否则若剩下了还可以匹配 $u_0, v_0$ 或 $u_1, v_1$, 就做完了.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Forest题解</title>
      <link href="/2022/05/17/P6556Forest/"/>
      <url>/2022/05/17/P6556Forest/</url>
      
        <content type="html"><![CDATA[<h1 id="The-Forest题解"><a href="#The-Forest题解" class="headerlink" title="The Forest题解"></a>The Forest题解</h1><h3 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h3><p>t组询问, 每次给两棵n个点的树A和B, 求有多少点集满足B树上是一个连通块而A树上是一条链. $n\le1e5, t\le3$ </p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>链比连通块性质更好, 从A树角度考虑</p><h4 id="A是链的解法"><a href="#A是链的解法" class="headerlink" title="A是链的解法"></a>A是链的解法</h4><p>这是后面的基础. 对于树上的一个连通块, 满足 $V-E&#x3D;1$, 当A是链也就是每条链成了一个区间, 于是每次移动区间右端点, 数据结构维护左端点, 于是可以开一棵线段树, 下标 $i$ 位置表示以链上下标为 $i$ 的位置为左端点, 到当前右端点这一段区间的 $V-E$, 因为 $V-E$ 不可能比 $1$ 更小, 所以维护区间最小值和最小值个数, 支持区间加, 每次</p><ul><li><p>$r’: &#x3D;r+1$</p></li><li><p>给 $1$ 到 $r’$ 加一, 对于它们所有都多了 $r’$ 这个点</p></li><li><p>遍历  $r’$ 在B树上的每一条边, 若指向的顶点在当前区间内, 给这个点到 $r’$ 的这个区间减一, 因为左端点在这个区间时点集会包含这条边.</p></li></ul><h4 id="完整解法一-–-换根"><a href="#完整解法一-–-换根" class="headerlink" title="完整解法一 – 换根"></a>完整解法一 – 换根</h4><p>把刚才的解法拓展到树上, 维护每个点到根 $rt$ 的这条路径的 $V-E$, 对任意一个根, 可以 $O(n)$ 求出所有节点的值, 然后进行换根, 考虑根移动到它的一个儿子时, 如图, 当根由 $u$ 到 $v$, $v$ 的子树内节点到根的路径要去掉 $u$, $v$ 的子树外节点到根路径要加上 $v$, 类比链上加一个点两个步骤, 就有了以下四个步骤</p><p><img src="https://raw.githubusercontent.com/FireInIceCode/imgs/main/imgs/202205062307160.png" alt="示意图"></p><ol><li><p>$v$ 的子树内节点到根路径少了 $u$ 这个点, 所以给 $v$ 子树内所有节点 $V-E$ 的值减1</p></li><li><p>它们也失去了 $u$ 在B树上的边, 所以遍历这些边, 设一条边连向 $w$, 若 $w$ 在 $v$ 子树内( $w$ 在子树外不会被子树内到根路径包含)把 $w$ 子树加一( $w$ 子树内的点到 $u$ 的路径会包含 $w$ )</p></li><li><p>$v$ 子树外的点到根路径多了 $v$ 这个点, 所以给 $v$ 子树外所有点 $V-E$ 的值 +1</p></li><li><p>它们也拥有了 $v$ 在B树上的边, 遍历这些边, 设一条边连向 $w$ , 在 $w$ 以 $u$ 为根的意义下 $w$ 的子树到 $v$ 路径包含这条边, 给它们减一, 此时分两种情况</p><ul><li><p>$w$ 在 $u$ 到 $rt$ 的路径上( $rt$ 是一开始的根), $w$ 有一个儿子包含 $u$ , 叫它 $t$ , 分析发现 $w$ 以 $u$ 为根的子树就是在以 $rt$ 为根的情况下除了 $t$ 的子树的所有点.</p></li><li><p>$w$ 不在 $u$ 到 $rt$ 的路径上, 此时以 $u$ 为根的子树和以 $rt$ 为根的子树相同, 直接给这个子树减一.</p></li></ul></li></ol><p>根从儿子转移到父亲显然就是把上述步骤所有加一减一取反.</p><p>我们发现所有操作都是对一个子树操作(一个子树外可转化为全局减去这个子树), 所以在dfs序上建线段树, 仍然维护区间最小值和最小值个数, 支持区间加即可.</p><p>根走的路程是A树的欧拉环游, 会进入&#x2F;退出每个点一次, 所以进入一个点执行的操作3和4是 $O(nlogn)$ 的, 但进入一个点会一起遍历它父亲在B树上的边, 那么对于A树上儿子很多的点就会重复遍历B树上的边很多次, 如果这个点碰巧在B树上度数也大, 那么在执行步骤2的复杂度就 $O(n^2)$ 了</p><p>所以要保证每条边只遍历常数次, 可以对每个点B树上的边按边指向的点在A树上的 dfs 序排序, 并按 dfs 升序&#x2F;降序遍历A树上的儿子转移, 于是步骤2中满足 $u$ 在 $v$ 子树中的边是一个区间, 保证了每个边遍历一次. 总复杂度就是 $O(nlogn)$ 的了</p><p>我们在每个节点</p><p>代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">500</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sons[N];</span><br><span class="line">    <span class="type">int</span> ecnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        ecnt++;</span><br><span class="line">        sons[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ecnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sons[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; at, bt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Seg</span> &#123;</span><br><span class="line">    <span class="type">int</span> minval, mincnt, atag;</span><br><span class="line">&#125; segs[N * <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(Seg&amp; x, <span class="type">const</span> Seg&amp; a, <span class="type">const</span> Seg&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.minval == b.minval) &#123;</span><br><span class="line">        x.mincnt = a.mincnt + b.mincnt;</span><br><span class="line">        x.minval = a.minval;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.minval &lt; b.minval) &#123;</span><br><span class="line">        x.mincnt = a.mincnt;</span><br><span class="line">        x.minval = a.minval;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.mincnt = b.mincnt;</span><br><span class="line">        x.minval = b.minval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">refresh</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">merge</span>(segs[x], segs[x &lt;&lt; <span class="number">1</span>], segs[x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag_add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    segs[x].minval += v;</span><br><span class="line">    segs[x].atag += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (segs[x].atag) &#123;</span><br><span class="line">        <span class="built_in">tag_add</span>(x &lt;&lt; <span class="number">1</span>, segs[x].atag);</span><br><span class="line">        <span class="built_in">tag_add</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, segs[x].atag);</span><br><span class="line">        segs[x].atag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rangeadd</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> al, <span class="type">int</span> ar, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (al &lt;= l &amp;&amp; ar &gt;= r) &#123;</span><br><span class="line">        <span class="built_in">tag_add</span>(x, v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (al &lt;= mid)</span><br><span class="line">        <span class="built_in">rangeadd</span>(x &lt;&lt; <span class="number">1</span>, l, mid, al, ar, v);</span><br><span class="line">    <span class="keyword">if</span> (ar &gt; mid)</span><br><span class="line">        <span class="built_in">rangeadd</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, al, ar, v);</span><br><span class="line">    <span class="built_in">refresh</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Seg <span class="title">query</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> ql, <span class="type">int</span> qr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= l &amp;&amp; qr &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span> segs[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    Seg ans = (Seg)&#123;INF, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (ql &lt;= mid)</span><br><span class="line">        <span class="built_in">merge</span>(ans, ans, <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span>, l, mid, ql, qr));</span><br><span class="line">    <span class="keyword">if</span> (qr &gt; mid)</span><br><span class="line">        <span class="built_in">merge</span>(ans, ans, <span class="built_in">query</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ves[N];</span><br><span class="line"><span class="type">int</span> dfn[N], arr[N], siz[N], dcnt;</span><br><span class="line"><span class="type">bool</span> onpath[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    dfn[u] = ++dcnt;</span><br><span class="line">    arr[dcnt] = u;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    ves[u] = ves[f] + <span class="number">1</span>;</span><br><span class="line">    onpath[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : bt.sons[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (onpath[v]) &#123;</span><br><span class="line">            ves[u]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : at.sons[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">    onpath[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        segs[x].mincnt = <span class="number">1</span>;</span><br><span class="line">        segs[x].atag = <span class="number">0</span>;</span><br><span class="line">        segs[x].minval = ves[arr[l]];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span>, l, mid);</span><br><span class="line">    <span class="built_in">build</span>(x &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">refresh</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[a] &lt; dfn[b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">in</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[b] &gt;= dfn[a] &amp;&amp; dfn[b] &lt; dfn[a] + siz[a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeadd</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">rangeadd</span>(<span class="number">1</span>, <span class="number">1</span>, dcnt, dfn[u], dfn[u] + siz[u] - <span class="number">1</span>, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= dcnt; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, dcnt, i, i).minval &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">moveRoot</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> x, <span class="type">int</span> bi)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">treeadd</span>(v, <span class="number">-1</span> * x);  <span class="comment">// v子树内的点少了u</span></span><br><span class="line">    <span class="comment">//删除u的边</span></span><br><span class="line">    <span class="keyword">while</span> (bi &lt; bt.sons[u].<span class="built_in">size</span>() &amp;&amp; dfn[bt.sons[u][bi]] &lt; dfn[v] + siz[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dfn[bt.sons[u][bi]] &gt;= dfn[v])</span><br><span class="line">            <span class="built_in">treeadd</span>(bt.sons[u][bi], <span class="number">1</span> * x);</span><br><span class="line">        bi++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">treeadd</span>(<span class="number">1</span>, <span class="number">1</span> * x);  <span class="comment">// v子树外的点多了v</span></span><br><span class="line">    <span class="built_in">treeadd</span>(v, <span class="number">-1</span> * x);</span><br><span class="line">    <span class="comment">//增加v的边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w : bt.sons[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">in</span>(v, w))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (u == w) &#123;</span><br><span class="line">            <span class="built_in">treeadd</span>(v, <span class="number">1</span> * x);</span><br><span class="line">            <span class="built_in">treeadd</span>(<span class="number">1</span>, <span class="number">-1</span> * x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">in</span>(w, u)) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = at.sons[w].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (dfn[at.sons[w][mid]] &lt;= dfn[u]) &#123;</span><br><span class="line">                    l = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> t = at.sons[w][l];</span><br><span class="line">            <span class="built_in">treeadd</span>(t, <span class="number">1</span> * x);</span><br><span class="line">            <span class="built_in">treeadd</span>(<span class="number">1</span>, <span class="number">-1</span> * x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">treeadd</span>(w, <span class="number">-1</span> * x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, dcnt, <span class="number">1</span>, dcnt).mincnt;</span><br><span class="line">    <span class="built_in">sort</span>(at.sons[u].<span class="built_in">begin</span>(), at.sons[u].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="built_in">sort</span>(bt.sons[u].<span class="built_in">begin</span>(), bt.sons[u].<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="type">int</span> bi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : at.sons[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">moveRoot</span>(u, v, <span class="number">1</span>, bi);</span><br><span class="line">        <span class="built_in">solve</span>(v, u);</span><br><span class="line">        bi = <span class="built_in">moveRoot</span>(u, v, <span class="number">-1</span>, bi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(segs,<span class="number">0</span>,<span class="built_in">sizeof</span>(segs));</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    dcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        bt.<span class="built_in">add_edge</span>(u, v);</span><br><span class="line">        bt.<span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        at.<span class="built_in">add_edge</span>(u, v);</span><br><span class="line">        at.<span class="built_in">add_edge</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, dcnt);</span><br><span class="line">    <span class="built_in">solve</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; (ans - n) / <span class="number">2</span> + n &lt;&lt; endl;</span><br><span class="line">    at.<span class="built_in">clear</span>(n);</span><br><span class="line">    bt.<span class="built_in">clear</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">test</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整解法二-–-点分治"><a href="#完整解法二-–-点分治" class="headerlink" title="完整解法二 – 点分治"></a>完整解法二 – 点分治</h4><p>仍然考虑个链的做法拓展到树上, 在A树进行点分治, 首先对于每一层:</p><ul><li>预处理分治的当前层中所有节点到重心的链在B树上的 $V-E$ , 此时可以顺便把从一个端点在根的路径的答案求出, 于是后面仅考虑两端点在不同子树的, 也就是说, 当处理一棵子树时子树内的点答案正确性无需考虑.</li><li>按dfs序递增的遍历根在A树上所有儿子, 此时遍历到一个点时, 维护的 $V-E$ 就是所有点到分治中心的链的值, dfs当前儿子的子树, 进入一个点时把答案移动成所有点到当前点的 $V-E$ , 所以就是<ul><li>给当前子树外的所有点 $+1$</li><li>遍历它每一条边, 判断这条边是指向节点(设为 $w$ )在当前处理的子树外还是当前节点到根的路径上:<ul><li>子树外: 给 $w$ 的子树 $-1$</li><li>子树内到根的路径上: 因为我们已经只考虑跨子树的路径, 所以只要给当前子树外的点 $-1$ 即可.</li></ul></li></ul></li></ul><p>注意每做完一棵子树清空.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 换根 </tag>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/05/17/hello_world/"/>
      <url>/2022/05/17/hello_world/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>新博客开通啦<br>洛谷每篇文章只有一个标签过于烦人, 所以就这样啦<br>以前洛谷上的文章已经都迁移过来, 但以后的<del>可能</del>只在这里发</p><p>写一些杂项</p><p>hexo迁移到jekyll.</p><p>jekyll又迁移到hexo为了支持加密文章.</p><h2 id="一点说明"><a href="#一点说明" class="headerlink" title="一点说明"></a>一点说明</h2><p>序列常常会用 $a_n$ 表示长度为 $n$ 的序列.</p><p>标签咕咕表示还在更新<del>(或表示总有一天会更新)</del></p><p>标签日志指做题记录, 笔记是记录某些人的讲课或自己学的科技, 训练多半是还包括模拟赛等.</p><p>半角标点是信仰.</p><h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="jekyll的部分"><a href="#jekyll的部分" class="headerlink" title="jekyll的部分"></a>jekyll的部分</h3><p>现在支持emoji和折叠了</p><p>博客副标题里不能用<code>%</code>, 否则会死</p><p>死亡特点是没有标题, 并且时间不对(为你<code>push</code>的日期)</p><p>latex里不能出现{ { . . .  } }, 因为这个是jekyll的模板语法. </p><p>死亡特点是居中对齐的latex源码.</p><h3 id="hexo的部分"><a href="#hexo的部分" class="headerlink" title="hexo的部分"></a>hexo的部分</h3><p>要clean以应用更改.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感性理解网络单纯形</title>
      <link href="/2022/05/17/network_simplex/"/>
      <url>/2022/05/17/network_simplex/</url>
      
        <content type="html"><![CDATA[<h1 id="感性理解网络单纯形"><a href="#感性理解网络单纯形" class="headerlink" title="感性理解网络单纯形"></a>感性理解网络单纯形</h1><p>传说最快费用流</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>单纯形, 费用流基本概念</p><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>$n$ 为点数, $m$ 为边数, 先假设图为<strong>联通</strong>的(显然不联通没有影响)</p><p>边 $e$ 的单位费用为 $cost_e$ , 流量上界为 $cap_e$ , 由 $u_e$ 指向 $v_e$ </p><p>认为我们建网络流的图时是建了反向边的</p><h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>我们知道费用流模型在线性规划标准形式的系数矩阵是<strong>全幺模矩阵</strong>, (这个矩阵有 $n$ 行 $m$ 列, 仅由 $0, 1, -1$ 组成, 每一列可以表示一条边, 设这条边由 $u$ 指向 $v$, 则矩阵中 $u$ 行为 $-1$, $v$ 行为 $1$).</p><p>直接单纯形, 我们会设每一条边的流量, 然后再转化标准形式, 所以这里可以认为边的流量是线性规划中的变量(忽略松弛变量).</p><p><strong>注意到此矩阵的一组基对应图的一棵生成树</strong>. 证明: 若选中的基包含一个环, 则将这个环的边的列顺次相加得到0, 则这不是一组基, 所以基的列对应的图无环, 又因其能张成原图, 所以其联通, 因此能唯一对应一棵生成树.</p><p>于是得到这样对应关系:</p><ul><li><p>单纯形中变量对应边的流量</p></li><li><p>单纯形中基的选择对应图的一棵生成树(一种边的选择)</p></li></ul><p>于是对应着其流程, 我们要找到</p><ul><li><p>如何将一个非基变量替换一个基变量</p><ul><li><p>如何选择一个非基变量并移入</p><ul><li>如何增加一个变量的值</li></ul></li><li><p>如何选择一个基变量并移出</p></li></ul></li></ul><h4 id="增加一个变量的值-边的流量"><a href="#增加一个变量的值-边的流量" class="headerlink" title="增加一个变量的值(边的流量)"></a>增加一个变量的值(边的流量)</h4><p>对于一条边, 我们可以沿着它在一个环上推动一个流:</p><p><img src="https://raw.githubusercontent.com/FireInIceCode/imgs/main/imgs/202205111557679.png"></p><p>如图, 如果图中存在这一一个环, 我们可以沿着它推送10的流量, 容易发现仍然满足流量平衡.</p><h4 id="寻找应该移入的非基变量"><a href="#寻找应该移入的非基变量" class="headerlink" title="寻找应该移入的非基变量"></a>寻找应该移入的非基变量</h4><p>当沿着一个环增加变量的值时, 为了保证费用最小, 我们<strong>只在环的费用和为负时做</strong>, 但这样无法保证流量最大, 所以可以<strong>先给源点到汇点建一条边流满, 费用为 inf, 流量为 inf</strong>, 此时它的反向边会和其他由源到汇的流形成一个环, 且沿着这个环推动费用只降不增(反向边费用为 -inf )于是保证了在最大流前提下寻找最小费用.</p><p>于是我们面临的问题是, 如何快速计算环的和, 这里有一个不错的 trick:</p><p>对于每一个点计算它到根的路径的费用和, 我们命名为 $Pi$ , 则对于边 e: u-&gt;v , 它形成的环的费用和为 $Reduce_e &#x3D; Cost_e + Pi_u -Pi_v$ , 因为除了 e 本身的费用外, 从 u 到 u 和 v 的 lca 的费用是 $pi_{lca} - pi_u$ (因为方向是逆着树边走的所以<strong>费用取反</strong>) , 从 lca 走到 v 的费用是 $Pi_u - Pi_{lca}$ , 两者相加即可得到.</p><h4 id="替换基变量"><a href="#替换基变量" class="headerlink" title="替换基变量:"></a>替换基变量:</h4><p>按照单纯形算法我们要替换掉的是一个<strong>限制最紧</strong>的变量, 对应到这里就是找到这个<strong>环中剩余流量最小的边</strong>把它移出.</p><h4 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h4><p>于是我们按照以下流程去做:</p><ol><li><p>找到初始的基, 也就是随便建一棵生成树</p></li><li><p>根据选择策略找到一条边, 给这个环整体加上一个流, 所以</p><ol><li><p>我们看看这个环最大能加多少(就是这个环上边容量的最小值), 并给它加上这么多. 这个操作就相当于我们在LP中把这条边的变量加入基变量, 对于这条边的变量进行增加以在顶点间移动. </p></li><li><p>加入这个基变量后要删除一个(基大小为矩阵的秩), 移出环上剩余流量最小的边</p></li></ol></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="边的选择"><a href="#边的选择" class="headerlink" title="边的选择"></a>边的选择</h3><p>三种方式</p><ol><li><p>按照单纯形中, 我们可以检查每一条边并找到其中 $Reduce_e$ 最小的 e 作为新的基变量</p></li><li><p>直接循环遍历所有边, 每碰到一个 $Reduce_e &lt; 0$ 的就选了</p></li><li><p>平衡前两种, 划分大小为B的块, 对每一个块内使用策略1, 块和块间策略2, 按LEMON论文, B应取 $\sqrt V$</p></li></ol><h3 id="实现1-单次O-n-暴力"><a href="#实现1-单次O-n-暴力" class="headerlink" title="实现1, 单次O(n), 暴力"></a>实现1, 单次O(n), 暴力</h3><p><del>暴力怎么做? (小声) 暴力怎么做? (大声) 暴力是不是, 加边, 加边, 加边, 并查集查询</del></p><p>用向上标记法lca(充满了暴力的味道), 每次删除一条边时暴力翻转一条链的父子关系(画图可以得知, 这个关系是从删除的那条边中深的端点到新加的那条边的端点的链)</p><h3 id="实现2-单次O-logn-Link-Cut-Tree"><a href="#实现2-单次O-logn-Link-Cut-Tree" class="headerlink" title="实现2, 单次O(logn), Link-Cut Tree"></a>实现2, 单次O(logn), Link-Cut Tree</h3><p>我觉大家看到树上删去一条边, 新加一条边, 寻找链上最小值, 是不是都想到LCT了</p><p>常数大, 但再大 O(logn) 也大不过 O(n) 吧, 不知道为什么没见人写过.</p><p>如果有人写了这个告诉我谢谢.</p><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>每次移入移出遍历为最坏 $O(V)$ , 在边的选择上用策略3期望 $O(\sqrt E )$ </p><p>至于到底要执行多少次这个移入, 移出的过程, 这和单纯形一样是玄学吧, ~~目前有多种不同的分析, 得出的结论大致相近, ~~为:</p><p><del>O(能过), O(很快), O(玄学)和</del>O(基本到不了的最坏指数级)</p><p>我为了<del>偷懒</del>代码的简洁选择了策略2+暴力的实现, 经测试随机数据下, 在我的拖拉机电脑上大概1s跑m&#x3D;1. 5e5, v&#x3D;4e4的图刚刚好, 已经远远超过EK和Zkw的 $VE^2$ 了吧</p><p>我的实现:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span>+<span class="number">500</span>,M=<span class="number">5e6</span>+<span class="number">500</span>,INF=<span class="number">1e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Edge&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w,c,next;</span><br><span class="line">&#125; edges[M];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> _add_edge(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)&#123;</span><br><span class="line">    edges[++ecnt]=(Edge)&#123;u,v,w,c,head[u]&#125;;</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    _add_edge(u,v,w,c);</span><br><span class="line">    _add_edge(v,u,<span class="number">0</span>,-c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fe为父亲指向自己的边,mark是标记当前信息是否过期等用途,curtime表示mark值为curtime的信息未过期</span></span><br><span class="line"><span class="type">int</span> piCache[N],fa[N],fe[N],circle[N],mark[N],curtime=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 随机一棵生成树初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init_tree</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fi)</span></span>&#123;</span><br><span class="line">    fe[u]=fi;</span><br><span class="line">    fa[u]=edges[fi].u;</span><br><span class="line">    mark[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edges[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=edges[i].v;</span><br><span class="line">        <span class="comment">//不过这里mark就判重用的</span></span><br><span class="line">        <span class="keyword">if</span>(mark[v]||edges[i].w==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">init_tree</span>(v,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark[x]==curtime)<span class="keyword">return</span> piCache[x];</span><br><span class="line">    mark[x]=curtime;</span><br><span class="line">    piCache[x]=<span class="built_in">pi</span>(fa[x])+edges[fe[x]].c;</span><br><span class="line">    <span class="keyword">return</span> piCache[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; pii;</span><br><span class="line"></span><br><span class="line"><span class="comment">//沿着e在生成树上形成的环推送流</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pushFlow</span><span class="params">(<span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="comment">//向上标记法求lca,够暴力</span></span><br><span class="line">    <span class="type">int</span> rt=edges[e].u,lca=edges[e].v;</span><br><span class="line">    curtime++;</span><br><span class="line">    <span class="type">int</span> ccnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(rt)&#123;</span><br><span class="line">        mark[rt]=curtime;</span><br><span class="line">        rt=fa[rt];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(mark[lca]!=curtime)&#123;</span><br><span class="line">        mark[lca]=curtime;</span><br><span class="line">        lca=fa[lca];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到被替换的(省域流量最小的)边,记录环上最小剩余流量</span></span><br><span class="line">    <span class="type">int</span> minflow=edges[e].w,p=<span class="number">2</span>,del_u=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=edges[e].u;u!=lca;u=fa[u])&#123;</span><br><span class="line">        circle[++ccnt]=fe[u];</span><br><span class="line">        <span class="keyword">if</span>(edges[fe[u]].w&lt;minflow)&#123;</span><br><span class="line">            minflow=edges[fe[u]].w;</span><br><span class="line">            del_u=u;</span><br><span class="line">            p=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> u=edges[e].v;u!=lca;u=fa[u])&#123;</span><br><span class="line">        <span class="type">int</span> ne=fe[u]^<span class="number">1</span>;</span><br><span class="line">        circle[++ccnt]=ne;</span><br><span class="line">        <span class="keyword">if</span>(edges[ne].w&lt;minflow)&#123;</span><br><span class="line">            minflow=edges[ne].w;</span><br><span class="line">            p=<span class="number">1</span>;</span><br><span class="line">            del_u=u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    circle[++ccnt]=e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//沿着环推送流量</span></span><br><span class="line">    <span class="type">int</span> cost=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=ccnt;i++)&#123;</span><br><span class="line">        cost+=edges[circle[i]].c*minflow;</span><br><span class="line">        edges[circle[i]].w-=minflow;</span><br><span class="line">        edges[circle[i]^<span class="number">1</span>].w+=minflow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果最小的就是当前边就不用加到树上了</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">2</span>)<span class="keyword">return</span> cost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把边加入树上,翻转一条链</span></span><br><span class="line">    <span class="type">int</span> u=edges[e].u,v=edges[e].v;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="number">1</span>)<span class="built_in">swap</span>(u,v);</span><br><span class="line">    <span class="type">int</span> last_e=e^p,last_u=v;</span><br><span class="line">    <span class="keyword">while</span>(last_u!=del_u)&#123;</span><br><span class="line">        last_e^=<span class="number">1</span>;</span><br><span class="line">        mark[u]--; <span class="comment">// 设置这条链上的信息过期</span></span><br><span class="line">        <span class="built_in">swap</span>(fe[u],last_e);</span><br><span class="line">        <span class="type">int</span> nu=fa[u];</span><br><span class="line">        fa[u]=last_u;</span><br><span class="line">        last_u=u;</span><br><span class="line">        u=nu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总算法</span></span><br><span class="line"><span class="function">pii <span class="title">simplex</span><span class="params">(<span class="type">int</span> s,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="built_in">add_edge</span>(t,s,INF,-INF);</span><br><span class="line">    <span class="built_in">init_tree</span>(t,<span class="number">0</span>);</span><br><span class="line">    mark[t]=++curtime;</span><br><span class="line">    fa[t]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cost=<span class="number">0</span>,flow=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//反复执行</span></span><br><span class="line">    <span class="type">bool</span> running=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(running)&#123;</span><br><span class="line">        running=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=ecnt;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edges[i].w&amp;&amp;edges[i].c+<span class="built_in">pi</span>(edges[i].u)-<span class="built_in">pi</span>(edges[i].v)&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                cost+=<span class="built_in">pushFlow</span>(i);</span><br><span class="line">                running=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//flow在每次直接累加是错的,会把正反的都算上,直接根据一开始加的那条边算</span></span><br><span class="line">    flow=edges[ecnt].w;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(flow,cost+flow*INF); <span class="comment">//+flow*INF是消除一开始加的那条边的费用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个是luogu或uoj费用流板子对应的主程序</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m,s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v,w,c;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v,w,c);</span><br><span class="line">    &#125;</span><br><span class="line">    pii res=<span class="built_in">simplex</span>(s,t);</span><br><span class="line">    cout&lt;&lt;res.first&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;res.second&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>Q: 这东西太快了, 我想用它跑最大流</p><p>A: 可以, 但费用设成0远比设成1或其他值快(然后你可以用它过HLPP板子</p><p>Q: 为什么我用这个跑不过luogu费用流板子上最优解(一个EK算法)?</p><p>A: 你不可能跑过打表</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://codeforces.com/blog/entry/94190">[Tutorial] Network simplex - Codeforces</a> 好文, 就是从这学的</p><p><a href="https://www.cs.upc.edu/~erodri/webpage/cps/theory/lp/network/slides.pdf">矩阵角度讲解</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 单纯形 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点分治优化树上连通块DP</title>
      <link href="/2022/05/17/nodeconquerwithdp/"/>
      <url>/2022/05/17/nodeconquerwithdp/</url>
      
        <content type="html"><![CDATA[<h1 id="点分治优化树上连通块DP"><a href="#点分治优化树上连通块DP" class="headerlink" title="点分治优化树上连通块DP"></a>点分治优化树上连通块DP</h1><p>qyc只摆了一个优化连通块背包dp的例题, 所以我理解并不透彻(</p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>有时我们处理树上连通块, 由于在树上, 对于包含根的连通块, 连通块若不包含父亲则一定不能包含儿子, 根据这个性质, 我们可以把dp进行不重不漏的划分, 选这个父亲的方案或不选的方案, 从而可以直接将对应状态直接合并来代替困难的dp合并.</p><p>既然划分成选或不选根, 就容易理解通过点分治进行根的选取从而达到优化效果了</p><p>适用于解决合并困难而插入一个点较简单的计数dp (也可能不是计数? 但这种划分还能怎么用没见过)</p><h4 id="例题Tree-Cutting-HDU-5909-Virtual-Judge-vjudge-net"><a href="#例题Tree-Cutting-HDU-5909-Virtual-Judge-vjudge-net" class="headerlink" title="例题Tree Cutting - HDU 5909 - Virtual Judge (vjudge. net):"></a>例题<a href="https://vjudge.net/problem/HDU-5909">Tree Cutting - HDU 5909 - Virtual Judge (vjudge. net)</a>:</h4><h5 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h5><p>点有点权, 对每一个k求点权异或和为k的连通块个数</p><h5 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h5><p>首先对于每个分治部分处理:</p><p>dp[j]为当前异或和为j的连通块个数</p><p>一开始dp[j]全为空, dp[0]&#x3D;1, 即都不选时异或和为0</p><p>dfs当前点分治的部分, 进入一个节点就有两种情况</p><ul><li><p>不选这个节点, 则这个点的儿子也不能选了, 那么答案仍然是是其父亲传下来的dp[j], 我们叫他dp0[j]</p></li><li><p>选这个节点, 那么我们把父亲传下来的答案dp[j]&#x3D;dp[j^w], w为当前点权, 即相当于选上了这个点的影响, 然后继续dfs, 在这个修改后的dp[]上算子孙的答案, 给儿孙们处理完了叫它dp1[j]</p></li></ul><p>最后这个点的答案就为dp[j]&#x3D;dp0[j]+dp1[j], 可以发现正好对应了所有情况.</p><p>对于每个分治重心, dfs相当于带着dp[]在树上转一圈, 便得到了这个分治部分的答案.</p><p>我们还需要给dp[0]–, 因为这个分治重心需要强制选, 否则所有节点均不选的情况会在每个分治重心都算一次, 我们把它剔除, 合并完所有分治重心的答案后再dp[0]++</p><p>然后我们要把所有分治重心的答案合并, 因为每个分治重心的答案都是不互相包含的, 所以就直接各个重心答案对应位置相加即最终答案.</p><p>给一份代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1600</span>,P=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,next;</span><br><span class="line">&#125; edges[N*<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ecnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    edges[++ecnt].u=u;</span><br><span class="line">    edges[ecnt].v=v;</span><br><span class="line">    edges[ecnt].next=head[u];</span><br><span class="line">    head[u]=ecnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> rt,rtmaxson,total;</span><br><span class="line"><span class="type">int</span> siz[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    siz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edges[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=edges[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]||v==f)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">findroot</span>(v,u);</span><br><span class="line">        siz[u]+=siz[v];</span><br><span class="line">        maxp=<span class="built_in">max</span>(maxp,siz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxp=<span class="built_in">max</span>(maxp,total-siz[u]);</span><br><span class="line">    <span class="keyword">if</span>(maxp&lt;rtmaxson)&#123;</span><br><span class="line">        rtmaxson=maxp;</span><br><span class="line">        rt=u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> dp[N],cdp[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cdp[u][i]=dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="comment">// dp[i^w[u]]=(cdp[u][i^w[u]]+cdp[u][i])%P;</span></span><br><span class="line">        dp[i^w[u]]=cdp[u][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edges[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=edges[i].v;</span><br><span class="line">        <span class="keyword">if</span>(v==f||vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        dp[i]=(dp[i]+cdp[u][i])%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> adp[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfz</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(u,<span class="number">0</span>);</span><br><span class="line">    dp[<span class="number">0</span>]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        adp[u][i]=dp[i];</span><br><span class="line">        dp[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edges[i].next)&#123;</span><br><span class="line">        <span class="type">int</span> v=edges[i].v;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="keyword">continue</span>;</span><br><span class="line">        total=siz[v];</span><br><span class="line">        rt=<span class="number">0</span>,rtmaxson=<span class="number">1e9</span>;</span><br><span class="line">        <span class="built_in">findroot</span>(v,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfz</span>(rt,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line">    ecnt=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        <span class="built_in">add_edge</span>(u,v);</span><br><span class="line">        <span class="built_in">add_edge</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    rt=<span class="number">0</span>,total=n,rtmaxson=<span class="number">1e9</span>;</span><br><span class="line">    <span class="built_in">findroot</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">    <span class="built_in">dfz</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            dp[j]=(dp[j]+adp[i][j])%P;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cout&lt;&lt;dp[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=m<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h4><p>HDU难用极了, 建议写完直接用我的拍一拍就行了</p><p>如果你想在HDU上过这个题, 注意一下几点</p><ul><li><p>CE: HDU不支持(结构体名){. . . }的创建结构体方法, 且iostream里并没有min&#x2F;max</p></li><li><p>PE(Presentation Error): 最恶心的地方, 每一行末尾不能有空格, 但整个程序最后要有一个空行</p></li><li><p>WA: 你写错了</p></li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><p><a href="https://www.luogu.com.cn/blog/YouAreDalao/shu-fen-zhi-notes">树分治学习笔记 - ShanLunjiaJian的blog - 洛谷博客 (luogu. com. cn)</a>包含这个内容, 不过不如下面那个详细</p><p><a href="https://www.luogu.com.cn/blog/YouAreDalao/dian-fen-zhi-you-hua-dp">点分治优化dp学习笔记 - ShanLunjiaJian的blog - 洛谷博客 (luogu. com. cn)</a>对此有更抽象泛华的解释</p><p><a href="https://blog.csdn.net/weixin_45539557/article/details/115713573">hdu5909 (点分治+dfs序上树形DP_TeJoy的博客-CSDN博客</a>讲了一种dfs序满足连通块限制的trick</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 点分治 </tag>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板复习</title>
      <link href="/2022/05/17/templates/"/>
      <url>/2022/05/17/templates/</url>
      
        <content type="html"><![CDATA[<h1 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h1><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="tarjan"><a href="#tarjan" class="headerlink" title="tarjan:"></a>tarjan:</h3><ul><li><p>割点</p><ul><li><p>条件: 对于点 $u$ 存在儿子 $v$ 使 $low_v\ge dfn_u$ (实现时 $low$ 可以算 $u$ 的 $dfn$, 也对)</p></li><li><p>感性理解: 说明 $v$ 的子树内除了 $u$ 之外没有其他方法走到外面</p></li><li><p>注意: 对于 dfs 树的根(开始 dfs 的节点), 要通过统计子树个数方法判断( $&gt;1$ 则为割点)</p></li><li><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> rt=<span class="number">0</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(rt==<span class="number">0</span>)rt=u;</span><br><span class="line">  dfn[u]=low[u]=++dcnt;</span><br><span class="line">  <span class="type">int</span> children=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> v:G[u])&#123;</span><br><span class="line">      <span class="keyword">if</span>(dfn[v])&#123;</span><br><span class="line">          low[u]=<span class="built_in">min</span>(low[u],dfn[v]);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">dfs</span>(v,rt);</span><br><span class="line">      children++;</span><br><span class="line">      low[u]=<span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">      <span class="keyword">if</span>(u!=rt&amp;&amp;low[v]&gt;=dfn[u])&#123;</span><br><span class="line">          <span class="comment">//说明是割点</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(children&gt;<span class="number">1</span>&amp;&amp;u==rt)&#123;</span><br><span class="line">      <span class="comment">//说明是割点</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>割边</p><ul><li>条件: 对于边 $e$: $u\to v, low_v&gt;&#x3D;dfn_u$</li><li>理解: 同割点</li><li>实现: 简单不放</li></ul></li><li><p>强联通分量</p><ul><li>条件: dfs 时把点入栈, 在 $dfn_u&#x3D;low_v$ 时, 要退出 dfs 时若满足条件一直弹栈到把自己也弹了, 弹出部分都是同一 scc</li><li>理解: 同一强联通分量在 dfs 中是连续的一块, 在栈里也是</li><li>细节: low 不更新横叉边指向的点(已经被访问却在栈外)</li></ul></li><li><p>圆方树</p><ul><li>仙人掌版<ul><li>&#96;&#96;&#96;cpp<br>void addpoints(int stop,int ex) {<br>scnt++;<br>tadd_edge(ex,scnt);<br>int v;<br>do{<br>    v&#x3D;stk.top();<br>    tadd_edge(v,scnt);<br>    stk.pop();<br>}while(v!&#x3D;stop);<br>}<br>void tarjan(int u) {<br>dfn[u] &#x3D; low[u] &#x3D; ++dcnt;<br>stk.push(u);<br>for (int v : G[u])<br>    if (dfn[v])<br>        low[u] &#x3D; min(low[u], dfn[v]);<br>    else {<br>        tarjan(v);<br>        low[u] &#x3D; min(low[u], low[v]);<br>        if (low[v] &gt;&#x3D; dfn[u])<br>            if (stk.top() &#x3D;&#x3D; v) {<br>                tadd_edge(u,v);<br>                stk.pop();<br>            } else<br>                addpoints(v,u);<br>    }<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 差分约束</span><br><span class="line"></span><br><span class="line">#### 细节:</span><br><span class="line"></span><br><span class="line">1. 最短路是满足条件的最大解, 最长路是最小解</span><br><span class="line"></span><br><span class="line">2. 建立隐藏条件边</span><br><span class="line"></span><br><span class="line">3. 相等条件双向连边</span><br><span class="line"></span><br><span class="line">## 字符串</span><br><span class="line"></span><br><span class="line">### SAM</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">const int N=1e6+500;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int nxt[27];</span><br><span class="line">    int len,link;</span><br><span class="line">&#125; ns[N*2];</span><br><span class="line">int root,last,scnt;</span><br><span class="line">void init()&#123;</span><br><span class="line">    root=0;</span><br><span class="line">    ns[0].link=-1;</span><br><span class="line">    ns[0].len=0;</span><br><span class="line">    last=root;</span><br><span class="line">    scnt=0;</span><br><span class="line">&#125;</span><br><span class="line">void insert(char c)&#123;</span><br><span class="line">    int cur=++scnt;</span><br><span class="line">    ns[cur].len=ns[last].len+1;</span><br><span class="line">    int p=last;</span><br><span class="line">    last=cur;</span><br><span class="line">    while(p!=-1&amp;&amp;!ns[p].nxt[c])&#123;</span><br><span class="line">        ns[p].nxt[c]=cur;</span><br><span class="line">        p=ns[p].link;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p==-1)&#123;</span><br><span class="line">        ns[cur].link=root;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int q=ns[p].nxt[c];</span><br><span class="line">    if(ns[p].len+1==ns[q].len)&#123;</span><br><span class="line">        ns[cur].link=q;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int clone=++scnt;</span><br><span class="line">    ns[clone].len=ns[p].len+1;</span><br><span class="line">    ns[clone].link=ns[q].link;</span><br><span class="line">    memcpy(ns[clone].nxt,ns[q].nxt,sizeof(ns[clone].nxt));</span><br><span class="line">    while(p!=-1&amp;&amp;ns[p].nxt[c]==q)&#123;</span><br><span class="line">        ns[p].nxt[c]=clone;</span><br><span class="line">        p=ns[p].link;</span><br><span class="line">    &#125;</span><br><span class="line">    ns[q].link=ns[cur].link=clone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="细节"><a href="#细节" class="headerlink" title="细节:"></a>细节:</h4><ol><li>记得初始化</li><li>记得<code>p=ns[p]. link</code>的挑父亲</li><li>记得数组开 $2$ 倍</li><li>广义SAM要特判!</li></ol><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">500</span>,inf=<span class="number">1e7</span>+<span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt[N], siz[N], val[N], ch[N][<span class="number">2</span>], fa[N],ncnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">refresh</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    siz[x] = siz[ch[x][<span class="number">0</span>]] + siz[ch[x][<span class="number">1</span>]] + cnt[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> f = fa[x], gf = fa[f], w1 = <span class="built_in">chk</span>(x), w2 = <span class="built_in">chk</span>(f);</span><br><span class="line">    fa[ch[x][!w1]] = f;</span><br><span class="line">    ch[f][w1] = ch[x][!w1];</span><br><span class="line">    fa[f] = x;</span><br><span class="line">    ch[x][!w1] = f;</span><br><span class="line">    fa[x] = gf;</span><br><span class="line">    ch[gf][w2] = x;</span><br><span class="line">    <span class="built_in">refresh</span>(f);</span><br><span class="line">    <span class="built_in">refresh</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> goal = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (fa[x] != goal) &#123;</span><br><span class="line">        <span class="type">int</span> f = fa[x];</span><br><span class="line">        <span class="keyword">if</span>(fa[f]!=goal)&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">chk</span>(x) == <span class="built_in">chk</span>(f))</span><br><span class="line">                <span class="built_in">rotate</span>(f);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">rotate</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!goal)</span><br><span class="line">        root = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=root;</span><br><span class="line">    <span class="keyword">while</span>(val[u]!=v&amp;&amp;ch[u][v&gt;val[u]])&#123;</span><br><span class="line">        u=ch[u][v&gt;val[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(val[u]==v)&#123;</span><br><span class="line">        cnt[u]++;</span><br><span class="line">        <span class="built_in">splay</span>(u);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> x=++ncnt;</span><br><span class="line">        cnt[x]=siz[x]=<span class="number">1</span>;</span><br><span class="line">        val[x]=v;</span><br><span class="line">        fa[x]=u;</span><br><span class="line">        <span class="keyword">if</span>(u)ch[u][v&gt;val[u]]=x;</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=root;</span><br><span class="line">    <span class="keyword">while</span>(val[u]!=v&amp;&amp;ch[u][v&gt;val[u]])&#123;</span><br><span class="line">        u=ch[u][v&gt;val[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(<span class="built_in">find</span>(v));</span><br><span class="line">    <span class="keyword">if</span>(val[root]&lt;v)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">int</span> u=ch[root][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(ch[u][<span class="number">1</span>])u=ch[u][<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">succ</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">splay</span>(<span class="built_in">find</span>(v));</span><br><span class="line">    <span class="keyword">if</span>(val[root]&gt;v)<span class="keyword">return</span> root;</span><br><span class="line">    <span class="type">int</span> u=ch[root][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(ch[u][<span class="number">0</span>])u=ch[u][<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="built_in">find</span>(v);</span><br><span class="line">    <span class="keyword">if</span>(cnt[u]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        cnt[u]--;</span><br><span class="line">        <span class="built_in">splay</span>(u);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> pr=<span class="built_in">pre</span>(val[u]),su=<span class="built_in">succ</span>(val[u]);</span><br><span class="line">        <span class="built_in">splay</span>(pr);</span><br><span class="line">        <span class="built_in">splay</span>(su,pr);</span><br><span class="line">        fa[u]=ch[su][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">splay</span>(su);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;=siz[ch[u][<span class="number">0</span>]])u=ch[u][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val&gt;siz[ch[u][<span class="number">0</span>]]+cnt[u])val-=siz[ch[u][<span class="number">0</span>]]+cnt[u],u=ch[u][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank_</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u=<span class="built_in">find</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(u);</span><br><span class="line">    <span class="keyword">return</span> siz[ch[u][<span class="number">0</span>]]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">insert</span>(-inf);</span><br><span class="line">    <span class="built_in">insert</span>(inf);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> opt,x;</span><br><span class="line">        cin&gt;&gt;opt&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">remove</span>(x);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">5</span>)&#123;</span><br><span class="line">            cout&lt;&lt;val[<span class="built_in">pre</span>(x)]&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">6</span>)&#123;</span><br><span class="line">            cout&lt;&lt;val[<span class="built_in">succ</span>(x)]&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(opt==<span class="number">3</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">rank_</span>(x)<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;val[<span class="built_in">kth</span>(x+<span class="number">1</span>)]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="细节-1"><a href="#细节-1" class="headerlink" title="细节"></a>细节</h4><ol><li>双旋要判断祖父是不是目标</li><li>当不保证求前驱后继的节点存在时, 要在<code>splay(find(val))</code>后判断根是否满足条件.</li><li>区分节点编号和值, 用那个变量命名(</li></ol><h3 id="LCT"><a href="#LCT" class="headerlink" title="LCT"></a>LCT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> fa[N],ch[N][<span class="number">2</span>],val[N],xors[N];</span><br><span class="line"><span class="type">bool</span> rev[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">notroot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>]==x||ch[fa[x]][<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>]==x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">refresh</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    xors[x]=xors[ch[x][<span class="number">0</span>]]^xors[ch[x][<span class="number">1</span>]]^val[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tag_rev</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ch[x][<span class="number">0</span>],ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x]^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!rev[x])<span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">tag_rev</span>(ch[x][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">tag_rev</span>(ch[x][<span class="number">1</span>]);</span><br><span class="line">    rev[x]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f=fa[x],gf=fa[f],k1=<span class="built_in">chk</span>(x),k2=<span class="built_in">chk</span>(f);</span><br><span class="line">    fa[x]=gf;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">notroot</span>(f))ch[gf][k2]=x;</span><br><span class="line">    <span class="keyword">if</span>(ch[x][k1^<span class="number">1</span>])fa[ch[x][k1^<span class="number">1</span>]]=f;</span><br><span class="line">    ch[f][k1]=ch[x][k1^<span class="number">1</span>];</span><br><span class="line">    fa[f]=x;</span><br><span class="line">    ch[x][k1^<span class="number">1</span>]=f;</span><br><span class="line">    <span class="built_in">refresh</span>(f);</span><br><span class="line">    <span class="built_in">refresh</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> stk[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> scnt=<span class="number">0</span>,tmp=x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">notroot</span>(tmp))&#123;</span><br><span class="line">        stk[++scnt]=tmp;</span><br><span class="line">        tmp=fa[tmp];</span><br><span class="line">    &#125;</span><br><span class="line">    stk[++scnt]=tmp;</span><br><span class="line">    <span class="keyword">while</span>(scnt)<span class="built_in">pushdown</span>(stk[scnt--]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">notroot</span>(x))&#123;</span><br><span class="line">        <span class="type">int</span> f=fa[x];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">notroot</span>(f))&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">chk</span>(f)==<span class="built_in">chk</span>(x))&#123;</span><br><span class="line">                <span class="built_in">rotate</span>(f);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">rotate</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">access</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;x;y=x,x=fa[x])&#123;</span><br><span class="line">        <span class="built_in">splay</span>(x);</span><br><span class="line">        ch[x][<span class="number">1</span>]=y;</span><br><span class="line">        <span class="built_in">refresh</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">changeroot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="built_in">tag_rev</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findroot</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">access</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="built_in">pushdown</span>(x);</span><br><span class="line">    <span class="keyword">while</span>(ch[x][<span class="number">0</span>])&#123;</span><br><span class="line">        x=ch[x][<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">pushdown</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">link</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">findroot</span>(v)!=u)&#123;</span><br><span class="line">        fa[u]=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cut</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">findroot</span>(y)!=x||fa[y]!=x||ch[y][<span class="number">0</span>])<span class="keyword">return</span>;</span><br><span class="line">    fa[y]=<span class="number">0</span>;</span><br><span class="line">    ch[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">refresh</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">changeroot</span>(x);</span><br><span class="line">    <span class="built_in">access</span>(y);</span><br><span class="line">    <span class="built_in">splay</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="细节-2"><a href="#细节-2" class="headerlink" title="细节:"></a>细节:</h4><ol start="0"><li><p>link, cut时如果不判断应该是进行<code>makeroot(x)</code>, <code>access(y)</code>, <code>splay(y)</code>, <code>findroot</code>代码中干了这些</p></li><li><p>注意<code>findroot</code>最后要<code>splay</code>根</p></li><li><p><code>cut</code>的判断: <code>findroot(y)==x</code>说明在同一棵树, <code>fa[y]==x</code>是因为直接相连, <code>ch[y][0]==0</code>因为比它浅的只有根, 根是它的父亲.</p></li><li><p><code>access</code>背过</p></li><li><p><code>findroot</code>要记得<code>pushdown</code></p></li></ol><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="FWT"><a href="#FWT" class="headerlink" title="FWT"></a>FWT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwtAnd</span><span class="params">(<span class="type">int</span> *f,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=l)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;k++)&#123;</span><br><span class="line">                f[p+k]=(f[p+k]+f[p+k+mid]*x)%P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwtOr</span><span class="params">(<span class="type">int</span> *f,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=l)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;k++)&#123;</span><br><span class="line">                f[p+k+mid]=(f[p+k]*x+f[p+k+mid])%P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fwtXor</span><span class="params">(<span class="type">int</span> *f,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> mid=l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=l)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;mid;k++)&#123;</span><br><span class="line">                <span class="type">int</span> o1=f[p+k],o2=f[p+k+mid];</span><br><span class="line">                f[p+k]=(o1+o2)*x%P;</span><br><span class="line">                f[p+k+mid]=(o1-o2)*x%P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别把与和或弄反, 异或最后 $x$ 是 $1$(正变换)或 $1&#x2F;2$(逆变换)</p><p>输出时要注意把数弄回正的, 因为减法过程会出负数</p><h3 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span>* rev)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">1</span>&lt;&lt;w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        rev[i] = (rev[i &gt;&gt; <span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i &amp; <span class="number">1</span>)&lt;&lt;(w<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bittrans</span><span class="params">(<span class="type">int</span> n, ll* f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">            <span class="built_in">swap</span>(f[i], f[rev[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">fpow</span><span class="params">(ll a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">fpow</span>(a*a%P,b/<span class="number">2</span>)*a%P;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fpow</span>(a*a%P,b/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ntt</span><span class="params">(<span class="type">int</span> n,ll* f,<span class="type">bool</span> op)</span></span>&#123;</span><br><span class="line">    ll g=<span class="number">3</span>,invg=<span class="built_in">fpow</span>(g,P<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">bittrans</span>(n,f);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">2</span>;l&lt;=n;l&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ll wn=<span class="built_in">fpow</span>(op?g:invg,(P<span class="number">-1</span>)/l);</span><br><span class="line">        <span class="type">int</span> mid=l&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;n;p+=l)&#123;</span><br><span class="line">            ll w=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;mid;i++)&#123;</span><br><span class="line">                ll x=f[p+i],y=f[p+mid+i]*w%P;</span><br><span class="line">                f[p+i]=(x+y)%P;</span><br><span class="line">                f[p+mid+i]=(x-y+P)%P;</span><br><span class="line">                w=(w*wn)%P;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!op)&#123;</span><br><span class="line">        ll invn=<span class="built_in">fpow</span>(n,P<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)f[i]=f[i]*invn%P;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂题(tricks)</title>
      <link href="/2022/05/17/unsorted_problems/"/>
      <url>/2022/05/17/unsorted_problems/</url>
      
        <content type="html"><![CDATA[<p>做题笔记</p><h2 id="几个杂题"><a href="#几个杂题" class="headerlink" title="几个杂题"></a>几个杂题</h2><h3 id="P2150-寿司晚宴-dp-状压dp"><a href="#P2150-寿司晚宴-dp-状压dp" class="headerlink" title="P2150 寿司晚宴 [dp] [状压dp]"></a>P2150 寿司晚宴 [dp] [状压dp]</h3><p>大于 $\sqrt n$ 的质因数最多只有一个, 最多出现一次, 相同大质因数一起处理, 背包合并</p><p>[trick] 大于 $\sqrt n$ 的质因数只有一个单独处理</p><h3 id="P2048-超级钢琴-greedy"><a href="#P2048-超级钢琴-greedy" class="headerlink" title="P2048 超级钢琴 [greedy]"></a>P2048 超级钢琴 [greedy]</h3><p>要求所有区间的前k大, 考虑处理 $k$ 次取最大, 开一个堆记录 $(l, rl, rr, t)$ 表示左端点为 $l$ , 右端点在 $rl$ 到 $rr$ 间时最优位置为 $t$ 的答案, 每次从堆中取出最优解, 把区间分裂成 $(l, rl, t-1)$ 和 $(l, t+1, r)$ 两个区间放回堆中</p><p>[trick] 把 $n^2$ 个点对贡献压缩成 $n$ 个 $p, l, r$ 表示一个点和区间 $l, r$ 中的点的贡献, $n^2$ 个可能贡献取前 $O(n)$ 个, 可能是先放能代表所有的, 一边拿一边把新的加入堆.</p><h3 id="P3783-天才黑客-ds-virtual-tree-最短路-前缀和优化建图"><a href="#P3783-天才黑客-ds-virtual-tree-最短路-前缀和优化建图" class="headerlink" title="P3783 天才黑客 [ds] [virtual-tree] [最短路] [前缀和优化建图]"></a>P3783 天才黑客 [ds] [virtual-tree] [最短路] [前缀和优化建图]</h3><p>点边互换, 考虑对于一个点怎么把这些边连到一起.</p><p>考虑边之间的贡献是lcp, 那么可以转字典树上lca, 然后转字典树欧拉序最小值.</p><p>那么在这个序列上一个最小值会贡献前面一段后面一段, 用前后缀优化建图. 并且因为要对每个点单独跑一遍所以要用虚树.</p><p>最后可能会连出多余的边, 但是最短路保证了只会走最小值(重边自动取min), 所以是正确的.</p><p>[trick] 最短路最小值自动取min</p><h3 id="P1763-埃及分数-ida-搜索"><a href="#P1763-埃及分数-ida-搜索" class="headerlink" title="P1763 埃及分数 [ida] [搜索]"></a>P1763 埃及分数 [ida] [搜索]</h3><p>居然是第一次写迭代加深</p><p>首先迭代加深主要是用在dfs搜索情况太多必然会挂, bfs每层情况太多存不下, 此时若能确定一个状态的后继状态的一个较小的范围那么就可以用.</p><p>如果我们决定每层分母从小到大, 也就是分数递减, 那么重点就是看每层的上下界, 设减去前面搜了的还剩 $\frac {a}{b}$ 要填, 当前分母为x, 后面还有 $rest$ 层:</p><p>当分母大到一定程度, 即使后面的都等于自己也到不了1时显然是不行的, 所以 $rest*\frac {1} {x} \ge \frac {a} {b}$ </p><p>当分母小到一定程度, 即使后面都是0也超了更是不行的, 所以 $\frac {1} {x} \le {a} {b}$ </p><p>最后, 这题似乎并没有靠谱做法, 至少在要求最大分母少于 $10^7$ 时讨论区里这组数据还杀遍程序无敌手:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line">570 877</span><br><span class="line">Output:</span><br><span class="line">2 7 144 15786 18417 42096</span><br></pre></td></tr></table></figure><hr><h3 id="P8350-SDOI-x2F-SXOI2022-进制转换"><a href="#P8350-SDOI-x2F-SXOI2022-进制转换" class="headerlink" title="P8350 [SDOI&#x2F;SXOI2022] 进制转换"></a>P8350 [SDOI&#x2F;SXOI2022] 进制转换</h3><blockquote><p>给定 $n, x, y, z$ 求 $\sum_{i&#x3D;1}^n x^iy^{f(i)}z^{g(i)}$.<br>$f(i), g(i)$ 表示 $i$ 在二进制, 三进制下表示的数位和.<br>$n\le 10^{13}$</p></blockquote><p>数据范围让你想到根号, 于是考虑折半.</p><p>因为看起来二进制结构更好, 所以考虑折三进制, 可以设数 $w&#x3D;i+j\cdot 3^C_1$,</p><p>那么看起来 $x$ 和 $z$ 的贡献就是把项 $x^iz^{g(i)}$ 卷起来.</p><p>考虑二进制, 在依据刚才的 $C_1$ 划分后, 再按照二进制划分为 $C_2$ 使得 $2^{C_2}\ge 3^{C_1}$, 此时发现合并时低 $C_2$ 位是直接加, 问题是可能出一个进位, 于是只需卷两遍即可.</p><p>[trick] 折半, 卷积优化折半</p><h3 id="P8330-ZJOI2022-众数"><a href="#P8330-ZJOI2022-众数" class="headerlink" title="P8330 [ZJOI2022] 众数"></a>P8330 [ZJOI2022] 众数</h3><blockquote><p>给定 $a_n$, 求区间 $[l, r]$ 使得区间内的众数出现次数和区间外的数的众数出现次数的和最大.</p><p>$n\le 5\times 10^5$, 3s</p></blockquote><p>[trick] 出现次数相关, 根号分治.</p><p>大的部分, 枚举一个多于 $\sqrt n$ 的数, 处理出出现次数的前缀和, 再枚举另一个数作为内区间, 显然区间内这个数的出现次数要多于刚才的大数, 所以用SDOI2022 d1t1 trick让复杂度关于小数即可. 大数作为内区间同理.</p><p>小的部分, 考虑对于一个出现次数 $c$ 的颜色本质不同区间有 $c^2$ 个, 于是一共有 $n\sqrt n$ 个本质不同区间, 那么只要 $O(1)$ 算区间众数, 这显然不太可做, 性质是众数出现次数数根号级. 考虑扫描线, 对每个 $l$ 维护 $[l, r]$ 的答案, 那么当 $r$ 移动一个的时候, 遍历位置 $r$ 之前所有的出现位置 $x_1\ldots x_m$, 对每个 $x_j$, 从 $x_j$ 开始更新 $x_j, x_j-1\ldots$ 的答案, 如果不能更新直接结束, 这样因为更新总次数(也就是维护的答案总和)是 $n\sqrt n$ 量级, 所以复杂度是对的. </p><p>总复杂度 $n\sqrt n$.</p><p>[trick] 把答案作为势能(每次尝试更新答案)</p><h3 id="CF1731F-Function-Sum"><a href="#CF1731F-Function-Sum" class="headerlink" title="CF1731F Function Sum"></a>CF1731F Function Sum</h3><blockquote><p>对于一个长度为 $n$ 的数列 $a$.</p><p>定义 $lsl(i)$ 表示 $i$ 左边的数中比 $a_i$ 小的数的个数, 即 $\sum\limits_{j &#x3D; 1}^{i - 1}[a_j &lt; a_i]$.</p><p>同样的定义 $grr(i)$ 表示 $i$ 右边的比 $a_i$ 大的数的个数, 即 $\sum\limits_{j &#x3D; i + 1}^n[a_j &gt; a_i]$.</p><p>我们称一个位置是好的当且仅当 $lsl(i) &lt; grr(i)$.</p><p>我们再对于一个数列 $a$ 定义一个函数 $f(a)$ 为 $\sum\limits_{i &#x3D; 1}^na_i[i\  \text{is good}]$.</p><p>现在给定两个整数 $n, k$, 请你求出对于所有长度为 $n$ 且 $1 \leq a_i \leq k$ 的数列 $a$ 的 $f(a)$ 的和是多少.</p><p>答案对 $\text{998244353}$ 取模.</p><p>$n\le 50, k\le 998244352$</p></blockquote><p>容易发现每个位置对答案的贡献可以单独计算. 那么此时你试着算一个位置 $p$ 是好的的序列个数, 应该是</p><p>$$<br>\sum_a \sum_b \sum_v (v-1)^{a+n-p-b}(k-v)^{p-1-a+b} \cdot v<br>$$</p><p>这样的, 所以把 $v$ 当自变量就是多项式, 那么最后做一个前缀和次数增加一, 所以算前 $n+1$ 项+拉插</p><h3 id="P7324-WC2021-表达式求值"><a href="#P7324-WC2021-表达式求值" class="headerlink" title="P7324 [WC2021] 表达式求值"></a>P7324 [WC2021] 表达式求值</h3><blockquote><p>定义二元操作符 <code>&lt;</code>: 对于两个长度都为 $n$ 的数组 $A, B$(下标从 $1$ 到 $n$), $A$ <code>&lt;</code> $B$ 的结果也是一个长度为 $n$ 的数组, 记为 $C$. 则有 $C[i] &#x3D; \min(A[i], B[i])$($1 \le i \le n$).</p><p>定义二元操作符 <code>&gt;</code>: 对于两个长度都为 $n$ 的数组 $A, B$(下标从 $1$ 到 $n$), $A$ <code>&gt;</code> $B$ 的结果也是一个长度为 $n$ 的数组, 记为 $C$. 则有 $C[i] &#x3D; \max(A[i], B[i])$($1 \le i \le n$).</p><p>现在有 $m$($1 \le m \le 10$)个长度均为 $n$ 的整数数组 $A_0, A_1, \ldots , A_{m-1}$. 给定一个待计算的表达式 $E$, 其满足 $E$ 中出现的每个操作数都是 $A_0, A_1, \ldots , A_{m-1}$ 其中之一, 且 $E$ 中只包含 <code>&lt;</code> 和 <code>&gt;</code> 两种操作符(<code>&lt;</code> 和 <code>&gt;</code> 的运算优先级相同), 因此该表达式的结果值也将是一个长度为 $n$ 的数组.</p><p>特殊地, 表达式 $E$ 中还可能出现操作符 <code>? </code>, 它表示该运算符可能是 <code>&lt;</code> 也可能是 <code>&gt;</code>. 因此若表达式中有 $t$ 个 <code>? </code>, 则该表达式可生成 $2^t$ 个可求确定值的表达式, 从而可以得到 $2^t$ 个结果值, 你的任务就是求出这 $2^t$ 个结果值(每个结果都是一个数组)中所有的元素的和. 你只需要给出所有元素之和对 ${10}^9 + 7$ 取模后的值.</p><p>$1 \le n \le 5 \times {10}^4$, $1 \le m \le 10$, $\vert S\vert \le 5 \times {10}^4$, $1 \le A_i[j] \le {10}^9$.</p></blockquote><p>容易想到每一位独立, 考虑一位怎么做. 同时可以假设没有相同元素, 否则钦定大小关系. 另外建出表达式树也是显然的.</p><p>然后发现, 对于某一位能不能到最后, 只取决于有哪些数比他小, 与实际值和其他元素相对大小无关. 于是设 $f_{i, S, u, 0&#x2F;1&#x2F;2}$ 表示比 $a_i$ 小的节点集合是 $S$, 表达式树上节点 $u$ 的值比 $a_i$ 大&#x2F;小&#x2F;相等的方案数. 枚举 $i, S$, 转移是第四维上的max卷积. 复杂度是 $m2^m\vert S\vert$.</p><p>正解是考虑优化掉 $i$, 因为 $S$ 已经反映了 $i$ 的大小信息: 于是改成计算答案大于等于 $S$ 中的元素的答案, 这样就不依赖 $i$ 了, 状态可以改成 $f_{S, u, 0&#x2F;1}$ $0&#x2F;1$ 表示当前节点大于等于或小于(不在 $S$ 中或在 $S$ 中), 复杂度 $2^m\vert S\vert$</p><p>[trick] 只取一个序列中有效的大小关系在此题把 $n!$ 优化成 $2^n$. 将dp状态之间的关系利用好(如 $S$ 表示了 $i$ 的大小信息)</p><h3 id="AGC003E-Sequential-operations-on-Sequence"><a href="#AGC003E-Sequential-operations-on-Sequence" class="headerlink" title="[AGC003E] Sequential operations on Sequence"></a>[AGC003E] Sequential operations on Sequence</h3><blockquote><p>一串数, 初始为 $1\sim n$, 现在给 $Q$ 个操作, 每次操作把数组长度变为 $q_i$(更短则截取前缀, 更长则不断重复原数组), $Q$ 次操作后 $1\sim n$ 每个数出现了多少次.</p><p>$1\le q_i \le 10^{18}$</p></blockquote><p>首先变短操作之前的变长是没用的, 于是可以先把序列变成单调的. 显然我们不能维护整个数组, 于是想到设 $f_i(x)$ 表示第一个大于的 $q$ 进行完之后, 前 $x$ 个位置 $i$ 的出现次数, 那么有 $f_i(q_i)&#x3D;(\lfloor \dfrac{q_i}{q_{i-1}} \rfloor)f_i(q_{i-1})+f_i(q_{i}\bmod q_{i-1})$, 于是考虑从后往前, 对每个 $f$ 维护其对最终结果的贡献系数. 右边部分因为每次膜比自己小的数, 最多递归log次, 直接做就行.</p><h3 id="CF1394C-Boboniu-and-String"><a href="#CF1394C-Boboniu-and-String" class="headerlink" title="CF1394C Boboniu and String"></a>CF1394C Boboniu and String</h3><p>什么烂题面, 容易发现实际上跟字符串是什么完全没关系, 就是只要<code>B</code>, <code>N</code>数量对, 然后发现每次操作你一定选增加的那个就行, 每次你可以让两者<code>B</code>, <code>N</code>的数量差同时加一或减一, 或者单独调一个. 那你就二分答案, 每个 $s$ 会给出一个对 $t$ 中<code>B</code>, <code>N</code>数量的限制, 判有无解即可.</p><h3 id="CF1034C-Region-Separation"><a href="#CF1034C-Region-Separation" class="headerlink" title="CF1034C Region Separation"></a>CF1034C Region Separation</h3><blockquote><p>一棵 $n$ 个点的树, 每个点有权值. 你想砍树. 你可以砍任意次, 每次你选择一些边断开, 需要满足砍完后每个连通块的权值和是相等的. 求有多少种砍树方案. $n\le 10^6$</p></blockquote><p>设权值总和为 $s$, 考虑假设砍到 $\dfrac{s}{d}$ 块, 每块大小为 $d$, 那么深度从大到小, 如果一个点大小不够就把它合并到父亲上, 如果正好是 $d$ 就分一段, 发现好像方案唯一? 实际上就是断所有子树大小为 $d$ 的倍数的点的父边, 最后要求这样的点有 $\dfrac{s}{d}$ 个. 于是先求出子树大小数组 $s$, 设 $f_d&#x3D;\sum_i [d\vert s_i]$, 因为 $d$ 很大改为枚举 $\dfrac{s}{d}$ 即划分的块数 $k$, 则 $[\frac{s}{k}\vert s_u]$, 考虑一个 $s_u$ 对所有 $\dfrac{s}{gcd(s, s_u)}\vert k$ 有贡献, 那可以存进桶里枚举 $k$ 统计, 复杂度是调和级数. 然后要算 $g_k$ 为划分成 $k$ 块的方案数, 则 $g_k&#x3D;f_k\times (\sum_{i\vert k} g_i+1)$.</p><p>最后复杂度是 $n\ln n$</p><p>[trick] 把树分成 $k$ 个连通块要求它们权值相等的方案数唯一, 条件为存在 $k$ 个子树大小为 $k$ 的倍数</p><h3 id="CF1608F-MEX-counting"><a href="#CF1608F-MEX-counting" class="headerlink" title="CF1608F MEX counting"></a>CF1608F MEX counting</h3><p>显然dp, 但mex显然不能记下来, 考虑把方案数拖到后面算上, dp设 $f_{i, j, k}$ 表示填完前 $i$ 个, 当前 $\mathrm{mex}(a_1\ldots a_n)&#x3D;j$, 已经填过 $k$ 种不同的大于 $j$ 的值即可.</p><p>状态数显然是 $n^2k$, 瓶颈在填入 $j$(即更新 $\mathrm{mex}$ 时)需要枚举新的 $j$ 并计算贡献, 然后这个东西上个前缀和优化就转移 $O(1)$ 了.</p><h3 id="P3352-ZJOI2016-线段树"><a href="#P3352-ZJOI2016-线段树" class="headerlink" title="P3352 [ZJOI2016] 线段树"></a>P3352 [ZJOI2016] 线段树</h3><p>容易想到拆成 $v&#x3D;\sum_i [v&gt;i]$, 此时相当于 $01$ 序列, 容易发现当前的 $0$ 的答案只和两边最近的 $1$ 相关, 于是设 $f_{i, l, r, v}$ 表示进行 $i$ 次操作, 当前考虑某个值是否 $&gt;v$, 使得左边&#x2F;右边最近的 $1$ 分别在 $l-1, r+1$ 的位置的方案数, 容易做到 $n^4$.</p><h2 id="codeforces-2200左右的trees题"><a href="#codeforces-2200左右的trees题" class="headerlink" title="codeforces 2200左右的trees题"></a>codeforces 2200左右的trees题</h2><h3 id="CF76A-Gift-lct-mst"><a href="#CF76A-Gift-lct-mst" class="headerlink" title="CF76A Gift [lct] [mst]"></a>CF76A Gift [lct] [mst]</h3><blockquote><p>一张图, 每条边有两个属性 $(g_i, s_i)$ . 给定 $G, S$ , 求一棵图的生成树 $T$ , 使得 $G \times \max(g_i) + S \times \max (s_i)$ 最小. ( $i\in T$ )</p><p>注意: 图可能包含重边和自环.</p><p>$N\le 200, M\le 50000$</p></blockquote><p>考虑把所有 $G$ 和 $S$ 直接乘上去, 就不用管了. 问题变成 $\min \max(g_i)+\max(s_i)$</p><p>那么枚举一个最大的 $g$ , 能选的边是一个前缀, LCT! .</p><p>题解区里没有LCT? 要不我去写一个? 考虑一个阳间做法, 这题 $N$ 只有200. </p><h3 id="CF77C-Beavermuncher-0xFF-dp"><a href="#CF77C-Beavermuncher-0xFF-dp" class="headerlink" title="CF77C Beavermuncher-0xFF [dp]"></a>CF77C Beavermuncher-0xFF [dp]</h3><blockquote><p>给定一棵树, 点 $i$ 的权值为 $k_i$ 求一条从根出发到根结束的路径使得每个点经过次数不大于其权值. 最大化路径长度.<br>$n, k_i\le 10^5$</p></blockquote><p>$f_i$ 表示进入 $i$ 的子树走一圈回到 $i$ 的最大数量, 那么求 $f_u$ 肯定是走了孩子中 $f$ 递增排休后的一个前缀. 结束了.</p><h3 id="CF575B-Bribes-ds"><a href="#CF575B-Bribes-ds" class="headerlink" title="CF575B Bribes [ds]"></a>CF575B Bribes [ds]</h3><blockquote><p>给一棵树, 一些边无方向边权为0, 有向边逆向经过一次边权翻倍. 求按照给定顺序经过 $k$ 个点的边权和. 答案膜.</p><p>$n\le 10^5, k\le 10^6$</p></blockquote><p>首先一个显然的 $2log$ 做法, 就是树剖区间乘区间和.</p><p>那么正解可以对每一条边单独考虑, 按某方向经过它的代价当然是有若干次子树内与子树外这个切换.</p><p>考虑切换是上一次在一个子树区间内, 下一次在子树区间外的个数, 那么把相邻两个数看作一个点, 就转化为二维数点了, 1log.</p><p>看题解, 愚蠢了. 直接树上差分做.</p><h3 id="CF893F-Subtree-Minimum-Query-线段树合并"><a href="#CF893F-Subtree-Minimum-Query-线段树合并" class="headerlink" title="CF893F Subtree Minimum Query [线段树合并]"></a>CF893F Subtree Minimum Query [线段树合并]</h3><blockquote><p>给你一颗有根树, 点有权值, $m$ 次询问, 每次问你某个点的子树中距离其不超过 $k$ 的点的权值的最小值. (边权均为 $1$ , 点权有可能重复, $k$ 值每次询问有可能不同)<br>强制在线</p><p>$n\le 10^5, m\le 10^6, a_i\le 10^9$</p></blockquote><p>线段树合并一眼题.</p><p>看题解, 原来题目深意在于难为主席树. 不过可以直接考虑就是深度, dfs序两维的数点要强制在线. 那显然就是时间轴建哪的问题, 发现如果时间轴建在dfs序上会寄因为要考虑这个值在区间中出现次数(值有重复). 但只要两维反一下就直接做.</p><p>另外给相同点权强行钦定大小整成多个也能做啊.</p><h3 id="CF1174F-Ehab-and-the-Big-Finale-交互-点分治-树剖"><a href="#CF1174F-Ehab-and-the-Big-Finale-交互-点分治-树剖" class="headerlink" title="CF1174F Ehab and the Big Finale [交互] [点分治] [树剖]"></a>CF1174F Ehab and the Big Finale [交互] [点分治] [树剖]</h3><blockquote><p>给一棵 $n$ 点树, 有一个不知道的点 $x$ , 每次你可以询问 $x$ 到一个点的距离, 或者询问 $x$ 的祖先的哪一个儿子是 $x$ 的祖先. 找出 $x$ .</p><p>你可以进行36次操作. $n\le 2\times 10^5$</p></blockquote><p>首先显然是一个 $\log$ 的复杂度. 在树上进行 $\log$ 的常见分治有点&#x2F;边分治, 树剖.</p><p>我们没法添加虚边, 排除边分治.</p><p>发现点分治很直接, 我们找到重心, 如果是点的祖先就进入对应子树再找重心, 否则距离可以用来判断当前点是不是祖先. 就做完了. 次数可能多一次随便剪一剪.</p><h3 id="CF652E-Pursuit-For-Artifacts-边双-连通性"><a href="#CF652E-Pursuit-For-Artifacts-边双-连通性" class="headerlink" title="CF652E Pursuit For Artifacts [边双] [连通性]"></a>CF652E Pursuit For Artifacts [边双] [连通性]</h3><blockquote><p>给定一张 $n$ 点 $m$ 边简单无向连通图, 边权是 $0, 1$ . 每条边只能走一次, 求是否存在 $a\to b$ 的路径边权不为0.</p><p>$n, m\le 3\times 10^5$</p></blockquote><p>圆方树的重要结论是两个点间简单路径的并集是圆方树上到两个圆点路径距离为1的点. 边双结论相同. 所以缩点之后树上做即可. 所以这题完全可以 $10^5$ 询问吧!</p><hr><h2 id="Codeforces-好题-Div-1-1"><a href="#Codeforces-好题-Div-1-1" class="headerlink" title="Codeforces 好题 Div. 1-1"></a>Codeforces 好题 Div. 1-1</h2><p>看了上面那几个, 又从后面随机了几个, 没意思就换了个题单. 是编号2213 Codeforces 好题 Div. 1-1</p><p>尽量秒</p><h3 id="CF5E-Bindian-Signalizing-单调栈-环转序列"><a href="#CF5E-Bindian-Signalizing-单调栈-环转序列" class="headerlink" title="CF5E Bindian Signalizing [单调栈] [环转序列]"></a>CF5E Bindian Signalizing [单调栈] [环转序列]</h3><blockquote><p>圆环上有 $n$ 个点, 每个点有权值 $a_i$ , 求点对 $(i, j)$ 数量使得对于圆环上的两个区间 $[i, j]$ 中有至少一个满足 $\max_{k\in [i, j]} a_k\le \min{(a_i, a_j)}$</p><p>$n\le 10^6$</p></blockquote><p>考虑一个点能与哪些点形成点对.</p><p>如果这个点是全局最大值, 那么能与所有形成点对. 否则不会有一个点同时可以与这个点在两个方向的区间上形成点对.</p><p>考虑序列上一个点与前面的点形成点对, 显然维护缀max这件事只需要一个单调栈.</p><p>环上需要考虑跨过最后的贡献, 很难写. 最好的办法是把最大值转到最前面按序列做.</p><h3 id="CF8E-Beads-数位dp-dp"><a href="#CF8E-Beads-数位dp-dp" class="headerlink" title="CF8E Beads [数位dp] [dp]"></a>CF8E Beads [数位dp] [dp]</h3><blockquote><p>求所有长 $n$ 的01串 $s$ 中同时满足字典序不大于其逆序串, 取反串和逆序取反串的串中按字典序排序的第 $m$ 个.</p><p>$n\le 50, m\le 10^16$</p></blockquote><p>字典序不大于取反串, $s_1&#x3D;0$ .</p><p>根据最后一位是0或1决定是小于逆序串还是逆序取反串. 分别处理. 假设现在最后一位是0, 处理不大于逆序串.</p><p>可以同时两边向中间dp. $f_{i, 0&#x2F;1}$ 表示前 $i$ 个和后 $i$ 个已经确定, 且填到现在是小于逆序串还是等于逆序串的方案数.</p><p>我们会计数了, 但如何求 $kth$ 呢?</p><p>假设我们会钦定若干个字符后的方案数–我们确实会, 那么可以直接逐位确定.</p><p>看题解: 可以直接折半搜? ! 看来以后看到 $n\le 50$ 要想到这基本上是折半的上界.</p><h3 id="CF10E-Greedy-Change"><a href="#CF10E-Greedy-Change" class="headerlink" title="CF10E Greedy Change"></a>CF10E Greedy Change</h3><blockquote><p>给定 $n$ 种货币, 求最小的 $w$ 使得贪心求解兑换方式不对(贪心方式就是每次找到不大于它的最大的减去), 或说明不存在.</p><p>$n\le 400$</p></blockquote><p>论文题, 汪娟题</p><p>todo</p><h3 id="CF11D-A-Simple-Task-dp-状压dp"><a href="#CF11D-A-Simple-Task-dp-状压dp" class="headerlink" title="CF11D A Simple Task [dp] [状压dp]"></a>CF11D A Simple Task [dp] [状压dp]</h3><blockquote><p>求简单无向图的环数.</p><p>$n\le 19$</p></blockquote><p>降智了, 这不是图论题这是状压dp看到19该想到的.</p><p>那就对每个点跑一遍, $f_{i, S}$ 表示从点 $u$ 出发走到点 $i$ , 走过的点集合为 $S$ , 但很遗憾会把一个环算好多次.</p><p>不对每个点跑一次了, 钦定 $S$ 中走过的点最小的为出发节点(所以扩展时只能扩展比这个大的).</p><p>最后这样会把一条边算成一个环, 还会把一个环算两次, 所以去掉即可.</p><h3 id="CF13E-Holes-lct-分块-ds"><a href="#CF13E-Holes-lct-分块-ds" class="headerlink" title="CF13E Holes [lct] [分块] [ds]"></a>CF13E Holes [lct] [分块] [ds]</h3><p>就是弹飞绵羊</p><h3 id="CF15D-Map-二维前缀和"><a href="#CF15D-Map-二维前缀和" class="headerlink" title="CF15D Map [二维前缀和]"></a>CF15D Map [二维前缀和]</h3><blockquote><p>小P要在某个 $n\times m$ 规模的矩阵上建大小为 $a\times b$ 的房子, 已知这个矩阵每一点上的数值 $h_{i, j}$ 代表开始时地面的高度. <br>若建造 $a\times b$ 房子的地面不一致, 则要把选取的 $a\times b$ 大的矩阵中所有地面都挖低使得和其中一块最低的地面高度一样, 花费是挖的高度和. 小P会重复如下的步骤直至无法再建造更多的房子: </p><ol><li>找到 $n\times m$ 矩阵中建造房子花费最少的 $a\times b$ 矩阵, 优先选择左上角的矩阵. \</li><li>输出左上角的位置, 并输出在这里建房子的花费\</li><li>已经建过房子的地面不能再建房子. <br>$a, b\le 1000, h_{i, j}\le 10^9$</li></ol></blockquote><p>直接每个点预处理以这个点为左上角的代价排序. 代价处理需要二维前缀和求和, 和一个东西求最小值.</p><p>最小值要想求的简单, 感觉一个不错的办法是先竖着求竖着 $b$ 个的最小值再横着合并 $a$ .</p><p>然后解决选的不能和已有的覆盖, 这个怎么做呢? 每次选定一个点就把受这个影响的地方暴力覆盖, 复杂度是对的因为一共 $nm$ 个点.</p><h3 id="CF19E-Fairy-dfs树-graph"><a href="#CF19E-Fairy-dfs树-graph" class="headerlink" title="CF19E Fairy [dfs树] [graph]"></a>CF19E Fairy [dfs树] [graph]</h3><blockquote><p>给一张无向图, 求删一条边变成二分图的方案数.</p><p>$n, m\le 10^4$</p></blockquote><p>碰到不知道咋做的图论想dfs树.</p><p>dfs树上只有树边和返祖边, 定义一个返祖边对应的只有一条返祖边的环为本源环, 其中本源环为奇环的是坏边, 偶环的是好边, 注意到边能被删当且仅当在所有坏边的本源环上且不在好边的本源环上, 于是树上差分实现判断每条树边被多少坏边的本源环包含即可. 而返祖边只有当奇环总数是 $1$ 的时候删掉那条坏边可行.</p><p>这个充要条件是最巧妙的一步, 必须包含所有本源环显然, 不能删掉偶本源环内的是因为去掉之后偶环剩下的部分和奇环剩下的部分组成奇环.</p><p>[think] 这个做法的本质是dfs树把无向图排布成一个优秀的结构让返祖边表示本源环.</p><h3 id="CF25E-Test-greedy-string"><a href="#CF25E-Test-greedy-string" class="headerlink" title="CF25E Test [greedy] [string]"></a>CF25E Test [greedy] [string]</h3><blockquote><p>给出 $s_1, s_2, s_3$ , 求最短的 $t$ 使得其包含给出的三个串作为子串.</p><p>$n\le 10^4$</p></blockquote><p>暴力枚举三个子串出现的先后顺序, 最后答案只能是它们接起来. 算接起来的重叠部分可以直接kmp或hash二分.</p><h3 id="CF39C-Moon-Craters-dp"><a href="#CF39C-Moon-Craters-dp" class="headerlink" title="CF39C Moon Craters [dp]"></a>CF39C Moon Craters [dp]</h3><blockquote><p>给出在一个直线上的 $n$ 个圆(位置和半径为 $p_i, r_i$ ), 如果两个圆不相交则可以放在一起(可以包含), 求最多有多少个圆一起.</p><p>$n\le 2000$</p></blockquote><p>$f_{i, j}$ 表示区间 $i, j$ 的个数做就行了. 注意直接转移 $n^3$ , 但划分区间的时候可以钦定左半边是一整个圆, 这样只要划分那些有一个左端点是 $i$ 的区间的右端点即可.</p><h3 id="CF55D-Beautiful-numbers-dp-状态设计"><a href="#CF55D-Beautiful-numbers-dp-状态设计" class="headerlink" title="CF55D Beautiful numbers [dp] [状态设计]"></a>CF55D Beautiful numbers [dp] [状态设计]</h3><blockquote><p>求 $[l, r]$ 中美丽的数的个数, $x$ 美丽当且仅当 $x$ 可以被每一个非零位整除( $15$ 是美丽的因为可被 $1, 5$ 整除)</p><p>$1\le l\le r\le 9\times 10^18$</p></blockquote><p>看着很数位dp. 但要想判断是否能被整除需要知道数值是无法忍受的. 考虑 $1-9$ 的 $lcm$ 只有 $2520$ , $2520$ 的因数(对应当前 $0-9$ 的不同选择情况)只有48个, 于是就 $f_{i, j, k, 0&#x2F;1}$ 表示前 $i$ 位, 膜 $2520$ 为 $j$ , 当前选择的数要求它被 $2520$ 的第 $k$ 个因数整除, 是否顶到头的方案数.</p><h3 id="CF73D-FreeDiv-graph-greedy"><a href="#CF73D-FreeDiv-graph-greedy" class="headerlink" title="CF73D FreeDiv [graph] [greedy]"></a>CF73D FreeDiv [graph] [greedy]</h3><blockquote><p>给出一个 $n$ 点 $m$ 边的图和常数 $k$ , 你可以现在图中任意连边, 然后在得到的图中继续连边, 但此时一个点只能连出一条, 同一个连通块只能连 $k$ 条, 求为了得到一个连通图第一步需要连多少边.</p><p>$n, k, m\le 10^6$</p></blockquote><p>首先考虑判断继续加边前什么样子时图可以连通. 实际上只要能连的边总数大于需要边数因为我们可以保证不连环.</p><p>那么边数总和是 $\dfrac{\sum \min siz_i, k}{2}$ , 需求量是连通块个数-1, 所以 $siz$ 越大越好(取 $\min$ ), 所以每次取两个最小的连通块合并直到满足式子即可.</p><h3 id="CF85D-Sum-of-Medians-ds"><a href="#CF85D-Sum-of-Medians-ds" class="headerlink" title="CF85D Sum of Medians [ds]"></a>CF85D Sum of Medians [ds]</h3><blockquote><p>维护一个集合, 支持添加一个数, 删除一个数, 或者查询对于将集合内的数从小到大排好序后形成有 $k$ 个数的序列 $a$ , 求</p><p>$$\sum_{i}^{(i\le k)\land (i\bmod 5&#x3D;3)}a_i$$</p><p>$n\le 10^5, x\le 10^9$</p></blockquote><p>权值线段树, 维护每个点膜5余0, 1, 2, 3, 4的和即可.</p><h3 id="CF86D-Powerful-array-ds"><a href="#CF86D-Powerful-array-ds" class="headerlink" title="CF86D Powerful array [ds]"></a>CF86D Powerful array [ds]</h3><p>莫队板子.</p><h3 id="CF93C-Azembler-ds"><a href="#CF93C-Azembler-ds" class="headerlink" title="CF93C Azembler [ds]"></a>CF93C Azembler [ds]</h3><p>爆搜idfs板子</p><h3 id="CF95E-Lucky-Country-dp-自然根号"><a href="#CF95E-Lucky-Country-dp-自然根号" class="headerlink" title="CF95E Lucky Country [dp] [自然根号]"></a>CF95E Lucky Country [dp] [自然根号]</h3><blockquote><p>如果一个数中不包含除 $4$ 和 $7$ 之外的数字则是幸运数. 有 $n$ 个岛屿, 通过双向道路连接. 这些岛屿被分为几个地区. 每个岛属于恰好一个区域, 同一区域中的任何两个岛之间存在道路, 不同区域的任何两个岛之间没有路径. 如果一个地区的岛屿数量是一个幸运数字, 则这个地区是幸运的. 问最少增加几条道路能创建一个幸运地区.</p><p>$n, m\le 10^5$</p></blockquote><p>处理连通块+背包, 但01背包这个过不去.</p><p>考虑所有连通块大小之和为 $n$ , 那么经典套路不同的大小有 $\sqrt n$ 种, 所以可以作成 $\sqrt n$ 个物品的完全背包, 结束.</p><h3 id="CF103E-Buying-Sets"><a href="#CF103E-Buying-Sets" class="headerlink" title="CF103E Buying Sets"></a>CF103E Buying Sets</h3><p>放到了网络流选做里.</p><h3 id="CF115E-Linear-Kindom-Races-线段树-dp"><a href="#CF115E-Linear-Kindom-Races-线段树-dp" class="headerlink" title="CF115E Linear Kindom Races [线段树] [dp]"></a>CF115E Linear Kindom Races [线段树] [dp]</h3><blockquote><p>给定序列 $a_n$ 和 $m$ 个区间, 每个区间有价值 $w_i$ , 若要得到区间 $[l, r]$ 的 $w$ 需要支付 $\sum_{l\le i\le r} a_i$ . 求最大收益(收入-支出)</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>这是dp题.</p><p>很自然的想法是 $f_i$ 表示前 $i$ 个的最大收益, $i$ 如果不修复直接从上一个整过来, 否则 $f_i$ 可能一直修复一个区间到 $f_j$ , 我们钦定没有跨过区间 $[j, i]$ 的端点, 然后贡献就是完整包含在 $[j, i]$ 的区间的 $\sum w_k$ 减去 $\sum a_l$ , 考虑优化.</p><p>用线段树维护它, 线段树上每个位置放的就是完整包含在这一段的贡献, 那么就每个下标 $i$ 维护这个决策的值就行了.</p><h3 id="CF132E-Bits-of-merry-old-England"><a href="#CF132E-Bits-of-merry-old-England" class="headerlink" title="CF132E Bits of merry old England"></a>CF132E Bits of merry old England</h3><p>放到网络流选做里.</p><h3 id="CF164C-Machine-Programming"><a href="#CF164C-Machine-Programming" class="headerlink" title="CF164C Machine Programming"></a>CF164C Machine Programming</h3><p>放到网络流选做里</p><h3 id="CF176E-Archaeology-ds"><a href="#CF176E-Archaeology-ds" class="headerlink" title="CF176E Archaeology [ds]"></a>CF176E Archaeology [ds]</h3><p>就是 异象石.</p><h3 id="CF200A-Cinema"><a href="#CF200A-Cinema" class="headerlink" title="CF200A Cinema"></a>CF200A Cinema</h3><blockquote><p>给出 $n\times m$ 的01矩阵 $A$ , 每个元素初值为 $0$ , $k$ 次操作, 每次给出 $x, y$ , 求离其曼哈顿距离最近的 $0$ 并将其设置为1.</p><p>$n, m\le 2000, k\le \min(nm, 10^5)$</p></blockquote><p>KDT? </p><p>最无脑的一定是拆开曼哈顿距离, 四个方向各放一个树套树了吧, 可以直接冲.</p><p>代码阳间的是, 考虑因为只有 $k$ 个 $1$ , 所以一个 $0$ 距离最近的 $1$ 不超过 $\sqrt k$ , 于是维护每个点离它最近的距离, 然后查的时候暴力枚举等于这个距离的一圈有没有即可. 因为你询问的 $q$ 个点的最近距离的总和是 $\sqrt k$ 的. 就做完了啊.</p><h3 id="CF204D-Little-Elephant-and-Retro-Strings-count"><a href="#CF204D-Little-Elephant-and-Retro-Strings-count" class="headerlink" title="CF204D Little Elephant and Retro Strings [count]"></a>CF204D Little Elephant and Retro Strings [count]</h3><blockquote><p>给定字符串 $s$ , 字符为 $\texttt{01? }$ , $\texttt{? }$ 表示任意. 求多少种方案满足存在两个不相交子串(严格), 且左边的全 $\texttt{1}$ , 右边的全 $\texttt{0}$ .</p><p>$k\le \vert s\vert \le 10^6$</p></blockquote><p>统计问题, 设 $f_i, g_i, h_i$ 分别表示前 $i$ 个的最后 $k$ 个全 $\texttt{0}$ , 后 $i$ 个前 $k$ 个全 $\texttt{0}$ , 后 $i$ 个出现过 $\texttt{0}$ 段, 然后方案数就是 $\sum f_ih_{i+1}$</p><p>就是要这种可以在多个地方贡献的问题钦定在第一处&#x2F;最后一处等特殊位置.</p><h3 id="CF235C-Cyclical-Quest"><a href="#CF235C-Cyclical-Quest" class="headerlink" title="CF235C Cyclical Quest"></a>CF235C Cyclical Quest</h3><p>收录在字符串选做上</p><h3 id="CF254D-Rats-bfs"><a href="#CF254D-Rats-bfs" class="headerlink" title="CF254D Rats [bfs]"></a>CF254D Rats [bfs]</h3><blockquote><p>一个 $n<em>m$ 的网格图中, 有一些格子是墙, 用 $X$ 表示, 其余格子中, 有一些格子中有*<em>老鼠</em></em>, 用 $R$ 表示, 其余空格子用 $.$ 表示</p><p>现在需要放置两颗<strong>手榴弹</strong>, 每颗手榴弹初始在格子 $(r_i, c_i)$ 上, 在 $1-d$ 秒内, 每过 $1$ 秒其伤害范围会从现有的每个伤害范围的格子向外扩展一格, 即若 $(a, b)$ 为伤害范围, 则下一秒 $(a+1, b), (a-1, b), (a, b+1), (a, b-1)$ 中不为墙的格子都会变为伤害范围, 当一个有老鼠的格子成为伤害范围, 那个格子的老鼠就会死掉</p><p>你需要给出能够杀死所有老鼠的两个手榴弹的放置坐标 $(r_1, c_1)和(r_2, c_2)$ , 如果无解, 则输出 $-1$<br>$n, m, d$ 为常数, $n, m\le 1000, d\le 8$</p></blockquote><p>疯狂bfs, 先随便找一只老鼠bfs能炸到它的地方, 在这个区域枚举第一个炸弹的位置, 找到一只第一个炸弹炸不到的老鼠, 在这里枚举第二个炸弹的位置, 复杂度 $d^8$</p><h3 id="CF263E-Rhombus"><a href="#CF263E-Rhombus" class="headerlink" title="CF263E Rhombus"></a>CF263E Rhombus</h3><blockquote><p>$n\times m$ 的矩阵 $a$</p><p>函数 $f(x, y)&#x3D;\sum_{i&#x3D;1}^n\sum_{j&#x3D;1}^m a_{i, j} \times max(0, k-\vert i-x\vert -\vert j-y\vert )$ , 求 $(a, b)$ 最大化 $f(a, b)$ , 其中 $a\in [k, n-k+1], b\in [k, m-k+1]$<br>$n, m\le 1000$</p></blockquote><p>todo</p><h2 id="qyc推荐"><a href="#qyc推荐" class="headerlink" title="qyc推荐"></a>qyc推荐</h2><h3 id="2022SDFZ省选模拟赛6-词典-闵可夫斯基和-决策单调性-dp"><a href="#2022SDFZ省选模拟赛6-词典-闵可夫斯基和-决策单调性-dp" class="headerlink" title="[2022SDFZ省选模拟赛6] 词典 [闵可夫斯基和] [决策单调性] [dp]"></a>[2022SDFZ省选模拟赛6] 词典 [闵可夫斯基和] [决策单调性] [dp]</h3><blockquote><p>一个 $01$ 串 $s$ 是<strong>单词</strong>当且仅当 $s$ 中不含两个连续的 $0$ .</p><p>一个包含 $n$ 个单词的<strong>词典</strong>是 $n$ 个单词的集合, 且满足其中任意一个单词都不是任意其他单词的前缀.</p><p>给定一个词典 $D$ , 定义 $01$ 串 $s$ 的代价 $C(s)&#x3D;\displaystyle \sum^{k}_{j&#x3D;1}\lfloor 1+\log_2 j\rfloor$ , 其中 $k$ 是 $D$ 中满足 $s$ 是 $t$ 的前缀的单词 $t$ 的数量. 该词典 $D$ 的代价即为所有 $01$ 串的代价之和.</p><p>例如, 考虑一个包含 4 个单词的词典 ${0, 10, 110, 111}$ . 这个词典的代价为 $C(\epsilon)+C(0)+C(1)+C(10)+C(11)+C(110)+C(111)&#x3D;8+1+5+1+3+1+1&#x3D;20$ . 这里 $\epsilon$ 表示空串.</p><p>求包含 $n$ 个单词的词典的代价的最小值.</p><p>多组询问, $n\le 10^{15}, t\le 50000$</p></blockquote><p>神仙题.</p><p>考虑把字典插入到一个trie里, 那么因为没有互为前缀所以所有单词叶子, 因为没有两个连续 $0$ 所以左儿子没有左儿子, 树的结构就是</p><p><img src="/img/2022-10-19-21-07-53-image.png" alt="picture 2"></p><p>于是考虑dp, 设 $f_{i}$ 表示 $i$ 个叶子的最小代价, 设题面里的代价函数为 $g(k)$ 则有 $f_{i}&#x3D;g(i)+g(j)+f_j+f_{i-j}$ . 这里 $j$ 是枚举 $b$ 的子树大小, 那么发现 $v$ 的代价是 $g(j)$ , $u$ 的代价是 $g(i)$ .</p><p>然后猜测 $g$ 和 $f$ 都是上凸的, 用闵和优化(闵和带来的决策单调性, 两个函数归并每次向后延一段)可以做到 $O(n)$ . 再考虑发现因为 $g$ 的差分只有 $\log$ 段, $f$ 的差分只有 $\log^2$ 段, 所以每次向后延伸一段差分相同的部分, 复杂度就成了 $\log^2$ 的了.</p><h3 id="UOJ182-UR-12-a-1-b-problem-poly"><a href="#UOJ182-UR-12-a-1-b-problem-poly" class="headerlink" title="UOJ182. [UR #12]a^-1 + b problem [poly]"></a>UOJ182. [UR #12]a^-1 + b problem [poly]</h3><blockquote><p>区间加, 区间和, 区间取逆元</p><p>$n\le 10^5, m\le 6\times 10^4$ , 膜998244353</p></blockquote><p>每个数可以写成 $\dfrac{ax+b}{cx+d}$ , 把 $c$ 化成1, 写成 $a+(b-ad)\dfrac{1}{x+d}$ , 前面的提出来是常量, 所以最后多点求值.</p><h3 id="P8371-POI2001-绿色游戏-game-graph-调整"><a href="#P8371-POI2001-绿色游戏-game-graph-调整" class="headerlink" title="P8371 [POI2001]绿色游戏 [game] [graph] [调整]"></a>P8371 [POI2001]绿色游戏 [game] [graph] [调整]</h3><blockquote><p>绿色游戏是一种两人游戏, 双方分别称 $\text{Ann}$ 和 $\text{Billy}$ . 游戏的内容主要是轮流在棋盘上移动一颗棋子.</p><p>棋盘上的点一部分是绿色的, 其余是白色的. 它们全部从 $1$ 至 $a+b$ 编号. 编号 $1$ 至 $a$ 的点属于 $\text{Ann}$ , 编号 $a+1$ 至 $a+b$ 的点属于 $\text{Billy}$ . 每个点都有一些后继点, 均可一步到达. 属于 $\text{Ann}$ 的点的后继点一定属于 $\text{Billy}$ , 反之亦然. 所有的点都至少有一个后继点, 这样总可以往下走一步.</p><p>游戏开始时把棋子放在任意的一点 $P$ 上, 然后双方轮流移动棋子至当前所在点(属于移动方)的一个后继点上(属于对手). 游戏由点 $P$ 的拥有者开始, 结束时棋子第二次到达了某一点, 称点 $Q$ . 如果在从点 $Q$ 至点 $Q$ 的一连串移动中, 棋子至少一次被放到绿色点上, 则 $\text{Ann}$ 赢. 若从点 $P$ 开始, 不管 $\text{Billy}$ 如何移动, $\text{Ann}$ 总能保证赢得这次游戏, 则称 $\text{Ann}$ 对起始点 $P$ 有必胜的策略.</p><p>请你编写一个程序:</p><ol><li><p>读入对棋盘的描述.</p></li><li><p>算出 $\text{Ann}$ 有必胜策略的起始点.</p></li></ol><p>$a, b\le 3000$ , 边数 $30000$ , 绿点个数 $green\le 100$</p></blockquote><p>qyc推荐的题.</p><p>考虑路径上所有经过的点中, 只让走了两次的那个绿点贡献(必然存在的), 那么如果一个绿点出发有必到达自己策略它是必胜的, 否则就不用管. 而只要从必胜绿点走出去dp就行了. 于是把所有绿点都当必胜的去dp, 每次dp出一个会输的绿点就把它从必胜绿点踢出去接着做, 复杂度是 $green\times m$ .</p><p>这么做最后被踢出去的当然真的不能胜利, 而胜利的确实可以走到环上, 所以正确.</p><p>[think] POI最爱的钦点-调整法.</p><h2 id="from-dwt-blog"><a href="#from-dwt-blog" class="headerlink" title="from dwt blog"></a>from dwt blog</h2><h3 id="AGC052B-Tree-Edges-XOR-adhoc"><a href="#AGC052B-Tree-Edges-XOR-adhoc" class="headerlink" title="AGC052B Tree Edges XOR [adhoc]"></a>AGC052B Tree Edges XOR [adhoc]</h3><blockquote><p>给定 $Tree(n)$ , 保证 $n$ 是奇数, 边有边权 $w_{i, 1}$ , 现在你可以任意次把与一个边相连的其他边的权值异或上这条边的权值, 求是否可以让每条边的边权变为 $w_{i, 2}$ .</p><p>$n\le 10^5, w\le 2^30$</p></blockquote><p>最困难的一步在第一步吧. 考虑这个操作本质上在干什么, 发现让边权等于连到它上的两个点权的异或, 则这是在交换相邻两点的点权.</p><p>[think] 重新赋值出性质.</p><p>[think] 考虑操作本质.</p><p>于是现在要给初始状态和结束状态分配点权使得权值集合相同. 考虑点权其实只要确定一个点, 剩下的点权都是确定的这个点异或上一个定值, 于是分别确定1号点权值, 然后解异或方程即可.</p><h3 id="ARC126D-Pure-Straight-dp-状压dp"><a href="#ARC126D-Pure-Straight-dp-状压dp" class="headerlink" title="ARC126D Pure Straight [dp] [状压dp]"></a>ARC126D Pure Straight [dp] [状压dp]</h3><blockquote><p>给定 $a_n$ , $a_i\in [1, k]$ , 每次可以交换相邻两个, 求最少次数使得 $a$ 包含子区间值恰为 $1, 2, 3, \ldots, k$ (排好序).</p><p>$n\le 200, k\le 16$</p></blockquote><p>$k$ 很小, 说明很状压.</p><p>于是想到设 $f_{i, S}$ 表示前 $i$ 个, 最后 $\vert S \vert$ 个已经是排好序的 $S$ 的最小代价.</p><p>对于一个元素, 它如果在最终集合里就移动到 $S$ 对应位置, 否则应该整个移动过 $S$ 前面.</p><p>发现是错误的–这个元素除了往前移动到 $S$ 前, 还可以向后移动出 $S$ . 于是取个min即可.</p><h2 id="CF-and-Atcoder选糊"><a href="#CF-and-Atcoder选糊" class="headerlink" title="CF and Atcoder选糊"></a>CF and Atcoder选糊</h2><p>看看他们都VP了哪些场.</p><h3 id="CF1083-Codeforces-Round-526-Div-1"><a href="#CF1083-Codeforces-Round-526-Div-1" class="headerlink" title="CF1083 Codeforces Round #526 (Div. 1)"></a>CF1083 Codeforces Round #526 (Div. 1)</h3><h4 id="A-The-Fair-Nut-and-the-Best-Path-dp-树形dp"><a href="#A-The-Fair-Nut-and-the-Best-Path-dp-树形dp" class="headerlink" title="A. The Fair Nut and the Best Path [dp] [树形dp]"></a>A. The Fair Nut and the Best Path [dp] [树形dp]</h4><blockquote><p>给定 $Tree(n)$ , 点有点权 $w_i$ , 边有边权 $c_i$ , 一开始你的分数是0, 走过一个点加 $w_i$ , 走过一个边减 $c_i$ , 任意时刻要求分数 $\ge 0$ , 求走一条链最大化最大分数.</p><p>$n\le 3\times 10^5$</p></blockquote><p>直接dp, $f_{i, 0&#x2F;1}$ 表示当前点作为端点&#x2F;作为中间点的最大收益即可, 转移显然.</p><h4 id="B-The-Fair-Nut-and-Strings-greedy"><a href="#B-The-Fair-Nut-and-Strings-greedy" class="headerlink" title="B. The Fair Nut and Strings [greedy]"></a>B. The Fair Nut and Strings [greedy]</h4><blockquote><p>有 $k$ 个长度为 $n$ 的只含 $a$ 或 $b$ 字符串, 并不知道它们具体是多少, 只知道它们的字典序不小于字符串 $A$ , 同时不大于字符串 $B$ . 定义一个字符串是合法的当且仅当它是这 $k$ 个字符串之一的前缀(如果它是多个串的前缀那么只计算一次). 求最多一共会有多少个合法的字符串.</p><p>$n\le 5\times 10^5, k\le 10^9$</p></blockquote><p>就是最大化这 $k$ 个字符的trie点数.</p><p>直接贪心, 尽可能多的分配, 和 $k$ 取个min.</p><h4 id="C-Max-Mex-ds-线段树-可合并信息"><a href="#C-Max-Mex-ds-线段树-可合并信息" class="headerlink" title="C. Max Mex [ds] [线段树] [可合并信息]"></a>C. Max Mex [ds] [线段树] [可合并信息]</h4><blockquote><p>给定一棵有 $n$ 个点的树, 每个节点有点权. 所有的点权构成了一个 $0 \sim n - 1$ 的排列.<br>有 $q$ 次操作, 每次操作 $1$ 为交换两个点的点权, 操作 $2$ 为查询 $Mex(l)$ 值最大的 $Mex(l)$ 值, 其中 $l$ 是树上的一条路径. 定义一条路径 $l$ 的 $Mex$ 值 $Mex(l)$ 为这条路径上最小的没有出现过的自然数.</p></blockquote><p>考虑这个东西是可合并信息: 两条链能不能合并是简单的, 那你就开一个线段树维护走了值在这个区间的点的链, 操作 $1$ 就是单点修改, 操作 $2$ 直接线段树上二分.</p><p>实现重点应该是链的合并, 写法包括:</p><ul><li>枚举新的链的两个端点判断剩下两个是否在上面. 6个lca.</li><li>枚举新的链的两个端点判断长度是否等于虚数边权和. 4个lca.</li><li>枚举新的链不是端点的两个点, 分类讨论.</li></ul><p>前两个要树剖lca(倍增直接T飞), 第三个不用lca(就是为了和dwt证明不写树剖)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">intree</span>(b,a))<span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">intree</span>(a,b))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">intree</span>(b,c)&amp;&amp;(!(<span class="built_in">intree</span>(a,d)&amp;&amp;<span class="built_in">intree</span>(<span class="built_in">findchild</span>(a,c),d)))||<span class="built_in">intree</span>(b,d)&amp;&amp;(!(<span class="built_in">intree</span>(a,c)&amp;&amp;<span class="built_in">intree</span>(<span class="built_in">findchild</span>(a,d),c))))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">intree</span>(a,c)&amp;&amp;<span class="built_in">intree</span>(b,d)||<span class="built_in">intree</span>(a,d)&amp;&amp;<span class="built_in">intree</span>(b,c))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">bool intree(a,b): return if a is the ancestor of b</span></span><br><span class="line"><span class="comment">int findchild(a,b): return the child of a which is the ancestor of b</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>[trick] 线段树维护的信息也可以是可合并的图信息, 包括树的直径, 链等等</p><h4 id="D-The-Fair-Nut’s-getting-crazy-ds-扫描线-拆式子-线段树"><a href="#D-The-Fair-Nut’s-getting-crazy-ds-扫描线-拆式子-线段树" class="headerlink" title="D. The Fair Nut’s getting crazy [ds] [扫描线] [拆式子] [线段树]"></a>D. The Fair Nut’s getting crazy [ds] [扫描线] [拆式子] [线段树]</h4><blockquote><p>给定一个长度为 $n$ 的序列 ${a_i}$ . 你需要从该序列中选出两个非空的子段, 这两个子段满足:</p><ul><li>两个子段非包含关系.</li><li>两个子段存在交.</li><li>位于两个子段交中的元素在每个子段中只能出现一次.<br>求共有多少种不同的子段选择方案. 输出总方案数对 $10^9 + 7$ 取模后的结果.<br>需要注意的是, 选择子段 $[a, b]$ 、 $[c, d]$ 与选择子段 $[c, d]$ 、 $[a, b]$ 被视为是相同的两种方案.<br>$1 \leq n \leq 10^5, -10^9 \leq a_i \leq 10^9$ .</li></ul></blockquote><p>第一眼看成选任意多个子段, 转变成某些不可做题.</p><p>假设每个值分别考虑, 那么相当于划分若干段, 限制了四个端点的范围. 问题似乎变成了四维超长方体并体积. 这做个锤子.</p><p>假设一个确定的交, 要查第一个满足 $pre$ 在交这个区间的位置. 三维偏序是2log. 发现不可扩展. 不对这不是智障行为吗? 查在这个区间中最大的 $nxt, pre$ 可是简单的很, 也就是如果确定了 $[l, r]$ 作为交, 左右端点范围是 $\min_{i\in [l, r]} nxt_i -1$ 和 $\max_{i\in[l, r]} pre_i +1$</p><p>不如考虑画画式子, 为了方便设那个 $\min, \max$ 分别为 $f(l, r), g(l, r)$ 我们要求</p><p>$$<br>\sum_l \sum_r [l&lt;r] (f(l, r)-r)*(l-g(l, r))<br>$$</p><p>可能还有点不重要的常数项(好像没有? ). 拆开, $r\cdot g(l, r)$ 这种东西似乎可以扫 $r$ 解决, 就是区间取max(单调! 变成区间赋值)和区间和.</p><p>现在问题是 $f(l, r)\cdot g(l, r)$ , 考虑扫描 $r$ , 问题是区间赋值, 求序列点积. 发现维护区间 $a, b$ 和答案就是线性变换.</p><p><del>就这也配3500</del></p><h4 id="E-The-Fair-Nut-and-Rectangles-dp-斜率优化"><a href="#E-The-Fair-Nut-and-Rectangles-dp-斜率优化" class="headerlink" title="E. The Fair Nut and Rectangles [dp] [斜率优化]"></a>E. The Fair Nut and Rectangles [dp] [斜率优化]</h4><blockquote><p>给定 $n$ 个矩形, 左下角为 $(0, 0)$ , 右上角为 $(x_i, y_i)$ , 每个矩形有权值 $a_i$ , 矩形互不包含, 求选择若干矩形使得并的面积减权值和最大.</p><p>$n\le 10^6, x_i, y_i\le 10^9$</p></blockquote><p>考虑你画一画, 发现如果我们从左往右选, 因为 $y_i$ 递减, 每个矩形的贡献就是上一个矩形到它的距离乘 $y_i$ , 于是就直接dp, $f_i$ 表示前 $i$ 个矩形选的最大值, 然后斜率优化转移.</p><h4 id="F-The-Fair-Nut-and-Amusing-Xor-ds-greedy-分块"><a href="#F-The-Fair-Nut-and-Amusing-Xor-ds-greedy-分块" class="headerlink" title="F. The Fair Nut and Amusing Xor [ds] [greedy] [分块]"></a>F. The Fair Nut and Amusing Xor [ds] [greedy] [分块]</h4><blockquote><p>给定 $a_n, b_n$ 和常数 $k$ , 每次可以选择长 $k$ 的子段全异或上一个值, 求把 $a$ 变成 $b$ 的最小次数或说明无解. 有 $q$ 次单点修改, 每次修改结束输出结果.</p><p>$n, q\le 2\times 10^5$</p></blockquote><p>设 $c_i&#x3D;a_i\mathrm{xor} b_i$ , 就成了从全 $0$ 变成 $c$ 的次数.</p><p>然后因为区间异或想到差分数组设为 $d$ , 每次修改 $d$ 的两个位置.</p><p>然后考虑每个 $\bmod k$ 等价类是独立的, 那么此时一个等价类的次数就是大小减前缀异或和等于自己的数的个数.</p><p>那这个就好做了, 相当于区间异或, 查询0的个数. 每个整块存出现次数和异或标记散块暴力即可.</p><p>[trick] 固定长 $k$ 可以分成若干等价类</p><h3 id="CF1687-Codeforces-Round-796-Div-1"><a href="#CF1687-Codeforces-Round-796-Div-1" class="headerlink" title="CF1687 Codeforces Round #796 (Div. 1)"></a>CF1687 Codeforces Round #796 (Div. 1)</h3><h4 id="A-The-Enchanted-Forest-greedy"><a href="#A-The-Enchanted-Forest-greedy" class="headerlink" title="A. The Enchanted Forest [greedy]"></a>A. The Enchanted Forest [greedy]</h4><blockquote><p>魔法森林可以被抽象成一条有着 $n$ 个节点, 从 $1$ 到 $n$ 标号的数轴. 在魔理沙出发之前, 她的好友帕秋莉运用魔法去侦测了每个节点上的蘑菇数量, 分别为 $a_1, a_2, \dots, a_n$ .<br>在第 $0$ 分钟的时候, 魔理沙可以从任意一个节点出发. 在每一分钟的时候, 她将会做以下事情:</p><ul><li>她将从节点 $x$ 移动到节点 $y$ ( $\vert x-y\vert \leq 1$ , 即 $y$ 可能等于 $x$ )</li><li>她将会收集节点 $y$ 上的所有蘑菇.</li><li>魔法森林中每个节点会再生长出一个蘑菇.<br>注意, 她不能在第 $0$ 分钟的时候收集蘑菇.<br>现在魔理沙希望知道她在前 $k$ 分钟的时候, 最多能收集到多少个蘑菇. 请你帮帮她.</li></ul></blockquote><p>考虑如果她 $k\ge n$ , 是不是直接答案一样模拟.</p><p>如果 $k&lt;n$ , 那么一定不会回头, 新长出来的部分是固定的, 于是求最大的长 $k$ 的和.</p><h4 id="B-Railway-System"><a href="#B-Railway-System" class="headerlink" title="B. Railway System"></a>B. Railway System</h4><p>收录在图论选做里.</p><h4 id="C-Sanae-and-Giant-Robot-greedy"><a href="#C-Sanae-and-Giant-Robot-greedy" class="headerlink" title="C. Sanae and Giant Robot [greedy]"></a>C. Sanae and Giant Robot [greedy]</h4><blockquote><p>给定 $a_n, b_n$ 和 $m$ 个区间 $[l_i, r_i]$ , 每次可以把一个区间的 $a_i$ 赋值为对应位置的 $b_i$ 当且仅当这么做 $\sum a_i$ 不变. 求是否可以把 $a$ 变成 $b$ .</p><p>$n, m\le 2\times 10^5$</p></blockquote><p>考虑每个位置先减去 $b_i$ , 那么相当于每次选一个和为 $0$ 的区间赋值成0, 问最后能不能全变成0.</p><p>相当于前缀和, 每次选择相同的两个数把中间变得也相同. 感觉这个模型比较好.</p><p>考虑如果某一次赋值的时候不是赋成0, 那么一定不优–你必然需要一个更大的把它搞成0, 或者你必然不会用中间的部分和区间外组成匹配对.</p><p>那就简单了, 每次找个0的对暴力操作, 想怎么做怎么做.</p><h4 id="D-Cute-number-math"><a href="#D-Cute-number-math" class="headerlink" title="D. Cute number [math]"></a>D. Cute number [math]</h4><blockquote><p>给定 $a_n$ , 找到最小的 $k\ge 0$ 使得 $\forall i, a_i+k$ 是可爱的. 定义一个数 $x$ 是可爱的当且仅当 $x-g(x)&lt;f(x)-x$ , 其中 $f(x), g(x)$ 分别是第一个大于, 小于等于它的数.</p><p>$n\le 10^6, a_i\le 2\times 10^6$ , $a$ 不降.</p></blockquote><p>相当于值域被划分成若干段, 每个段的前一半是合法的. 或者说每个数处在一个 $[x^2, x(x+1)]$ 中.</p><p>考虑 $a_1$ 对应的 $x$ 是 $v$ 一定合法, 所以只有 $v$ 段.</p><p>那么枚举一个 $x_1$ ( $a_1+k$ 所对应的 $x$ ), 合法的 $a_1+k$ 是一个区间, 对接下来的每个 $a_i$ , 这个区间能到的 $x$ 段必然只有一个(它们的 $x$ 只会更大, 长度只会更长, 并且一个 $x$ 两边一段都是不合法的). 于是求个交就能得到答案.</p><p>考虑优化, 当枚举到 $x$ 时, 两个差在 $x$ 之内的数必然在同一块, 把它们缩起来, 分析复杂度的话考虑差分数组 $c_n$ , $c_i$ 在 $x&lt;c_i$ 的时候没有被缩起来, 所以总代价是 $\sum c_i&#x3D;v$ . 复杂度 $O(v)$ .</p><h4 id="E-F-todo"><a href="#E-F-todo" class="headerlink" title="E. F. todo"></a>E. F. todo</h4><h3 id="CF1152-Codeforces-Round-554-Div-2"><a href="#CF1152-Codeforces-Round-554-Div-2" class="headerlink" title="CF1152 Codeforces Round #554 (Div. 2)"></a>CF1152 Codeforces Round #554 (Div. 2)</h3><h4 id="A-Neko-Finds-Grapes"><a href="#A-Neko-Finds-Grapes" class="headerlink" title="A. Neko Finds Grapes"></a>A. Neko Finds Grapes</h4><p>智障题.</p><h4 id="B-Neko-Performs-Cat-Furrier-Transform"><a href="#B-Neko-Performs-Cat-Furrier-Transform" class="headerlink" title="B. Neko Performs Cat Furrier Transform"></a>B. Neko Performs Cat Furrier Transform</h4><p>模拟</p><h4 id="C-Neko-does-Maths"><a href="#C-Neko-does-Maths" class="headerlink" title="C. Neko does Maths"></a>C. Neko does Maths</h4><blockquote><p>给定两个正整数 $a, b$ , 找到非负整数 $k$ 使 $a+k$ 与 $b+k$ 的最小公倍数最小, 如有多解输出最小的 $k$ .<br>$a, b\le 10^9$</p></blockquote><p>降大智了.</p><p>考虑最小公倍数很离谱, 但最大公约数比较好: 两者差始终为定值, 最大公约数是差的约数.</p><p>于是直接枚举最大公约数, 算出最小的 $k$ 然后更新最小公倍数即可.</p><h4 id="D-Neko-and-Aki’s-Prank"><a href="#D-Neko-and-Aki’s-Prank" class="headerlink" title="D. Neko and Aki’s Prank"></a>D. Neko and Aki’s Prank</h4><blockquote><p>求所有长度为 $2n$ 的合法括号序列组成的trie的最大匹配. 合法括号串是仅有 $\texttt{()}$ 组成且匹配的. 膜 $998244353$ .<br>$n\le 1000$ .</p></blockquote><p>考虑一个子树可以由 $(d, v)$ 表示为高度为 $d$ , 并且括号和是 $-v$ .</p><p>可以转化为求最大独立集.</p><p>$f_{d, v, 0&#x2F;1}$ 表示这样的子树, 有没有选根即可. $n^2$ .</p><p>看到题解区里由点离谱的构造: 直接选所有深度为偶数的边和其父节点的连边(冲突保留一条), 然后用卡特兰数.</p><h4 id="E-Neko-and-Flashback"><a href="#E-Neko-and-Flashback" class="headerlink" title="E. Neko and Flashback"></a>E. Neko and Flashback</h4><blockquote><p>对于序列 $a_n$ 和 $p_{n-1}$ , 构造 $b_i&#x3D;\min(a_i, a_{i+1}), c_i&#x3D;\max(a_i, a_{i+1}), b’<em>i&#x3D;b</em>{p_i}, c’<em>i&#x3D;c</em>{p_i}$ . 给定 $b’, c’$ 求 $a$ 或判断无解.<br>$n\le 10^5, v\le 10^9$</p></blockquote><p>看错题了, $b$ 和 $c$ 的重排方式是相同的.</p><p>考虑那么任意一个 $b_i, c_i$ 相当于告诉你 $a_i, a_{i+1}$ 两个数连着, 是充要的, 于是每个值建图跑欧拉回路即可.</p><h4 id="F-Neko-Rules-the-Catniverse"><a href="#F-Neko-Rules-the-Catniverse" class="headerlink" title="F. Neko Rules the Catniverse"></a>F. Neko Rules the Catniverse</h4><blockquote><p>给定参数 $n, k, m$ , 你需要求有多少个大小为 $k$ 的序列 $a$ 满足如下三个条件:</p><ol><li>任意两个元素其权值不同.</li><li>对于任意 $i$ 满足 $1\le i\le k$ 有 $1\le a_i\le n$ .</li><li>对于任意 $i$ 满足 $2\le i\le k$ 有 $a_i\le a_{i-1}+m$ .<br>答案对 $10^9+7$ 取模.</li></ol><p>$1\le k\le \min(n, 12)$ , $1\le m\le 4$ .</p></blockquote><h5 id="F1-Small-Version"><a href="#F1-Small-Version" class="headerlink" title="F1 (Small Version)"></a>F1 (Small Version)</h5><blockquote><p>$1\le n\le 10^5$</p></blockquote><p>显然你应该扫值域插入着dp, 插入的要求是这个位置的前一个位置在不小于 $i-m$, 发现插入更大的元素无法缩小两个数的间距, 所以要求一开始插入的时候就让前一位置不小于 $i-m$. 于是显然你至少要记录 $f_{i, j}$ 表示前 $i$ 个数选了 $j$ 个, 此时你能插入的位置取决于在 $[i-m, i-1]$ 中的元素选了几个, 因为这个要转移所以你要记录选了谁(不然向上一位不知道掉出去的是谁), 所以 $f_{i, j, S}$ 表示最小的 $i$ 个数, 选了 $j$ 个, $[i-m, i-1]$ 中选了集合 $S$. 复杂度 $nk2^m$</p><h5 id="F2-Big-Version"><a href="#F2-Big-Version" class="headerlink" title="F2 (Big Version)"></a>F2 (Big Version)</h5><p>考虑两层之间转移固定, 直接矩阵快速幂就是 $(k2^m)^3\log n$.</p><h3 id="CF1793"><a href="#CF1793" class="headerlink" title="CF1793"></a>CF1793</h3><p>好久文化课了</p><h4 id="A-Yet-Another-Promotion"><a href="#A-Yet-Another-Promotion" class="headerlink" title="A. Yet Another Promotion"></a>A. Yet Another Promotion</h4><p>显然</p><h4 id="B-Fedya-and-Array"><a href="#B-Fedya-and-Array" class="headerlink" title="B. Fedya and Array"></a>B. Fedya and Array</h4><blockquote><p>构造最短的序列 $a$, 满足所有 $a_i&gt;a_{i-1}, a_{i+1}$ 的 $a_i$ 和为 $x$, 同理小于的和为 $y$.<br>$n\le 10^5$</p></blockquote><p>考虑并观察样例, 如果 $a&lt;0&lt;b$, 构造是显然的, 直接用两个峰做完了, 那么整体平移一下就问题解决, 长度是 $2(b-a)$</p><h4 id="C-Dora-and-Search"><a href="#C-Dora-and-Search" class="headerlink" title="C. Dora and Search"></a>C. Dora and Search</h4><blockquote><p>给定排列 $a_n$, 求任意一个子区间满足左右端点不是区间内的最大&#x2F;最小值</p><p>$n\le 2\times 10^5$</p></blockquote><p>求每个数向左&#x2F;向右作为最大&#x2F;最小值的范围, 一个右端点的限制是左端点小于某个位置, 一个左端点的限制是右端点大于某个位置, 于是把左端点排序, 就扫右端点维护左端点即可吧</p><p>官方题解更简单: 从整个序列开始收缩, 显然如果当前区间 $[l, r]$ 的某个端点 $x$ 不满足条件, 则包含这个端点的前&#x2F;后缀不满足, 于是直接收缩一个, 不断重复即可.</p><h4 id="D-Moscow-Gorillas"><a href="#D-Moscow-Gorillas" class="headerlink" title="D. Moscow Gorillas"></a>D. Moscow Gorillas</h4><blockquote><p>给定排列 $a_n, b_n$, 求有多少个区间 $[l, r]$ 满足 $\mathrm{mex}(a_l\ldots, a_r)&#x3D;\mathrm{mex}(b_l\ldots, b_r)$</p><p>$n\le 2\times 10^5$</p></blockquote><p>那么肯定考虑枚举 $mex$ 求数量.</p><p>mex等于 $x$ 的要求是小于 $x$ 的必须包含且不包含 $x+1$, 从小到大枚举 $x$, 是不是随便做了.</p><h4 id="E-Velepin-and-Marketing"><a href="#E-Velepin-and-Marketing" class="headerlink" title="E. Velepin and Marketing"></a>E. Velepin and Marketing</h4><blockquote><p>给定 $n$ 个元素和 $m$ 个集合, 每个元素有属性 $a_i$, 把元素分到集合中, 要保证每个集合中有至少一个元素, 且若一个元素 $i$ 所在的集合大小大于 $a_i$, 则元素 $i$ 是开心的, 求最大开心元素个数.</p><p>$n\le 3\times 10^5$</p></blockquote><p>考虑对 $a$ 排序+二分答案 $x$, 显然最后要开心的是最小的 $x$ 个.</p><p>那么对于后 $x$ 个元素, 每个元素放入一个集合, 此时如果剩下元素, 就把剩下的和所有前 $x$ 个放到一个集合check, 否则从小往大放元素, 每次一个集合全部满足要求就切换到下一个集合. 这个部分可以预处理</p><h4 id="F-Rebrending"><a href="#F-Rebrending" class="headerlink" title="F. Rebrending"></a>F. Rebrending</h4><blockquote><p>给定序列 $a_n$, $q$ 次询问区间 $[l, r]$ 中最小的 $\vert a_i-a_j\vert$.</p><p>$n\le 3\times 10^5$</p></blockquote><p>是的大原题.</p><p>对于每个位置 $a_i$, 从左到右考虑 $j$ 是否能形成贡献, 此时假设现在已经有 $i, j$, 那么对于元素 $k$, 显然应该与 $i, j$ 近的那个贡献, 于是如果和 $i$ 贡献, 那么 $\vert a_k-a_i\vert \le \dfrac{1}{2}\cdot\vert a_i-a_j \vert$, 所以只有 $n \log n$ 对</p><p>直接主席树和二维数点复杂度2log</p><h3 id="AT-cf17-final-CODE-FESTIVAL-2017-Final"><a href="#AT-cf17-final-CODE-FESTIVAL-2017-Final" class="headerlink" title="AT_cf17_final CODE FESTIVAL 2017 Final"></a>AT_cf17_final CODE FESTIVAL 2017 Final</h3><h4 id="D"><a href="#D" class="headerlink" title="D"></a>D</h4><p>收录在greedy</p><h4 id="E"><a href="#E" class="headerlink" title="E"></a>E</h4><blockquote><p>有字符串 $S$, 按照顺序多次进行以下 $N$ 种操作:</p><ul><li>操作 $i$: $S$ 的第 $l_i$ 个字母到第 $r_i$ 个字母分别变为它们的下一个字母. (<code>a</code> 变成 <code>b</code>, <code>b</code> 变成 <code>c</code>・・・); 假设 <code>z</code> 的下一个字母是 <code>a</code>.</li></ul><p>判断是否可以把 $S$ 变成回文.<br>$\vert S\vert\le 10^5$</p></blockquote><p>容易想到差分, 回文串的差分要求对称位置互为相反数.</p><p>那么每个区间操作 $[l, r]$ 看作 $l\to r+1$ 形成一张图, 注意这里边是双向的(转 $25$ 下), 这就非常好, 于是可以在连通块内任意分配值, 只要判断每个连通块的和是对的就行了.</p><h4 id="F"><a href="#F" class="headerlink" title="F"></a>F</h4><blockquote><p>选择 $n\in [1000, 2000], k\ge 1$, 构造矩阵 $A_{n\times k}$, 满足 $A_{i, j}\in [1, N], A_{i, j}\ne A_{i, j’}$, 任意两行恰有一个相同数字, 每个数一共出现 $k$ 次.</p></blockquote><p>考虑 $n$ 行形成的完全图, 则有 $\dfrac{n(n-1)}{2}$ 条边, 而每个数出现 $k$ 次, 贡献 $\dfrac{k(k-1)}{2}$ 条边, 所以 $(n-1)&#x3D;k(k-1)$.</p><p>然后手动模拟 $k&#x3D;3, k&#x3D;4$, 得到策略: 考虑枚举最小值, 第一行先写下 $1\ldots k$, 然后第一列写下一串 $1$, 在后面跟上递增的序列, 保证 $1$ 的部分是对的, 接下来对每个 $2\ldots k$, 每个数写 $k-1$ 个到第一行, 后面对于数 $i$, 从上面以 $1$ 为最小值的第二行到第 $k$ 行的表格中纵向加 $1$, 横向加 $i-1$ 的走着取.</p><p>这个策略只能 $n$ 是质数, 然后就可以了.</p><h4 id="G"><a href="#G" class="headerlink" title="G"></a>G</h4><blockquote><p>考虑以下游戏.</p><ul><li>准备一个具有 $N$ 个格子和许多石头的列.</li><li>首先, 在格子 $i\ (1\ \leq\ i\ \leq\ N)$ 中放置 $a_i$ 个石头.</li><li>玩家可以进行”选择恰好有 $i$ 个石头的格子 $i$, 并在那里放置的所有石头, 以及从格子 $1$ 到格子 $i-1$ 的 $i-1$ 个格子中的石头, 每个格子各放置 $1$ 个石头”的操作, 可以进行任意次数.</li><li>最终, 剩余的石头数量的总和是分数.<br>对于长度为 $N$ 的数列 $a$ 进行这个游戏时, 将其作为分数考虑的最小值为 $f(a)$.<br>在该情况下, 对于所有长度为 $N$, 每个元素为 $0$ 到 $K$ 之间的数列 $a$, $f(a)$ 的总和是多少? 由于答案可能非常大, 因此请使用 $1000000007\ (&#x3D;\ 10^9+7)$ 进行取模.</li></ul><p>$K\le N\le 100$</p></blockquote><p>画一条 $y&#x3D;x$ 的线, 一旦一个位置高出它, 就再也不可能被操作了, 所以最优步骤一定是每次操作最低的能操作的位置. 同时每次操作都是让总和小 $1$, 直接数一共操作多少次.</p><p>$f_{i, j}$ 表示后 $i$ 个数操作了 $j$ 次, 则当前位置可以操作 $t_i&#x3D;(a_i+j)&#x2F;i$ 次, $f_{i, j+(a_i+j)&#x2F;i}&#x3D;f_{i+1, j}$</p><h4 id="H"><a href="#H" class="headerlink" title="H"></a>H</h4><blockquote><p>在北冰洋, 海上漂浮着 $H$ 行 $W$ 列的冰块. 我们将该区域视为网格, 并将第 $i$ 行和第 $j$ 列的方格表示为 $Square(i, j)$. 漂浮在每个方格中的冰块<strong>不是薄冰就是厚冰</strong>.<strong>正方形网格外没有冰块</strong>.</p><p>$Square(i, j)$ 处的冰块可以用以下三种字符表示:</p><ul><li><code>+</code> 此方格是薄冰.</li><li><code>#</code> 此方格是厚冰.</li><li><code>P</code> 此方格是<strong>企鹅</strong>所在地, 为<strong>薄冰</strong>.</li></ul><p>夏天一到, 因温度上升和薄冰的不稳定性, 薄冰将会一个接一个的融化消失. 我们定义, $Square(i, j)$ 处的<strong>薄冰</strong>在<strong>同时不满足以下两个条件时</strong>就会融化:</p><ul><li>$Square(i-1, j)$ 和 $Square(i+1, j)$ 都有冰块.</li><li>$Square(i, j-1)$ 和 $Square(i, j+1)$ 都有冰块.</li></ul><p>现在, 一个不怀好意的人来到了这里. 他可以用锤子砸厚冰, 使其变为薄冰. 请问, 他至少要砸多少块厚冰, 才能使企鹅所在处的冰块融化消失?</p><p>$1 \le H, W \le 40$.</p></blockquote><p>困难</p><p>用 $(x_1, y_1), (x_2, y_2)$ 表示左上角 $x_1, y_1$, 右下角 $x_2, y_2$ 的矩形.</p><p>注意到当 $(a, b)(e, f)$ 中两个矩形 $(a, b)(c, d), (c, d)(e, f), (a&lt;c&lt;e, b&lt;d&lt;f)$, 当 $(a, d)(c, f)$ 与 $(c, b)(e, d)$ 全空了的时候, 就互不相干了.</p><p>所以dp, $f_{a, b, c, d}$ 表示矩形 $(a, b)(e, f)$ 的答案, 每次转移的时候枚举 $(c, d)$, 分成四部分, 递归到有<code>P</code>的那个矩形, 删空侧面的两个矩形.</p><p><img src="/img/2023-06-17-11-11-55-image.png" alt="picture 2">  </p><h2 id="NOIP选做"><a href="#NOIP选做" class="headerlink" title="NOIP选做"></a>NOIP选做</h2><h3 id="P7916-CSP-S-2021-交通规划"><a href="#P7916-CSP-S-2021-交通规划" class="headerlink" title="P7916 [CSP-S 2021] 交通规划"></a>P7916 [CSP-S 2021] 交通规划</h3><p>考虑显然同种颜色形成若干连通块, 问题就是去找连通块之间的分界线. 于是转成对偶图(分界线画出来就是割掉若干条边啊因为), 那么相邻异色附加点对在图外围的部分当成一个点, 就成了两两匹配这些点, 代价是匹配的点对之间的最短路长度. 于是直接跑出两两之间距离然后暴力dp(容易发现相交一定不优, 所以是简单区间dp), 合法性显然. 对于最优性, 可以考虑分界线不会是中间一个圈, 同时一定不会从同色点之间出发, 那么方案都可以得到这样的分界线.</p><h3 id="P7116-NOIP2020-微信步数"><a href="#P7116-NOIP2020-微信步数" class="headerlink" title="P7116 [NOIP2020] 微信步数"></a>P7116 [NOIP2020] 微信步数</h3><p>容易想到计算第 $i$ 步后哪些位置出发的还存在, 对这个统计答案.</p><p>发现只要记录每一维左右两侧最大位移, 因为每一维上存在的点是一个区间, 那么答案就是 $\prod_i r_i-l_i+1$, 复杂度是 $nwk$.</p><p>考虑走完 $n$ 步是一个周期, 假设走完一轮增加的向量为 $a$, 上一轮到这一步时的最大位移向量 $l, r$ 就要分别和 $l+a, r+a$ 取min&#x2F;max, 取决于 $a$ 在每一维上的正负, 对于确定的 $a$, 其实是加一个常向量. 于是第 $i$ 步时的贡献就成了关于轮数的 $k$ 次多项式</p><h3 id="P5665-CSP-S2019-划分"><a href="#P5665-CSP-S2019-划分" class="headerlink" title="P5665 [CSP-S2019] 划分"></a>P5665 [CSP-S2019] 划分</h3><p>容易想到一个 $n^3$ 暴力dp, 容易发现对任意一个区间, 一定满足最后一段尽量小的是这个区间内的最优解.</p><p>于是dp时若原本记录 $f_{i, j}$ 表示前 $i$ 个位置最后一个区间左端点是 $j$, 则最优的 $j$ 唯一(本来就是更小的 $j$ 能转移到更多答案, 只保留一个即可).</p><p>那就简单了, 设前缀和数组为 $s$, $i$ 位置的最优决策点为 $p_i$, 则要求 $f_i&#x3D;\min_{j, s_i&gt;2s_j-s_{p_j}} f_j+(s_i-s_j)^2$, 因为 $s_i$ 单增, 所以上一个单调队列维护即可.</p><h3 id="P5666-CSP-S2019-树的重心"><a href="#P5666-CSP-S2019-树的重心" class="headerlink" title="P5666 [CSP-S2019] 树的重心"></a>P5666 [CSP-S2019] 树的重心</h3><p>至少做到大常数单log是简单题, 容易想到对每个点求作为了多少次重心, 那么根据重心定义要求最大的子树小于一半, 于是可以直接列出删除的部分的大小满足的不等式, 然后线段树合并维护子树大小集合即可.</p><h3 id="P5021-NOIP2018-提高组-赛道修建"><a href="#P5021-NOIP2018-提高组-赛道修建" class="headerlink" title="P5021 [NOIP2018 提高组] 赛道修建"></a>P5021 [NOIP2018 提高组] 赛道修建</h3><p>上来一个明显的二分答案, 然后考虑判断是否能到这个数, 第一反应是dp, 在节点 $u$ 考虑向上延一条, 剩余的在下面两两配对.</p><p>但会爆炸而且注意到这里可以贪, 如果到节点 $u$, 底下延上来的大于答案直接加上, 然后从最小值开始每次找第一个加起来满足条件的配对, 最后传上去剩下的最大的. 因为要在满足答案最大的情况下传上去的尽可能大, 那么从小往大的过程中, 一定不会有 $a$ 可以配对而不配(说明存在 $b&gt;a$, 使得 $b$ 配对后原来和 $a$ 配对的可以传上去, 显然不可能).</p><h3 id="P5659-CSP-S2019-树上的数"><a href="#P5659-CSP-S2019-树上的数" class="headerlink" title="P5659 [CSP-S2019] 树上的数"></a>P5659 [CSP-S2019] 树上的数</h3><p>先考虑一个顶点的情况, 发现依次删掉 $u$ 连向 $v_1\ldots v_k$ 的边后, 点 $v_i$ 上的值转移到 $v_{i+1}$ 上, $v_k$ 转移到 $u$ 上, $u$ 转移到 $a_1$ 上, 形成一条链的关系, 那么如果让 $v_i\to v_j$ 就确定了这两条边删除顺序是 $v_i$ 后紧接着删除 $v_j$, 如果 $u\to v_i$ 就说明 $v_i$ 是第一个删的, $v_i\to u$ 说明是最后一个删的. 那么对每个点用并查集维护这些链, 并记录每个点的 $front_u, back_u$ 表示此点第一个和最后一个删的边, 考虑判定不合法的情况:</p><ul><li>$u\to v$:<ul><li>$u$ 有已经确定的 $front_u$</li><li>$v$ 不是某条链头的第一个($v$ 要作为 $front_u$ 必须是第一个)</li><li>$back_u$ 存在且如果让 $v$ 成为 $front_u$ 则 $front_u, back_u$ 会到同一条链中且链外还有其他元素</li></ul></li><li>$v\to u$(作为结尾和作为开头是对称的)<ul><li>$u$ 有已经确定的 $back_u$</li><li>$v$ 不是某条链头的最后一个</li><li>$front_u$ 存在且如果让 $v$ 成为 $back_u$ 则 $front_u, back_u$ 会到同一条链中且链外还有其他元素</li></ul></li><li>$f\to u\to v$($u$ 作为中转点)<ul><li>加入这个关系后 $u$ 的 $front_u$ 和 $back_u$ 到同一条链中, 且链外还有其他元素</li><li>$v$ 不是 $front_u$, $f$ 不是 $back_u$</li><li>$v, f$ 当前不在同一条链, 且 $v$ 是链头, $f$ 是链尾</li></ul></li></ul><p>因为满足以上条件的情况下必然存在合法解(剩下的边随便乱连串起来)要求最小字典序, 所以考虑逐个确定数字 $i$ 能移动到的最小的节点, 直接枚举 $u$, 枚举 $v$, 判断链的复杂度是 $n^3$ 的, 考虑对每个 $u$ 去 $dfs$ 整个树找到能作为结尾的 $v$ 再从中选择, 复杂度变为 $n^2$</p><h3 id="P3960-NOIP2017-提高组-列队"><a href="#P3960-NOIP2017-提高组-列队" class="headerlink" title="P3960 [NOIP2017 提高组] 列队"></a>P3960 [NOIP2017 提高组] 列队</h3><p>首先观察到操作就是第 $x$ 行, 第 $n$ 列的后缀往前移动一格, 再配一个单点修改. 那么容易想到单独维护最后一列, 于是拿出来一个放到最后就可以用平衡树简单实现. 然后发现点很多不能把点都插到平衡树里, 想到直接上一个珂朵莉树维护连续区间就结束了.</p><p>注意到维护这个东西其实可以bit, 开一个长 $n+q$ 的bit然后支持倍增和求和即可. 那么动态开点也能做. 空间多1log.</p><p>最后可以离线处理每行的答案就是这一行原来元素的询问, 在线处理新元素, 这样只要维护最后一行和每行新元素.</p><h3 id="P1315-NOIP2011-提高组-观光公交"><a href="#P1315-NOIP2011-提高组-观光公交" class="headerlink" title="P1315 [NOIP2011 提高组] 观光公交"></a>P1315 [NOIP2011 提高组] 观光公交</h3><p>首先转换一下贡献, $\sum_p T’_p-T_p&#x3D;\sum_i t_i cnt_i-\sum T_i$, 其中 $p$ 是枚举的人, $i$ 是枚举点, $t$ 表示到达某点的时间, $T’$ 表示某人下车时间.</p><p>考虑一个点的出发时间, 应该是到这个点的时间 $t_i$ 和最晚上车的人的时间 $maxt_i$ 的max, 可以先求一遍这个, 然后若 $t_i\le maxt_i$, 则这个加速对更大的 $i$ 无影响, 而有影响的部分就是区间 $cnt$ 和. 于是维护区间直接贪心即可做到 $nk$</p><p>upd:</p><p>假设读者已经都会了费用流的做法, 因为是费用流, 所以关于流量是凸的, 我们考虑WQS二分+增量费用流+反悔贪心完成:</p><p><img src="/img/2023-08-22-09-38-50-image.png" alt="picture 0">  </p><p>那么如图, 加一个与S相连的点时要保证红边的方向, 于是发现没有可行的负环&#x2F;增广路, 增加蓝色的点 $v$ 的时候增广路的形式是 $S\to u\to v\to T$(浅蓝), 负环是 $T\to u\to v\to T$(浅紫), 只有这两种决策, 于是问题解决, 开两个堆维护与 $S$ 相连, 且 $S$ 到它的边上还能流的点和与 $T$ 相连, 且它到 $T$ 的边有流量的点, 用线段树维护中间的边的流量, 用前缀和维护代价和, 每次取出堆顶, 计算两种决策的流量和代价, 然后更新流量和答案. 因为要控制流量, 找增广路的时候要给代价额外加上二分的常数 $C$.</p><p>这里很好的性质就是由于我们的决策, 一条非汇边满了之后不可能再退流, 一条汇边在它之后空了之后不可能在有流量, 所以只要每次取出堆顶暴力check, 不满足直接弹就是对的. 又因为处理每个负环和增广路的时候, 我们至少会让一条边的流满, 所以模拟费用流的复杂度是 $n\log n$ 的, 最后上一个WQS二分, 复杂度成了 $n\log n\log k$, 现在可以出 $k\le 10^9$ 了!</p><h3 id="P3959-NOIP2017-提高组-宝藏"><a href="#P3959-NOIP2017-提高组-宝藏" class="headerlink" title="P3959 [NOIP2017 提高组] 宝藏"></a>P3959 [NOIP2017 提高组] 宝藏</h3><p>首先这数据范围看着就是状压dp. 显然如果加点顺序确定, 加的边就是确定的, 问题是dp加点的时候我们需要它的深度. 深度集合是难以压缩的, 依赖于图的结构, 于是考虑直接把最后一次加点的深度作为状态, 每次加入同一个深度的所有点, 于是 $f_{i, S}$ 表示集合 $S$ 中的点已经加入, 最深的点深度为 $i$. 显然这样会算错, 但是同样显然算错了的只会更劣, 不影响答案统计. 复杂度 $n^3 3^n$</p><h3 id="P5022-NOIP2018-提高组-旅行"><a href="#P5022-NOIP2018-提高组-旅行" class="headerlink" title="P5022 [NOIP2018 提高组] 旅行"></a>P5022 [NOIP2018 提高组] 旅行</h3><p>树就是直接dfs, 基环树粗暴法是直接枚举断一条边, 仔细分析的话注意到流程一定是入环, 访问环上一边, 回溯, 访问另一边, 回溯只有在当前环上点要走的下一个环上点是所有除了父亲以外的点中最大时才可能(否则从小到大访问, 回溯了这里的子树就无法访问了), 同时在走的时候记录如果此时回溯下一个到的是谁, 跟本来会访问的比对即可.</p><h3 id="P5023-NOIP2018-提高组-填数游戏"><a href="#P5023-NOIP2018-提高组-填数游戏" class="headerlink" title="P5023 [NOIP2018 提高组] 填数游戏"></a>P5023 [NOIP2018 提高组] 填数游戏</h3><p>这个数据范围让我怎么看怎么想状压啊!</p><p>考虑dp, 那么发现我们肯定是按照对角线推进, 限制包括: 每条对角线从上到下递增, 同时要求若 $(i-1, j)&#x3D;(i, j-1)$, 则 $(i, j)$ 为右上角的矩形中所有的对角线分别相等(否则两条路径在 $i, j$ 处交叉再到下面再次交叉就不合法了)</p><h2 id="SDOI题选做"><a href="#SDOI题选做" class="headerlink" title="SDOI题选做"></a>SDOI题选做</h2><h3 id="P4620-SDOI2018-荣誉称号"><a href="#P4620-SDOI2018-荣誉称号" class="headerlink" title="P4620 [SDOI2018] 荣誉称号"></a>P4620 [SDOI2018] 荣誉称号</h3><blockquote><p>休闲游戏玩家小 $Q$ 不仅在算法竞赛方面取得了优异的成绩, 还在一款收集钻石的游戏中排名很高.</p><p>这款游戏一共有 $n$ 种不同类别的钻石, 编号依次为 $1$ 到 $n$. 小 $Q$ 已经玩了这款游戏很久了, 对于第<br>$i$ 种钻石, 他已经收集到了 $a_i$ 个. 这款游戏最大的亮点就是, 钻石只有一种获得途径, 那就是从商城中购买. 具体来说, 第 $i$ 种钻石的单价为 $b_i$ 点券. 为了鼓励玩家充值, 每种钻石都没有数量上限, 只要肯充钱, 就可以拥有任意多的钻石. 但是这款游戏并没有开发 “丢弃道具” 功能, 因此小 $Q$ 不能通过丢弃钻石去完成任务.</p><p>最近这款游戏推出了一个限时成就任务, 完成任务的玩家可以获得荣誉称号, 而完成任务条件则是:<br>给定正整数 $k$ 和 $m$, 对于任意一个整数 $x (x\ge 2^k)$, $a_{x}+a_{\lfloor\frac{x}{2}\rfloor}+a_{\lfloor\frac{x}{4}\rfloor}+a_{\lfloor\frac{x}{8}\rfloor}+. . . +a_{\lfloor\frac{x}{2^k}\rfloor}$ 都要是 $m$ 的倍数.</p><p>高玩小 $Q$ 当然想完成这个限时成就任务, 但是在充钱之前他想知道他究竟需要多少点券才能完成这个任务. 请写一个程序帮助小 $Q$ 计算最少需要的点券数量.</p><ul><li>$1 \le T \le 10$,</li><li>$1 \le k \le 10$ 且 $2^k \le n$,</li><li>$1 \le p \le min(n, 100000)$, $10000 \le SA, SB, SC \le 1000000$,</li><li>$1 \le A, B, ai, bi \le 10^7$.</li><li>$n\le 10^7, m\le 200$</li></ul></blockquote><p>看到 $\dfrac{x}{2^k}$ 可以把序列先搬到二叉树上.</p><p>然后就要满足任意长 $k$ 的链的和都是 $m$ 的倍数, 那么考虑一条链在尾端加入在链首删除, 就要保证新链尾与原链首同余, 于是第 $k+1$ 层往后的方案都是由前 $k$ 层唯一确定的, 可以先处理出 $w_{i, j}$ 表示深度大于 $k$ 且模 $k$ 为 $i$ 的所有层中的点都调整到模 $m$ 为 $j$ 的代价和, 那么接下来dp前 $k$ 层的方案, 设 $f_{u, i}$ 表示 $u$ 的子树, 所有叶子到 $u$ 的和为 $i$ 的最小代价(由刚才处理的 $w$ 得出), 答案即为 $f_{1, 0}$, 后面dp的复杂度 $2^km^2$, 前面预处理 $w$ 是 $n+mk$</p><h3 id="P5359-SDOI2019-染色"><a href="#P5359-SDOI2019-染色" class="headerlink" title="P5359 [SDOI2019] 染色"></a>P5359 [SDOI2019] 染色</h3><p>最简单的暴力肯定是 $f_{i, c_1, c_2}$ 表示前 $i$ 行最后两个数分别是啥.</p><p>考虑如果把没数的一段压起来处理, 这样转移时 $c_1, c_2$ 有一个是确定的, 就可以只记录一维, 而上下两位置都没数的方案只和两头两列有关, 根据数的关系不同, 确定了前两个不同的数后后面可以有 $7$ 种, 去掉上下对称后可以精简到 $5$ 种, 而预处理长 $n$ 的空段两边是哪种情况的复杂度 $g(n, 0&#x2F;1&#x2F;2&#x2F;3&#x2F;4)$ 是线性的. 于是复杂度变成了 $nc$.</p><p>然后考虑数据结构优化dp转移, 就是单点修改&#x2F;查询, 全局加&#x2F;乘&#x2F;赋值&#x2F;查询, 随便做了.</p><h3 id="P4618-SDOI2018-原题识别"><a href="#P4618-SDOI2018-原题识别" class="headerlink" title="P4618 [SDOI2018] 原题识别"></a>P4618 [SDOI2018] 原题识别</h3><blockquote><p>给定一棵树, 询问树链上本质不同颜色数以及一条链的所有子链的本质不同颜色数之和.<br>$n, q\le 10^5$, 数据随机</p></blockquote><p>随的方法是 $p$ 个点之后随机挂叶子, 众所周知的结论意味着一个点到主链期望 $\log n$ 步.</p><p>先考虑序列上怎么做操作 $2$, 那么要询问一个点在 $[1, a]$, 一个点在 $[1, b]$ 中的答案, 让 $a&lt;b$, 记录每个点上次出现位置 $pre_i$, 则当且仅当 $pre_i\lt l\le i\le r$ 时点有贡献, 那么对于 $[1, a]$ 的点 $i$ 就是 $2(i-pre_i-1)(a-i+1)+(i-pre_i)(b-a)$, 对于 $a, b$ 中的点就是 $<a href="a-pre_i">pre_i&lt;a</a>(b-i+1)$, 第一个直接乱维护, 第二个两维限制可以接着主席树, 都是维护下 $i, pre_i, i^2, ipre_i$ 的和就行了.</p><p>然后上树, 就要用刚才的随机性质了, 那么设 $u&#x3D;lca(a, b), dis(u, a)&lt;dis(u, b)$, 此时根据一开始分析树的形态 $dis(u, a)&lt;\log n$, 那么可以先原样照搬的解决掉 $x, y$ 有祖先关系的情况, 现在问题来到 $x, y$ 分别在 $u\Rightarrow a, u\Rightarrow b$ 上, 此时从上到下 $u\Rightarrow a$ 上的一个点作为左端点, 相当于每次加入一个点 $x$ 钦点它被选, 而 $u\Rightarrow b$ 上一个点本来的贡献应该是 $<a href="dis(u,b)-i">dep_{pre_i}&lt;dep_u</a>$, 那只要查长链上最浅的 $i$ 满足 $a_i&#x3D;a_x$ 即可.</p><p>比较套路比较麻烦题, 基本上是基于随机树的性质+ $i, pre$ 乱搞.</p><h3 id="P5360-SDOI2019-世界地图"><a href="#P5360-SDOI2019-世界地图" class="headerlink" title="P5360 [SDOI2019] 世界地图"></a>P5360 [SDOI2019] 世界地图</h3><blockquote><p>$n\times m$ 网格图, 边有边权, 第一列和第 $m$ 列相连, $q$ 次询问删除第 $[l, r]$ 列中的点后的最小生成树权值和.</p><p>$n\le 100, m\le 10000, q\le 10000$</p></blockquote><p>考虑这是让你合并一个前缀一个后缀的mst, 直接合并边集复杂度和 $m$ 有关肯定爆炸, 考虑逐条加入 $(i, 1)$ 和 $(i, m)$ 之间的边, 则要判断新边和这条环上最大边比谁大然后换掉最大边, 那么一个前缀可能被替换掉的边就是这个前缀Kruskal重构树上所有 $(i, 1)$ 的点的虚树上的非叶子点, 每次把这些边, 新加入的 $(i, 1), (i, m)$ 边和后缀的 $O(n)$ 条边拿出来跑Kru就能合并, 问题变为怎么获得两边的信息.</p><p>对于一个前缀, 维护其第一列和最后一列的点的虚树上的非叶子点也就是可能删掉的边, 那么每次新加一列这个操作可以像刚才上面一样Kru, 并获得新的可能被删掉的边.</p><h3 id="P4607-SDOI2018-反回文串"><a href="#P4607-SDOI2018-反回文串" class="headerlink" title="P4607 [SDOI2018] 反回文串"></a>P4607 [SDOI2018] 反回文串</h3><blockquote><p>“回文串什么的最讨厌了……”</p><p>小 $Q$ 讨厌任何形式的回文串:</p><ul><li><p>如果一个字符串从左往右读和从右往左读是一样的, 那么小 $Q$ 讨厌它; 例如 $aa$ 和 $aba$.</p></li><li><p>对于一个字符串来说, 若将某个前缀子串移除并拼接到字符串的尾部, 能得到一个小 $Q$ 讨厌的字符串, 那么小 $Q$ 也会讨厌原来的这个字符串; 例如 $aab$ 和 $baa$.</p></li></ul><p>那么问题来了, 如果任意字符串只可以由 $k$ 种已知的字符组成, 那么长度为 $n$ 的所有字符串里, 有多少字符串是小 $Q$ 讨厌的?</p><p>答案可能很大, 你只需要给出答案对 $p$ 取模的值.</p><p>$1 \le T \le 10, 1 \le n \le 10^{18}, 1 \le k \le n, 10^9 \le p \le 2^{30}$</p></blockquote><p>摆结论: 一个字符串的不同轮换数是循环节长度, 一个回文串的循环节也一定是回文串.</p><p>但是长 $m$ 的回文最小循环节 $t$ 贡献并非 $m$, 比如 $abba$ 轮换两下是 $baab$, 于是 $abba$ 和 $baab$ 会把它们的循环数两遍, 实际上对于任意一个 $m$ 是偶数的最小回文循环节, 将其平移 $\dfrac{m}{2}$ 位会得到另一个回文串, 所以只贡献 $\dfrac{m}{2}$, 而奇数回文串照常贡献 $m$.</p><p>于是设长 $m$ 的回文且无更小循环节的串数量是 $f(m)$, 其中每个的贡献是 $g(m)$, 就是要求 $\sum_{d\vert n}f(d)g(d)$</p><p>但是 $f(d)$ 是不好求的, 由这个无更小循环节容易想到反演, 即</p><p>$$<br>h(d)&#x3D;k^{\lfloor \dfrac{d}{2} \rfloor}&#x3D;\sum_{p\vert d} f(p)\Longrightarrow h&#x3D;f<em>1, f&#x3D;h</em>\mu<br>$$</p><p>注意到其实你可以只在约数上卷 $\mu$, 用一个经典trick, 卷 $\mu$ 等价于对所有质数 $p$ 卷上每个</p><p>$$<br>m_p(x)&#x3D;\begin{cases}<br>  1, x&#x3D;1\<br>  -1, x&#x3D;p\<br>  0, otherwise<br>\end{cases}<br>$$</p><p>对 $a_n$ 进行这个相当于对每个数 $i$ 另 $a_{ip}: &#x3D; a_{ip}-a_i$, 也就是说对所有约数求 $f(p)$ 的时候只会用到质因子的 $m_p$, 可以直接求出所有约数的 $f(p)$ 了, 就解决问题了.</p><p>我是智障, 卷 $\mu$ 就是狄利克雷差分, 卷 $1$ 是狄利克雷前缀和. 怎么把这个忘了.</p><h3 id="P4605-SDOI2018-物理实验"><a href="#P4605-SDOI2018-物理实验" class="headerlink" title="P4605 [SDOI2018] 物理实验"></a>P4605 [SDOI2018] 物理实验</h3><blockquote><p>小 T 这学期有物理实验课, 为了顺利完成下一节课的实验, 他打算在课前对实验内容进行预习.</p><p>这次实验在一个二维平面上进行, 平面上放置了一条无限长的直线导轨, 导轨上放置了一个长为 $L$ 的激光发射器, 激光发射器会向导轨两侧沿导轨垂直方向发射宽度为 $L$ 的激光束.</p><p>平面上还放置了 $n$ 个挡板, 每个挡板可以看作是一条线段, 现在每个挡板都不和直线导轨接触, 且<br>和直线导轨的夹角不超过 $85\degree$, 任意两个挡板也不会相互接触, 激光束不能穿透这些挡板, 并且会被挡板吸收掉, 不会被挡板反射出去.</p><p>小 T 想确定一个激光发射器的位置使得被激光束照射到的挡板长度之和最大, 你需要帮小 T 算出这<br>个最大值.</p><ul><li>$T \le 100$</li><li>$1 \le n \le 10^4$,</li><li>$1 \le L \le 2 \times 10^9$,</li><li>所有坐标的绝对值不超过 $10^9$.</li></ul></blockquote><p>显然先把坐标轴转回来, 让导轨是横轴, 然后用线段的横坐标可以把轴分成若干段, 每一段的贡献是导轨两侧离它最近的线段的 $\cot$ 值乘长度.</p><p>求最近的线段是简单的, 因为保证不相交, 所以任意位置线段的相对顺序不变, 所以上一个 $set$, 扫描线, 在 $x_1, x_2$ 处插入&#x2F;删除线段即可.</p><p>最后求最大值的话容易发现最优情况下激光光束的一遍一定贴着一个端点, 双指针秒了.</p><h3 id="P4619-SDOI2018-旧试题"><a href="#P4619-SDOI2018-旧试题" class="headerlink" title="P4619 [SDOI2018] 旧试题"></a>P4619 [SDOI2018] 旧试题</h3><blockquote><p>求 $\sum_{i&#x3D;1}^A\sum_{j&#x3D;1}^B\sum_{k&#x3D;1}^C d(ijk) \pmod {10^9+7}$, 其中 $d$ 为约数个数.</p><p>$A, B, C\le 1\times 10^5$</p></blockquote><p>上来先反演.</p><p>[trick]求 $d(ijk)$ 考虑其每个约数都可以拆成 $xyz$, 其中 $x, y, z$ 分别为 $i, j, k$ 的约数, 然后为了不重钦定选质因子 $p^k$ 的时候如果够就在 $x$ 中选, 不够了再到 $y$ 中选剩下 $p^{k-c_x}$, 其中 $c_x$ 为 $x$ 中 $p$ 的次数, 而不在 $x$ 中选这个质因子, 再不够同理到 $z$ 中选则每个质因子只出现一次, 所以<br>$$<br>d(ijk)&#x3D;\sum_{x\vert i}\sum_{y\vert j}\sum_{z\vert k} [x\perp y][y\perp z][z\perp x]<br>$$</p><p>于是再把互质用莫反搞掉</p><p>$$<br>\begin{gathered}<br>  \sum_i \sum_j \sum_k d(ijk)\<br>  &#x3D;\sum_i \sum_j \sum_k \sum_{x\vert i} \sum_{y\vert j} \sum_{z\vert k} [x\perp y][y\perp z][z\perp x]\<br>  &#x3D;\sum_{x} \sum_{y} \sum_{z}[x\perp y][y\perp z][z\perp x] \lfloor \dfrac{A}{x}\rfloor\lfloor \dfrac{B}{y}\rfloor\lfloor \dfrac{C}{z}\rfloor\<br>  &#x3D;\sum_{x} \sum_{y} \sum_{z}\sum_{d_1\vert x, d_1\vert y}\mu(d_1)\sum_{d_2\vert y, d_2\vert z}\mu(d_1)\sum_{d_3\vert x, d_3\vert z}\mu(d_1) \lfloor \dfrac{A}{x}\rfloor\lfloor \dfrac{B}{y}\rfloor\lfloor \dfrac{C}{z}\rfloor\<br>  &#x3D;\sum_{d_1}\mu(d_1)\sum_{d_2}\mu(d_2)\sum_{d_3}\mu(d_3)\sum_{\mathrm{lcm}(d_1, d_2)\vert x}\dfrac{A}{x}\sum_{\mathrm{lcm}(d_2, d_3)\vert y}\dfrac{A}{y}\sum_{\mathrm{lcm}(d_3, d_1)\vert z}\dfrac{A}{z}\<br>  &#x3D;\sum_{d_1}\mu(d_1)\sum_{d_2}\mu(d_2)\sum_{d_3}\mu(d_3)\sum_{a\mathrm{lcm}(d_1, d_2)\le A}\dfrac{A}{a\mathrm{lcm}(d_1, d_2)}\sum_{b\mathrm{lcm}(d_2, d_3)\le B}\dfrac{B}{b\mathrm{lcm}(d_2, d_3)}\sum_{c\mathrm{lcm}(d_3, d_1)\le C}\dfrac{C}{a\mathrm{lcm}(d_3, d_1)}<br>\end{gathered}<br>$$</p><p>上面所有除法都带取整. 然后你考虑 $d_1, d_2, d_3$ 三元组的贡献, 要求他们 $\mu$ 都不是 $0$, 并且 lcm 小于某值, 那么枚举一个lcm值把所有这个lcm对应的点连边, 发现边数 $8\times 10^5$ 量级, 而有贡献前提是构成三元环, 所以上三元环计数, 每统计到一个三元环加上其答案即可. (然后要算 $\sum_k \dfrac{A}{ak}&#x3D;\dfrac{\frac{A}{a}}{k}$)可以预处理.</p><h3 id="P3705-SDOI2017-新生舞会"><a href="#P3705-SDOI2017-新生舞会" class="headerlink" title="P3705 [SDOI2017] 新生舞会"></a>P3705 [SDOI2017] 新生舞会</h3><p>简单题, 分数规划基本上就是二分之后移项变成一个线性规划问题去判定, 而这个线性规划问题就是若匹配 $i, j$ 则代价 $a_i-b_imid$, 费用流即可.</p><h3 id="P3702-SDOI2017-序列计数"><a href="#P3702-SDOI2017-序列计数" class="headerlink" title="P3702 [SDOI2017] 序列计数"></a>P3702 [SDOI2017] 序列计数</h3><p>先考虑求不含质数的, 把单个数的GF写出来是 $\sum a_ix^i$, 其中 $a_i$ 为 $m$ 以内模 $p$ 为 $i$ 的质数个数, 然后暴力算它的 $n$ 次幂就是 $p^2\log n$ 过了</p><h3 id="P3704-SDOI2017-数字表格"><a href="#P3704-SDOI2017-数字表格" class="headerlink" title="P3704 [SDOI2017] 数字表格"></a>P3704 [SDOI2017] 数字表格</h3><blockquote><p>求 $\prod_{i&#x3D;1}^n\prod_{j&#x3D;1}^m Fib(\gcd(i, j))$, $n, m\le 10^6$.</p></blockquote><p>转而枚举 $\gcd(i, j)$, 则求 $\prod_d Fib(d)^{g(d)}$, 其中 $g(d)&#x3D;\sum_{i&#x3D;1}^\frac{n}{d}\sum_{j&#x3D;1}^\frac{m}{d} [\gcd(i, j)]&#x3D;1&#x3D;\sum_k \mu(k)\dfrac{n}{dk}\dfrac{m}{dk}$.</p><p>带回去, 得到</p><p>$$<br>ans&#x3D;\prod_{T&#x3D;kd}\prod_d (Fib(d)^{\mu(\frac{T}{d})})^{\frac{n}{T}\frac{m}{T}}<br>$$</p><p>里面的部分暴力是 $\sum_T \sqrt T$ 是 $n\sqrt n$ 的不太行, 考虑对每个 $d$ 把 $Fib(d)^{\mu(k)}$ 乘到 $kd$ 去, 调和级数过了.</p><h3 id="P3703-SDOI2017-树点涂色"><a href="#P3703-SDOI2017-树点涂色" class="headerlink" title="P3703 [SDOI2017] 树点涂色"></a>P3703 [SDOI2017] 树点涂色</h3><p>首先看到区间赋值, 你应该想到树剖颜色段均摊的性质, 那么树剖之后操作 $1$ 均摊改线性个段, 那么每次修改段的时候对一个颜色段深度最浅的点子树加就能做操作 $3$, $x, y$ 路径权值可以差分, 反正不差分也不困难.</p><h3 id="P3707-SDOI2017-相关分析"><a href="#P3707-SDOI2017-相关分析" class="headerlink" title="P3707 [SDOI2017] 相关分析"></a>P3707 [SDOI2017] 相关分析</h3><p>简单题, 拆开那个大式子最后就是让你维护 $\sum x_iy_i, \sum x_i^2, \sum x_i, \sum y_i$, 然后修改的话要一个区间价标记一个区间加下标标记, 互不干扰的, 并且对和的影响都是显然的.</p><h3 id="P3780-SDOI2017-苹果树"><a href="#P3780-SDOI2017-苹果树" class="headerlink" title="P3780 [SDOI2017] 苹果树"></a>P3780 [SDOI2017] 苹果树</h3><blockquote><p>夏天近了, 又到了恋爱的季节, 小Q家门前的苹果树上结满了红红圆圆的苹果.</p><p>这株苹果树是一个有着 $n$ 个结点的有根树, 其中结点被依次编号为 $1$ 至 $n$. $1$ 号结点为根, 其余每一个结点的父结点一定是某个编号较小的结点. 每一个结点上都有一些苹果, 第 $i$ 个结点上有 $a_i (a_i &gt; 0)$ 个苹果, 每取走其中一个苹果就可以得到 $v_i (v_i &gt; 0)$ 的幸福度(若在这个结点取走 $k \leq a_i$ 个苹果, 则可以收获 $kv_i$ 的幸福度). 如果在一个结点取走了至少一个苹果, 则必须要在其父结点处取走至少一个苹果.</p><p>现在, 给定正整数 $k$, 请从树上取走若干苹果. 如果总计取走了 $t$ 个苹果, 且所有取了至少一个苹果的那些结点的最大深度为 $h$(这里规定根结点的深度为 $1$), 则要求 $t-h \leq k$. 问最大可以收获多少的幸福度? (这些幸福度全都归属于恋爱中的小Q. )</p><p>$n\le 20000, k\le 5\times 10^5$</p></blockquote><p>好奇妙</p><p>首先理解一下题意, 可以把 $t-h\le k$ 相当于先给一条链每个点选一个且是免费的, 然后再选剩下的是付费的, 答案可以认为是不包含这条链的背包和这条链上让 $a_i: &#x3D; a_i-1$ 的背包合并.</p><p>但是不包含一条链的背包我们不会做, 显然这条链一定到叶子, 发现如果把树画到平面上, 按照dfs序, 链左边的点dfs序小于当前叶子, 右边的点大于dfs序, 那么只要在dfs序上正反两遍合并背包得到 $f, g$ 两个背包, 再卷上链上的背包 $h$ 即是答案, 而这两些多重背包都可以优化到 $nk$</p><p>问题是, 如果只卷两个背包因为我们只想知道一项复杂度是 $k$ 的, 但是合并三个背包就 $k^2$ 了, 于是我们希望能把这条链上的背包 $h$ 处理到 $f$ 或 $g$ 上, 于是考虑在进入一个节点的时候(入栈)向背包插入 $a_i-1$ 且不要求至少选一个, 退出该节点的时候要么插入 $1$ 要么相当于这个点及其子树都不选.</p><p>最终复杂度 $nk$</p><p>[trick] 树的dfs序可以把树按照一条到叶子的链分成两半</p><h3 id="P3779-SDOI2017-龙与地下城"><a href="#P3779-SDOI2017-龙与地下城" class="headerlink" title="P3779 [SDOI2017] 龙与地下城"></a>P3779 [SDOI2017] 龙与地下城</h3><blockquote><p>求 $y$ 个均匀随机变量 $w_i$ 的和在 $[a, b]$ 中的概率, 每个变量是 $[1, x]$ 中的整数.</p><p>$x\le 20, y\le 2\times 10^5, a, b\le xy$, 精度要求绝对误差 $0. 013579$</p></blockquote><p>好大的误差? 干嘛用的?</p><p>首先暴力是不是, 把它们卷起来, 上个FFT的话可以做到 $xy\log(xy)$, 有点过不了.</p><p>好大的误差干嘛用的? 注意到当 $Y$ 很大的时候结果服从正态分布, 那么方法一是直接积出来, 方法二是FFT过程中不断丢掉很小的数使得多项式长度不长.</p><p>[trick] 精度大就是让你丢0的.</p><h3 id="P3785-SDOI2017-文本校正"><a href="#P3785-SDOI2017-文本校正" class="headerlink" title="P3785 [SDOI2017] 文本校正"></a>P3785 [SDOI2017] 文本校正</h3><blockquote><p>给定两个字符串 $s, t$, 要求看能否把 $s$ 划分成 $3$ 个非空的段 $s_1, s_2, s_3$, 使得 $t$ 是以某种顺序连接这 $3$ 个段得到的.</p><p>$n\le 10^6$</p></blockquote><p>按照 $s$ 的顺序分类:</p><p>$t&#x3D;s_1+s_2+s_3$ 是显然的, $s_2+s_3+s_1$ 和 $s_3+s_1+s_2$ 都是一个轮换判定也是显然的.</p><p>对于 $t&#x3D;s_1+s_3+s_2$ 和 $s_2+s_1+s_3$, 就是要判断去掉一个前缀之后两个字符串是可以划分两段后相等的, 考虑 $s_2+s_1+s_3$ 的情况, 枚举 $s$ 第一段的右端点 $i$, 求 $s$ 剩下的部分和 $t$ 的lcp值 $l_i$, 设 $t$ 的第一段的右端点为 $j$, 剩下部分与 $s$ 的lcp为 $l’_j$, 则要满足 $i\le l’_j, j\le l_i, i+j\ge L$, 那么二维数点了. 而 $l_i, l’_j$ 用exkmp解决.</p><p>还剩下 $t&#x3D;s_3+s_2+s_1$ 的情况, 就要找 $i, j, i+j&lt;n, s_{1\ldots i}&#x3D;t_{n-i+1\ldots n}, s_{n-j+1\ldots n}&#x3D;t_{1\ldots j}$ 满足 $n-lcp(s_{i+1\ldots n}, t_{j+1\ldots n}\le i+j$.</p><p>第三个限制是两个字符串在反串 SAM parent 树上lca的最大长度限制, 考虑从大到小枚举 $i$, 从小到大不断加入可行的 $j$, 每次把 $t_{j+1\ldots n}$ 到根的路径上的点 $u$ 都和 $n-j-maxlen_u$ 取min, 或者查找 $s_{i+1\ldots n}$ 到根的路径上的最小值是否小于 $l$, 要做到单log要上全局平衡二叉树.</p><h2 id="THUSC-2024"><a href="#THUSC-2024" class="headerlink" title="THUSC 2024"></a>THUSC 2024</h2><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><blockquote><p>给定 $n, L, d_n$, 求<br>$$<br>\sum_{(a_1, \dots a_n), \forall a_i\le d_i} \max(0, (a_1\mathrm{xor}a_2\ldots a_n)-L)<br>$$<br>$10$ 组数据, $n\le 10$, $d_i\le 10^{18}, L\le 10^9$</p></blockquote><p>感觉T1不会很难所以写了 $4^n\log V$, 听说mikefeng也是 $4^n\log V$, 不过这玩意有 $d^2\log V$ 啊!</p><p>但是怎么正解就是 $4^d\log V$, 有点拉了.</p><p>从高往低枚举第一个存在至少一个数没顶上界的位置, 考虑因为异或的性质, 更低位就均匀了(总可以控制当前位置使得低 $k$ 位取任意值, 每个值方案数均为其他数任选的方案数), 于是现在就数 $C\sum_i \max(0, a+i-L)$ 的形式, 就做完了. 复杂度 $d\log V$</p><h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><p>赛时看错题了&#x2F;&#x2F;&#x2F;fn</p><p>第1-4是要处理怎么做乘法, 前三个做法是爆搜剪枝</p><p>第四个注意到 $x+998244353&#x3D;2^{30}$ 才能满分? ? ?</p><p>第5-7个点是区间求和</p><p>第8是狄利克雷前缀和, 9是FMT</p><p>第10个是随机数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 杂题 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
